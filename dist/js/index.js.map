{"version":3,"sources":["webpack:///index.js","webpack:///webpack/bootstrap 7c9e4fa24d023465f2db","webpack:///./src/js/app.js","webpack:///./src/js/main.js","webpack:///./~/jquery/dist/jquery.js","webpack:///./~/three/build/three.js","webpack:///./src/js/libs/stats.js","webpack:///./~/dat-gui/index.js","webpack:///./~/dat-gui/vendor/dat.gui.js","webpack:///./~/dat-gui/vendor/dat.color.js","webpack:///./src/js/object/Cube.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","$","window","THREE","Stats","dat","sample","MainDisplay","CubeObject","Cube","initStats","stats","setMode","domElement","style","position","left","top","document","getElementById","appendChild","init","s","prototype","renderScene","self","this","$window","$MainDisplay","renderer","WebGLRenderer","alert","setClearColor","Color","setSize","innerWidth","innerHeight","shadowMap","enabled","pixelRatio","Math","min","devicePixelRatio","setPixelRatio","scene","Scene","camera","PerspectiveCamera","x","y","z","lookAt","on","e","onResize","trigger","planeGeometry","PlaneGeometry","planeMaterial","MeshLambertMaterial","color","plane","Mesh","receiveShadow","rotation","PI","add","spotLight","SpotLight","set","castShadow","update","updateAnimation","bind","controls","rotationSpeed","bouncingSpeed","gui","GUI","render","requestAnimationFrame","width","height","aspect","updateProjectionMatrix","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","factory","w","Error","noGlobal","DOMEval","code","doc","script","createElement","text","head","parentNode","removeChild","isArrayLike","obj","length","type","jQuery","isWindow","winnow","elements","qualifier","not","isFunction","grep","elem","i","nodeType","indexOf","risSimple","test","filter","sibling","cur","dir","createOptions","options","object","each","match","rnothtmlwhite","_","flag","Identity","v","Thrower","ex","adoptValue","value","resolve","reject","method","promise","done","fail","then","undefined","completed","removeEventListener","ready","Data","expando","uid","getData","data","rbrace","JSON","parse","dataAttr","key","name","replace","rmultiDash","toLowerCase","getAttribute","dataUser","adjustCSS","prop","valueParts","tween","adjusted","scale","maxIterations","currentValue","css","initial","unit","cssNumber","initialInUnit","rcssNum","exec","start","end","getDefaultDisplay","temp","ownerDocument","nodeName","display","defaultDisplayMap","body","showHide","show","values","index","dataPriv","get","isHiddenWithinTree","getAll","context","tag","ret","getElementsByTagName","querySelectorAll","merge","setGlobalEval","elems","refElements","l","buildFragment","scripts","selection","ignored","tmp","wrap","contains","j","fragment","createDocumentFragment","nodes","rhtml","rtagName","wrapMap","_default","innerHTML","htmlPrefilter","lastChild","childNodes","firstChild","textContent","push","createTextNode","inArray","rscriptType","returnTrue","returnFalse","safeActiveElement","activeElement","err","types","selector","fn","one","origFn","event","off","apply","arguments","guid","manipulationTarget","content","disableScript","restoreScript","rscriptTypeMasked","removeAttribute","cloneCopyEvent","src","dest","pdataOld","pdataCur","udataOld","udataCur","events","hasData","access","handle","extend","fixInput","rcheckableType","checked","defaultValue","domManip","collection","args","callback","concat","first","hasScripts","node","iNoClone","support","checkClone","rchecked","eq","html","map","clone","_evalUrl","rcleanScript","remove","keepData","cleanData","curCSS","computed","minWidth","maxWidth","getStyles","getPropertyValue","pixelMarginRight","rnumnonpx","rmargin","addGetHookIf","conditionFn","hookFn","vendorPropName","emptyStyle","capName","toUpperCase","slice","cssPrefixes","setPositiveNumber","subtract","matches","max","augmentWidthOrHeight","extra","isBorderBox","styles","val","cssExpand","getWidthOrHeight","valueIsBorderBox","getClientRects","getBoundingClientRect","boxSizingReliable","parseFloat","Tween","easing","raf","timerId","fx","tick","createFxNow","setTimeout","fxNow","now","genFx","includeWidth","which","attrs","opacity","createTween","animation","Animation","tweeners","defaultPrefilter","props","opts","toggle","hooks","oldfire","propTween","restoreDisplay","isBox","anim","orig","hidden","dataShow","queue","_queueHooks","unqueued","empty","fire","always","rfxtypes","isEmptyObject","overflow","overflowX","overflowY","propFilter","specialEasing","camelCase","isArray","cssHooks","expand","properties","result","stopped","prefilters","deferred","Deferred","currentTime","remaining","startTime","duration","percent","tweens","run","notifyWith","resolveWith","originalProperties","originalOptions","stop","gotoEnd","rejectWith","proxy","timer","progress","complete","stripAndCollapse","tokens","join","getClass","buildParams","prefix","traditional","rbracket","addToPrefiltersOrTransports","structure","dataTypeExpression","func","dataType","dataTypes","unshift","inspectPrefiltersOrTransports","jqXHR","inspect","selected","inspected","prefilterOrFactory","dataTypeOrTransport","seekingTransport","transports","ajaxExtend","target","deep","flatOptions","ajaxSettings","ajaxHandleResponses","responses","ct","finalDataType","firstDataType","contents","shift","mimeType","getResponseHeader","converters","ajaxConvert","response","isSuccess","conv2","current","conv","prev","responseFields","dataFilter","split","throws","state","error","getWindow","defaultView","arr","getProto","Object","getPrototypeOf","class2type","toString","hasOwn","hasOwnProperty","fnToString","ObjectFunctionString","version","rtrim","rmsPrefix","rdashAlpha","fcamelCase","all","letter","jquery","constructor","toArray","num","pushStack","prevObject","last","len","sort","splice","copy","copyIsArray","isPlainObject","random","isReady","msg","noop","Array","isNumeric","isNaN","proto","Ctor","globalEval","string","trim","makeArray","results","second","invert","callbackInverse","callbackExpect","arg","Date","Symbol","iterator","Sizzle","seed","nid","groups","newSelector","newContext","preferredDoc","setDocument","documentIsHTML","rquickExpr","getElementsByClassName","qsa","compilerCache","rbuggyQSA","rcssescape","fcssescape","setAttribute","tokenize","toSelector","rsibling","testContext","qsaError","select","createCache","cache","keys","Expr","cacheLength","markFunction","assert","el","addHandle","handler","attrHandle","siblingCheck","a","b","diff","sourceIndex","nextSibling","createInputPseudo","createButtonPseudo","createDisabledPseudo","disabled","isDisabled","disabledAncestor","createPositionalPseudo","argument","matchIndexes","setFilters","addCombinator","matcher","combinator","base","skip","next","checkNonElements","doneName","xml","oldCache","uniqueCache","outerCache","newCache","dirruns","uniqueID","elementMatcher","matchers","multipleContexts","contexts","condense","unmatched","newUnmatched","mapped","setMatcher","preFilter","postFilter","postFinder","postSelector","preMap","postMap","preexisting","matcherIn","matcherOut","matcherFromTokens","checkContext","leadingRelative","relative","implicitRelative","matchContext","matchAnyContext","outermostContext","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","find","dirrunsUnique","pop","uniqueSort","getText","isXML","compile","sortInput","hasDuplicate","docElem","rbuggyMatches","classCache","tokenCache","sortOrder","push_native","list","booleans","whitespace","identifier","attributes","pseudos","rwhitespace","RegExp","rcomma","rcombinators","rattributeQuotes","rpseudo","ridentifier","matchExpr","ID","CLASS","TAG","ATTR","PSEUDO","CHILD","bool","needsContext","rinputs","rheader","rnative","runescape","funescape","escaped","escapedWhitespace","high","String","fromCharCode","ch","asCodePoint","charCodeAt","unloadHandler","els","documentElement","hasCompare","subWindow","addEventListener","attachEvent","className","createComment","getById","getElementsByName","attrId","getAttributeNode","input","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","expr","attr","specified","escape","sel","duplicates","detectDuplicates","sortStable","nodeValue","selectors","createPseudo",">"," ","+","~","excess","unquoted","nodeNameSelector","pattern","operator","check","what","simple","forward","ofType","nodeIndex","parent","useCache","pseudo","idx","matched","has","innerText","lang","elemLang","hash","location","root","focus","hasFocus","href","tabIndex","selectedIndex","header","button","even","odd","lt","gt","radio","checkbox","file","password","image","submit","reset","filters","parseOnly","soFar","preFilters","cached","token","compiled","unique","isXMLDoc","escapeSelector","until","truncate","is","siblings","n","rneedsContext","rsingleTag","rootjQuery","parseHTML","rparentsprev","guaranteedUnique","children","targets","closest","prevAll","addBack","parents","parentsUntil","nextAll","nextUntil","prevUntil","contentDocument","reverse","Callbacks","firing","memory","fired","locked","firingIndex","once","stopOnFalse","disable","lock","fireWith","tuples","catch","pipe","fns","newDefer","tuple","returned","notify","onFulfilled","onRejected","onProgress","depth","special","that","mightThrow","maxDepth","TypeError","process","exceptionHook","stackTrace","getStackHook","stateString","when","singleValue","resolveContexts","resolveValues","master","updateFunc","rerrorNames","stack","console","warn","message","readyException","readyList","readyWait","holdReady","hold","wait","readyState","doScroll","chainable","emptyGet","raw","bulk","acceptData","owner","defineProperty","configurable","removeData","_data","_removeData","dequeue","startLength","setter","clearQueue","count","defer","pnum","source","swap","old","hide","option","thead","col","tr","td","optgroup","tbody","tfoot","colgroup","caption","th","div","cloneNode","noCloneChecked","rkeyEvent","rmouseEvent","rtypenamespace","handleObjIn","eventHandle","t","handleObj","handlers","namespaces","origType","elemData","triggered","dispatch","delegateType","bindType","namespace","delegateCount","setup","mappedTypes","origCount","teardown","removeEvent","nativeEvent","handlerQueue","fix","delegateTarget","preDispatch","isPropagationStopped","currentTarget","isImmediatePropagationStopped","rnamespace","preventDefault","stopPropagation","postDispatch","matchedHandlers","matchedSelectors","addProp","hook","Event","enumerable","originalEvent","writable","load","noBubble","blur","click","beforeunload","returnValue","isDefaultPrevented","defaultPrevented","relatedTarget","timeStamp","isSimulated","stopImmediatePropagation","altKey","bubbles","cancelable","changedTouches","ctrlKey","detail","eventPhase","metaKey","pageX","pageY","shiftKey","view","char","charCode","keyCode","buttons","clientX","clientY","offsetX","offsetY","pointerId","pointerType","screenX","screenY","targetTouches","toElement","touches","mouseenter","mouseleave","pointerenter","pointerleave","related","rxhtmlTag","rnoInnerhtml","dataAndEvents","deepDataAndEvents","srcElements","destElements","inPage","detach","append","prepend","insertBefore","before","after","replaceWith","replaceChild","appendTo","prependTo","insertAfter","replaceAll","original","insert","opener","getComputedStyle","computeStyleTests","cssText","container","divStyle","pixelPositionVal","reliableMarginLeftVal","marginLeft","boxSizingReliableVal","marginRight","pixelMarginRightVal","backgroundClip","clearCloneStyle","pixelPosition","reliableMarginLeft","rdisplayswap","cssShow","visibility","cssNormalTransform","letterSpacing","fontWeight","animationIterationCount","columnCount","fillOpacity","flexGrow","flexShrink","lineHeight","order","orphans","widows","zIndex","zoom","cssProps","float","origName","isFinite","margin","padding","border","suffix","expanded","parts","propHooks","eased","pos","step","scrollTop","scrollLeft","linear","swing","cos","rrun","*","tweener","prefilter","speed","opt","speeds","fadeTo","to","animate","optall","doAnimation","finish","stopQueue","timers","cssFn","slideDown","slideUp","slideToggle","fadeIn","fadeOut","fadeToggle","interval","setInterval","cancelAnimationFrame","clearInterval","slow","fast","delay","time","timeout","clearTimeout","checkOn","optSelected","radioValue","boolHook","removeAttr","nType","attrHooks","attrNames","getter","lowercaseName","rfocusable","rclickable","removeProp","propFix","tabindex","parseInt","for","class","addClass","classes","curValue","clazz","finalValue","removeClass","toggleClass","stateVal","classNames","hasClass","rreturn","valHooks","optionSet","rfocusMorph","onlyHandlers","bubbleType","ontype","eventPath","isTrigger","parentWindow","simulate","triggerHandler","hover","fnOver","fnOut","focusin","attaches","nonce","rquery","parseXML","DOMParser","parseFromString","rCRLF","rsubmitterTypes","rsubmittable","param","valueOrFunction","encodeURIComponent","serialize","serializeArray","r20","rhash","rantiCache","rheaders","rlocalProtocol","rnoContent","rprotocol","allTypes","originAnchor","active","lastModified","etag","url","isLocal","protocol","processData","async","contentType","accepts","json","* text","text html","text json","text xml","ajaxSetup","settings","ajaxPrefilter","ajaxTransport","ajax","status","nativeStatusText","headers","success","modified","statusText","timeoutTimer","transport","responseHeadersString","ifModified","cacheURL","callbackContext","statusCode","fireGlobals","globalEventContext","completeDeferred","responseHeaders","urlAnchor","uncached","requestHeaders","requestHeadersNames","strAbort","getAllResponseHeaders","setRequestHeader","overrideMimeType","abort","finalText","crossDomain","host","hasContent","beforeSend","send","getJSON","getScript","wrapAll","firstElementChild","wrapInner","unwrap","visible","offsetWidth","offsetHeight","xhr","XMLHttpRequest","xhrSuccessStatus","0","1223","xhrSupported","cors","errorCallback","open","username","xhrFields","onload","onerror","onabort","onreadystatechange","responseType","responseText","binary","text script","charset","scriptCharset","evt","oldCallbacks","rjsonp","jsonp","jsonpCallback","originalSettings","callbackName","overwritten","responseContainer","jsonProp","createHTMLDocument","implementation","keepScripts","parsed","params","animated","offset","setOffset","curPosition","curLeft","curCSSTop","curTop","curOffset","curCSSLeft","calculatePosition","curElem","using","win","rect","pageYOffset","clientTop","pageXOffset","clientLeft","offsetParent","parentOffset","scrollTo","Height","Width","","defaultExtra","funcName","unbind","delegate","undelegate","parseJSON","_jQuery","_$","noConflict","EventDispatcher","Vector2","Texture","mapping","wrapS","wrapT","magFilter","minFilter","format","anisotropy","encoding","TextureIdCount","uuid","_Math","generateUUID","sourceFile","DEFAULT_IMAGE","mipmaps","DEFAULT_MAPPING","ClampToEdgeWrapping","LinearFilter","LinearMipMapLinearFilter","RGBAFormat","UnsignedByteType","repeat","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","LinearEncoding","onUpdate","Vector4","WebGLRenderTarget","scissor","scissorTest","viewport","texture","depthBuffer","stencilBuffer","depthTexture","WebGLRenderTargetCube","activeCubeFace","activeMipMapLevel","Quaternion","_x","_y","_z","_w","Vector3","Matrix4","Float32Array","CubeTexture","images","CubeReflectionMapping","UniformContainer","seq","flatten","array","nBlocks","blockSize","firstElem","r","arrayCacheF32","allocTexUnits","arrayCacheI32","Int32Array","allocTextureUnit","setValue1f","gl","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","g","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","setTexture2D","emptyTexture","setValueT6","setTextureCube","emptyCubeTexture","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","size","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","units","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","setValue","PureArrayUniform","StructuredUniform","addUniform","uniformObject","parseUniform","path","pathLength","RePathPart","lastIndex","matchEnd","idIsIndex","subscript","WebGLUniforms","program","getProgramParameter","ACTIVE_UNIFORMS","info","getActiveUniform","getUniformLocation","setRGB","Box2","Infinity","LensFlarePlugin","flares","vertices","faces","Uint16Array","vertexBuffer","createBuffer","elementBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","tempTexture","createTexture","occlusionTexture","bindTexture","TEXTURE_2D","texImage2D","RGB","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","RGBA","shader","vertexShader","fragmentShader","createProgram","vertex","getAttribLocation","uv","uniforms","renderType","occlusionMap","screenPosition","createShader","FRAGMENT_SHADER","VERTEX_SHADER","getPrecision","shaderSource","compileShader","attachShader","linkProgram","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","useProgram","initAttributes","enableAttribute","disableUnusedAttributes","vertexAttribPointer","FLOAT","CULL_FACE","setDepthWrite","flare","matrixWorld","applyMatrix4","matrixWorldInverse","applyProjection","projectionMatrix","containsPoint","activeTexture","TEXTURE0","TEXTURE1","copyTexImage2D","BLEND","enable","DEPTH_TEST","drawElements","TRIANGLES","UNSIGNED_SHORT","positionScreen","customUpdateCallback","updateLensFlares","jl","lensFlares","sprite","setBlending","blending","blendEquation","blendSrc","blendDst","resetGLState","SpritePlugin","sprites","uvOffset","uvScale","modelViewMatrix","fogType","fogDensity","fogNear","fogFar","fogColor","alphaTest","canvas","createElementNS","getContext","fillStyle","fillRect","needsUpdate","painterSortStable","renderOrder","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","fog","isFog","near","far","isFogExp2","density","multiplyMatrices","material","decompose","setDepthTest","depthTest","depthWrite","Material","MaterialIdCount","lights","NormalBlending","side","FrontSide","shading","SmoothShading","vertexColors","NoColors","transparent","SrcAlphaFactor","OneMinusSrcAlphaFactor","AddEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","LessEqualDepth","clippingPlanes","clipIntersection","clipShadows","colorWrite","precision","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","count$1","ShaderMaterial","parameters","defines","linewidth","wireframe","wireframeLinewidth","clipping","skinning","morphTargets","morphNormals","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","uv2","index0AttributeName","setValues","MeshDepthMaterial","depthPacking","BasicDepthPacking","alphaMap","displacementMap","displacementScale","displacementBias","Box3","Sphere","center","radius","Matrix3","Plane","normal","constant","Frustum","p0","p1","p2","p3","p4","p5","planes","WebGLShadowMap","_renderer","_lights","_objects","capabilities","getDepthMaterial","isPointLight","lightPositionWorld","geometry","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","isBufferGeometry","morphAttributes","isGeometry","useSkinning","isSkinnedMesh","variantIndex","_MorphingFlag","_SkinningFlag","localClippingEnabled","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","scope","renderSingleSided","DoubleSide","renderReverseSided","BackSide","lightPos","projectObject","shadowCamera","layers","mask","isMesh","isLine","isPoints","frustumCulled","_frustum","intersectsObject","_renderList","_gl","_state","_projScreenMatrix","_lightShadows","shadows","_shadowMapSize","_maxShadowMapSize","maxTextureSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","RGBADepthPacking","distanceShader","ShaderLib","distanceUniforms","UniformsUtils","depthMaterial","distanceMaterial","USE_SHADOWMAP","autoUpdate","PCFShadowMap","clearColor","setScissorTest","faceCount","il","light","shadow","mapSize","vpWidth","vpHeight","pars","NearestFilter","isSpotLightShadow","shadowMatrix","matrix","setFromMatrixPosition","setRenderTarget","clear","face","up","vpDimensions","updateMatrixWorld","getInverse","multiply","setFromMatrix","isMultiMaterial","materials","k","kl","group","groupMaterial","materialIndex","renderBufferDirect","getClearColor","clearAlpha","getClearAlpha","Ray","origin","direction","Euler","_order","DefaultOrder","Layers","Object3D","onRotationChange","quaternion","setFromEuler","onQuaternionChange","setFromQuaternion","Object3DIdCount","DefaultUp","onChange","defineProperties","normalMatrix","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","userData","onBeforeRender","onAfterRender","count$2","Line3","Triangle","Face3","isVector3","vertexNormals","isColor","MeshBasicMaterial","aoMap","aoMapIntensity","specularMap","envMap","combine","MultiplyOperation","reflectivity","refractionRatio","wireframeLinecap","wireframeLinejoin","BufferAttribute","itemSize","normalized","dynamic","updateRange","Int8Attribute","Int8Array","Uint8Attribute","Uint8Array","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Int32Attribute","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","setDynamic","Geometry","GeometryIdCount","colors","faceVertexUvs","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","count$3","DirectGeometry","indices","normals","uvs","uvs2","BufferGeometry","drawRange","drawMode","TrianglesDrawMode","updateMorphTargets","BoxBufferGeometry","widthSegments","heightSegments","depthSegments","calculateVertexCount","h","d","calculateIndexCount","buildPlane","u","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","vector","iy","ix","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","addGroup","groupStart","floor","vertexCount","indexCount","setIndex","addAttribute","PlaneBufferGeometry","width_half","height_half","segment_width","segment_height","offset2","Camera","fov","filmGauge","filmOffset","OrthographicCamera","right","bottom","WebGLIndexedBufferRenderer","infoRender","mode","UNSIGNED_INT","calls","renderInstances","extension","drawElementsInstancedANGLE","maxInstancedCount","WebGLBufferRenderer","drawArrays","isInterleavedBufferAttribute","drawArraysInstancedANGLE","WebGLLights","shadowBias","shadowRadius","shadowMapSize","distance","coneCos","penumbraCos","decay","skyColor","groundColor","addLineNumbers","lines","WebGLShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","getEncodingComponents","sRGBEncoding","RGBEEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","GammaEncoding","getTexelDecodingFunction","functionName","components","getTexelEncodingFunction","getToneMappingFunction","toneMapping","toneMappingName","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","generateExtensions","rendererExtensions","chunks","envMapCubeUV","bumpMap","normalMap","flatShading","logarithmicDepthBuffer","filterEmptyLine","generateDefines","fetchAttributeLocations","identifiers","ACTIVE_ATTRIBUTES","getActiveAttrib","replaceLightNums","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","ShaderChunk","unrollLoops","snippet","unroll","WebGLProgram","__webglShader","shadowMapTypeDefine","shadowMapType","PCFSoftShadowMap","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","CubeRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","MixOperation","AddOperation","prefixVertex","prefixFragment","gammaFactorDefine","gammaFactor","customExtensions","customDefines","isRawShaderMaterial","supportsVertexTextures","maxBones","lightMap","emissiveMap","roughnessMap","metalnessMap","useVertexTexture","doubleSided","flipSided","numClippingPlanes","shadowMapEnabled","sizeAttenuation","useFog","fogExp","numClipIntersection","physicallyCorrectLights","NoToneMapping","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","isShaderMaterial","vertexGlsl","fragmentGlsl","glVertexShader","glFragmentShader","bindAttribLocation","programLog","getProgramInfoLog","vertexLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","log","deleteShader","cachedUniforms","getUniforms","cachedAttributes","getAttributes","destroy","deleteProgram","programIdCount","usedTimes","WebGLPrograms","allocateBones","floatVertexTextures","skeleton","nVertexUniforms","maxVertexUniforms","nVertexMatrices","bones","getTextureEncodingFromMap","gammaOverrideLinear","isTexture","isWebGLRenderTarget","programs","shaderIDs","MeshNormalMaterial","MeshPhongMaterial","MeshStandardMaterial","MeshPhysicalMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","parameterNames","getParameters","nClipPlanes","nClipIntersection","shaderID","getMaxPrecision","currentRenderTarget","getCurrentRenderTarget","vertexTextures","gammaOutput","gammaInput","envMapMode","FlatShading","maxMorphTargets","maxMorphNormals","directional","point","spot","hemi","getProgramCode","acquireProgram","pl","programInfo","releaseProgram","WebGLGeometries","onGeometryDispose","buffergeometry","geometries","deleteAttribute","deleteAttributes","property","delete","bufferproperty","getAttributeBuffer","attribute","__webglBuffer","buffer","deleteBuffer","removeAttributeBuffer","_bufferGeometry","setFromObject","WebGLObjects","updateFromObject","updateAttribute","bufferType","attributeProperties","updateBuffer","usage","DYNAMIC_DRAW","bufferSubData","BYTES_PER_ELEMENT","subarray","getWireframeAttribute","TypeArray","WebGLTextures","paramThreeToGL","clampToMaxSize","maxSize","drawImage","isPowerOfTwo","makePowerOfTwo","HTMLImageElement","HTMLCanvasElement","nearestPowerOfTwo","textureNeedsPowerOfTwo","filterFallback","f","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LINEAR","onTextureDispose","deallocateTexture","_infoMemory","textures","onRenderTargetDispose","renderTarget","deallocateRenderTarget","textureProperties","__image__webglTextureCube","deleteTexture","__webglInit","__webglTexture","renderTargetProperties","dispose","isWebGLRenderTargetCube","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","slot","__version","uploadTexture","TEXTURE_CUBE_MAP","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isCompressedTexture","isDataTexture","cubeImage","maxCubemapSize","isPowerOfTwoImage","glFormat","glType","setTextureParameters","mipmap","RGBFormat","getCompressedTextureFormats","compressedTexImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","generateMipmap","setTextureCubeDynamic","textureType","FloatType","HalfFloatType","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","isDepthTexture","internalFormat","DEPTH_COMPONENT","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","DepthStencilFormat","DEPTH_STENCIL","setupFrameBufferTexture","framebuffer","attachment","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","isCube","webglDepthTexture","DepthFormat","setupDepthRenderbuffer","createRenderbuffer","setupRenderTarget","isTargetPowerOfTwo","createFramebuffer","COLOR_ATTACHMENT0","updateRenderTargetMipmap","webglTexture","WebGL2RenderingContext","WebGLProperties","WebGLState","ColorBuffer","currentColorMask","currentColorClear","setMask","colorMask","setLocked","setClear","equals","DepthBuffer","currentDepthMask","currentDepthFunc","currentDepthClear","setTest","depthMask","setFunc","NeverDepth","NEVER","AlwaysDepth","ALWAYS","LessDepth","LESS","LEQUAL","EqualDepth","EQUAL","GreaterEqualDepth","GEQUAL","GreaterDepth","GREATER","NotEqualDepth","NOTEQUAL","clearDepth","StencilBuffer","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilTest","STENCIL_TEST","stencilMask","stencilFunc","stencilRef","setOp","stencilFail","stencilZFail","stencilZPass","stencilOp","stencil","clearStencil","setDepthFunc","setFlipSided","setCullFace","CullFaceBack","newAttributes","enabledAttributes","enableVertexAttribArray","attributeDivisors","vertexAttribDivisorANGLE","enableAttributeAndDivisor","meshPerAttribute","disableVertexAttribArray","compressedTextureFormats","formats","getParameter","COMPRESSED_TEXTURE_FORMATS","NoBlending","currentBlending","currentPremultipledAlpha","AdditiveBlending","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","blendFunc","SRC_ALPHA","SubtractiveBlending","ZERO","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","MultiplyBlending","SRC_COLOR","CustomBlending","currentBlendEquation","currentBlendEquationAlpha","currentBlendSrc","currentBlendDst","currentBlendSrcAlpha","currentBlendDstAlpha","setColorWrite","colorBuffer","setStencilTest","setStencilWrite","stencilWrite","setStencilFunc","setStencilOp","currentFlipSided","frontFace","CW","CCW","cullFace","CullFaceNone","currentCullFace","BACK","CullFaceFront","FRONT","FRONT_AND_BACK","setLineWidth","currentLineWidth","lineWidth","setPolygonOffset","factor","POLYGON_OFFSET_FILL","currentPolygonOffsetFactor","currentPolygonOffsetUnits","getScissorTest","currentScissorTest","SCISSOR_TEST","webglSlot","maxTextures","currentTextureSlot","webglType","boundTexture","currentBoundTextures","emptyTextures","currentScissor","currentViewport","maxVertexAttributes","MAX_VERTEX_ATTRIBS","MAX_TEXTURE_IMAGE_UNITS","buffers","WebGLCapabilities","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getShaderPrecisionFormat","HIGH_FLOAT","MEDIUM_FLOAT","maxPrecision","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","floatFragmentTextures","WebGLExtensions","getExtension","WebGLClipping","resetGlobalState","uniform","globalState","numGlobalPlanes","numPlanes","numIntersection","projectPlanes","dstOffset","skipTransform","nPlanes","dstArray","flatSize","viewMatrix","viewNormalMatrix","getNormalMatrix","i4","renderingShadows","enableLocalClipping","beginShadows","endShadows","setState","fromCache","nGlobal","lGlobal","clippingState","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","setDefaultGLState","_currentScissor","_scissor","multiplyScalar","_currentViewport","_viewport","_clearColor","_clearAlpha","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReference","programCache","setupVertexAttributes","startIndex","isInstancedBufferGeometry","geometryAttributes","programAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","SHORT","INT","BYTE","objects","stride","isInstancedInterleavedBuffer","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","absNumericalSort","abs","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","computeBoundingSphere","_sphere","isSphereViewable","isSpriteViewable","sphere","intersectsSphere","_clipping","_this","negRad","distanceToPoint","isLight","isSprite","isLensFlare","isImmediateRenderObject","sortObjects","renderObjects","renderList","overrideMaterial","setMaterial","setProgram","renderBufferImmediate","initMaterial","materialProperties","programChange","numSupportedMorphTargets","numSupportedMorphNormals","lightsHash","ambientLightColor","ambient","directionalLights","spotLights","pointLights","hemisphereLights","directionalShadowMap","directionalShadowMatrix","spotShadowMap","spotShadowMatrix","pointShadowMap","pointShadowMatrix","progUniforms","uniformsList","seqWithValue","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","LN2","isMeshPhongMaterial","isMeshStandardMaterial","uCamPos","cameraPosition","isMeshLambertMaterial","isMeshBasicMaterial","setOptional","markUniformsLightsNeedsUpdate","refreshUniformsFog","isMeshDepthMaterial","refreshUniformsCommon","isLineBasicMaterial","refreshUniformsLine","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","isMeshPhysicalMaterial","refreshUniformsPhysical","refreshUniformsStandard","isMeshNormalMaterial","upload","diffuse","emissive","emissiveIntensity","uvScaleMap","offsetRepeat","flipEnvMap","isCubeTexture","dashSize","totalSize","gapSize","_height","lightMapIntensity","specular","shininess","bumpScale","normalScale","roughness","metalness","envMapIntensity","clearCoat","clearCoatRoughness","setupShadows","lightShadowsLength","setupLights","ll","intensity","directionalLength","pointLength","spotLength","hemiLength","isAmbientLight","isDirectionalLight","lightCache","sub","transformDirection","bias","isSpotLight","angle","penumbra","negate","identity","setPosition","isHemisphereLight","normalize","textureUnit","RepeatWrapping","REPEAT","MirroredRepeatWrapping","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LinearMipMapNearestFilter","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UnsignedShort4444Type","UNSIGNED_SHORT_4_4_4_4","UnsignedShort5551Type","UNSIGNED_SHORT_5_5_5_1","UnsignedShort565Type","UNSIGNED_SHORT_5_6_5","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","HALF_FLOAT_OES","AlphaFormat","ALPHA","LuminanceFormat","LUMINANCE","LuminanceAlphaFormat","LUMINANCE_ALPHA","SubtractEquation","FUNC_SUBTRACT","ReverseSubtractEquation","FUNC_REVERSE_SUBTRACT","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","DstAlphaFactor","DST_ALPHA","OneMinusDstAlphaFactor","ONE_MINUS_DST_ALPHA","DstColorFactor","DST_COLOR","OneMinusDstColorFactor","ONE_MINUS_DST_COLOR","SrcAlphaSaturateFactor","SRC_ALPHA_SATURATE","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","RGB_ETC1_Format","COMPRESSED_RGB_ETC1_WEBGL","MinEquation","MaxEquation","MIN_EXT","MAX_EXT","UnsignedInt248Type","UNSIGNED_INT_24_8_WEBGL","REVISION","_canvas","_context","_alpha","alpha","_depth","_stencil","_antialias","antialias","_preserveDrawingBuffer","preserveDrawingBuffer","morphInfluences","autoClear","autoClearColor","autoClearDepth","autoClearStencil","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_scissorTest","_infoRender","points","rangeMin","rangeMax","MaxIndex","bufferRenderer","indexedBufferRenderer","backgroundCamera","backgroundCamera2","backgroundPlaneMesh","backgroundBoxShader","backgroundBoxMesh","spritePlugin","lensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","getPixelRatio","getSize","updateStyle","setViewport","setScissor","boolean","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearTarget","hasPositions","hasNormals","hasUvs","hasColors","positionArray","normalArray","nx","ny","nz","uvArray","colorArray","updateBuffers","geometryProgram","morphTargetInfluences","activeInfluences","influence","rangeFactor","dataCount","rangeStart","rangeCount","drawStart","drawEnd","drawCount","LINES","TriangleStripDrawMode","TRIANGLE_STRIP","TriangleFanDrawMode","TRIANGLE_FAN","isLineSegments","LINE_STRIP","POINTS","forceClear","isCamera","background","extractRotation","setFaceCulling","frontFaceDirection","FrontFaceDirectionCW","warned","setTexture","readRenderTargetPixels","restore","textureFormat","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","FogExp2","Fog","LensFlare","SpriteMaterial","Sprite","LOD","levels","DataTexture","Skeleton","boneInverses","identityMatrix","sqrt","nextPowerOfTwo","ceil","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","Bone","skin","SkinnedMesh","bindMode","bindMatrix","bindMatrixInverse","bone","gbone","fromArray","rotq","scl","normalizeSkinWeights","linecap","linejoin","Line","LineSegments","Points","Group","VideoTexture","video","HAVE_CURRENT_DATA","CompressedTexture","CanvasTexture","DepthTexture","WireframeGeometry","sortFunction","edge","numEdges","edges","coords","o","ol","index2","getX","getY","getZ","numTris","index1","ParametricBufferGeometry","slices","stacks","sliceCount","computeVertexNormals","ParametricGeometry","fromBufferGeometry","mergeVertices","PolyhedronBufferGeometry","subdivide","getVertexByIndex","subdivideFace","cols","pow","aj","lerp","bj","rows","pushVertex","appplyRadius","generateUVs","azimuth","inclination","uvBuffer","correctUVs","correctSeam","x0","x1","x2","centroid","uvA","uvB","uvC","divideScalar","azi","correctUV","atan2","normalizeNormals","TetrahedronBufferGeometry","TetrahedronGeometry","OctahedronBufferGeometry","OctahedronGeometry","IcosahedronBufferGeometry","IcosahedronGeometry","DodecahedronBufferGeometry","DodecahedronGeometry","PolyhedronGeometry","TubeBufferGeometry","tubularSegments","radialSegments","closed","generateBufferData","generateSegment","generateIndices","P","getPointAt","N","frames","B","binormals","sin","computeFrenetFrames","tangents","TubeGeometry","taper","bufferGeometry","TorusKnotBufferGeometry","tube","q","calculatePositionOnCurve","cu","su","quOverP","cs","indexOffset","P1","P2","T","subVectors","addVectors","crossVectors","cx","cy","setXYZ","setXY","setX","TorusKnotGeometry","heightScale","TorusBufferGeometry","arc","TorusGeometry","ExtrudeGeometry","shapes","addShapeList","computeFaceNormals","TextGeometry","font","isFont","generateShapes","curveSegments","amount","bevelThickness","bevelSize","bevelEnabled","SphereBufferGeometry","phiStart","phiLength","thetaStart","thetaLength","thetaEnd","positions","verticesRow","px","py","pz","v1","v2","v3","v4","SphereGeometry","RingBufferGeometry","innerRadius","outerRadius","thetaSegments","phiSegments","segment","radiusStep","thetaSegmentLevel","RingGeometry","LatheBufferGeometry","segments","clamp","inverseSegments","phi","n1","n2","LatheGeometry","ShapeGeometry","EdgesGeometry","thresholdAngle","geometry2","thresholdDot","DEG2RAD","vert1","vert2","face1","face2","dot","CylinderBufferGeometry","radiusTop","radiusBottom","openEnded","nbCap","generateTorso","slope","indexRow","theta","sinTheta","cosTheta","halfHeight","indexArray","i1","i2","i3","generateCap","centerIndexStart","centerIndexEnd","sign","CylinderGeometry","ConeGeometry","ConeBufferGeometry","CircleBufferGeometry","ii","CircleGeometry","BoxGeometry","ShadowMaterial","UniformsLib","RawShaderMaterial","MultiMaterial","STANDARD","PHYSICAL","LoadingManager","onLoad","onError","isLoading","itemsLoaded","itemsTotal","onStart","itemStart","itemEnd","itemError","XHRLoader","manager","DefaultLoadingManager","CompressedTextureLoader","_parser","BinaryTextureLoader","ImageLoader","CubeTextureLoader","TextureLoader","Light","HemisphereLight","updateMatrix","LightShadow","SpotLightShadow","power","PointLight","DirectionalLightShadow","DirectionalLight","AmbientLight","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","LinearInterpolant","DiscreteInterpolant","KeyframeTrackConstructor","times","interpolation","AnimationUtils","convertArray","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","optimize","VectorKeyframeTrack","QuaternionLinearInterpolant","QuaternionKeyframeTrack","NumberKeyframeTrack","StringKeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","KeyframeTrack","AnimationClip","tracks","resetDuration","MaterialLoader","BufferGeometryLoader","Loader","onLoadStart","onLoadProgress","onLoadComplete","JSONLoader","withCredentials","ObjectLoader","texturePath","Curve","LineCurve","CurvePath","curves","autoClose","EllipseCurve","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","aRotation","SplineCurve","CubicBezierCurve","v0","QuadraticBezierCurve","Shape","Path","holes","currentPoint","fromPoints","ShapePath","subPaths","currentPath","Font","FontLoader","getAudioContext","AudioContext","webkitAudioContext","AudioLoader","StereoCamera","eyeSep","cameraL","cameraR","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","updateCubeMap","AudioListener","gain","createGain","connect","destination","Audio","listener","createBufferSource","onended","onEnded","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","PositionalAudio","panner","createPanner","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getOutput","PropertyMixer","binding","typeName","mixFunction","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","useCount","referenceCount","PropertyBinding","rootNode","parsedPath","parseTrackName","findNode","AnimationObjectGroup","var_args","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath","total","inUse","bindingsPerObject","AnimationAction","mixer","clip","localRoot","_mixer","_clip","_localRoot","nTracks","interpolants","interpolantSettings","endingStart","ZeroCurvatureEnding","endingEnd","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","LoopRepeat","_loopCount","_startTime","timeScale","_effectiveTimeScale","weight","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","AnimationMixer","_root","_initMemoryManager","_accuIndex","Uniform","InstancedBufferGeometry","InterleavedBufferAttribute","interleavedBuffer","InterleavedBuffer","InstancedInterleavedBuffer","InstancedBufferAttribute","Raycaster","ray","threshold","PointCloud","ascSort","intersectObject","raycaster","intersects","recursive","raycast","Clock","autoStart","oldTime","elapsedTime","running","Spline","interpolate","t2","t3","intPoint","w2","w3","pa","pb","pc","pd","initFromArray","getPoint","getControlPointsArray","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","distanceTo","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Spherical","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","fps","createAnimation","setAnimationWeight","ImmediateRenderObject","renderCallback","VertexNormalsHelper","hex","nNormals","objGeometry","SpotLightHelper","cone","SkeletonHelper","getBoneList","isBone","VertexColors","PointLightHelper","sphereSize","HemisphereLightHelper","rotateX","FaceColors","lightSphere","GridHelper","divisions","color1","color2","FaceNormalsHelper","DirectionalLightHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","BoundingBoxHelper","box","BoxHelper","ArrowHelper","headLength","headWidth","line","lineGeometry","coneGeometry","setDirection","setLength","AxisHelper","ClosedSplineCurve3","CatmullRomCurve3","ArcCurve","aRadius","Face4","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","EdgesHelper","WireframeHelper","Projector","projectVector","project","unprojectVector","unproject","pickingRay","CanvasRenderer","Number","EPSILON","Function","assign","output","nextKey","_listeners","listeners","hasEventListener","listenerArray","dispatchEvent","MOUSE","LEFT","MIDDLE","RIGHT","CullFaceFrontBack","FrontFaceDirectionCCW","BasicShadowMap","BlendingMode","UVMapping","TextureMapping","TextureWrapping","TextureFilter","RGBEFormat","LoopOnce","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroSlopeEnding","WrapAroundEnding","LogLuvEncoding","RAD2DEG","chars","rnd","euclideanModulo","mapLinear","a1","a2","b1","b2","smoothstep","smootherstep","random16","randInt","low","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","round","isVector2","setScalar","scalar","setY","setComponent","getComponent","addScalar","addScaledVector","subScalar","divide","clampScalar","minVal","maxVal","clampLength","roundToZero","lengthSq","lengthManhattan","distanceToSquared","dx","dy","distanceToManhattan","lerpVectors","fromAttribute","rotateAround","toJSON","meta","getDataURL","toDataURL","metadata","generator","transformUv","isVector4","setZ","setW","setAxisAngleFromQuaternion","acos","setAxisAngleFromRotationMatrix","epsilon","epsilon2","te","m11","m12","m13","m21","m22","m23","m31","m32","m33","xx","yy","zz","xy","xz","yz","create","onChangeCallback","euler","isEuler","c1","c2","c3","s1","s2","s3","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","trace","setFromUnitVectors","EPS","vFrom","vTo","inverse","conjugate","multiplyQuaternions","premultiply","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","qa","qm","slerpFlat","dst","src0","srcOffset0","src1","srcOffset1","y0","z0","w0","y1","z1","w1","sqrSin","tDir","multiplyVectors","applyEuler","applyQuaternion","applyAxisAngle","applyMatrix3","qx","qy","qz","qw","iz","iw","cross","ax","ay","az","bx","by","bz","projectOnVector","projectOnPlane","planeNormal","reflect","angleTo","dz","setFromSpherical","sinPhiRadius","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","isMatrix4","n11","n12","n13","n14","n21","n22","n23","n24","n31","n32","n33","n34","n41","n42","n43","n44","copyPosition","me","extractBasis","xAxis","yAxis","zAxis","makeBasis","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","y2","z2","wx","wy","wz","eye","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","applyToVector3Array","applyToBuffer","determinant","transpose","flattenToArrayOffset","getPosition","throwOnDegenerate","t11","t12","t13","t14","det","detInv","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","invSX","invSY","invSZ","makeFrustum","makePerspective","ymax","tan","ymin","xmin","xmax","makeOrthographic","merged","uniforms_src","uniforms_dst","parameter_src","isMatrix3","alphamap_fragment","alphamap_pars_fragment","alphatest_fragment","aomap_fragment","aomap_pars_fragment","begin_vertex","beginnormal_vertex","bsdfs","bumpmap_pars_fragment","clipping_planes_fragment","clipping_planes_pars_fragment","clipping_planes_pars_vertex","clipping_planes_vertex","color_fragment","color_pars_fragment","color_pars_vertex","color_vertex","common","cube_uv_reflection_fragment","defaultnormal_vertex","displacementmap_pars_vertex","displacementmap_vertex","emissivemap_fragment","emissivemap_pars_fragment","encodings_fragment","encodings_pars_fragment","envmap_fragment","envmap_pars_fragment","envmap_pars_vertex","envmap_vertex","fog_fragment","fog_pars_fragment","lightmap_fragment","lightmap_pars_fragment","lights_lambert_vertex","lights_pars","lights_phong_fragment","lights_phong_pars_fragment","lights_physical_fragment","lights_physical_pars_fragment","lights_template","logdepthbuf_fragment","logdepthbuf_pars_fragment","logdepthbuf_pars_vertex","logdepthbuf_vertex","map_fragment","map_pars_fragment","map_particle_fragment","map_particle_pars_fragment","metalnessmap_fragment","metalnessmap_pars_fragment","morphnormal_vertex","morphtarget_pars_vertex","morphtarget_vertex","normal_flip","normal_fragment","normalmap_pars_fragment","packing","premultiplied_alpha_fragment","project_vertex","roughnessmap_fragment","roughnessmap_pars_fragment","shadowmap_pars_fragment","shadowmap_pars_vertex","shadowmap_vertex","shadowmask_pars_fragment","skinbase_vertex","skinning_pars_vertex","skinning_vertex","skinnormal_vertex","specularmap_fragment","specularmap_pars_fragment","tonemapping_fragment","tonemapping_pars_fragment","uv_pars_fragment","uv_pars_vertex","uv_vertex","uv2_pars_fragment","uv2_pars_vertex","uv2_vertex","worldpos_vertex","cube_frag","cube_vert","depth_frag","depth_vert","distanceRGBA_frag","distanceRGBA_vert","equirect_frag","equirect_vert","linedashed_frag","linedashed_vert","meshbasic_frag","meshbasic_vert","meshlambert_frag","meshlambert_vert","meshphong_frag","meshphong_vert","meshphysical_frag","meshphysical_vert","normal_frag","normal_vert","points_frag","points_vert","shadow_frag","shadow_vert","setHex","setStyle","setHSL","hue2rgb","handleAlpha","charAt","ColorKeywords","copyGammaToLinear","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","getHex","getHexString","getHSL","optionalTarget","hue","saturation","hsl","lightness","delta","getStyle","offsetHSL","addColors","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","basic","lambert","phong","standard","dashed","cube","tCube","tFlip","equirect","tEquirect","distanceRGBA","physical","setFromPoints","makeEmpty","expandByPoint","setFromCenterAndSize","halfSize","isEmpty","getCenter","expandByVector","expandByScalar","containsBox","intersectsBox","clampPoint","clampedPoint","intersect","union","translate","isMaterial","newValue","extractFromCache","isRoot","srcPlanes","dstPlanes","isBox3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","traverse","closestPoint","intersectsPlane","getBoundingSphere","optionalCenter","maxRadiusSq","radiusSum","deltaLengthSq","getBoundingBox","setFromMatrix4","matrix4","transposeIntoArray","setComponents","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","denominator","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","frustum","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","intersectsSprite","negRadius","d1","d2","at","recast","closestPointToPoint","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","invDet","intersectSphere","tca","radius2","thc","t0","t1","distanceToPlane","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","RotationOrders","asin","setFromVector3","reorder","newOrder","toVector3","optionalResult","channel","isObject3D","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","force","isRootObject","stringify","distanceSq","closestPointToPointParameter","startP","startEnd","clampToLine","startEnd2","startEnd_startP","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","setFromPointsAndIndices","i0","triangle","area","midpoint","edgeList","projectedPoint","minDistance","isBufferAttribute","setArray","copyAt","copyArray","copyColorsArray","copyIndicesArray","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXYZW","computeBoundingBox","addFace","tempNormals","tempUVs","tempUVs2","cb","ab","fl","vA","vB","vC","areaWeighted","vl","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","colors1","colors2","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","verticesMap","changes","precisionPoints","faceIndicesToRemove","dupIndex","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","getNormalIndex","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","getIndex","clearGroups","setDrawRange","direct","__directGeometry","lineDistance","fromDirectGeometry","pA","pB","pC","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","array2","setDrawMode","morphTargetDictionary","ml","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","faceIndex","inverseMatrix","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","tl","uvs_f","isPerspectiveCamera","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","clearViewOffset","skew","isOrthographicCamera","zoomW","zoomH","scaleW","scaleH","vecX","vecY","wantedRotation","matrixPosition","guessSizeSq","level","addLevel","getObjectForDistance","pose","offsetMatrix","sw","vec","skinWeight","linePrecision","precisionSq","vStart","vEnd","interSegment","interRay","distSq","nbVertices","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","ShapeUtils","contour","triangulate","snip","verts","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","removeDupEndPts","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","forEach","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","addShape","scalePt2","pt","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","getSpacedPoints","shapePoints","extractPoints","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","indexA","indexB","indexC","indexD","Geometries","freeze","isShadowMaterial","Materials","Cache","files","dataUriRegex","dataUriRegexResult","isBase64","decodeURIComponent","atob","ArrayBuffer","Blob","parser","request","setPath","setResponseType","setWithCredentials","loadTexture","loader","texDatas","mipmapCount","isCubemap","DataTextureLoader","texData","URL","revokeObjectURL","blob","createObjectURL","setCrossOrigin","crossOrigin","urls","isJPEG","search","arraySlice","from","isTypedArray","forceClone","isView","DataView","getKeyframeOrder","compareTime","sortedArray","nValues","srcOffset","flattenJSON","jsonKeys","valuePropertyName","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","DefaultSettings_","getSettings_","copySampleValue_","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","offset1","offset0","weight1","weight0","KeyframeTrackPrototype","InterpolantFactoryMethodDiscrete","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","ValueTypeName","getInterpolation","timeOffset","endTime","nKeys","valid","prevTime","currTime","smoothInterpolation","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","trackType","_getTrackTypeForValueTypeName","track","jsonTracks","frameTime","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","findByName","objectOrClipArray","clipArray","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","animationMorphTargets","clips","parseAnimation","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","setTextures","getTexture","TYPED_ARRAYS","typedArray","drawcalls","offsets","extractUrlBase","initMaterials","createMaterial","textureLoader","materialLoader","fullPath","Handlers","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","mapEmissiveRepeat","mapEmissiveOffset","mapEmissiveWrap","mapEmissiveAnisotropy","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","mapMetalnessRepeat","mapMetalnessOffset","mapMetalnessWrap","mapMetalnessAnisotropy","mapRoughnessRepeat","mapRoughnessOffset","mapRoughnessWrap","mapRoughnessAnisotropy","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","regex","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","morphAnimationClips","substring","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","loadImage","parseConstant","getGeometry","getMaterial","isInteger","getUtoTmapping","getPoints","lengths","getLengths","cacheArcLengths","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","mat","MAX_VALUE","tz","getPointFunc","isLineCurve","tangent","curve","closePath","startPoint","endPoint","curveLengths","getCurveLengths","lens","cacheLengths","sums","resolution","isEllipseCurve","isSplineCurve","createPointsGeometry","createGeometry","createSpacedPointsGeometry","twoPi","deltaAngle","samePoints","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","point0","point1","point2","point3","PathPrototype","moveTo","lineTo","quadraticCurveTo","aCPx","aCPy","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","absarc","absellipse","ellipse","firstPoint","lastPoint","getPointsHoles","holesPts","extractAllPoints","toShapes","isCCW","noHoles","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","isPointInsidePolygon","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","createPaths","paths","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","outline","_cachedOutline","action","ha","decodeAudioData","audioBuffer","instance","eyeRight","eyeLeft","eyeSepOnProjection","removeFilter","disconnect","getFilter","setFilter","getMasterVolume","setMasterVolume","orientation","setOrientation","setNodeSource","audioNode","setBuffer","play","pause","getFilters","setPlaybackRate","getPlaybackRate","getLoop","setLoop","getVolume","setVolume","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","getFrequencyData","getByteFrequencyData","getAverageFrequency","accumulate","accuIndex","currentWeight","mix","originalValueOffset","saveOriginalState","getValue","restoreOriginalState","targetArray","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","_getValue_unbound","_setValue_unbound","Composite","targetGroup","optionalParsedPath","_targetGroup","subscribe_","firstValidIndex","bindings","isAnimationObjectGroup","re","searchSkeleton","searchNodeSubtree","childNode","subTreeNode","nObjects","nCachedObjects","indicesByUUID","parsedPaths","nBindings","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastObject","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setEffectiveWeight","getEffectiveWeight","_scheduleFading","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","startTimeScale","endTimeScale","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","getRoot","_update","deltaTime","timeDirection","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","pending","atStart","atEnd","weightNow","weightThen","clipAction","optionalRoot","rootUuid","clipObject","clipUuid","actionsForClip","_actionsByClip","prototypeAction","existingAction","actionByRoot","knownActions","newAction","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","_nActiveBindings","uncacheClip","actionsByClip","actionsToRemove","cacheIndex","lastInactiveAction","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","_removeInactiveBinding","uncacheAction","bindingsByName","_addInactiveBinding","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","lastInactiveBinding","remove_empty_map","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","isInterleavedBuffer","setFromCamera","intersectObjects","performance","getElapsedTime","getDelta","newTime","other","makeSafe","vec3","lastFrame","currentFrame","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe","objPos","objNorm","vector2","coneLength","coneWidth","boneList","matrixWorldInv","boneMatrix","setColors","lightPlane","targetLine","setPoint","setColor","CubicPoly","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","SplineCurve3","CubicBezierCurve3","QuadraticBezierCurve3","LineCurve3","SceneUtils","createMultiMaterialObject","attach","LineStrip","LinePieces","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","extrude","makeGeometry","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","audioLoader","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","CubeGeometry","MeshFaceMaterial","Particle","addPanel","panel","dom","showPanel","beginTime","fpsPanel","Panel","msPanel","memPanel","begin","usedJSHeapSize","jsHeapSizeLimit","fg","bg","PR","WIDTH","HEIGHT","TEXT_X","TEXT_Y","GRAPH_X","GRAPH_Y","GRAPH_WIDTH","GRAPH_HEIGHT","textBaseline","fillText","globalAlpha","maxValue","utils","controllers","link","rel","inject","injected","ARR_EACH","ARR_SLICE","BREAK","isUndefined","defaults","toCall","itr","fnc","isNull","isObject","isNumber","isString","isBoolean","Controller","initialValue","__onChange","__onFinishChange","onFinishChange","updateDisplay","isModified","cssValueToPixels","CSS_VALUE_PIXELS","EVENT_MAP","HTMLEvents","MouseEvents","KeyboardEvents","EVENT_MAP_INV","makeSelectable","selectable","onselectstart","MozUserSelect","KhtmlUserSelect","unselectable","makeFullscreen","horizontal","vertical","fakeEvent","eventType","aux","createEvent","initMouseEvent","clickCount","initKeyboardEvent","initKeyEvent","initEvent","detachEvent","getWidth","getHeight","getOffset","offsetLeft","offsetTop","isActive","OptionController","superclass","__select","element","desiredValue","toReturn","NumberController","numDecimals","__min","__max","__step","__impliedStep","LN10","__precision","NumberControllerBox","roundToDecimal","decimals","tenTo","attempted","__input","onBlur","onMouseDown","onMouseDrag","onMouseUp","prev_y","__truncationSuspended","NumberControllerSlider","styleSheet","o2","__background","__foreground","useDefaultStyles","pct","FunctionController","__button","BooleanController","__prev","__checkbox","interpret","INTERPRETATIONS","family","litmus","conversions","conversion","conversionName","read","THREE_CHAR_HEX","space","write","SIX_CHAR_HEX","CSS_RGB","CSS_RGBA","HEX","RGB_ARRAY","RGBA_ARRAY","RGBA_OBJ","RGB_OBJ","HSVA_OBJ","HSV_OBJ","saveDialogueContents","controllerFactory","ColorController","CenteredDiv","controller","factoryArgs","__li","recallSavedValue","li","addRow","CLASS_CONTROLLER_ROW","augmentController","__controllers","liBefore","__ul","__gui","nextElementSibling","listen","borderLeftColor","__color","__preset_select","markPresetModified","matched_index","__rememberedObjects","controller_map","__rememberedObjectIndecesToControllers","remembered","preset","preset_map","DEFAULT_DEFAULT_PRESET_NAME","getLocalStorageHash","addSaveMenu","showHideExplain","explain","useLocalStorage","__save_row","gears","button2","button3","addPresetOption","SUPPORTS_LOCAL_STORAGE","saveLocally","localStorageCheckBox","localStorage","getItem","newConstructorTextArea","SAVE_DIALOGUE","getSaveObject","save","presetName","prompt","saveAs","revert","addResizeHandle","dragStart","pmouseX","__closeButton","CLASS_DRAG","drag","dragStop","__resize_handle","cursor","setWidth","autoPlace","getCurrentPreset","useInitialValues","saved_values","setSelected","setPresetSelectIndex","updateDisplays","controllerArray","auto_place_container","CSS_NAMESPACE","HIDE_KEY_CODE","CLOSE_BUTTON_HEIGHT","auto_place_virgin","hideable_guis","saveToLocalStorage","setItem","resetWidth","__folders","__listening","DEFAULT_WIDTH","resizable","hideable","scrollable","use_local_storage","title_row_name","CLASS_CLOSED","TEXT_OPEN","TEXT_CLOSED","CLASS_MAIN","saved_gui","CLASS_CLOSE_BUTTON","title_row","on_click_title","CLASS_AUTO_PLACE_CONTAINER","CLASS_AUTO_PLACE","toggleHide","CLASS_TOO_TALL","addColor","addFolder","new_gui_params","folders","close","remember","folder","StringController","linearGradient","vendors","vendor","hueGradient","fieldDown","setSV","unbindSV","__state","toOriginal","unbindH","setH","__saturation_field","__hue_field","__temp","__selector","__field_knob","__field_knob_border","__hue_knob","__input_textShadow","value_field","backgroundColor","boxShadow","borderRadius","borderRight","textAlign","textShadow","mismatch","COMPONENTS","component","flip","_flip","marginTop","math","defineRGBComponent","componentHexIndex","recalculateRGB","defineHSVComponent","recalculateHSV","component_from_hex","hsv_to_rgb","rgb_to_hsv","rgb_to_hex","tmpComponent","hi","NaN","hex_with_component","componentIndex","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","backgroundElement","WebkitTransition","webkitTransform","layout","cubeGeometry","cubeMaterial"],"mappings":"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,GAAA,2GAEAC,GAAA,6EAEAC,GAAA,iSAEAC,GAAA,2QAEAC,GAAA,+LAEAC,GAAA,ivBAEAC,GAAA,ohBAEAC,GAAA,+RAEAC,GAAA,8aAEAC,GAAA,wXAEAC,GAAA,+LAEAC,GAAA,qyBAEAC,GAAA,6dAEAC,GAAA,80CAEAC,GAAA,kzBAEAC,GAAA,wiEAEAC,GAAA,ugCAEAC,GAAA,+yDAEAC,GAAA,knCAEAC,GAAA,koEAEAC,GAAA,gmCAEAC,GAAA,oUAEAC,GAAA,+XAEAC,GAAA,8yBAEAC,GAAA,ujBAEAC,GAAA,sRAEAC,GAAA,4KAEA3uD;AACAmoD,qBACAC,0BACAC,sBACAC,kBACAC,uBACAC,gBACAC,sBACAC,SACAC,yBACAC,4BACAC,iCACAC,+BACAC,0BACAC,kBACAC,uBACAC,qBACAC,gBACAC,UACAC,+BACAC,wBACAC,+BACAC,0BACAC,wBACAC,6BACAC,sBACAC,2BACAC,mBACAC,wBACAC,sBACAC,iBACAC,gBACAC,qBACAC,qBACAC,0BACAC,yBACAC,eACAC,yBACAC,8BACAC,4BACAC,iCACAC,mBACAC,wBACAC,6BACAC,2BACAC,sBACAC,gBACAC,qBACAC,yBACAC,8BACAC,yBACAC,8BACAC,sBACAC,2BACAC,sBACAC,eACAC,mBACAC,2BACAC,WACAC,gCACAC,kBACAC,yBACAC,8BACAC,2BACAC,yBACAC,oBACAC,4BACAC,mBACAC,wBACAC,mBACAC,qBACAC,wBACAC,6BACAC,wBACAC,6BACAC,oBACAC,kBACAC,aACAC,qBACAC,mBACAC,cACAC,mBAEAC,aACAC,aACAC,cACAC,cACAC,qBACAC,qBACAC,iBACAC,iBACAC,mBACAC,mBACAC,kBACAC,kBACAC,oBACAC,oBACAC,kBACAC,kBACAC,qBACAC,qBACAC,eACAC,eACAC,eACAC,eACAC,eACAC,eAoBA1jH,GAAAV,WAEA6b,YAAAnb,EAEA4pD,SAAA,EAEAla,EAAA,EAAAiB,EAAA,EAAAlxB,EAAA,EAEArd,IAAA,SAAAmE,GAgBA,MAdAA,MAAAqjD,QAEAnqD,KAAAmc,KAAArV,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","file":"index.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cats = __webpack_require__(1);\n\t\n\t// console.log(cats);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function($) {window.THREE = __webpack_require__(3);\n\tvar Stats = __webpack_require__(4);\n\tvar dat = __webpack_require__(5);\n\t\n\t__webpack_require__(8);\n\t\n\t(function () {\n\t\n\t  var sample = window.sample || {};\n\t  window.sample = sample;\n\t\n\t  //初期化実行\n\t  $(function () {\n\t    new sample.MainDisplay();\n\t  });\n\t})();\n\t\n\t//Cubeをインスタンス化\n\tvar CubeObject = new Cube();\n\t\n\t(function () {\n\t  var sample = window.sample || {};\n\t  window.sample = sample;\n\t\n\t  /**\n\t   * メインクラス\n\t   */\n\t  sample.MainDisplay = function () {\n\t    //イニシャライズ\n\t    p.init();\n\t  };\n\t\n\t  var p, s;\n\t\n\t  s = sample.MainDisplay;\n\t  p = s.prototype;\n\t\n\t  var renderScene;\n\t\n\t  /**\n\t   * イニシャライズ\n\t   */\n\t  p.init = function () {\n\t    var self = this;\n\t\n\t    this.$window = $(window);\n\t    this.$MainDisplay = $('#WebGL-output');\n\t\n\t    //WebGL renderer\n\t    this.renderer = new THREE.WebGLRenderer();\n\t    if (!this.renderer) {\n\t      alert('Three.jsの初期化に失敗しました。');\n\t    }\n\t    this.renderer.setClearColor(new THREE.Color(0xEEEEEE));\n\t    this.renderer.setSize(window.innerWidth, window.innerHeight);\n\t    this.renderer.shadowMap.enabled = true;\n\t\n\t    // 高解像度対応\n\t    var pixelRatio = Math.min(window.devicePixelRatio || 1, 2);\n\t    this.renderer.setPixelRatio(pixelRatio);\n\t\n\t    //scene\n\t    this.scene = new THREE.Scene();\n\t\n\t    //camera\n\t    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n\t    this.camera.position.x = -30;\n\t    this.camera.position.y = 40;\n\t    this.camera.position.z = 30;\n\t    this.camera.lookAt(this.scene.position);\n\t\n\t    // window resize\n\t    this.$window.on('resize', function (e) {\n\t      self.onResize();\n\t    });\n\t\n\t    // resizeイベントを発火してキャンバスサイズをリサイズ\n\t    this.$window.trigger('resize');\n\t\n\t    //axes\n\t    // var axes = new THREE.AxisHelper(20);\n\t    // this.scene.add(axes);\n\t\n\t    //planeGeometry\n\t    var planeGeometry = new THREE.PlaneGeometry(60, 20);\n\t\n\t    //planeMaterial\n\t    var planeMaterial = new THREE.MeshLambertMaterial({\n\t      color: 0xffffff\n\t    });\n\t\n\t    //plane\n\t    var plane = new THREE.Mesh(planeGeometry, planeMaterial);\n\t    plane.receiveShadow = true;\n\t    //planeを回転\n\t    plane.rotation.x = -0.5 * Math.PI;\n\t    plane.position.x = 15;\n\t    plane.position.y = 0;\n\t    plane.position.z = 0;\n\t    this.scene.add(plane);\n\t\n\t    //Cubeをシーンに追加\n\t    this.scene.add(CubeObject.init());\n\t\n\t    //sphereGeometry\n\t    // var sphereGeometry = new THREE.SphereGeometry(4, 20,20);\n\t    //\n\t    // //sphereMaterial\n\t    // var sphereMaterial = new THREE.MeshLambertMaterial({\n\t    //   color: 0x7777ff, wireframe: false\n\t    // });\n\t    //\n\t    // //sphere\n\t    // var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);\n\t    // sphere.castShadow = true;\n\t    // //sphereを回転\n\t    // sphere.position.x = 20;\n\t    // sphere.position.y = 4;\n\t    // sphere.position.z = 2;\n\t    // this.scene.add(sphere);\n\t\n\t\n\t    var spotLight = new THREE.SpotLight(0xffffff);\n\t    spotLight.position.set(-20, 30, -5);\n\t    spotLight.castShadow = true;\n\t    this.scene.add(spotLight);\n\t\n\t    document.getElementById(\"WebGL-output\").appendChild(this.renderer.domElement);\n\t\n\t    var stats = initStats();\n\t    renderScene = function () {\n\t      stats.update();\n\t      // rotate the cube around its axes\n\t      // CubeObject.init().rotation.x += 0.02;\n\t      // CubeObject.init().rotation.y += 0.02;\n\t      // CubeObject.init().rotation.z += 0.02;\n\t\n\t      // bounce the sphere up and down\n\t      // step += 0.04;\n\t      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n\t      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\t\n\t      // render using requestAnimationFrame\n\t      this.updateAnimation();\n\t    }.bind(this);\n\t\n\t    // call the render function\n\t    var step = 0;\n\t    renderScene();\n\t\n\t    /**\n\t     * dat.gui\n\t     * dat.guiのコントローラーを定義\n\t     */\n\t    var controls = new function () {\n\t      this.rotationSpeed = 0.001;\n\t      this.bouncingSpeed = 0.001;\n\t    }();\n\t\n\t    var gui = new dat.GUI();\n\t    gui.add(controls, 'rotationSpeed', 0, 0.1);\n\t    gui.add(controls, 'bouncingSpeed', 0, 0.1);\n\t\n\t    var render = function () {\n\t      stats.update();\n\t      // rotate the cube around its axes\n\t      // cube.rotation.x += controls.rotationSpeed;\n\t      // cube.rotation.y += controls.rotationSpeed;\n\t      // cube.rotation.z += controls.rotationSpeed;\n\t\n\t      // bounce the sphere up and down\n\t      // step += controls.bouncingSpeed;\n\t      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n\t      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\t\n\t      requestAnimationFrame(render);\n\t      this.renderer.render(this.scene, this.camera);\n\t    }.bind(this);\n\t    render();\n\t  };\n\t\n\t  //Stats表示設定\n\t  function initStats() {\n\t\n\t    var stats = new Stats();\n\t\n\t    stats.setMode(0); // 0: fps, 1: ms\n\t\n\t    // Align top-left\n\t    stats.domElement.style.position = 'absolute';\n\t    stats.domElement.style.left = '0px';\n\t    stats.domElement.style.top = '0px';\n\t\n\t    document.getElementById(\"Stats-output\").appendChild(stats.domElement);\n\t\n\t    return stats;\n\t  }\n\t\n\t  /**\n\t   * アニメーション開始\n\t   */\n\t  // p.start = function () {\n\t  //   var self = this;\n\t  //\n\t  //   var enterFrameHandler = function() {\n\t  //     requestAnimationFrame(enterFrameHandler);\n\t  //     self.update();\n\t  //   };\n\t  //\n\t  //   enterFrameHandler();\n\t  // };\n\t\n\t  /**\n\t   * アニメーションループ内で実行される\n\t   */\n\t  p.updateAnimation = function () {\n\t    requestAnimationFrame(renderScene);\n\t    this.renderer.render(this.scene, this.camera);\n\t  };\n\t\n\t  /**\n\t   * リサイズ処理\n\t   * @param {jQuery.Event} e - jQueryのイベントオブジェクト\n\t   */\n\t  p.onResize = function () {\n\t\n\t    this.width = this.$window.width();\n\t    this.height = this.$window.height();\n\t\n\t    this.camera.aspect = this.width / this.height;\n\t    this.camera.updateProjectionMatrix();\n\t\n\t    this.renderer.setSize(this.width, this.height);\n\t  };\n\t\n\t  // p.createDatGUIBox = function () {\n\t\n\t  // };\n\t})();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * jQuery JavaScript Library v3.1.1\n\t * https://jquery.com/\n\t *\n\t * Includes Sizzle.js\n\t * https://sizzlejs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * https://jquery.org/license\n\t *\n\t * Date: 2016-09-22T22:30Z\n\t */\n\t( function( global, factory ) {\n\t\n\t\t\"use strict\";\n\t\n\t\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\n\t\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t\t// is present, execute the factory and get jQuery.\n\t\t\t// For environments that do not have a `window` with a `document`\n\t\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t\t// This accentuates the need for the creation of a real `window`.\n\t\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t\t// See ticket #14549 for more info.\n\t\t\tmodule.exports = global.document ?\n\t\t\t\tfactory( global, true ) :\n\t\t\t\tfunction( w ) {\n\t\t\t\t\tif ( !w.document ) {\n\t\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn factory( w );\n\t\t\t\t};\n\t\t} else {\n\t\t\tfactory( global );\n\t\t}\n\t\n\t// Pass this if window is not defined yet\n\t} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\t\n\t// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n\t// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n\t// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n\t// enough that all such attempts are guarded in a try block.\n\t\"use strict\";\n\t\n\tvar arr = [];\n\t\n\tvar document = window.document;\n\t\n\tvar getProto = Object.getPrototypeOf;\n\t\n\tvar slice = arr.slice;\n\t\n\tvar concat = arr.concat;\n\t\n\tvar push = arr.push;\n\t\n\tvar indexOf = arr.indexOf;\n\t\n\tvar class2type = {};\n\t\n\tvar toString = class2type.toString;\n\t\n\tvar hasOwn = class2type.hasOwnProperty;\n\t\n\tvar fnToString = hasOwn.toString;\n\t\n\tvar ObjectFunctionString = fnToString.call( Object );\n\t\n\tvar support = {};\n\t\n\t\n\t\n\t\tfunction DOMEval( code, doc ) {\n\t\t\tdoc = doc || document;\n\t\n\t\t\tvar script = doc.createElement( \"script\" );\n\t\n\t\t\tscript.text = code;\n\t\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t\t}\n\t/* global Symbol */\n\t// Defining this global in .eslintrc.json would create a danger of using the global\n\t// unguarded in another place, it seems safer to define global only for this module\n\t\n\t\n\t\n\tvar\n\t\tversion = \"3.1.1\",\n\t\n\t\t// Define a local copy of jQuery\n\t\tjQuery = function( selector, context ) {\n\t\n\t\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\t\treturn new jQuery.fn.init( selector, context );\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only\n\t\t// Make sure we trim BOM and NBSP\n\t\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\t\n\t\t// Matches dashed string for camelizing\n\t\trmsPrefix = /^-ms-/,\n\t\trdashAlpha = /-([a-z])/g,\n\t\n\t\t// Used by jQuery.camelCase as callback to replace()\n\t\tfcamelCase = function( all, letter ) {\n\t\t\treturn letter.toUpperCase();\n\t\t};\n\t\n\tjQuery.fn = jQuery.prototype = {\n\t\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\t\n\t\tconstructor: jQuery,\n\t\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\t\n\t\ttoArray: function() {\n\t\t\treturn slice.call( this );\n\t\t},\n\t\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function( num ) {\n\t\n\t\t\t// Return all the elements in a clean array\n\t\t\tif ( num == null ) {\n\t\t\t\treturn slice.call( this );\n\t\t\t}\n\t\n\t\t\t// Return just the one element from the set\n\t\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t\t},\n\t\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function( elems ) {\n\t\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\t\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\t\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\t\n\t\t// Execute a callback for every element in the matched set.\n\t\teach: function( callback ) {\n\t\t\treturn jQuery.each( this, callback );\n\t\t},\n\t\n\t\tmap: function( callback ) {\n\t\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\t\treturn callback.call( elem, i, elem );\n\t\t\t} ) );\n\t\t},\n\t\n\t\tslice: function() {\n\t\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t\t},\n\t\n\t\tfirst: function() {\n\t\t\treturn this.eq( 0 );\n\t\t},\n\t\n\t\tlast: function() {\n\t\t\treturn this.eq( -1 );\n\t\t},\n\t\n\t\teq: function( i ) {\n\t\t\tvar len = this.length,\n\t\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t\t},\n\t\n\t\tend: function() {\n\t\t\treturn this.prevObject || this.constructor();\n\t\t},\n\t\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: arr.sort,\n\t\tsplice: arr.splice\n\t};\n\t\n\tjQuery.extend = jQuery.fn.extend = function() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[ 0 ] || {},\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif ( typeof target === \"boolean\" ) {\n\t\t\tdeep = target;\n\t\n\t\t\t// Skip the boolean and the target\n\t\t\ttarget = arguments[ i ] || {};\n\t\t\ti++;\n\t\t}\n\t\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\t// Extend jQuery itself if only one argument is passed\n\t\tif ( i === length ) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\t\n\t\tfor ( ; i < length; i++ ) {\n\t\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ( ( options = arguments[ i ] ) != null ) {\n\t\n\t\t\t\t// Extend the base object\n\t\t\t\tfor ( name in options ) {\n\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\tcopy = options[ name ];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\t\n\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\t\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\tjQuery.extend( {\n\t\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\t\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\t\n\t\terror: function( msg ) {\n\t\t\tthrow new Error( msg );\n\t\t},\n\t\n\t\tnoop: function() {},\n\t\n\t\tisFunction: function( obj ) {\n\t\t\treturn jQuery.type( obj ) === \"function\";\n\t\t},\n\t\n\t\tisArray: Array.isArray,\n\t\n\t\tisWindow: function( obj ) {\n\t\t\treturn obj != null && obj === obj.window;\n\t\t},\n\t\n\t\tisNumeric: function( obj ) {\n\t\n\t\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t\t// strings and numbers (primitives or objects)\n\t\t\t// that can be coerced to finite numbers (gh-2662)\n\t\t\tvar type = jQuery.type( obj );\n\t\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\t\n\t\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t\t// subtraction forces infinities to NaN\n\t\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t\t},\n\t\n\t\tisPlainObject: function( obj ) {\n\t\t\tvar proto, Ctor;\n\t\n\t\t\t// Detect obvious negatives\n\t\t\t// Use toString instead of jQuery.type to catch host objects\n\t\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tproto = getProto( obj );\n\t\n\t\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\t\tif ( !proto ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t\t},\n\t\n\t\tisEmptyObject: function( obj ) {\n\t\n\t\t\t/* eslint-disable no-unused-vars */\n\t\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\t\tvar name;\n\t\n\t\t\tfor ( name in obj ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\ttype: function( obj ) {\n\t\t\tif ( obj == null ) {\n\t\t\t\treturn obj + \"\";\n\t\t\t}\n\t\n\t\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\t\ttypeof obj;\n\t\t},\n\t\n\t\t// Evaluates a script in a global context\n\t\tglobalEval: function( code ) {\n\t\t\tDOMEval( code );\n\t\t},\n\t\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function( string ) {\n\t\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t\t},\n\t\n\t\tnodeName: function( elem, name ) {\n\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t\t},\n\t\n\t\teach: function( obj, callback ) {\n\t\t\tvar length, i = 0;\n\t\n\t\t\tif ( isArrayLike( obj ) ) {\n\t\t\t\tlength = obj.length;\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn obj;\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only\n\t\ttrim: function( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t\t},\n\t\n\t\t// results is for internal usage only\n\t\tmakeArray: function( arr, results ) {\n\t\t\tvar ret = results || [];\n\t\n\t\t\tif ( arr != null ) {\n\t\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call( ret, arr );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn ret;\n\t\t},\n\t\n\t\tinArray: function( elem, arr, i ) {\n\t\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\tmerge: function( first, second ) {\n\t\t\tvar len = +second.length,\n\t\t\t\tj = 0,\n\t\t\t\ti = first.length;\n\t\n\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\n\t\t\tfirst.length = i;\n\t\n\t\t\treturn first;\n\t\t},\n\t\n\t\tgrep: function( elems, callback, invert ) {\n\t\t\tvar callbackInverse,\n\t\t\t\tmatches = [],\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tcallbackExpect = !invert;\n\t\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn matches;\n\t\t},\n\t\n\t\t// arg is for internal usage only\n\t\tmap: function( elems, callback, arg ) {\n\t\t\tvar length, value,\n\t\t\t\ti = 0,\n\t\t\t\tret = [];\n\t\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif ( isArrayLike( elems ) ) {\n\t\t\t\tlength = elems.length;\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor ( i in elems ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply( [], ret );\n\t\t},\n\t\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\t\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function( fn, context ) {\n\t\t\tvar tmp, args, proxy;\n\t\n\t\t\tif ( typeof context === \"string\" ) {\n\t\t\t\ttmp = fn[ context ];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\t\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\n\t\t\t// Simulated bind\n\t\t\targs = slice.call( arguments, 2 );\n\t\t\tproxy = function() {\n\t\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t\t};\n\t\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\t\n\t\t\treturn proxy;\n\t\t},\n\t\n\t\tnow: Date.now,\n\t\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t} );\n\t\n\tif ( typeof Symbol === \"function\" ) {\n\t\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n\t}\n\t\n\t// Populate the class2type map\n\tjQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n\tfunction( i, name ) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t} );\n\t\n\tfunction isArrayLike( obj ) {\n\t\n\t\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn't used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\t\ttype = jQuery.type( obj );\n\t\n\t\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\treturn type === \"array\" || length === 0 ||\n\t\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n\t * Sizzle CSS Selector Engine v2.3.3\n\t * https://sizzlejs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2016-08-08\n\t */\n\t(function( window ) {\n\t\n\tvar i,\n\t\tsupport,\n\t\tExpr,\n\t\tgetText,\n\t\tisXML,\n\t\ttokenize,\n\t\tcompile,\n\t\tselect,\n\t\toutermostContext,\n\t\tsortInput,\n\t\thasDuplicate,\n\t\n\t\t// Local document vars\n\t\tsetDocument,\n\t\tdocument,\n\t\tdocElem,\n\t\tdocumentIsHTML,\n\t\trbuggyQSA,\n\t\trbuggyMatches,\n\t\tmatches,\n\t\tcontains,\n\t\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + 1 * new Date(),\n\t\tpreferredDoc = window.document,\n\t\tdirruns = 0,\n\t\tdone = 0,\n\t\tclassCache = createCache(),\n\t\ttokenCache = createCache(),\n\t\tcompilerCache = createCache(),\n\t\tsortOrder = function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\t\n\t\t// Instance methods\n\t\thasOwn = ({}).hasOwnProperty,\n\t\tarr = [],\n\t\tpop = arr.pop,\n\t\tpush_native = arr.push,\n\t\tpush = arr.push,\n\t\tslice = arr.slice,\n\t\t// Use a stripped-down indexOf as it's faster than native\n\t\t// https://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function( list, elem ) {\n\t\t\tvar i = 0,\n\t\t\t\tlen = list.length;\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tif ( list[i] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\n\t\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\t\n\t\t// Regular expressions\n\t\n\t\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\t\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t\t// Operator (capture 2)\n\t\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\t\"*\\\\]\",\n\t\n\t\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t\t// 2. simple (capture 6)\n\t\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t\t// 3. anything else (capture 2)\n\t\t\t\".*\" +\n\t\t\t\")\\\\)|)\",\n\t\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\t\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\t\n\t\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\t\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\t\n\t\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\t\n\t\trpseudo = new RegExp( pseudos ),\n\t\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\t\n\t\tmatchExpr = {\n\t\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t\t},\n\t\n\t\trinputs = /^(?:input|select|textarea|button)$/i,\n\t\trheader = /^h\\d$/i,\n\t\n\t\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\t\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\n\t\trsibling = /[+~]/,\n\t\n\t\t// CSS escapes\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\t\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ?\n\t\t\t\tescaped :\n\t\t\t\thigh < 0 ?\n\t\t\t\t\t// BMP codepoint\n\t\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t\t},\n\t\n\t\t// CSS string/identifier serialization\n\t\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\t\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\t\tfcssescape = function( ch, asCodePoint ) {\n\t\t\tif ( asCodePoint ) {\n\t\n\t\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\t\treturn \"\\uFFFD\";\n\t\t\t\t}\n\t\n\t\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t\t}\n\t\n\t\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\t\treturn \"\\\\\" + ch;\n\t\t},\n\t\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a \"Permission Denied\"\n\t\t// error in IE\n\t\tunloadHandler = function() {\n\t\t\tsetDocument();\n\t\t},\n\t\n\t\tdisabledAncestor = addCombinator(\n\t\t\tfunction( elem ) {\n\t\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t\t},\n\t\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t\t);\n\t\n\t// Optimize for push.apply( _, NodeList )\n\ttry {\n\t\tpush.apply(\n\t\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\t\tpreferredDoc.childNodes\n\t\t);\n\t\t// Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\t\tarr[ preferredDoc.childNodes.length ].nodeType;\n\t} catch ( e ) {\n\t\tpush = { apply: arr.length ?\n\t\n\t\t\t// Leverage slice if possible\n\t\t\tfunction( target, els ) {\n\t\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t\t} :\n\t\n\t\t\t// Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction( target, els ) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t\ti = 0;\n\t\t\t\t// Can't trust NodeList.length\n\t\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction Sizzle( selector, context, results, seed ) {\n\t\tvar m, i, elem, nid, match, groups, newSelector,\n\t\t\tnewContext = context && context.ownerDocument,\n\t\n\t\t\t// nodeType defaults to 9, since context defaults to document\n\t\t\tnodeType = context ? context.nodeType : 9;\n\t\n\t\tresults = results || [];\n\t\n\t\t// Return early from calls with invalid selector or context\n\t\tif ( typeof selector !== \"string\" || !selector ||\n\t\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\t\n\t\t\treturn results;\n\t\t}\n\t\n\t\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\t\tif ( !seed ) {\n\t\n\t\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\t\tsetDocument( context );\n\t\t\t}\n\t\t\tcontext = context || document;\n\t\n\t\t\tif ( documentIsHTML ) {\n\t\n\t\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\n\t\t\t\t\t// ID selector\n\t\t\t\t\tif ( (m = match[1]) ) {\n\t\n\t\t\t\t\t\t// Document context\n\t\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\t\n\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Element context\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\t\telem.id === m ) {\n\t\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t// Type selector\n\t\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\t\treturn results;\n\t\n\t\t\t\t\t// Class selector\n\t\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\t\tcontext.getElementsByClassName ) {\n\t\n\t\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Take advantage of querySelectorAll\n\t\t\t\tif ( support.qsa &&\n\t\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\n\t\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\t\tnewContext = context;\n\t\t\t\t\t\tnewSelector = selector;\n\t\n\t\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t\t// Support: IE <=8\n\t\t\t\t\t// Exclude object elements\n\t\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\t\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\n\t\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\t\tcontext;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( newSelector ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// All others\n\t\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n\t}\n\t\n\t/**\n\t * Create key-value caches of limited size\n\t * @returns {function(string, object)} Returns the Object data after storing it on itself with\n\t *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n\t *\tdeleting the oldest entry\n\t */\n\tfunction createCache() {\n\t\tvar keys = [];\n\t\n\t\tfunction cache( key, value ) {\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[ keys.shift() ];\n\t\t\t}\n\t\t\treturn (cache[ key + \" \" ] = value);\n\t\t}\n\t\treturn cache;\n\t}\n\t\n\t/**\n\t * Mark a function for special use by Sizzle\n\t * @param {Function} fn The function to mark\n\t */\n\tfunction markFunction( fn ) {\n\t\tfn[ expando ] = true;\n\t\treturn fn;\n\t}\n\t\n\t/**\n\t * Support testing using an element\n\t * @param {Function} fn Passed the created element and returns a boolean result\n\t */\n\tfunction assert( fn ) {\n\t\tvar el = document.createElement(\"fieldset\");\n\t\n\t\ttry {\n\t\t\treturn !!fn( el );\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t// Remove from its parent by default\n\t\t\tif ( el.parentNode ) {\n\t\t\t\tel.parentNode.removeChild( el );\n\t\t\t}\n\t\t\t// release memory in IE\n\t\t\tel = null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the same handler for all of the specified attrs\n\t * @param {String} attrs Pipe-separated list of attributes\n\t * @param {Function} handler The method that will be applied\n\t */\n\tfunction addHandle( attrs, handler ) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t\ti = arr.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks document order of two siblings\n\t * @param {Element} a\n\t * @param {Element} b\n\t * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n\t */\n\tfunction siblingCheck( a, b ) {\n\t\tvar cur = b && a,\n\t\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t\ta.sourceIndex - b.sourceIndex;\n\t\n\t\t// Use IE sourceIndex if available on both nodes\n\t\tif ( diff ) {\n\t\t\treturn diff;\n\t\t}\n\t\n\t\t// Check if b follows a\n\t\tif ( cur ) {\n\t\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\t\tif ( cur === b ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn a ? 1 : -1;\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for input types\n\t * @param {String} type\n\t */\n\tfunction createInputPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for buttons\n\t * @param {String} type\n\t */\n\tfunction createButtonPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for :enabled/:disabled\n\t * @param {Boolean} disabled true for :disabled; false for :enabled\n\t */\n\tfunction createDisabledPseudo( disabled ) {\n\t\n\t\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\t\treturn function( elem ) {\n\t\n\t\t\t// Only certain elements can match :enabled or :disabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\t\tif ( \"form\" in elem ) {\n\t\n\t\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t\t// * option elements in a disabled optgroup\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t\t// All such elements have a \"form\" property.\n\t\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\t\n\t\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\t\treturn elem.isDisabled === disabled ||\n\t\n\t\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t\t}\n\t\n\t\t\t\treturn elem.disabled === disabled;\n\t\n\t\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t\t// even exist on them, let alone have a boolean value.\n\t\t\t} else if ( \"label\" in elem ) {\n\t\t\t\treturn elem.disabled === disabled;\n\t\t\t}\n\t\n\t\t\t// Remaining elements are neither :enabled nor :disabled\n\t\t\treturn false;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for positionals\n\t * @param {Function} fn\n\t */\n\tfunction createPositionalPseudo( fn ) {\n\t\treturn markFunction(function( argument ) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function( seed, matches ) {\n\t\t\t\tvar j,\n\t\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\t\ti = matchIndexes.length;\n\t\n\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t\n\t/**\n\t * Checks a node for validity as a Sizzle context\n\t * @param {Element|Object=} context\n\t * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n\t */\n\tfunction testContext( context ) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t}\n\t\n\t// Expose support vars for convenience\n\tsupport = Sizzle.support = {};\n\t\n\t/**\n\t * Detects XML nodes\n\t * @param {Element|Object} elem An element or a document\n\t * @returns {Boolean} True iff elem is a non-HTML XML node\n\t */\n\tisXML = Sizzle.isXML = function( elem ) {\n\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t// (such as loading iframes in IE - #4833)\n\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t};\n\t\n\t/**\n\t * Sets document-related variables once based on the current document\n\t * @param {Element|Object} [doc] An element or document object to use to set the document\n\t * @returns {Object} Returns the current document\n\t */\n\tsetDocument = Sizzle.setDocument = function( node ) {\n\t\tvar hasCompare, subWindow,\n\t\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\t\n\t\t// Return early if doc is invalid or already selected\n\t\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\t\treturn document;\n\t\t}\n\t\n\t\t// Update global variables\n\t\tdocument = doc;\n\t\tdocElem = document.documentElement;\n\t\tdocumentIsHTML = !isXML( document );\n\t\n\t\t// Support: IE 9-11, Edge\n\t\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t\tif ( preferredDoc !== document &&\n\t\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\t\n\t\t\t// Support: IE 11, Edge\n\t\t\tif ( subWindow.addEventListener ) {\n\t\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\t\n\t\t\t// Support: IE 9 - 10 only\n\t\t\t} else if ( subWindow.attachEvent ) {\n\t\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t\t}\n\t\t}\n\t\n\t\t/* Attributes\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\t\tsupport.attributes = assert(function( el ) {\n\t\t\tel.className = \"i\";\n\t\t\treturn !el.getAttribute(\"className\");\n\t\t});\n\t\n\t\t/* getElement(s)By*\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\tsupport.getElementsByTagName = assert(function( el ) {\n\t\t\tel.appendChild( document.createComment(\"\") );\n\t\t\treturn !el.getElementsByTagName(\"*\").length;\n\t\t});\n\t\n\t\t// Support: IE<9\n\t\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\t\n\t\t// Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programmatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\t\tsupport.getById = assert(function( el ) {\n\t\t\tdocElem.appendChild( el ).id = expando;\n\t\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t\t});\n\t\n\t\t// ID filter and find\n\t\tif ( support.getById ) {\n\t\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\n\t\t\t// Support: IE 6 - 7 only\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar node, i, elems,\n\t\t\t\t\t\telem = context.getElementById( id );\n\t\n\t\t\t\t\tif ( elem ) {\n\t\n\t\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\t// Tag\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\t\tfunction( tag, context ) {\n\t\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\t\treturn context.getElementsByTagName( tag );\n\t\n\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t\t} else if ( support.qsa ) {\n\t\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t\t}\n\t\t\t} :\n\t\n\t\t\tfunction( tag, context ) {\n\t\t\t\tvar elem,\n\t\t\t\t\ttmp = [],\n\t\t\t\t\ti = 0,\n\t\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\t\tresults = context.getElementsByTagName( tag );\n\t\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif ( tag === \"*\" ) {\n\t\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\n\t\t// Class\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\t\treturn context.getElementsByClassName( className );\n\t\t\t}\n\t\t};\n\t\n\t\t/* QSA/matchesSelector\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// QSA and matchesSelector support\n\t\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\trbuggyMatches = [];\n\t\n\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See https://bugs.jquery.com/ticket/13378\n\t\trbuggyQSA = [];\n\t\n\t\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function( el ) {\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\t\"<option selected=''></option></select>\";\n\t\n\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t}\n\t\n\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tassert(function( el ) {\n\t\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\t\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = document.createElement(\"input\");\n\t\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t\t}\n\t\n\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE9-11+\n\t\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\t\n\t\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\t\tdocElem.webkitMatchesSelector ||\n\t\t\tdocElem.mozMatchesSelector ||\n\t\t\tdocElem.oMatchesSelector ||\n\t\t\tdocElem.msMatchesSelector) )) ) {\n\t\n\t\t\tassert(function( el ) {\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\t\n\t\t\t\t// This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t\t});\n\t\t}\n\t\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\t\n\t\t/* Contains\n\t\t---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\t\n\t\t// Element contains another\n\t\t// Purposefully self-exclusive\n\t\t// As in, an element does not contain itself\n\t\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\t\tfunction( a, b ) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t\tbup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\t\tadown.contains ?\n\t\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t\t));\n\t\t\t} :\n\t\t\tfunction( a, b ) {\n\t\t\t\tif ( b ) {\n\t\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\n\t\t/* Sorting\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Document order sorting\n\t\tsortOrder = hasCompare ?\n\t\tfunction( a, b ) {\n\t\n\t\t\t// Flag for duplicate removal\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\tif ( compare ) {\n\t\t\t\treturn compare;\n\t\t\t}\n\t\n\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\t\ta.compareDocumentPosition( b ) :\n\t\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\t\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\t\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\t\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\taup = a.parentNode,\n\t\t\t\tbup = b.parentNode,\n\t\t\t\tap = [ a ],\n\t\t\t\tbp = [ b ];\n\t\n\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\tif ( !aup || !bup ) {\n\t\t\t\treturn a === document ? -1 :\n\t\t\t\t\tb === document ? 1 :\n\t\t\t\t\taup ? -1 :\n\t\t\t\t\tbup ? 1 :\n\t\t\t\t\tsortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\n\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t} else if ( aup === bup ) {\n\t\t\t\treturn siblingCheck( a, b );\n\t\t\t}\n\t\n\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\tcur = a;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tap.unshift( cur );\n\t\t\t}\n\t\t\tcur = b;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tbp.unshift( cur );\n\t\t\t}\n\t\n\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\twhile ( ap[i] === bp[i] ) {\n\t\t\t\ti++;\n\t\t\t}\n\t\n\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\t\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t\t0;\n\t\t};\n\t\n\t\treturn document;\n\t};\n\t\n\tSizzle.matches = function( expr, elements ) {\n\t\treturn Sizzle( expr, null, null, elements );\n\t};\n\t\n\tSizzle.matchesSelector = function( elem, expr ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\t// Make sure that attribute selectors are quoted\n\t\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\t\n\t\tif ( support.matchesSelector && documentIsHTML &&\n\t\t\t!compilerCache[ expr + \" \" ] &&\n\t\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\t\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call( elem, expr );\n\t\n\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t\n\t\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n\t};\n\t\n\tSizzle.contains = function( context, elem ) {\n\t\t// Set document vars if needed\n\t\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\treturn contains( context, elem );\n\t};\n\t\n\tSizzle.attr = function( elem, name ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\t\tundefined;\n\t\n\t\treturn val !== undefined ?\n\t\t\tval :\n\t\t\tsupport.attributes || !documentIsHTML ?\n\t\t\t\telem.getAttribute( name ) :\n\t\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t};\n\t\n\tSizzle.escape = function( sel ) {\n\t\treturn (sel + \"\").replace( rcssescape, fcssescape );\n\t};\n\t\n\tSizzle.error = function( msg ) {\n\t\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n\t};\n\t\n\t/**\n\t * Document sorting and removing duplicates\n\t * @param {ArrayLike} results\n\t */\n\tSizzle.uniqueSort = function( results ) {\n\t\tvar elem,\n\t\t\tduplicates = [],\n\t\t\tj = 0,\n\t\t\ti = 0;\n\t\n\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice( 0 );\n\t\tresults.sort( sortOrder );\n\t\n\t\tif ( hasDuplicate ) {\n\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\t\tj = duplicates.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( j-- ) {\n\t\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t\t}\n\t\t}\n\t\n\t\t// Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\tsortInput = null;\n\t\n\t\treturn results;\n\t};\n\t\n\t/**\n\t * Utility function for retrieving the text value of an array of DOM nodes\n\t * @param {Array|Element} elem\n\t */\n\tgetText = Sizzle.getText = function( elem ) {\n\t\tvar node,\n\t\t\tret = \"\",\n\t\t\ti = 0,\n\t\t\tnodeType = elem.nodeType;\n\t\n\t\tif ( !nodeType ) {\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile ( (node = elem[i++]) ) {\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText( node );\n\t\t\t}\n\t\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\t\t\t\t// Traverse its children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tret += getText( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\t\t// Do not include comment or processing instruction nodes\n\t\n\t\treturn ret;\n\t};\n\t\n\tExpr = Sizzle.selectors = {\n\t\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\t\n\t\tcreatePseudo: markFunction,\n\t\n\t\tmatch: matchExpr,\n\t\n\t\tattrHandle: {},\n\t\n\t\tfind: {},\n\t\n\t\trelative: {\n\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t},\n\t\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function( match ) {\n\t\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\t\n\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\t\n\t\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\t\n\t\t\t\treturn match.slice( 0, 4 );\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( match ) {\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t\t1 type (only|nth|...)\n\t\t\t\t\t2 what (child|of-type)\n\t\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t\t5 sign of xn-component\n\t\t\t\t\t6 x of xn-component\n\t\t\t\t\t7 sign of y-component\n\t\t\t\t\t8 y of y-component\n\t\t\t\t*/\n\t\t\t\tmatch[1] = match[1].toLowerCase();\n\t\n\t\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\t\n\t\t\t\t// other types prohibit arguments\n\t\t\t\t} else if ( match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\t\n\t\t\t\treturn match;\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( match ) {\n\t\t\t\tvar excess,\n\t\t\t\t\tunquoted = !match[6] && match[2];\n\t\n\t\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\tif ( match[3] ) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\t\n\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\t\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t\t}\n\t\n\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\treturn match.slice( 0, 3 );\n\t\t\t}\n\t\t},\n\t\n\t\tfilter: {\n\t\n\t\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\t\tfunction() { return true; } :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CLASS\": function( className ) {\n\t\t\t\tvar pattern = classCache[ className + \" \" ];\n\t\n\t\t\t\treturn pattern ||\n\t\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar result = Sizzle.attr( elem, name );\n\t\n\t\t\t\t\tif ( result == null ) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( !operator ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresult += \"\";\n\t\n\t\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\t\tfalse;\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\t\tofType = what === \"of-type\";\n\t\n\t\t\t\treturn first === 1 && last === 0 ?\n\t\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} :\n\t\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\t\tdiff = false;\n\t\n\t\t\t\t\t\tif ( parent ) {\n\t\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\t\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif ( forward && useCache ) {\n\t\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\t\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\n\t\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t\t++diff ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\t\n\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\t\t\t\tif ( fn[ expando ] ) {\n\t\t\t\t\treturn fn( argument );\n\t\t\t\t}\n\t\n\t\t\t\t// But maintain support for old signatures\n\t\t\t\tif ( fn.length > 1 ) {\n\t\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\t\n\t\tpseudos: {\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function( selector ) {\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t\tresults = [],\n\t\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\t\n\t\t\t\treturn matcher[ expando ] ?\n\t\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\t\ti = seed.length;\n\t\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"has\": markFunction(function( selector ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"contains\": markFunction(function( text ) {\n\t\t\t\ttext = text.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t\t}\n\t\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar elemLang;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\t\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function( elem ) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t\t},\n\t\n\t\t\t\"root\": function( elem ) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\t\n\t\t\t\"focus\": function( elem ) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\t\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\t\"disabled\": createDisabledPseudo( true ),\n\t\n\t\t\t\"checked\": function( elem ) {\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t\t},\n\t\n\t\t\t\"selected\": function( elem ) {\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\t\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\t\n\t\t\t// Contents\n\t\t\t\"empty\": function( elem ) {\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\t\"parent\": function( elem ) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t\t},\n\t\n\t\t\t// Element/input types\n\t\t\t\"header\": function( elem ) {\n\t\t\t\treturn rheader.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"input\": function( elem ) {\n\t\t\t\treturn rinputs.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"button\": function( elem ) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\t\n\t\t\t\"text\": function( elem ) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\t\telem.type === \"text\" &&\n\t\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t\t},\n\t\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function() {\n\t\t\t\treturn [ 0 ];\n\t\t\t}),\n\t\n\t\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\treturn [ length - 1 ];\n\t\t\t}),\n\t\n\t\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t\t}),\n\t\n\t\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 1;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\t\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\t\n\t// Add button/input type pseudos\n\tfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\t\tExpr.pseudos[ i ] = createInputPseudo( i );\n\t}\n\tfor ( i in { submit: true, reset: true } ) {\n\t\tExpr.pseudos[ i ] = createButtonPseudo( i );\n\t}\n\t\n\t// Easy API for creating new setFilters\n\tfunction setFilters() {}\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\t\n\ttokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\t\tvar matched, match, tokens, type,\n\t\t\tsoFar, groups, preFilters,\n\t\t\tcached = tokenCache[ selector + \" \" ];\n\t\n\t\tif ( cached ) {\n\t\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t\t}\n\t\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\t\n\t\twhile ( soFar ) {\n\t\n\t\t\t// Comma and first run\n\t\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\t\tif ( match ) {\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t\t}\n\t\t\t\tgroups.push( (tokens = []) );\n\t\t\t}\n\t\n\t\t\tmatched = false;\n\t\n\t\t\t// Combinators\n\t\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\n\t\t\t// Filters\n\t\t\tfor ( type in Expr.filter ) {\n\t\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !matched ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\t\treturn parseOnly ?\n\t\t\tsoFar.length :\n\t\t\tsoFar ?\n\t\t\t\tSizzle.error( selector ) :\n\t\t\t\t// Cache the tokens\n\t\t\t\ttokenCache( selector, groups ).slice( 0 );\n\t};\n\t\n\tfunction toSelector( tokens ) {\n\t\tvar i = 0,\n\t\t\tlen = tokens.length,\n\t\t\tselector = \"\";\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\t\treturn selector;\n\t}\n\t\n\tfunction addCombinator( matcher, combinator, base ) {\n\t\tvar dir = combinator.dir,\n\t\t\tskip = combinator.next,\n\t\t\tkey = skip || dir,\n\t\t\tcheckNonElements = base && key === \"parentNode\",\n\t\t\tdoneName = done++;\n\t\n\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} :\n\t\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\t\tnewCache = [ dirruns, doneName ];\n\t\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\t\tif ( xml ) {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\t\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\t\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t}\n\t\n\tfunction elementMatcher( matchers ) {\n\t\treturn matchers.length > 1 ?\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} :\n\t\t\tmatchers[0];\n\t}\n\t\n\tfunction multipleContexts( selector, contexts, results ) {\n\t\tvar i = 0,\n\t\t\tlen = contexts.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tSizzle( selector, contexts[i], results );\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tfunction condense( unmatched, map, filter, context, xml ) {\n\t\tvar elem,\n\t\t\tnewUnmatched = [],\n\t\t\ti = 0,\n\t\t\tlen = unmatched.length,\n\t\t\tmapped = map != null;\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\t\tif ( mapped ) {\n\t\t\t\t\t\tmap.push( i );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn newUnmatched;\n\t}\n\t\n\tfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\t\tif ( postFilter && !postFilter[ expando ] ) {\n\t\t\tpostFilter = setMatcher( postFilter );\n\t\t}\n\t\tif ( postFinder && !postFinder[ expando ] ) {\n\t\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t\t}\n\t\treturn markFunction(function( seed, results, context, xml ) {\n\t\t\tvar temp, i, elem,\n\t\t\t\tpreMap = [],\n\t\t\t\tpostMap = [],\n\t\t\t\tpreexisting = results.length,\n\t\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\t\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\t\telems,\n\t\n\t\t\t\tmatcherOut = matcher ?\n\t\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\t\n\t\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t\t[] :\n\t\n\t\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\t\tresults :\n\t\t\t\t\tmatcherIn;\n\t\n\t\t\t// Find primary matches\n\t\t\tif ( matcher ) {\n\t\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t\t}\n\t\n\t\t\t// Apply postFilter\n\t\t\tif ( postFilter ) {\n\t\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\t\tpostFilter( temp, [], context, xml );\n\t\n\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\ti = temp.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( seed ) {\n\t\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\t\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(\n\t\t\t\t\tmatcherOut === results ?\n\t\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\t\tmatcherOut\n\t\t\t\t);\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t\n\tfunction matcherFromTokens( tokens ) {\n\t\tvar checkContext, matcher, j,\n\t\t\tlen = tokens.length,\n\t\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\ti = leadingRelative ? 1 : 0,\n\t\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t} ];\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\t\n\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\t\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn setMatcher(\n\t\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tmatchers.push( matcher );\n\t\t\t}\n\t\t}\n\t\n\t\treturn elementMatcher( matchers );\n\t}\n\t\n\tfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t\tbyElement = elementMatchers.length > 0,\n\t\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\t\tvar elem, j, matcher,\n\t\t\t\t\tmatchedCount = 0,\n\t\t\t\t\ti = \"0\",\n\t\t\t\t\tunmatched = seed && [],\n\t\t\t\t\tsetMatched = [],\n\t\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\t\tlen = elems.length;\n\t\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t\t}\n\t\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif ( bySet ) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t\t// makes the latter nonnegative.\n\t\t\t\tmatchedCount += i;\n\t\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t\t// no element matchers and no seed.\n\t\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t\t// numerically zero.\n\t\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply( results, setMatched );\n\t\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\t\n\t\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\t\n\t\t\t\treturn unmatched;\n\t\t\t};\n\t\n\t\treturn bySet ?\n\t\t\tmarkFunction( superMatcher ) :\n\t\t\tsuperMatcher;\n\t}\n\t\n\tcompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\t\tvar i,\n\t\t\tsetMatchers = [],\n\t\t\telementMatchers = [],\n\t\t\tcached = compilerCache[ selector + \" \" ];\n\t\n\t\tif ( !cached ) {\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif ( !match ) {\n\t\t\t\tmatch = tokenize( selector );\n\t\t\t}\n\t\t\ti = match.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\t\tif ( cached[ expando ] ) {\n\t\t\t\t\tsetMatchers.push( cached );\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push( cached );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Cache the compiled function\n\t\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t\n\t\t\t// Save selector and tokenization\n\t\t\tcached.selector = selector;\n\t\t}\n\t\treturn cached;\n\t};\n\t\n\t/**\n\t * A low-level selection function that works with Sizzle's compiled\n\t *  selector functions\n\t * @param {String|Function} selector A selector or a pre-compiled\n\t *  selector function built with Sizzle.compile\n\t * @param {Element} context\n\t * @param {Array} [results]\n\t * @param {Array} [seed] A set of elements to match against\n\t */\n\tselect = Sizzle.select = function( selector, context, results, seed ) {\n\t\tvar i, tokens, token, type, find,\n\t\t\tcompiled = typeof selector === \"function\" && selector,\n\t\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\t\n\t\tresults = results || [];\n\t\n\t\t// Try to minimize operations if there is only one selector in the list and no seed\n\t\t// (the latter of which guarantees us context)\n\t\tif ( match.length === 1 ) {\n\t\n\t\t\t// Reduce context if the leading compound selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\t\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\n\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if ( compiled ) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\t\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\t\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\t\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t\t)) ) {\n\t\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t( compiled || compile( selector, match ) )(\n\t\t\tseed,\n\t\t\tcontext,\n\t\t\t!documentIsHTML,\n\t\t\tresults,\n\t\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t\t);\n\t\treturn results;\n\t};\n\t\n\t// One-time assignments\n\t\n\t// Sort stability\n\tsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\t\n\t// Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\tsupport.detectDuplicates = !!hasDuplicate;\n\t\n\t// Initialize against the default document\n\tsetDocument();\n\t\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\tsupport.sortDetached = assert(function( el ) {\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n\t});\n\t\n\t// Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif ( !assert(function( el ) {\n\t\tel.innerHTML = \"<a href='#'></a>\";\n\t\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n\t}) ) {\n\t\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\tif ( !support.attributes || !assert(function( el ) {\n\t\tel.innerHTML = \"<input/>\";\n\t\tel.firstChild.setAttribute( \"value\", \"\" );\n\t\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n\t}) ) {\n\t\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\tif ( !assert(function( el ) {\n\t\treturn el.getAttribute(\"disabled\") == null;\n\t}) ) {\n\t\taddHandle( booleans, function( elem, name, isXML ) {\n\t\t\tvar val;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn Sizzle;\n\t\n\t})( window );\n\t\n\t\n\t\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\t\n\t// Deprecated\n\tjQuery.expr[ \":\" ] = jQuery.expr.pseudos;\n\tjQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\tjQuery.escapeSelector = Sizzle.escape;\n\t\n\t\n\t\n\t\n\tvar dir = function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\t\n\t\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t};\n\t\n\t\n\tvar siblings = function( n, elem ) {\n\t\tvar matched = [];\n\t\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\t\n\t\treturn matched;\n\t};\n\t\n\t\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\t\n\tvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\t\n\t\n\t\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\t\n\t// Implement the identical functionality for filter and not\n\tfunction winnow( elements, qualifier, not ) {\n\t\tif ( jQuery.isFunction( qualifier ) ) {\n\t\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Single element\n\t\tif ( qualifier.nodeType ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( elem === qualifier ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Arraylike of elements (jQuery, arguments, Array)\n\t\tif ( typeof qualifier !== \"string\" ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Simple selector that can be filtered directly, removing non-Elements\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\t\n\t\t// Complex selector, compare the two sets, removing non-Elements\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t\t} );\n\t}\n\t\n\tjQuery.filter = function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\t\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\t\n\t\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t\t}\n\t\n\t\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t} ) );\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tfind: function( selector ) {\n\t\t\tvar i, ret,\n\t\t\t\tlen = this.length,\n\t\t\t\tself = this;\n\t\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) );\n\t\t\t}\n\t\n\t\t\tret = this.pushStack( [] );\n\t\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t\t}\n\t\n\t\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t\t},\n\t\tfilter: function( selector ) {\n\t\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t\t},\n\t\tnot: function( selector ) {\n\t\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t\t},\n\t\tis: function( selector ) {\n\t\t\treturn !!winnow(\n\t\t\t\tthis,\n\t\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector ) :\n\t\t\t\t\tselector || [],\n\t\t\t\tfalse\n\t\t\t).length;\n\t\t}\n\t} );\n\t\n\t\n\t// Initialize a jQuery object\n\t\n\t\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\t\n\t\t// A simple way to check for HTML strings\n\t\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t\t// Strict HTML recognition (#11290: must start with <)\n\t\t// Shortcut simple #id case for speed\n\t\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\t\n\t\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\t\tvar match, elem;\n\t\n\t\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\t\tif ( !selector ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t// Method init() accepts an alternate rootjQuery\n\t\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\t\troot = root || rootjQuery;\n\t\n\t\t\t// Handle HTML strings\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\t\tselector.length >= 3 ) {\n\t\n\t\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\t\tmatch = [ null, selector, null ];\n\t\n\t\t\t\t} else {\n\t\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t\t}\n\t\n\t\t\t\t// Match html or make sure no context is specified for #id\n\t\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\t\n\t\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\t\n\t\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t) );\n\t\n\t\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\t\tfor ( match in context ) {\n\t\n\t\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\t\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\t\n\t\t\t\t\t\tif ( elem ) {\n\t\n\t\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\t\treturn ( context || root ).find( selector );\n\t\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t\t} else {\n\t\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t\t}\n\t\n\t\t\t// HANDLE: $(DOMElement)\n\t\t\t} else if ( selector.nodeType ) {\n\t\t\t\tthis[ 0 ] = selector;\n\t\t\t\tthis.length = 1;\n\t\t\t\treturn this;\n\t\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\t\treturn root.ready !== undefined ?\n\t\t\t\t\troot.ready( selector ) :\n\t\n\t\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\t\tselector( jQuery );\n\t\t\t}\n\t\n\t\t\treturn jQuery.makeArray( selector, this );\n\t\t};\n\t\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\t\n\t// Initialize central reference\n\trootjQuery = jQuery( document );\n\t\n\t\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t\n\t\t// Methods guaranteed to produce a unique set when starting from a unique set\n\t\tguaranteedUnique = {\n\t\t\tchildren: true,\n\t\t\tcontents: true,\n\t\t\tnext: true,\n\t\t\tprev: true\n\t\t};\n\t\n\tjQuery.fn.extend( {\n\t\thas: function( target ) {\n\t\t\tvar targets = jQuery( target, this ),\n\t\t\t\tl = targets.length;\n\t\n\t\t\treturn this.filter( function() {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tclosest: function( selectors, context ) {\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tmatched = [],\n\t\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\t\n\t\t\t// Positional selectors never match, since there's no _selection_ context\n\t\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\t\n\t\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\t\n\t\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\t\n\t\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t\t},\n\t\n\t\t// Determine the position of an element within the set\n\t\tindex: function( elem ) {\n\t\n\t\t\t// No argument, return index in parent\n\t\t\tif ( !elem ) {\n\t\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t\t}\n\t\n\t\t\t// Index in selector\n\t\t\tif ( typeof elem === \"string\" ) {\n\t\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t\t}\n\t\n\t\t\t// Locate the position of the desired element\n\t\t\treturn indexOf.call( this,\n\t\n\t\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t\t);\n\t\t},\n\t\n\t\tadd: function( selector, context ) {\n\t\t\treturn this.pushStack(\n\t\t\t\tjQuery.uniqueSort(\n\t\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\n\t\taddBack: function( selector ) {\n\t\t\treturn this.add( selector == null ?\n\t\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t\t);\n\t\t}\n\t} );\n\t\n\tfunction sibling( cur, dir ) {\n\t\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\t\treturn cur;\n\t}\n\t\n\tjQuery.each( {\n\t\tparent: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function( elem ) {\n\t\t\treturn dir( elem, \"parentNode\" );\n\t\t},\n\t\tparentsUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"parentNode\", until );\n\t\t},\n\t\tnext: function( elem ) {\n\t\t\treturn sibling( elem, \"nextSibling\" );\n\t\t},\n\t\tprev: function( elem ) {\n\t\t\treturn sibling( elem, \"previousSibling\" );\n\t\t},\n\t\tnextAll: function( elem ) {\n\t\t\treturn dir( elem, \"nextSibling\" );\n\t\t},\n\t\tprevAll: function( elem ) {\n\t\t\treturn dir( elem, \"previousSibling\" );\n\t\t},\n\t\tnextUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"nextSibling\", until );\n\t\t},\n\t\tprevUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"previousSibling\", until );\n\t\t},\n\t\tsiblings: function( elem ) {\n\t\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t\t},\n\t\tchildren: function( elem ) {\n\t\t\treturn siblings( elem.firstChild );\n\t\t},\n\t\tcontents: function( elem ) {\n\t\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t\t}\n\t}, function( name, fn ) {\n\t\tjQuery.fn[ name ] = function( until, selector ) {\n\t\t\tvar matched = jQuery.map( this, fn, until );\n\t\n\t\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\t\tselector = until;\n\t\t\t}\n\t\n\t\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t\t}\n\t\n\t\t\tif ( this.length > 1 ) {\n\t\n\t\t\t\t// Remove duplicates\n\t\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t\t}\n\t\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\t\tmatched.reverse();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched );\n\t\t};\n\t} );\n\tvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\t\n\t\n\t\n\t// Convert String-formatted options into Object-formatted ones\n\tfunction createOptions( options ) {\n\t\tvar object = {};\n\t\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\t\tobject[ flag ] = true;\n\t\t} );\n\t\treturn object;\n\t}\n\t\n\t/*\n\t * Create a callback list using the following parameters:\n\t *\n\t *\toptions: an optional list of space-separated options that will change how\n\t *\t\t\tthe callback list behaves or a more traditional option object\n\t *\n\t * By default a callback list will act like an event callback list and can be\n\t * \"fired\" multiple times.\n\t *\n\t * Possible options:\n\t *\n\t *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n\t *\n\t *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n\t *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n\t *\t\t\t\t\tvalues (like a Deferred)\n\t *\n\t *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n\t *\n\t *\tstopOnFalse:\tinterrupt callings when a callback returns false\n\t *\n\t */\n\tjQuery.Callbacks = function( options ) {\n\t\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ?\n\t\t\tcreateOptions( options ) :\n\t\t\tjQuery.extend( {}, options );\n\t\n\t\tvar // Flag to know if list is currently firing\n\t\t\tfiring,\n\t\n\t\t\t// Last fire value for non-forgettable lists\n\t\t\tmemory,\n\t\n\t\t\t// Flag to know if list was already fired\n\t\t\tfired,\n\t\n\t\t\t// Flag to prevent firing\n\t\t\tlocked,\n\t\n\t\t\t// Actual callback list\n\t\t\tlist = [],\n\t\n\t\t\t// Queue of execution data for repeatable lists\n\t\t\tqueue = [],\n\t\n\t\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\t\tfiringIndex = -1,\n\t\n\t\t\t// Fire callbacks\n\t\t\tfire = function() {\n\t\n\t\t\t\t// Enforce single-firing\n\t\t\t\tlocked = options.once;\n\t\n\t\t\t\t// Execute callbacks for all pending executions,\n\t\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\t\tfired = firing = true;\n\t\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\t\tmemory = queue.shift();\n\t\t\t\t\twhile ( ++firingIndex < list.length ) {\n\t\n\t\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\t\toptions.stopOnFalse ) {\n\t\n\t\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Forget the data if we're done with it\n\t\t\t\tif ( !options.memory ) {\n\t\t\t\t\tmemory = false;\n\t\t\t\t}\n\t\n\t\t\t\tfiring = false;\n\t\n\t\t\t\t// Clean up if we're done firing for good\n\t\t\t\tif ( locked ) {\n\t\n\t\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\t\tif ( memory ) {\n\t\t\t\t\t\tlist = [];\n\t\n\t\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// Actual Callbacks object\n\t\t\tself = {\n\t\n\t\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\t\tadd: function() {\n\t\t\t\t\tif ( list ) {\n\t\n\t\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\t\n\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} )( arguments );\n\t\n\t\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Remove a callback from the list\n\t\t\t\tremove: function() {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Check if a given callback is in the list.\n\t\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\t\thas: function( fn ) {\n\t\t\t\t\treturn fn ?\n\t\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\t\tlist.length > 0;\n\t\t\t\t},\n\t\n\t\t\t\t// Remove all callbacks from the list\n\t\t\t\tempty: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\tlist = [];\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Disable .fire and .add\n\t\t\t\t// Abort any current/pending executions\n\t\t\t\t// Clear all callbacks and values\n\t\t\t\tdisable: function() {\n\t\t\t\t\tlocked = queue = [];\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tdisabled: function() {\n\t\t\t\t\treturn !list;\n\t\t\t\t},\n\t\n\t\t\t\t// Disable .fire\n\t\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t\t// Abort any pending executions\n\t\t\t\tlock: function() {\n\t\t\t\t\tlocked = queue = [];\n\t\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tlocked: function() {\n\t\t\t\t\treturn !!locked;\n\t\t\t\t},\n\t\n\t\t\t\t// Call all callbacks with the given context and arguments\n\t\t\t\tfireWith: function( context, args ) {\n\t\t\t\t\tif ( !locked ) {\n\t\t\t\t\t\targs = args || [];\n\t\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\t\tqueue.push( args );\n\t\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Call all the callbacks with the given arguments\n\t\t\t\tfire: function() {\n\t\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// To know if the callbacks have already been called at least once\n\t\t\t\tfired: function() {\n\t\t\t\t\treturn !!fired;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\treturn self;\n\t};\n\t\n\t\n\tfunction Identity( v ) {\n\t\treturn v;\n\t}\n\tfunction Thrower( ex ) {\n\t\tthrow ex;\n\t}\n\t\n\tfunction adoptValue( value, resolve, reject ) {\n\t\tvar method;\n\t\n\t\ttry {\n\t\n\t\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\t\n\t\t\t// Other thenables\n\t\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\t\tmethod.call( value, resolve, reject );\n\t\n\t\t\t// Other non-thenables\n\t\t\t} else {\n\t\n\t\t\t\t// Support: Android 4.0 only\n\t\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\t\tresolve.call( undefined, value );\n\t\t\t}\n\t\n\t\t// For Promises/A+, convert exceptions into rejections\n\t\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t\t// Deferred#then to conditionally suppress rejection.\n\t\t} catch ( value ) {\n\t\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\treject.call( undefined, value );\n\t\t}\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\tDeferred: function( func ) {\n\t\t\tvar tuples = [\n\t\n\t\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t\t],\n\t\t\t\tstate = \"pending\",\n\t\t\t\tpromise = {\n\t\t\t\t\tstate: function() {\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t},\n\t\t\t\t\talways: function() {\n\t\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Keep pipe for back-compat\n\t\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\t\tvar fns = arguments;\n\t\n\t\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\n\t\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\t\n\t\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tfns = null;\n\t\t\t\t\t\t} ).promise();\n\t\t\t\t\t},\n\t\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\t\tvar returned, then;\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\t\tthen = returned &&\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\t\treturned.then;\n\t\n\t\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\n\t\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\n\t\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} ).promise();\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Get a promise for this deferred\n\t\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdeferred = {};\n\t\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\tvar list = tuple[ 2 ],\n\t\t\t\t\tstateString = tuple[ 5 ];\n\t\n\t\t\t\t// promise.progress = list.add\n\t\t\t\t// promise.done = list.add\n\t\t\t\t// promise.fail = list.add\n\t\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\t\n\t\t\t\t// Handle state\n\t\t\t\tif ( stateString ) {\n\t\t\t\t\tlist.add(\n\t\t\t\t\t\tfunction() {\n\t\n\t\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t\t},\n\t\n\t\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\t\n\t\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\t// progress_handlers.fire\n\t\t\t\t// fulfilled_handlers.fire\n\t\t\t\t// rejected_handlers.fire\n\t\t\t\tlist.add( tuple[ 3 ].fire );\n\t\n\t\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\n\t\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t\t} );\n\t\n\t\t\t// Make the deferred a promise\n\t\t\tpromise.promise( deferred );\n\t\n\t\t\t// Call given func if any\n\t\t\tif ( func ) {\n\t\t\t\tfunc.call( deferred, deferred );\n\t\t\t}\n\t\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\t\n\t\t// Deferred helper\n\t\twhen: function( singleValue ) {\n\t\t\tvar\n\t\n\t\t\t\t// count of uncompleted subordinates\n\t\t\t\tremaining = arguments.length,\n\t\n\t\t\t\t// count of unprocessed arguments\n\t\t\t\ti = remaining,\n\t\n\t\t\t\t// subordinate fulfillment data\n\t\t\t\tresolveContexts = Array( i ),\n\t\t\t\tresolveValues = slice.call( arguments ),\n\t\n\t\t\t\t// the master Deferred\n\t\t\t\tmaster = jQuery.Deferred(),\n\t\n\t\t\t\t// subordinate callback factory\n\t\t\t\tupdateFunc = function( i ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\n\t\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\t\tif ( remaining <= 1 ) {\n\t\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\t\n\t\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\t\n\t\t\t\t\treturn master.then();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\t\twhile ( i-- ) {\n\t\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t\t}\n\t\n\t\t\treturn master.promise();\n\t\t}\n\t} );\n\t\n\t\n\t// These usually indicate a programmer mistake during development,\n\t// warn about them ASAP rather than swallowing them by default.\n\tvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\t\n\tjQuery.Deferred.exceptionHook = function( error, stack ) {\n\t\n\t\t// Support: IE 8 - 9 only\n\t\t// Console exists when dev tools are open, which can happen at any time\n\t\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t\t}\n\t};\n\t\n\t\n\t\n\t\n\tjQuery.readyException = function( error ) {\n\t\twindow.setTimeout( function() {\n\t\t\tthrow error;\n\t\t} );\n\t};\n\t\n\t\n\t\n\t\n\t// The deferred used on DOM ready\n\tvar readyList = jQuery.Deferred();\n\t\n\tjQuery.fn.ready = function( fn ) {\n\t\n\t\treadyList\n\t\t\t.then( fn )\n\t\n\t\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t\t// happens at the time of error handling instead of callback\n\t\t\t// registration.\n\t\t\t.catch( function( error ) {\n\t\t\t\tjQuery.readyException( error );\n\t\t\t} );\n\t\n\t\treturn this;\n\t};\n\t\n\tjQuery.extend( {\n\t\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\t\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\t\n\t\t// Hold (or release) the ready event\n\t\tholdReady: function( hold ) {\n\t\t\tif ( hold ) {\n\t\t\t\tjQuery.readyWait++;\n\t\t\t} else {\n\t\t\t\tjQuery.ready( true );\n\t\t\t}\n\t\t},\n\t\n\t\t// Handle when the DOM is ready\n\t\tready: function( wait ) {\n\t\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\t\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith( document, [ jQuery ] );\n\t\t}\n\t} );\n\t\n\tjQuery.ready.then = readyList.then;\n\t\n\t// The ready event handler and self cleanup method\n\tfunction completed() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\t\twindow.removeEventListener( \"load\", completed );\n\t\tjQuery.ready();\n\t}\n\t\n\t// Catch cases where $(document).ready() is called\n\t// after the browser event has already occurred.\n\t// Support: IE <=9 - 10 only\n\t// Older IE sometimes signals \"interactive\" too soon\n\tif ( document.readyState === \"complete\" ||\n\t\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\t\n\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\twindow.setTimeout( jQuery.ready );\n\t\n\t} else {\n\t\n\t\t// Use the handy event callback\n\t\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\t\n\t\t// A fallback to window.onload, that will always work\n\t\twindow.addEventListener( \"load\", completed );\n\t}\n\t\n\t\n\t\n\t\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlen = elems.length,\n\t\t\tbulk = key == null;\n\t\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t\t}\n\t\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\t\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\t\n\t\t\tif ( bulk ) {\n\t\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\t\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tfn(\n\t\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\t\tvalue :\n\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif ( chainable ) {\n\t\t\treturn elems;\n\t\t}\n\t\n\t\t// Gets\n\t\tif ( bulk ) {\n\t\t\treturn fn.call( elems );\n\t\t}\n\t\n\t\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n\t};\n\tvar acceptData = function( owner ) {\n\t\n\t\t// Accepts only:\n\t\t//  - Node\n\t\t//    - Node.ELEMENT_NODE\n\t\t//    - Node.DOCUMENT_NODE\n\t\t//  - Object\n\t\t//    - Any\n\t\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n\t};\n\t\n\t\n\t\n\t\n\tfunction Data() {\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\t\n\tData.uid = 1;\n\t\n\tData.prototype = {\n\t\n\t\tcache: function( owner ) {\n\t\n\t\t\t// Check if the owner object already has a cache\n\t\t\tvar value = owner[ this.expando ];\n\t\n\t\t\t// If not, create one\n\t\t\tif ( !value ) {\n\t\t\t\tvalue = {};\n\t\n\t\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t\t// but we should not, see #8335.\n\t\t\t\t// Always return an empty object.\n\t\t\t\tif ( acceptData( owner ) ) {\n\t\n\t\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t\t// use plain assignment\n\t\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\t\towner[ this.expando ] = value;\n\t\n\t\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t\t// deleted when data is removed\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn value;\n\t\t},\n\t\tset: function( owner, data, value ) {\n\t\t\tvar prop,\n\t\t\t\tcache = this.cache( owner );\n\t\n\t\t\t// Handle: [ owner, key, value ] args\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\t\n\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\t\n\t\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cache;\n\t\t},\n\t\tget: function( owner, key ) {\n\t\t\treturn key === undefined ?\n\t\t\t\tthis.cache( owner ) :\n\t\n\t\t\t\t// Always use camelCase key (gh-2257)\n\t\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t\t},\n\t\taccess: function( owner, key, value ) {\n\t\n\t\t\t// In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\t\t\tif ( key === undefined ||\n\t\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\t\n\t\t\t\treturn this.get( owner, key );\n\t\t\t}\n\t\n\t\t\t// When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\t\t\tthis.set( owner, key, value );\n\t\n\t\t\t// Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function( owner, key ) {\n\t\t\tvar i,\n\t\t\t\tcache = owner[ this.expando ];\n\t\n\t\t\tif ( cache === undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( key !== undefined ) {\n\t\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif ( jQuery.isArray( key ) ) {\n\t\n\t\t\t\t\t// If key is an array of keys...\n\t\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t\t} else {\n\t\t\t\t\tkey = jQuery.camelCase( key );\n\t\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tkey = key in cache ?\n\t\t\t\t\t\t[ key ] :\n\t\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t\t}\n\t\n\t\t\t\ti = key.length;\n\t\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove the expando if there's no more data\n\t\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\t\n\t\t\t\t// Support: Chrome <=35 - 45\n\t\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tdelete owner[ this.expando ];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function( owner ) {\n\t\t\tvar cache = owner[ this.expando ];\n\t\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t\t}\n\t};\n\tvar dataPriv = new Data();\n\t\n\tvar dataUser = new Data();\n\t\n\t\n\t\n\t//\tImplementation Summary\n\t//\n\t//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t//\t2. Improve the module's maintainability by reducing the storage\n\t//\t\tpaths to a single mechanism.\n\t//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\t\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t\trmultiDash = /[A-Z]/g;\n\t\n\tfunction getData( data ) {\n\t\tif ( data === \"true\" ) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif ( data === \"false\" ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif ( data === \"null\" ) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Only convert to a number if it doesn't change the string\n\t\tif ( data === +data + \"\" ) {\n\t\t\treturn +data;\n\t\t}\n\t\n\t\tif ( rbrace.test( data ) ) {\n\t\t\treturn JSON.parse( data );\n\t\t}\n\t\n\t\treturn data;\n\t}\n\t\n\tfunction dataAttr( elem, key, data ) {\n\t\tvar name;\n\t\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\t\tdata = elem.getAttribute( name );\n\t\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\ttry {\n\t\t\t\t\tdata = getData( data );\n\t\t\t\t} catch ( e ) {}\n\t\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tdataUser.set( elem, key, data );\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\t\n\tjQuery.extend( {\n\t\thasData: function( elem ) {\n\t\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t\t},\n\t\n\t\tdata: function( elem, name, data ) {\n\t\t\treturn dataUser.access( elem, name, data );\n\t\t},\n\t\n\t\tremoveData: function( elem, name ) {\n\t\t\tdataUser.remove( elem, name );\n\t\t},\n\t\n\t\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t\t// with direct calls to dataPriv methods, these can be deprecated.\n\t\t_data: function( elem, name, data ) {\n\t\t\treturn dataPriv.access( elem, name, data );\n\t\t},\n\t\n\t\t_removeData: function( elem, name ) {\n\t\t\tdataPriv.remove( elem, name );\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tdata: function( key, value ) {\n\t\t\tvar i, name, data,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tattrs = elem && elem.attributes;\n\t\n\t\t\t// Gets all values\n\t\t\tif ( key === undefined ) {\n\t\t\t\tif ( this.length ) {\n\t\t\t\t\tdata = dataUser.get( elem );\n\t\n\t\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\n\t\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\t\t}\n\t\n\t\t\t// Sets multiple values\n\t\t\tif ( typeof key === \"object\" ) {\n\t\t\t\treturn this.each( function() {\n\t\t\t\t\tdataUser.set( this, key );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar data;\n\t\n\t\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\t\tif ( elem && value === undefined ) {\n\t\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Set the data...\n\t\t\t\tthis.each( function() {\n\t\n\t\t\t\t\t// We always store the camelCased key\n\t\t\t\t\tdataUser.set( this, key, value );\n\t\t\t\t} );\n\t\t\t}, null, value, arguments.length > 1, null, true );\n\t\t},\n\t\n\t\tremoveData: function( key ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.remove( this, key );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.extend( {\n\t\tqueue: function( elem, type, data ) {\n\t\t\tvar queue;\n\t\n\t\t\tif ( elem ) {\n\t\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\t\tqueue = dataPriv.get( elem, type );\n\t\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push( data );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\t\n\t\tdequeue: function( elem, type ) {\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\t\tstartLength = queue.length,\n\t\t\t\tfn = queue.shift(),\n\t\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\t\tnext = function() {\n\t\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t\t};\n\t\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif ( fn === \"inprogress\" ) {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif ( type === \"fx\" ) {\n\t\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call( elem, next, hooks );\n\t\t\t}\n\t\n\t\t\tif ( !startLength && hooks ) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\t\n\t\t// Not public - generate a queueHooks object, or return the current one\n\t\t_queueHooks: function( elem, type ) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t\t} )\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tqueue: function( type, data ) {\n\t\t\tvar setter = 2;\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\t\n\t\t\tif ( arguments.length < setter ) {\n\t\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t\t}\n\t\n\t\t\treturn data === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function() {\n\t\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\t\n\t\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\t\tjQuery._queueHooks( this, type );\n\t\n\t\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t},\n\t\tdequeue: function( type ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t} );\n\t\t},\n\t\tclearQueue: function( type ) {\n\t\t\treturn this.queue( type || \"fx\", [] );\n\t\t},\n\t\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function( type, obj ) {\n\t\t\tvar tmp,\n\t\t\t\tcount = 1,\n\t\t\t\tdefer = jQuery.Deferred(),\n\t\t\t\telements = this,\n\t\t\t\ti = this.length,\n\t\t\t\tresolve = function() {\n\t\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add( resolve );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise( obj );\n\t\t}\n\t} );\n\tvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\t\n\tvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\t\n\t\n\tvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\t\n\tvar isHiddenWithinTree = function( elem, el ) {\n\t\n\t\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t\t// in that case, element will be second argument\n\t\t\telem = el || elem;\n\t\n\t\t\t// Inline style trumps all\n\t\t\treturn elem.style.display === \"none\" ||\n\t\t\t\telem.style.display === \"\" &&\n\t\n\t\t\t\t// Otherwise, check computed style\n\t\t\t\t// Support: Firefox <=43 - 45\n\t\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t\t// in the document.\n\t\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\t\n\t\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t\t};\n\t\n\tvar swap = function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\t\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\t\n\t\tret = callback.apply( elem, args || [] );\n\t\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\t\n\t\treturn ret;\n\t};\n\t\n\t\n\t\n\t\n\tfunction adjustCSS( elem, prop, valueParts, tween ) {\n\t\tvar adjusted,\n\t\t\tscale = 1,\n\t\t\tmaxIterations = 20,\n\t\t\tcurrentValue = tween ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn tween.cur();\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t\t},\n\t\t\tinitial = currentValue(),\n\t\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\t\n\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\t\n\t\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\t\n\t\t\t// Trust units reported by jQuery.css\n\t\t\tunit = unit || initialInUnit[ 3 ];\n\t\n\t\t\t// Make sure we update the tween properties later on\n\t\t\tvalueParts = valueParts || [];\n\t\n\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\tinitialInUnit = +initial || 1;\n\t\n\t\t\tdo {\n\t\n\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\tscale = scale || \".5\";\n\t\n\t\t\t\t// Adjust and apply\n\t\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\n\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t\t} while (\n\t\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t\t);\n\t\t}\n\t\n\t\tif ( valueParts ) {\n\t\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\t\n\t\t\t// Apply relative offset (+=/-=) if specified\n\t\t\tadjusted = valueParts[ 1 ] ?\n\t\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t\t+valueParts[ 2 ];\n\t\t\tif ( tween ) {\n\t\t\t\ttween.unit = unit;\n\t\t\t\ttween.start = initialInUnit;\n\t\t\t\ttween.end = adjusted;\n\t\t\t}\n\t\t}\n\t\treturn adjusted;\n\t}\n\t\n\t\n\tvar defaultDisplayMap = {};\n\t\n\tfunction getDefaultDisplay( elem ) {\n\t\tvar temp,\n\t\t\tdoc = elem.ownerDocument,\n\t\t\tnodeName = elem.nodeName,\n\t\t\tdisplay = defaultDisplayMap[ nodeName ];\n\t\n\t\tif ( display ) {\n\t\t\treturn display;\n\t\t}\n\t\n\t\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\t\tdisplay = jQuery.css( temp, \"display\" );\n\t\n\t\ttemp.parentNode.removeChild( temp );\n\t\n\t\tif ( display === \"none\" ) {\n\t\t\tdisplay = \"block\";\n\t\t}\n\t\tdefaultDisplayMap[ nodeName ] = display;\n\t\n\t\treturn display;\n\t}\n\t\n\tfunction showHide( elements, show ) {\n\t\tvar display, elem,\n\t\t\tvalues = [],\n\t\t\tindex = 0,\n\t\t\tlength = elements.length;\n\t\n\t\t// Determine new display value for elements that need to change\n\t\tfor ( ; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tdisplay = elem.style.display;\n\t\t\tif ( show ) {\n\t\n\t\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t\t// inline or about-to-be-restored)\n\t\t\t\tif ( display === \"none\" ) {\n\t\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( display !== \"none\" ) {\n\t\t\t\t\tvalues[ index ] = \"none\";\n\t\n\t\t\t\t\t// Remember what we're overwriting\n\t\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Set the display of the elements in a second loop to avoid constant reflow\n\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\tif ( values[ index ] != null ) {\n\t\t\t\telements[ index ].style.display = values[ index ];\n\t\t\t}\n\t\t}\n\t\n\t\treturn elements;\n\t}\n\t\n\tjQuery.fn.extend( {\n\t\tshow: function() {\n\t\t\treturn showHide( this, true );\n\t\t},\n\t\thide: function() {\n\t\t\treturn showHide( this );\n\t\t},\n\t\ttoggle: function( state ) {\n\t\t\tif ( typeof state === \"boolean\" ) {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\t\tjQuery( this ).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery( this ).hide();\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\tvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\t\n\tvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\t\n\tvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\t\n\t\n\t\n\t// We have to close these tags to support XHTML (#13200)\n\tvar wrapMap = {\n\t\n\t\t// Support: IE <=9 only\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\n\t\t// XHTML parsers do not magically insert elements in the\n\t\t// same way that tag soup parsers do. So we cannot shorten\n\t\t// this by omitting <tbody> or other required elements.\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\t\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\t\n\t// Support: IE <=9 only\n\twrapMap.optgroup = wrapMap.option;\n\t\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\t\n\t\n\tfunction getAll( context, tag ) {\n\t\n\t\t// Support: IE <=9 - 11 only\n\t\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\t\tvar ret;\n\t\n\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\tret = context.getElementsByTagName( tag || \"*\" );\n\t\n\t\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\t\tret = context.querySelectorAll( tag || \"*\" );\n\t\n\t\t} else {\n\t\t\tret = [];\n\t\t}\n\t\n\t\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\t\treturn jQuery.merge( [ context ], ret );\n\t\t}\n\t\n\t\treturn ret;\n\t}\n\t\n\t\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval( elems, refElements ) {\n\t\tvar i = 0,\n\t\t\tl = elems.length;\n\t\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tdataPriv.set(\n\t\t\t\telems[ i ],\n\t\t\t\t\"globalEval\",\n\t\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t\t);\n\t\t}\n\t}\n\t\n\t\n\tvar rhtml = /<|&#?\\w+;/;\n\t\n\tfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\t\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\t\n\t\t\tif ( elem || elem === 0 ) {\n\t\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\t\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\t\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\t\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\t\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\t\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\t\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\t\n\t\ti = 0;\n\t\twhile ( ( elem = nodes[ i++ ] ) ) {\n\t\n\t\t\t// Skip elements already in the context collection (trac-4087)\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\t\tif ( ignored ) {\n\t\t\t\t\tignored.push( elem );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\t\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\t\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn fragment;\n\t}\n\t\n\t\n\t( function() {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\t\tinput = document.createElement( \"input\" );\n\t\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Check state lost if the name is set (#11217)\n\t\t// Support: Windows Web Apps (WWA)\n\t\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\t\tinput.setAttribute( \"type\", \"radio\" );\n\t\tinput.setAttribute( \"checked\", \"checked\" );\n\t\tinput.setAttribute( \"name\", \"t\" );\n\t\n\t\tdiv.appendChild( input );\n\t\n\t\t// Support: Android <=4.1 only\n\t\t// Older WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\t\n\t\t// Support: IE <=11 only\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\t} )();\n\tvar documentElement = document.documentElement;\n\t\n\t\n\t\n\tvar\n\t\trkeyEvent = /^key/,\n\t\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\t\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\t\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\t\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\t\n\t// Support: IE <=9 only\n\t// See #13393 for more info\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch ( err ) { }\n\t}\n\t\n\tfunction on( elem, types, selector, data, fn, one ) {\n\t\tvar origFn, type;\n\t\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn elem;\n\t\t}\n\t\n\t\tif ( data == null && fn == null ) {\n\t\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn elem;\n\t\t}\n\t\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn elem.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t} );\n\t}\n\t\n\t/*\n\t * Helper functions for managing events -- not part of the public interface.\n\t * Props to Dean Edwards' addEvent library for many of the ideas.\n\t */\n\tjQuery.event = {\n\t\n\t\tglobal: {},\n\t\n\t\tadd: function( elem, types, handler, data, selector ) {\n\t\n\t\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = dataPriv.get( elem );\n\t\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif ( !elemData ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif ( handler.handler ) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\t\n\t\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\t\tif ( selector ) {\n\t\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t\t}\n\t\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif ( !handler.guid ) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\t\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif ( !( events = elemData.events ) ) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\t\teventHandle = elemData.handle = function( e ) {\n\t\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\t\ttype = origType = tmp[ 1 ];\n\t\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend( {\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t\t}, handleObjIn );\n\t\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\t\n\t\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\t\tif ( !special.setup ||\n\t\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\n\t\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( special.add ) {\n\t\t\t\t\tspecial.add.call( elem, handleObj );\n\t\n\t\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif ( selector ) {\n\t\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push( handleObj );\n\t\t\t\t}\n\t\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[ type ] = true;\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// Detach an event or set of events from an element\n\t\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\n\t\t\tvar j, origCount, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\t\n\t\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\t\ttype = origType = tmp[ 1 ];\n\t\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tfor ( type in events ) {\n\t\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\t\thandlers = events[ type ] || [];\n\t\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\t\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\thandleObj = handlers[ j ];\n\t\n\t\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\t\thandlers.splice( j, 1 );\n\t\n\t\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\n\t\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdelete events[ type ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove data and the expando if it's no longer used\n\t\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t\t}\n\t\t},\n\t\n\t\tdispatch: function( nativeEvent ) {\n\t\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tvar event = jQuery.event.fix( nativeEvent );\n\t\n\t\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\t\targs = new Array( arguments.length ),\n\t\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\t\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[ 0 ] = event;\n\t\n\t\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\t\targs[ i ] = arguments[ i ];\n\t\t\t}\n\t\n\t\t\tevent.delegateTarget = this;\n\t\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\t\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\t\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\t\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\t\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\t\n\t\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\t\n\t\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif ( special.postDispatch ) {\n\t\t\t\tspecial.postDispatch.call( this, event );\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\thandlers: function( event, handlers ) {\n\t\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\t\thandlerQueue = [],\n\t\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\t\tcur = event.target;\n\t\n\t\t\t// Find delegate handlers\n\t\t\tif ( delegateCount &&\n\t\n\t\t\t\t// Support: IE <=9\n\t\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\t\tcur.nodeType &&\n\t\n\t\t\t\t// Support: Firefox <=42\n\t\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t\t// Support: IE 11 only\n\t\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\t\n\t\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\t\n\t\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\t\thandleObj = handlers[ i ];\n\t\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\t\n\t\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tcur = this;\n\t\t\tif ( delegateCount < handlers.length ) {\n\t\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t\t}\n\t\n\t\t\treturn handlerQueue;\n\t\t},\n\t\n\t\taddProp: function( name, hook ) {\n\t\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\n\t\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t\t}\n\t\t\t\t\t} :\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\n\t\t\t\tset: function( value ) {\n\t\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tfix: function( originalEvent ) {\n\t\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\t\toriginalEvent :\n\t\t\t\tnew jQuery.Event( originalEvent );\n\t\t},\n\t\n\t\tspecial: {\n\t\t\tload: {\n\t\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\t\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\t\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function( event ) {\n\t\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function( event ) {\n\t\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.removeEvent = function( elem, type, handle ) {\n\t\n\t\t// This \"if\" is needed for plain objects\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle );\n\t\t}\n\t};\n\t\n\tjQuery.Event = function( src, props ) {\n\t\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif ( !( this instanceof jQuery.Event ) ) {\n\t\t\treturn new jQuery.Event( src, props );\n\t\t}\n\t\n\t\t// Event object\n\t\tif ( src && src.type ) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\t\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\n\t\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\t\tsrc.returnValue === false ?\n\t\t\t\treturnTrue :\n\t\t\t\treturnFalse;\n\t\n\t\t\t// Create target properties\n\t\t\t// Support: Safari <=6 - 7 only\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\t\tsrc.target.parentNode :\n\t\t\t\tsrc.target;\n\t\n\t\t\tthis.currentTarget = src.currentTarget;\n\t\t\tthis.relatedTarget = src.relatedTarget;\n\t\n\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\t\n\t\t// Put explicitly provided properties onto the event object\n\t\tif ( props ) {\n\t\t\tjQuery.extend( this, props );\n\t\t}\n\t\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\t\n\t\t// Mark it as fixed\n\t\tthis[ jQuery.expando ] = true;\n\t};\n\t\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tconstructor: jQuery.Event,\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\t\tisSimulated: false,\n\t\n\t\tpreventDefault: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isPropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tstopImmediatePropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\t\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\t\n\t// Includes all common event props including KeyEvent and MouseEvent specific props\n\tjQuery.each( {\n\t\taltKey: true,\n\t\tbubbles: true,\n\t\tcancelable: true,\n\t\tchangedTouches: true,\n\t\tctrlKey: true,\n\t\tdetail: true,\n\t\teventPhase: true,\n\t\tmetaKey: true,\n\t\tpageX: true,\n\t\tpageY: true,\n\t\tshiftKey: true,\n\t\tview: true,\n\t\t\"char\": true,\n\t\tcharCode: true,\n\t\tkey: true,\n\t\tkeyCode: true,\n\t\tbutton: true,\n\t\tbuttons: true,\n\t\tclientX: true,\n\t\tclientY: true,\n\t\toffsetX: true,\n\t\toffsetY: true,\n\t\tpointerId: true,\n\t\tpointerType: true,\n\t\tscreenX: true,\n\t\tscreenY: true,\n\t\ttargetTouches: true,\n\t\ttoElement: true,\n\t\ttouches: true,\n\t\n\t\twhich: function( event ) {\n\t\t\tvar button = event.button;\n\t\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t\t}\n\t\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\t\tif ( button & 1 ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\tif ( button & 2 ) {\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\n\t\t\t\tif ( button & 4 ) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\treturn event.which;\n\t\t}\n\t}, jQuery.event.addProp );\n\t\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// so that event delegation works in jQuery.\n\t// Do the same for pointerenter/pointerleave and pointerover/pointerout\n\t//\n\t// Support: Safari 7 only\n\t// Safari sends mouseenter too often; see:\n\t// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n\t// for the description of the bug (it existed in older Chrome versions as well).\n\tjQuery.each( {\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t}, function( orig, fix ) {\n\t\tjQuery.event.special[ orig ] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\t\n\t\t\thandle: function( event ) {\n\t\t\t\tvar ret,\n\t\t\t\t\ttarget = this,\n\t\t\t\t\trelated = event.relatedTarget,\n\t\t\t\t\thandleObj = event.handleObj;\n\t\n\t\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\n\t\ton: function( types, selector, data, fn ) {\n\t\t\treturn on( this, types, selector, data, fn );\n\t\t},\n\t\tone: function( types, selector, data, fn ) {\n\t\t\treturn on( this, types, selector, data, fn, 1 );\n\t\t},\n\t\toff: function( types, selector, fn ) {\n\t\t\tvar handleObj, type;\n\t\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\t\thandleObj.namespace ?\n\t\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\t\thandleObj.origType,\n\t\t\t\t\thandleObj.selector,\n\t\t\t\t\thandleObj.handler\n\t\t\t\t);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( typeof types === \"object\" ) {\n\t\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t\n\tvar\n\t\n\t\t/* eslint-disable max-len */\n\t\n\t\t// See https://github.com/eslint/eslint/issues/3229\n\t\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\t\n\t\t/* eslint-enable */\n\t\n\t\t// Support: IE <=10 - 11, Edge 12 - 13\n\t\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\t\trnoInnerhtml = /<script|<style|<link/i,\n\t\n\t\t// checked=\"checked\" or checked\n\t\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t\trscriptTypeMasked = /^true\\/(.*)/,\n\t\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\t\n\tfunction manipulationTarget( elem, content ) {\n\t\tif ( jQuery.nodeName( elem, \"table\" ) &&\n\t\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\t\n\t\t\treturn elem.getElementsByTagName( \"tbody\" )[ 0 ] || elem;\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript( elem ) {\n\t\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript( elem ) {\n\t\tvar match = rscriptTypeMasked.exec( elem.type );\n\t\n\t\tif ( match ) {\n\t\t\telem.type = match[ 1 ];\n\t\t} else {\n\t\t\telem.removeAttribute( \"type\" );\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\tfunction cloneCopyEvent( src, dest ) {\n\t\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\t\n\t\tif ( dest.nodeType !== 1 ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// 1. Copy private data: events, handlers, etc.\n\t\tif ( dataPriv.hasData( src ) ) {\n\t\t\tpdataOld = dataPriv.access( src );\n\t\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\t\tevents = pdataOld.events;\n\t\n\t\t\tif ( events ) {\n\t\t\t\tdelete pdataCur.handle;\n\t\t\t\tpdataCur.events = {};\n\t\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// 2. Copy user data\n\t\tif ( dataUser.hasData( src ) ) {\n\t\t\tudataOld = dataUser.access( src );\n\t\t\tudataCur = jQuery.extend( {}, udataOld );\n\t\n\t\t\tdataUser.set( dest, udataCur );\n\t\t}\n\t}\n\t\n\t// Fix IE bugs, see support tests\n\tfunction fixInput( src, dest ) {\n\t\tvar nodeName = dest.nodeName.toLowerCase();\n\t\n\t\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\t\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t\tdest.checked = src.checked;\n\t\n\t\t// Fails to return the selected option to the default selected state when cloning options\n\t\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\t\n\tfunction domManip( collection, args, callback, ignored ) {\n\t\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\t\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = collection.length,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn collection.each( function( index ) {\n\t\t\t\tvar self = collection.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tdomManip( self, args, callback, ignored );\n\t\t\t} );\n\t\t}\n\t\n\t\tif ( l ) {\n\t\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\t\tfirst = fragment.firstChild;\n\t\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\t\n\t\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\t\tif ( first || ignored ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\t\n\t\t\t\t// Use the original fragment for the last item\n\t\t\t\t// instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\t\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\t\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\n\t\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\t\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\t\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\t\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn collection;\n\t}\n\t\n\tfunction remove( elem, selector, keepData ) {\n\t\tvar node,\n\t\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\t\ti = 0;\n\t\n\t\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t\t}\n\t\n\t\t\tif ( node.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t\t}\n\t\t\t\tnode.parentNode.removeChild( node );\n\t\t\t}\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\tjQuery.extend( {\n\t\thtmlPrefilter: function( html ) {\n\t\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t\t},\n\t\n\t\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\t\tvar i, l, srcElements, destElements,\n\t\t\t\tclone = elem.cloneNode( true ),\n\t\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t// Fix IE cloning issues\n\t\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\t\n\t\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll( clone );\n\t\t\t\tsrcElements = getAll( elem );\n\t\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif ( dataAndEvents ) {\n\t\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\t\tdestElements = destElements || getAll( clone );\n\t\n\t\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll( clone, \"script\" );\n\t\t\tif ( destElements.length > 0 ) {\n\t\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t\t}\n\t\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\t\n\t\tcleanData: function( elems ) {\n\t\t\tvar data, elem, type,\n\t\t\t\tspecial = jQuery.event.special,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\t\n\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\t\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tdetach: function( selector ) {\n\t\t\treturn remove( this, selector, true );\n\t\t},\n\t\n\t\tremove: function( selector ) {\n\t\t\treturn remove( this, selector );\n\t\t},\n\t\n\t\ttext: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\tjQuery.text( this ) :\n\t\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\tappend: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.appendChild( elem );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tprepend: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tbefore: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tafter: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tempty: function() {\n\t\t\tvar elem,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\n\t\t\t\t\t// Prevent memory leaks\n\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\n\t\t\t\t\t// Remove any remaining nodes\n\t\t\t\t\telem.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\t\n\t\t\treturn this.map( function() {\n\t\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t\t} );\n\t\t},\n\t\n\t\thtml: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\t\ti = 0,\n\t\t\t\t\tl = this.length;\n\t\n\t\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\t\treturn elem.innerHTML;\n\t\t\t\t}\n\t\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\t\n\t\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\t\telem = this[ i ] || {};\n\t\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\telem = 0;\n\t\n\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch ( e ) {}\n\t\t\t\t}\n\t\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tthis.empty().append( value );\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\treplaceWith: function() {\n\t\t\tvar ignored = [];\n\t\n\t\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tvar parent = this.parentNode;\n\t\n\t\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\t\tif ( parent ) {\n\t\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Force callback invocation\n\t\t\t}, ignored );\n\t\t}\n\t} );\n\t\n\tjQuery.each( {\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function( name, original ) {\n\t\tjQuery.fn[ name ] = function( selector ) {\n\t\t\tvar elems,\n\t\t\t\tret = [],\n\t\t\t\tinsert = jQuery( selector ),\n\t\t\t\tlast = insert.length - 1,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; i <= last; i++ ) {\n\t\t\t\telems = i === last ? this : this.clone( true );\n\t\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\t\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tpush.apply( ret, elems.get() );\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( ret );\n\t\t};\n\t} );\n\tvar rmargin = ( /^margin/ );\n\t\n\tvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\t\n\tvar getStyles = function( elem ) {\n\t\n\t\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t\t// IE throws on elements created in popups\n\t\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\t\tvar view = elem.ownerDocument.defaultView;\n\t\n\t\t\tif ( !view || !view.opener ) {\n\t\t\t\tview = window;\n\t\t\t}\n\t\n\t\t\treturn view.getComputedStyle( elem );\n\t\t};\n\t\n\t\n\t\n\t( function() {\n\t\n\t\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t\t// so they're executed at the same time to save the second computation.\n\t\tfunction computeStyleTests() {\n\t\n\t\t\t// This is a singleton, we need to execute it only once\n\t\t\tif ( !div ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tdiv.style.cssText =\n\t\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\t\"position:relative;display:block;\" +\n\t\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\t\"top:1%;width:50%\";\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdocumentElement.appendChild( container );\n\t\n\t\t\tvar divStyle = window.getComputedStyle( div );\n\t\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\n\t\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\t\n\t\t\t// Support: Android 4.0 - 4.3 only\n\t\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\t\tdiv.style.marginRight = \"50%\";\n\t\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\t\n\t\t\tdocumentElement.removeChild( container );\n\t\n\t\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t\t// it will also be a sign that checks already performed\n\t\t\tdiv = null;\n\t\t}\n\t\n\t\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\t\tcontainer = document.createElement( \"div\" ),\n\t\t\tdiv = document.createElement( \"div\" );\n\t\n\t\t// Finish early in limited (non-browser) environments\n\t\tif ( !div.style ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Support: IE <=9 - 11 only\n\t\t// Style of cloned element affects source element cloned (#8908)\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\t\n\t\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\t\"padding:0;margin-top:1px;position:absolute\";\n\t\tcontainer.appendChild( div );\n\t\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\tpixelMarginRight: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelMarginRightVal;\n\t\t\t},\n\t\t\treliableMarginLeft: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn reliableMarginLeftVal;\n\t\t\t}\n\t\t} );\n\t} )();\n\t\n\t\n\tfunction curCSS( elem, name, computed ) {\n\t\tvar width, minWidth, maxWidth, ret,\n\t\t\tstyle = elem.style;\n\t\n\t\tcomputed = computed || getStyles( elem );\n\t\n\t\t// Support: IE <=9 only\n\t\t// getPropertyValue is only needed for .css('filter') (#12537)\n\t\tif ( computed ) {\n\t\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\t\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Android Browser returns percentage for some values,\n\t\t\t// but width seems to be reliably pixels.\n\t\t\t// This is against the CSSOM draft spec:\n\t\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\t\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\t\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\t\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\t\n\t\treturn ret !== undefined ?\n\t\n\t\t\t// Support: IE <=9 - 11 only\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\tret + \"\" :\n\t\t\tret;\n\t}\n\t\n\t\n\tfunction addGetHookIf( conditionFn, hookFn ) {\n\t\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\tif ( conditionFn() ) {\n\t\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t\t// to missing dependency), remove it.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t\t}\n\t\t};\n\t}\n\t\n\t\n\tvar\n\t\n\t\t// Swappable if display is none or starts with table\n\t\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\t\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t\tcssNormalTransform = {\n\t\t\tletterSpacing: \"0\",\n\t\t\tfontWeight: \"400\"\n\t\t},\n\t\n\t\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\t\temptyStyle = document.createElement( \"div\" ).style;\n\t\n\t// Return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName( name ) {\n\t\n\t\t// Shortcut for names that are not vendor prefixed\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t\n\t\t// Check for vendor prefixed names\n\t\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\t\ti = cssPrefixes.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tname = cssPrefixes[ i ] + capName;\n\t\t\tif ( name in emptyStyle ) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction setPositiveNumber( elem, value, subtract ) {\n\t\n\t\t// Any relative (+/-) values have already been\n\t\t// normalized at this point\n\t\tvar matches = rcssNum.exec( value );\n\t\treturn matches ?\n\t\n\t\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\t\tvalue;\n\t}\n\t\n\tfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\t\tvar i,\n\t\t\tval = 0;\n\t\n\t\t// If we already have the right measurement, avoid augmentation\n\t\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\t\ti = 4;\n\t\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\t} else {\n\t\t\ti = name === \"width\" ? 1 : 0;\n\t\t}\n\t\n\t\tfor ( ; i < 4; i += 2 ) {\n\t\n\t\t\t// Both box models exclude margin, so add it if we want it\n\t\t\tif ( extra === \"margin\" ) {\n\t\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t\t}\n\t\n\t\t\tif ( isBorderBox ) {\n\t\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif ( extra === \"content\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t\t}\n\t\n\t\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t} else {\n\t\n\t\t\t\t// At this point, extra isn't content, so add padding\n\t\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\n\t\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn val;\n\t}\n\t\n\tfunction getWidthOrHeight( elem, name, extra ) {\n\t\n\t\t// Start with offset property, which is equivalent to the border-box value\n\t\tvar val,\n\t\t\tvalueIsBorderBox = true,\n\t\t\tstyles = getStyles( elem ),\n\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\t\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a disconnected node\n\t\t// in IE throws an error.\n\t\tif ( elem.getClientRects().length ) {\n\t\t\tval = elem.getBoundingClientRect()[ name ];\n\t\t}\n\t\n\t\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\t\tif ( val <= 0 || val == null ) {\n\t\n\t\t\t// Fall back to computed then uncomputed css if necessary\n\t\t\tval = curCSS( elem, name, styles );\n\t\t\tif ( val < 0 || val == null ) {\n\t\t\t\tval = elem.style[ name ];\n\t\t\t}\n\t\n\t\t\t// Computed unit is not pixels. Stop here and return.\n\t\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\t\treturn val;\n\t\t\t}\n\t\n\t\t\t// Check for style in case a browser which returns unreliable values\n\t\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\t\n\t\t\t// Normalize \"\", auto, and prepare for extra\n\t\t\tval = parseFloat( val ) || 0;\n\t\t}\n\t\n\t\t// Use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn ( val +\n\t\t\taugmentWidthOrHeight(\n\t\t\t\telem,\n\t\t\t\tname,\n\t\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\t\tvalueIsBorderBox,\n\t\t\t\tstyles\n\t\t\t)\n\t\t) + \"px\";\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"animationIterationCount\": true,\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"flexGrow\": true,\n\t\t\t\"flexShrink\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\t\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t\"float\": \"cssFloat\"\n\t\t},\n\t\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function( elem, name, value, extra ) {\n\t\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret, type, hooks,\n\t\t\t\torigName = jQuery.camelCase( name ),\n\t\t\t\tstyle = elem.style;\n\t\n\t\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\t\n\t\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// Check if we're setting a value\n\t\t\tif ( value !== undefined ) {\n\t\t\t\ttype = typeof value;\n\t\n\t\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\t\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\t\n\t\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\t\tif ( value == null || value !== value ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t\tif ( type === \"number\" ) {\n\t\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t\t}\n\t\n\t\t\t\t// background-* props affect original clone's values\n\t\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t\t}\n\t\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\t\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\t\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[ name ];\n\t\t\t}\n\t\t},\n\t\n\t\tcss: function( elem, name, extra, styles ) {\n\t\t\tvar val, num, hooks,\n\t\t\t\torigName = jQuery.camelCase( name );\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\t\n\t\t\t// Try prefixed name followed by the unprefixed name\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\t\tval = hooks.get( elem, true, extra );\n\t\t\t}\n\t\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif ( val === undefined ) {\n\t\t\t\tval = curCSS( elem, name, styles );\n\t\t\t}\n\t\n\t\t\t// Convert \"normal\" to computed value\n\t\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\t\tval = cssNormalTransform[ name ];\n\t\t\t}\n\t\n\t\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\t\tif ( extra === \"\" || extra ) {\n\t\t\t\tnum = parseFloat( val );\n\t\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\t\tjQuery.cssHooks[ name ] = {\n\t\t\tget: function( elem, computed, extra ) {\n\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\t\n\t\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t\t} ) :\n\t\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tset: function( elem, value, extra ) {\n\t\t\t\tvar matches,\n\t\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\t\tstyles\n\t\t\t\t\t);\n\t\n\t\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\t\n\t\t\t\t\telem.style[ name ] = value;\n\t\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t\t}\n\t\n\t\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t\t}\n\t\t};\n\t} );\n\t\n\tjQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t\t} )\n\t\t\t\t\t) + \"px\";\n\t\t\t}\n\t\t}\n\t);\n\t\n\t// These hooks are used by animate to expand properties\n\tjQuery.each( {\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function( prefix, suffix ) {\n\t\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\t\texpand: function( value ) {\n\t\t\t\tvar i = 0,\n\t\t\t\t\texpanded = {},\n\t\n\t\t\t\t\t// Assumes a single number if not a string\n\t\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\t\n\t\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t\t}\n\t\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\t\n\t\tif ( !rmargin.test( prefix ) ) {\n\t\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tcss: function( name, value ) {\n\t\t\treturn access( this, function( elem, name, value ) {\n\t\t\t\tvar styles, len,\n\t\t\t\t\tmap = {},\n\t\t\t\t\ti = 0;\n\t\n\t\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\t\tstyles = getStyles( elem );\n\t\t\t\t\tlen = name.length;\n\t\n\t\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\n\t\t\t\treturn value !== undefined ?\n\t\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\t\tjQuery.css( elem, name );\n\t\t\t}, name, value, arguments.length > 1 );\n\t\t}\n\t} );\n\t\n\t\n\tfunction Tween( elem, options, prop, end, easing ) {\n\t\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n\t}\n\tjQuery.Tween = Tween;\n\t\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || jQuery.easing._default;\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t\t},\n\t\tcur: function() {\n\t\t\tvar hooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\treturn hooks && hooks.get ?\n\t\t\t\thooks.get( this ) :\n\t\t\t\tTween.propHooks._default.get( this );\n\t\t},\n\t\trun: function( percent ) {\n\t\t\tvar eased,\n\t\t\t\thooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\tif ( this.options.duration ) {\n\t\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\t\n\t\t\tif ( this.options.step ) {\n\t\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t\t}\n\t\n\t\t\tif ( hooks && hooks.set ) {\n\t\t\t\thooks.set( this );\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set( this );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\t\n\tTween.prototype.init.prototype = Tween.prototype;\n\t\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function( tween ) {\n\t\t\t\tvar result;\n\t\n\t\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t\t// or when there is no matching style property that exists.\n\t\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t\t}\n\t\n\t\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function( tween ) {\n\t\n\t\t\t\t// Use step hook for back compat.\n\t\t\t\t// Use cssHook if its there.\n\t\t\t\t// Use .style if available and use plain properties where available.\n\t\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// Support: IE <=9 only\n\t// Panic based approach to setting things on disconnected nodes\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function( tween ) {\n\t\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.easing = {\n\t\tlinear: function( p ) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function( p ) {\n\t\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t\t},\n\t\t_default: \"swing\"\n\t};\n\t\n\tjQuery.fx = Tween.prototype.init;\n\t\n\t// Back compat <1.8 extension point\n\tjQuery.fx.step = {};\n\t\n\t\n\t\n\t\n\tvar\n\t\tfxNow, timerId,\n\t\trfxtypes = /^(?:toggle|show|hide)$/,\n\t\trrun = /queueHooks$/;\n\t\n\tfunction raf() {\n\t\tif ( timerId ) {\n\t\t\twindow.requestAnimationFrame( raf );\n\t\t\tjQuery.fx.tick();\n\t\t}\n\t}\n\t\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\twindow.setTimeout( function() {\n\t\t\tfxNow = undefined;\n\t\t} );\n\t\treturn ( fxNow = jQuery.now() );\n\t}\n\t\n\t// Generate parameters to create a standard animation\n\tfunction genFx( type, includeWidth ) {\n\t\tvar which,\n\t\t\ti = 0,\n\t\t\tattrs = { height: type };\n\t\n\t\t// If we include width, step value is 1 to do all cssExpand values,\n\t\t// otherwise step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\t\twhich = cssExpand[ i ];\n\t\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t\t}\n\t\n\t\tif ( includeWidth ) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\t\n\t\treturn attrs;\n\t}\n\t\n\tfunction createTween( value, prop, animation ) {\n\t\tvar tween,\n\t\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\t\n\t\t\t\t// We're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction defaultPrefilter( elem, props, opts ) {\n\t\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\t\tisBox = \"width\" in props || \"height\" in props,\n\t\t\tanim = this,\n\t\t\torig = {},\n\t\t\tstyle = elem.style,\n\t\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\t\n\t\t// Queue-skipping animations hijack the fx hooks\n\t\tif ( !opts.queue ) {\n\t\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\t\tif ( hooks.unqueued == null ) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function() {\n\t\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\t\n\t\t\tanim.always( function() {\n\t\n\t\t\t\t// Ensure the complete handler is called before this completes\n\t\t\t\tanim.always( function() {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\n\t\t// Detect show/hide animations\n\t\tfor ( prop in props ) {\n\t\t\tvalue = props[ prop ];\n\t\t\tif ( rfxtypes.test( value ) ) {\n\t\t\t\tdelete props[ prop ];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\t\n\t\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\t\thidden = true;\n\t\n\t\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t\t}\n\t\t}\n\t\n\t\t// Bail out if this is a no-op like .hide().hide()\n\t\tpropTween = !jQuery.isEmptyObject( props );\n\t\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Restrict \"overflow\" and \"display\" styles during box animations\n\t\tif ( isBox && elem.nodeType === 1 ) {\n\t\n\t\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t\t// from identically-valued overflowX and overflowY\n\t\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\t\n\t\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\t\trestoreDisplay = dataShow && dataShow.display;\n\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t\t}\n\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tif ( restoreDisplay ) {\n\t\t\t\t\tdisplay = restoreDisplay;\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Animate inline elements as inline-block\n\t\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\n\t\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\t\tif ( !propTween ) {\n\t\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif ( opts.overflow ) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tanim.always( function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t} );\n\t\t}\n\t\n\t\t// Implement show/hide animations\n\t\tpropTween = false;\n\t\tfor ( prop in orig ) {\n\t\n\t\t\t// General show/hide setup for this element animation\n\t\t\tif ( !propTween ) {\n\t\t\t\tif ( dataShow ) {\n\t\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t\t}\n\t\n\t\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\t\tif ( toggle ) {\n\t\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t\t}\n\t\n\t\t\t\t// Show elements before animating them\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\t}\n\t\n\t\t\t\t/* eslint-disable no-loop-func */\n\t\n\t\t\t\tanim.done( function() {\n\t\n\t\t\t\t/* eslint-enable no-loop-func */\n\t\n\t\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\t\tif ( !hidden ) {\n\t\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\t// Per-property setup\n\t\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\t\tpropTween.start = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction propFilter( props, specialEasing ) {\n\t\tvar index, name, easing, value, hooks;\n\t\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor ( index in props ) {\n\t\t\tname = jQuery.camelCase( index );\n\t\t\teasing = specialEasing[ name ];\n\t\t\tvalue = props[ index ];\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\teasing = value[ 1 ];\n\t\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t\t}\n\t\n\t\t\tif ( index !== name ) {\n\t\t\t\tprops[ name ] = value;\n\t\t\t\tdelete props[ index ];\n\t\t\t}\n\t\n\t\t\thooks = jQuery.cssHooks[ name ];\n\t\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\t\tvalue = hooks.expand( value );\n\t\t\t\tdelete props[ name ];\n\t\n\t\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\t\tfor ( index in value ) {\n\t\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[ name ] = easing;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction Animation( elem, properties, options ) {\n\t\tvar result,\n\t\t\tstopped,\n\t\t\tindex = 0,\n\t\t\tlength = Animation.prefilters.length,\n\t\t\tdeferred = jQuery.Deferred().always( function() {\n\t\n\t\t\t\t// Don't match elem in the :animated selector\n\t\t\t\tdelete tick.elem;\n\t\t\t} ),\n\t\t\ttick = function() {\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\n\t\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\t\tpercent = 1 - temp,\n\t\t\t\t\tindex = 0,\n\t\t\t\t\tlength = animation.tweens.length;\n\t\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t\t}\n\t\n\t\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\t\n\t\t\t\tif ( percent < 1 && length ) {\n\t\t\t\t\treturn remaining;\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation = deferred.promise( {\n\t\t\t\telem: elem,\n\t\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\t\topts: jQuery.extend( true, {\n\t\t\t\t\tspecialEasing: {},\n\t\t\t\t\teasing: jQuery.easing._default\n\t\t\t\t}, options ),\n\t\t\t\toriginalProperties: properties,\n\t\t\t\toriginalOptions: options,\n\t\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\t\tduration: options.duration,\n\t\t\t\ttweens: [],\n\t\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\t\treturn tween;\n\t\t\t\t},\n\t\t\t\tstop: function( gotoEnd ) {\n\t\t\t\t\tvar index = 0,\n\t\n\t\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\t\tif ( stopped ) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\tstopped = true;\n\t\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} ),\n\t\t\tprops = animation.props;\n\t\n\t\tpropFilter( props, animation.opts.specialEasing );\n\t\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\t\tif ( result ) {\n\t\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\n\t\tjQuery.map( props, createTween, animation );\n\t\n\t\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\t\tanimation.opts.start.call( elem, animation );\n\t\t}\n\t\n\t\tjQuery.fx.timer(\n\t\t\tjQuery.extend( tick, {\n\t\t\t\telem: elem,\n\t\t\t\tanim: animation,\n\t\t\t\tqueue: animation.opts.queue\n\t\t\t} )\n\t\t);\n\t\n\t\t// attach callbacks from options\n\t\treturn animation.progress( animation.opts.progress )\n\t\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t\t.fail( animation.opts.fail )\n\t\t\t.always( animation.opts.always );\n\t}\n\t\n\tjQuery.Animation = jQuery.extend( Animation, {\n\t\n\t\ttweeners: {\n\t\t\t\"*\": [ function( prop, value ) {\n\t\t\t\tvar tween = this.createTween( prop, value );\n\t\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\t\treturn tween;\n\t\t\t} ]\n\t\t},\n\t\n\t\ttweener: function( props, callback ) {\n\t\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [ \"*\" ];\n\t\t\t} else {\n\t\t\t\tprops = props.match( rnothtmlwhite );\n\t\t\t}\n\t\n\t\t\tvar prop,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = props.length;\n\t\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tprop = props[ index ];\n\t\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t\t}\n\t\t},\n\t\n\t\tprefilters: [ defaultPrefilter ],\n\t\n\t\tprefilter: function( callback, prepend ) {\n\t\t\tif ( prepend ) {\n\t\t\t\tAnimation.prefilters.unshift( callback );\n\t\t\t} else {\n\t\t\t\tAnimation.prefilters.push( callback );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tjQuery.speed = function( speed, easing, fn ) {\n\t\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t\t};\n\t\n\t\t// Go to the end state if fx are off or if document is hidden\n\t\tif ( jQuery.fx.off || document.hidden ) {\n\t\t\topt.duration = 0;\n\t\n\t\t} else {\n\t\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\t\n\t\t\t\t} else {\n\t\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif ( opt.queue == null || opt.queue === true ) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\t\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\t\n\t\topt.complete = function() {\n\t\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\t\topt.old.call( this );\n\t\t\t}\n\t\n\t\t\tif ( opt.queue ) {\n\t\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t\t}\n\t\t};\n\t\n\t\treturn opt;\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tfadeTo: function( speed, to, easing, callback ) {\n\t\n\t\t\t// Show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\t\n\t\t\t\t// Animate to the value specified\n\t\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t\t},\n\t\tanimate: function( prop, speed, easing, callback ) {\n\t\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\t\tdoAnimation = function() {\n\t\n\t\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\t\n\t\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\t\tanim.stop( true );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tdoAnimation.finish = doAnimation;\n\t\n\t\t\treturn empty || optall.queue === false ?\n\t\t\t\tthis.each( doAnimation ) :\n\t\t\t\tthis.queue( optall.queue, doAnimation );\n\t\t},\n\t\tstop: function( type, clearQueue, gotoEnd ) {\n\t\t\tvar stopQueue = function( hooks ) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop( gotoEnd );\n\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif ( clearQueue && type !== false ) {\n\t\t\t\tthis.queue( type || \"fx\", [] );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tdata = dataPriv.get( this );\n\t\n\t\t\t\tif ( index ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( index in data ) {\n\t\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\t\n\t\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\tfinish: function( type ) {\n\t\t\tif ( type !== false ) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tvar index,\n\t\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tlength = queue ? queue.length : 0;\n\t\n\t\t\t\t// Enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\t\n\t\t\t\t// Empty the queue first\n\t\t\t\tjQuery.queue( this, type, [] );\n\t\n\t\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\t\thooks.stop.call( this, true );\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any active animations, and finish them\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any animations in the old queue and finish them\n\t\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\t\tvar cssFn = jQuery.fn[ name ];\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\t\tcssFn.apply( this, arguments ) :\n\t\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t\t};\n\t} );\n\t\n\t// Generate shortcuts for custom animations\n\tjQuery.each( {\n\t\tslideDown: genFx( \"show\" ),\n\t\tslideUp: genFx( \"hide\" ),\n\t\tslideToggle: genFx( \"toggle\" ),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function( name, props ) {\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn this.animate( props, speed, easing, callback );\n\t\t};\n\t} );\n\t\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function() {\n\t\tvar timer,\n\t\t\ti = 0,\n\t\t\ttimers = jQuery.timers;\n\t\n\t\tfxNow = jQuery.now();\n\t\n\t\tfor ( ; i < timers.length; i++ ) {\n\t\t\ttimer = timers[ i ];\n\t\n\t\t\t// Checks the timer has not already been removed\n\t\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\t\ttimers.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\t\n\t\tif ( !timers.length ) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\t\n\tjQuery.fx.timer = function( timer ) {\n\t\tjQuery.timers.push( timer );\n\t\tif ( timer() ) {\n\t\t\tjQuery.fx.start();\n\t\t} else {\n\t\t\tjQuery.timers.pop();\n\t\t}\n\t};\n\t\n\tjQuery.fx.interval = 13;\n\tjQuery.fx.start = function() {\n\t\tif ( !timerId ) {\n\t\t\ttimerId = window.requestAnimationFrame ?\n\t\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t\t}\n\t};\n\t\n\tjQuery.fx.stop = function() {\n\t\tif ( window.cancelAnimationFrame ) {\n\t\t\twindow.cancelAnimationFrame( timerId );\n\t\t} else {\n\t\t\twindow.clearInterval( timerId );\n\t\t}\n\t\n\t\ttimerId = null;\n\t};\n\t\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\t\n\t\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\t\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = window.setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\twindow.clearTimeout( timeout );\n\t\t\t};\n\t\t} );\n\t};\n\t\n\t\n\t( function() {\n\t\tvar input = document.createElement( \"input\" ),\n\t\t\tselect = document.createElement( \"select\" ),\n\t\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\t\n\t\tinput.type = \"checkbox\";\n\t\n\t\t// Support: Android <=4.3 only\n\t\t// Default value for a checkbox should be \"on\"\n\t\tsupport.checkOn = input.value !== \"\";\n\t\n\t\t// Support: IE <=11 only\n\t\t// Must access selectedIndex to make default options select\n\t\tsupport.optSelected = opt.selected;\n\t\n\t\t// Support: IE <=11 only\n\t\t// An input loses its value after becoming a radio\n\t\tinput = document.createElement( \"input\" );\n\t\tinput.value = \"t\";\n\t\tinput.type = \"radio\";\n\t\tsupport.radioValue = input.value === \"t\";\n\t} )();\n\t\n\t\n\tvar boolHook,\n\t\tattrHandle = jQuery.expr.attrHandle;\n\t\n\tjQuery.fn.extend( {\n\t\tattr: function( name, value ) {\n\t\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveAttr: function( name ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.removeAttr( this, name );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tattr: function( elem, name, value ) {\n\t\t\tvar ret, hooks,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\t\treturn jQuery.prop( elem, name, value );\n\t\t\t}\n\t\n\t\t\t// Attribute hooks are determined by the lowercase version\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tif ( value === null ) {\n\t\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\t\n\t\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\n\t\t\tret = jQuery.find.attr( elem, name );\n\t\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ? undefined : ret;\n\t\t},\n\t\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tremoveAttr: function( elem, value ) {\n\t\t\tvar name,\n\t\t\t\ti = 0,\n\t\n\t\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\t\n\t\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\t\telem.removeAttribute( name );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Hooks for boolean attributes\n\tboolHook = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( value === false ) {\n\t\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, name );\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t};\n\t\n\tjQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\t\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\t\n\t\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\t\tvar ret, handle,\n\t\t\t\tlowercaseName = name.toLowerCase();\n\t\n\t\t\tif ( !isXML ) {\n\t\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\tlowercaseName :\n\t\t\t\t\tnull;\n\t\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t} );\n\t\n\t\n\t\n\t\n\tvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\t\trclickable = /^(?:a|area)$/i;\n\t\n\tjQuery.fn.extend( {\n\t\tprop: function( name, value ) {\n\t\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveProp: function( name ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tprop: function( elem, name, value ) {\n\t\t\tvar ret, hooks,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\t\thooks = jQuery.propHooks[ name ];\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\treturn ( elem[ name ] = value );\n\t\t\t}\n\t\n\t\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\n\t\t\treturn elem[ name ];\n\t\t},\n\t\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function( elem ) {\n\t\n\t\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\t\n\t\t\t\t\tif ( tabindex ) {\n\t\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (\n\t\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\t\telem.href\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t}\n\t} );\n\t\n\t// Support: IE <=11 only\n\t// Accessing the selectedIndex property\n\t// forces the browser to respect setting selected\n\t// on the option\n\t// The getter ensures a default option is selected\n\t// when in an optgroup\n\t// eslint rule \"no-unused-expressions\" is disabled for this code\n\t// since it considers such accessions noop\n\tif ( !support.optSelected ) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function( elem ) {\n\t\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\t\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tset: function( elem ) {\n\t\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\t\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.selectedIndex;\n\t\n\t\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tjQuery.each( [\n\t\t\"tabIndex\",\n\t\t\"readOnly\",\n\t\t\"maxLength\",\n\t\t\"cellSpacing\",\n\t\t\"cellPadding\",\n\t\t\"rowSpan\",\n\t\t\"colSpan\",\n\t\t\"useMap\",\n\t\t\"frameBorder\",\n\t\t\"contentEditable\"\n\t], function() {\n\t\tjQuery.propFix[ this.toLowerCase() ] = this;\n\t} );\n\t\n\t\n\t\n\t\n\t\t// Strip and collapse whitespace according to HTML spec\n\t\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\t\tfunction stripAndCollapse( value ) {\n\t\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\t\treturn tokens.join( \" \" );\n\t\t}\n\t\n\t\n\tfunction getClass( elem ) {\n\t\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n\t}\n\t\n\tjQuery.fn.extend( {\n\t\taddClass: function( value ) {\n\t\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\t\ti = 0;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( j ) {\n\t\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tif ( typeof value === \"string\" && value ) {\n\t\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\t\tcurValue = getClass( elem );\n\t\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tremoveClass: function( value ) {\n\t\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\t\ti = 0;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( j ) {\n\t\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tif ( !arguments.length ) {\n\t\t\t\treturn this.attr( \"class\", \"\" );\n\t\t\t}\n\t\n\t\t\tif ( typeof value === \"string\" && value ) {\n\t\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\t\tcurValue = getClass( elem );\n\t\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\ttoggleClass: function( value, stateVal ) {\n\t\t\tvar type = typeof value;\n\t\n\t\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( i ) {\n\t\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\t\tstateVal\n\t\t\t\t\t);\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar className, i, self, classNames;\n\t\n\t\t\t\tif ( type === \"string\" ) {\n\t\n\t\t\t\t\t// Toggle individual class names\n\t\t\t\t\ti = 0;\n\t\t\t\t\tself = jQuery( this );\n\t\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\t\n\t\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\t\tclassName = getClass( this );\n\t\t\t\t\tif ( className ) {\n\t\n\t\t\t\t\t\t// Store className if set\n\t\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\thasClass: function( selector ) {\n\t\t\tvar className, elem,\n\t\t\t\ti = 0;\n\t\n\t\t\tclassName = \" \" + selector + \" \";\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tvar rreturn = /\\r/g;\n\t\n\tjQuery.fn.extend( {\n\t\tval: function( value ) {\n\t\t\tvar hooks, ret, isFunction,\n\t\t\t\telem = this[ 0 ];\n\t\n\t\t\tif ( !arguments.length ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\t\n\t\t\t\t\tif ( hooks &&\n\t\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tret = elem.value;\n\t\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t\t}\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tvar val;\n\t\n\t\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\t\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\tval = \"\";\n\t\n\t\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\t\tval += \"\";\n\t\n\t\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\n\t\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\t\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function( elem ) {\n\t\n\t\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\t\treturn val != null ?\n\t\t\t\t\t\tval :\n\t\n\t\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar value, option, i,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\t\tmax = one ? index + 1 : options.length;\n\t\n\t\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\t\ti = max;\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\n\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\n\t\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\t\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery( option ).val();\n\t\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\t\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tvar optionSet, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\t\ti = options.length;\n\t\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\n\t\t\t\t\t\t/* eslint-disable no-cond-assign */\n\t\n\t\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Radios and checkboxes getter/setter\n\tjQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif ( !support.checkOn ) {\n\t\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Return jQuery for attributes-only inclusion\n\t\n\t\n\tvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\t\n\tjQuery.extend( jQuery.event, {\n\t\n\t\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\n\t\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\t\teventPath = [ elem || document ],\n\t\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\t\n\t\t\tcur = tmp = elem = elem || document;\n\t\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\t\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split( \".\" );\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\t\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[ jQuery.expando ] ?\n\t\t\t\tevent :\n\t\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\t\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join( \".\" );\n\t\t\tevent.rnamespace = event.namespace ?\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\t\tnull;\n\t\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\t\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ?\n\t\t\t\t[ event ] :\n\t\t\t\tjQuery.makeArray( data, [ event ] );\n\t\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\t\teventPath.push( cur );\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\t\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\n\t\t\t\tevent.type = i > 1 ?\n\t\t\t\t\tbubbleType :\n\t\t\t\t\tspecial.bindType || type;\n\t\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\t\tif ( handle ) {\n\t\t\t\t\thandle.apply( cur, data );\n\t\t\t\t}\n\t\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ ontype ];\n\t\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\t\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\t\n\t\t\t\tif ( ( !special._default ||\n\t\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\t\tacceptData( elem ) ) {\n\t\n\t\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ ontype ];\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\t// Piggyback on a donor event to simulate a different one\n\t\t// Used only for `focus(in | out)` events\n\t\tsimulate: function( type, elem, event ) {\n\t\t\tvar e = jQuery.extend(\n\t\t\t\tnew jQuery.Event(),\n\t\t\t\tevent,\n\t\t\t\t{\n\t\t\t\t\ttype: type,\n\t\t\t\t\tisSimulated: true\n\t\t\t\t}\n\t\t\t);\n\t\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t}\n\t\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\n\t\ttrigger: function( type, data ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.trigger( type, data, this );\n\t\t\t} );\n\t\t},\n\t\ttriggerHandler: function( type, data ) {\n\t\t\tvar elem = this[ 0 ];\n\t\t\tif ( elem ) {\n\t\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\t\tfunction( i, name ) {\n\t\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\thover: function( fnOver, fnOut ) {\n\t\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tsupport.focusin = \"onfocusin\" in window;\n\t\n\t\n\t// Support: Firefox <=44\n\t// Firefox doesn't have focus(in | out) events\n\t// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n\t//\n\t// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n\t// focus(in | out) events fire after focus & blur events,\n\t// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n\t// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\tif ( !support.focusin ) {\n\t\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\t\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t\t};\n\t\n\t\t\tjQuery.event.special[ fix ] = {\n\t\t\t\tsetup: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\t\tdataPriv.remove( doc, fix );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t} );\n\t}\n\tvar location = window.location;\n\t\n\tvar nonce = jQuery.now();\n\t\n\tvar rquery = ( /\\?/ );\n\t\n\t\n\t\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function( data ) {\n\t\tvar xml;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Support: IE 9 - 11 only\n\t\t// IE throws on parseFromString with invalid input.\n\t\ttry {\n\t\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t\t} catch ( e ) {\n\t\t\txml = undefined;\n\t\t}\n\t\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t};\n\t\n\t\n\tvar\n\t\trbracket = /\\[\\]$/,\n\t\trCRLF = /\\r?\\n/g,\n\t\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\t\n\tfunction buildParams( prefix, obj, traditional, add ) {\n\t\tvar name;\n\t\n\t\tif ( jQuery.isArray( obj ) ) {\n\t\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each( obj, function( i, v ) {\n\t\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd( prefix, v );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams(\n\t\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\t\tv,\n\t\t\t\t\t\ttraditional,\n\t\t\t\t\t\tadd\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\n\t\t\t// Serialize object item.\n\t\t\tfor ( name in obj ) {\n\t\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t\t}\n\t\n\t\t} else {\n\t\n\t\t\t// Serialize scalar item.\n\t\t\tadd( prefix, obj );\n\t\t}\n\t}\n\t\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function( a, traditional ) {\n\t\tvar prefix,\n\t\t\ts = [],\n\t\t\tadd = function( key, valueOrFunction ) {\n\t\n\t\t\t\t// If value is a function, invoke it and use its return value\n\t\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\t\tvalueOrFunction() :\n\t\t\t\t\tvalueOrFunction;\n\t\n\t\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t\t};\n\t\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function() {\n\t\t\t\tadd( this.name, this.value );\n\t\t\t} );\n\t\n\t\t} else {\n\t\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor ( prefix in a ) {\n\t\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the resulting serialization\n\t\treturn s.join( \"&\" );\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tserialize: function() {\n\t\t\treturn jQuery.param( this.serializeArray() );\n\t\t},\n\t\tserializeArray: function() {\n\t\t\treturn this.map( function() {\n\t\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t\t} )\n\t\t\t.filter( function() {\n\t\t\t\tvar type = this.type;\n\t\n\t\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t\t} )\n\t\t\t.map( function( i, elem ) {\n\t\t\t\tvar val = jQuery( this ).val();\n\t\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\n\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t} ).get();\n\t\t}\n\t} );\n\t\n\t\n\tvar\n\t\tr20 = /%20/g,\n\t\trhash = /#.*$/,\n\t\trantiCache = /([?&])_=[^&]*/,\n\t\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t\n\t\t// #7653, #8125, #8152: local protocol detection\n\t\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t\trnoContent = /^(?:GET|HEAD)$/,\n\t\trprotocol = /^\\/\\//,\n\t\n\t\t/* Prefilters\n\t\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t\t * 2) These are called:\n\t\t *    - BEFORE asking for a transport\n\t\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t\t * 3) key is the dataType\n\t\t * 4) the catchall symbol \"*\" can be used\n\t\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t\t */\n\t\tprefilters = {},\n\t\n\t\t/* Transports bindings\n\t\t * 1) key is the dataType\n\t\t * 2) the catchall symbol \"*\" can be used\n\t\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t\t */\n\t\ttransports = {},\n\t\n\t\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\t\tallTypes = \"*/\".concat( \"*\" ),\n\t\n\t\t// Anchor tag for parsing the document origin\n\t\toriginAnchor = document.createElement( \"a\" );\n\t\toriginAnchor.href = location.href;\n\t\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports( structure ) {\n\t\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function( dataTypeExpression, func ) {\n\t\n\t\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\t\n\t\t\tvar dataType,\n\t\t\t\ti = 0,\n\t\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\t\n\t\t\tif ( jQuery.isFunction( func ) ) {\n\t\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\t\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\t\n\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\t\n\t\tvar inspected = {},\n\t\t\tseekingTransport = ( structure === transports );\n\t\n\t\tfunction inspect( dataType ) {\n\t\t\tvar selected;\n\t\t\tinspected[ dataType ] = true;\n\t\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\n\t\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\t\treturn false;\n\t\t\t\t} else if ( seekingTransport ) {\n\t\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn selected;\n\t\t}\n\t\n\t\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n\t}\n\t\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend( target, src ) {\n\t\tvar key, deep,\n\t\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\t\n\t\tfor ( key in src ) {\n\t\t\tif ( src[ key ] !== undefined ) {\n\t\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t\t}\n\t\t}\n\t\tif ( deep ) {\n\t\t\tjQuery.extend( true, target, deep );\n\t\t}\n\t\n\t\treturn target;\n\t}\n\t\n\t/* Handles responses to an ajax request:\n\t * - finds the right dataType (mediates between content-type and expected dataType)\n\t * - returns the corresponding response\n\t */\n\tfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\t\n\t\tvar ct, type, finalDataType, firstDataType,\n\t\t\tcontents = s.contents,\n\t\t\tdataTypes = s.dataTypes;\n\t\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\t\tdataTypes.shift();\n\t\t\tif ( ct === undefined ) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t\t}\n\t\t}\n\t\n\t\t// Check if we're dealing with a known content-type\n\t\tif ( ct ) {\n\t\t\tfor ( type in contents ) {\n\t\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\t\tdataTypes.unshift( type );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif ( dataTypes[ 0 ] in responses ) {\n\t\t\tfinalDataType = dataTypes[ 0 ];\n\t\t} else {\n\t\n\t\t\t// Try convertible dataTypes\n\t\t\tfor ( type in responses ) {\n\t\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( !firstDataType ) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\t\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif ( finalDataType ) {\n\t\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\t\tdataTypes.unshift( finalDataType );\n\t\t\t}\n\t\t\treturn responses[ finalDataType ];\n\t\t}\n\t}\n\t\n\t/* Chain conversions given the request and the original response\n\t * Also sets the responseXXX fields on the jqXHR instance\n\t */\n\tfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\t\tvar conv2, current, conv, tmp, prev,\n\t\t\tconverters = {},\n\t\n\t\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\t\tdataTypes = s.dataTypes.slice();\n\t\n\t\t// Create converters map with lowercased keys\n\t\tif ( dataTypes[ 1 ] ) {\n\t\t\tfor ( conv in s.converters ) {\n\t\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t\t}\n\t\t}\n\t\n\t\tcurrent = dataTypes.shift();\n\t\n\t\t// Convert to each sequential dataType\n\t\twhile ( current ) {\n\t\n\t\t\tif ( s.responseFields[ current ] ) {\n\t\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t\t}\n\t\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t\t}\n\t\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\t\n\t\t\tif ( current ) {\n\t\n\t\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif ( current === \"*\" ) {\n\t\n\t\t\t\t\tcurrent = prev;\n\t\n\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\t\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\t\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif ( !conv ) {\n\t\t\t\t\t\tfor ( conv2 in converters ) {\n\t\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\t\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\t\tif ( conv ) {\n\t\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\t\n\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif ( conv !== true ) {\n\t\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn { state: \"success\", data: response };\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\t\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\t\n\t\tajaxSettings: {\n\t\t\turl: location.href,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\n\t\t\t/*\n\t\t\ttimeout: 0,\n\t\t\tdata: null,\n\t\t\tdataType: null,\n\t\t\tusername: null,\n\t\t\tpassword: null,\n\t\t\tcache: null,\n\t\t\tthrows: false,\n\t\t\ttraditional: false,\n\t\t\theaders: {},\n\t\t\t*/\n\t\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\t\n\t\t\tcontents: {\n\t\t\t\txml: /\\bxml\\b/,\n\t\t\t\thtml: /\\bhtml/,\n\t\t\t\tjson: /\\bjson\\b/\n\t\t\t},\n\t\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\t\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\t\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\t\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\t\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": JSON.parse,\n\t\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\t\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\t\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function( target, settings ) {\n\t\t\treturn settings ?\n\t\n\t\t\t\t// Building a settings object\n\t\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\t\n\t\t\t\t// Extending ajaxSettings\n\t\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t\t},\n\t\n\t\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\t\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\t\n\t\t// Main method\n\t\tajax: function( url, options ) {\n\t\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ( typeof url === \"object\" ) {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\t\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\t\n\t\t\tvar transport,\n\t\n\t\t\t\t// URL without anti-cache param\n\t\t\t\tcacheURL,\n\t\n\t\t\t\t// Response headers\n\t\t\t\tresponseHeadersString,\n\t\t\t\tresponseHeaders,\n\t\n\t\t\t\t// timeout handle\n\t\t\t\ttimeoutTimer,\n\t\n\t\t\t\t// Url cleanup var\n\t\t\t\turlAnchor,\n\t\n\t\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\t\tcompleted,\n\t\n\t\t\t\t// To know if global events are to be dispatched\n\t\t\t\tfireGlobals,\n\t\n\t\t\t\t// Loop variable\n\t\t\t\ti,\n\t\n\t\t\t\t// uncached part of the url\n\t\t\t\tuncached,\n\t\n\t\t\t\t// Create the final options object\n\t\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\n\t\t\t\t// Callbacks context\n\t\t\t\tcallbackContext = s.context || s,\n\t\n\t\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\t\tglobalEventContext = s.context &&\n\t\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\t\tjQuery.event,\n\t\n\t\t\t\t// Deferreds\n\t\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\t\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode = s.statusCode || {},\n\t\n\t\t\t\t// Headers (they are sent all at once)\n\t\t\t\trequestHeaders = {},\n\t\t\t\trequestHeadersNames = {},\n\t\n\t\t\t\t// Default abort message\n\t\t\t\tstrAbort = \"canceled\",\n\t\n\t\t\t\t// Fake xhr\n\t\t\t\tjqXHR = {\n\t\t\t\t\treadyState: 0,\n\t\n\t\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\t\tvar match;\n\t\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Raw string\n\t\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Caches the header\n\t\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Overrides response content-type header\n\t\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Status-dependent callbacks\n\t\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\t\tvar code;\n\t\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\t\tif ( completed ) {\n\t\n\t\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Cancel the request\n\t\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise( jqXHR );\n\t\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\t\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\t\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\t\n\t\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\t\tif ( s.crossDomain == null ) {\n\t\t\t\turlAnchor = document.createElement( \"a\" );\n\t\n\t\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t\t// e.g. http://example.com:80x/\n\t\t\t\ttry {\n\t\t\t\t\turlAnchor.href = s.url;\n\t\n\t\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\t\ts.crossDomain = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Convert data if not already a string\n\t\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t\t}\n\t\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\t\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\t\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\t\n\t\t\t// Watch for a new set of requests\n\t\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t\t}\n\t\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\t\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test( s.type );\n\t\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\t// Remove hash to simplify url manipulation\n\t\t\tcacheURL = s.url.replace( rhash, \"\" );\n\t\n\t\t\t// More options handling for requests with no content\n\t\t\tif ( !s.hasContent ) {\n\t\n\t\t\t\t// Remember the hash so we can put it back\n\t\t\t\tuncached = s.url.slice( cacheURL.length );\n\t\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif ( s.data ) {\n\t\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\t\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\t\n\t\t\t\t// Add or update anti-cache param if needed\n\t\t\t\tif ( s.cache === false ) {\n\t\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t\t}\n\t\n\t\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\t\ts.url = cacheURL + uncached;\n\t\n\t\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t\t} else if ( s.data && s.processData &&\n\t\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t\t}\n\t\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif ( s.ifModified ) {\n\t\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t\t}\n\t\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t\t}\n\t\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\n\t\t\t\t\"Accept\",\n\t\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\t\ts.accepts[ \"*\" ]\n\t\t\t);\n\t\n\t\t\t// Check for headers option\n\t\t\tfor ( i in s.headers ) {\n\t\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t\t}\n\t\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif ( s.beforeSend &&\n\t\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\t\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\t\n\t\t\t// Aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\t\n\t\t\t// Install callbacks on deferreds\n\t\t\tcompleteDeferred.add( s.complete );\n\t\t\tjqXHR.done( s.success );\n\t\t\tjqXHR.fail( s.error );\n\t\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\t\n\t\t\t// If no transport, we auto-abort\n\t\t\tif ( !transport ) {\n\t\t\t\tdone( -1, \"No Transport\" );\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\t\n\t\t\t\t// Send global event\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t\t}\n\t\n\t\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn jqXHR;\n\t\t\t\t}\n\t\n\t\t\t\t// Timeout\n\t\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t\t}, s.timeout );\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\t\t\t\tcompleted = false;\n\t\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Propagate others as results\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\t\tstatusText = nativeStatusText;\n\t\n\t\t\t\t// Ignore repeat invocations\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tcompleted = true;\n\t\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif ( timeoutTimer ) {\n\t\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t\t}\n\t\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\t\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\t\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\t\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\t\n\t\t\t\t// Get response data\n\t\t\t\tif ( responses ) {\n\t\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t\t}\n\t\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\t\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif ( isSuccess ) {\n\t\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// if no content\n\t\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\t\n\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\t\n\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\t\n\t\t\t\t// Success/Error\n\t\t\t\tif ( isSuccess ) {\n\t\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode( statusCode );\n\t\t\t\tstatusCode = undefined;\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn jqXHR;\n\t\t},\n\t\n\t\tgetJSON: function( url, data, callback ) {\n\t\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t\t},\n\t\n\t\tgetScript: function( url, callback ) {\n\t\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\t\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\n\t\t\t// The url can be an options object (which then must have .url)\n\t\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t\t};\n\t} );\n\t\n\t\n\tjQuery._evalUrl = function( url ) {\n\t\treturn jQuery.ajax( {\n\t\t\turl: url,\n\t\n\t\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tcache: true,\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t} );\n\t};\n\t\n\t\n\tjQuery.fn.extend( {\n\t\twrapAll: function( html ) {\n\t\t\tvar wrap;\n\t\n\t\t\tif ( this[ 0 ] ) {\n\t\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\t\n\t\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\twrap.map( function() {\n\t\t\t\t\tvar elem = this;\n\t\n\t\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn elem;\n\t\t\t\t} ).append( this );\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\twrapInner: function( html ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each( function( i ) {\n\t\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar self = jQuery( this ),\n\t\t\t\t\tcontents = self.contents();\n\t\n\t\t\t\tif ( contents.length ) {\n\t\t\t\t\tcontents.wrapAll( html );\n\t\n\t\t\t\t} else {\n\t\t\t\t\tself.append( html );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\twrap: function( html ) {\n\t\t\tvar isFunction = jQuery.isFunction( html );\n\t\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t\t} );\n\t\t},\n\t\n\t\tunwrap: function( selector ) {\n\t\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.expr.pseudos.hidden = function( elem ) {\n\t\treturn !jQuery.expr.pseudos.visible( elem );\n\t};\n\tjQuery.expr.pseudos.visible = function( elem ) {\n\t\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n\t};\n\t\n\t\n\t\n\t\n\tjQuery.ajaxSettings.xhr = function() {\n\t\ttry {\n\t\t\treturn new window.XMLHttpRequest();\n\t\t} catch ( e ) {}\n\t};\n\t\n\tvar xhrSuccessStatus = {\n\t\n\t\t\t// File protocol always yields status code 0, assume 200\n\t\t\t0: 200,\n\t\n\t\t\t// Support: IE <=9 only\n\t\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t\t1223: 204\n\t\t},\n\t\txhrSupported = jQuery.ajaxSettings.xhr();\n\t\n\tsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n\tsupport.ajax = xhrSupported = !!xhrSupported;\n\t\n\tjQuery.ajaxTransport( function( options ) {\n\t\tvar callback, errorCallback;\n\t\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t\txhr = options.xhr();\n\t\n\t\t\t\t\txhr.open(\n\t\t\t\t\t\toptions.type,\n\t\t\t\t\t\toptions.url,\n\t\t\t\t\t\toptions.async,\n\t\t\t\t\t\toptions.username,\n\t\t\t\t\t\toptions.password\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Callback\n\t\t\t\t\tcallback = function( type ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\t\n\t\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcomplete(\n\t\n\t\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// Listen to events\n\t\t\t\t\txhr.onload = callback();\n\t\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\t\n\t\t\t\t\t// Support: IE 9 only\n\t\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t\t// to handle uncaught aborts\n\t\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.onreadystatechange = function() {\n\t\n\t\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\t\n\t\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Create the abort callback\n\t\t\t\t\tcallback = callback( \"abort\" );\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\tjQuery.ajaxPrefilter( function( s ) {\n\t\tif ( s.crossDomain ) {\n\t\t\ts.contents.script = false;\n\t\t}\n\t} );\n\t\n\t// Install script dataType\n\tjQuery.ajaxSetup( {\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /\\b(?:java|ecma)script\\b/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function( text ) {\n\t\t\t\tjQuery.globalEval( text );\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Handle cache's special case and crossDomain\n\tjQuery.ajaxPrefilter( \"script\", function( s ) {\n\t\tif ( s.cache === undefined ) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif ( s.crossDomain ) {\n\t\t\ts.type = \"GET\";\n\t\t}\n\t} );\n\t\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport( \"script\", function( s ) {\n\t\n\t\t// This transport only deals with cross domain requests\n\t\tif ( s.crossDomain ) {\n\t\t\tvar script, callback;\n\t\t\treturn {\n\t\t\t\tsend: function( _, complete ) {\n\t\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\t\tsrc: s.url\n\t\t\t\t\t} ).on(\n\t\t\t\t\t\t\"load error\",\n\t\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t\t},\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tvar oldCallbacks = [],\n\t\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\t\n\t// Default jsonp settings\n\tjQuery.ajaxSetup( {\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function() {\n\t\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\t\tthis[ callback ] = true;\n\t\t\treturn callback;\n\t\t}\n\t} );\n\t\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\t\n\t\tvar callbackName, overwritten, responseContainer,\n\t\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\t\"url\" :\n\t\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t\t);\n\t\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\t\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\t\ts.jsonpCallback() :\n\t\t\t\ts.jsonpCallback;\n\t\n\t\t\t// Insert callback into url or form data\n\t\t\tif ( jsonProp ) {\n\t\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t\t} else if ( s.jsonp !== false ) {\n\t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\t\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[ \"script json\" ] = function() {\n\t\t\t\tif ( !responseContainer ) {\n\t\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t\t}\n\t\t\t\treturn responseContainer[ 0 ];\n\t\t\t};\n\t\n\t\t\t// Force json dataType\n\t\t\ts.dataTypes[ 0 ] = \"json\";\n\t\n\t\t\t// Install callback\n\t\t\toverwritten = window[ callbackName ];\n\t\t\twindow[ callbackName ] = function() {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\t\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always( function() {\n\t\n\t\t\t\t// If previous value didn't exist - remove it\n\t\t\t\tif ( overwritten === undefined ) {\n\t\t\t\t\tjQuery( window ).removeProp( callbackName );\n\t\n\t\t\t\t// Otherwise restore preexisting value\n\t\t\t\t} else {\n\t\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t\t}\n\t\n\t\t\t\t// Save back as free\n\t\t\t\tif ( s[ callbackName ] ) {\n\t\n\t\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\t\n\t\t\t\t\t// Save the callback name for future use\n\t\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t\t}\n\t\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t} );\n\t\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Support: Safari 8 only\n\t// In Safari 8 documents created via document.implementation.createHTMLDocument\n\t// collapse sibling forms: the second one becomes a child of the first one.\n\t// Because of that, this security measure has to be disabled in Safari 8.\n\t// https://bugs.webkit.org/show_bug.cgi?id=137337\n\tsupport.createHTMLDocument = ( function() {\n\t\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\t\tbody.innerHTML = \"<form></form><form></form>\";\n\t\treturn body.childNodes.length === 2;\n\t} )();\n\t\n\t\n\t// Argument \"data\" should be string of html\n\t// context (optional): If specified, the fragment will be created in this context,\n\t// defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function( data, context, keepScripts ) {\n\t\tif ( typeof data !== \"string\" ) {\n\t\t\treturn [];\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\n\t\tvar base, parsed, scripts;\n\t\n\t\tif ( !context ) {\n\t\n\t\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t\t// by using document.implementation\n\t\t\tif ( support.createHTMLDocument ) {\n\t\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\t\n\t\t\t\t// Set the base href for the created document\n\t\t\t\t// so any parsed elements with URLs\n\t\t\t\t// are based on the document's URL (gh-2965)\n\t\t\t\tbase = context.createElement( \"base\" );\n\t\t\t\tbase.href = document.location.href;\n\t\t\t\tcontext.head.appendChild( base );\n\t\t\t} else {\n\t\t\t\tcontext = document;\n\t\t\t}\n\t\t}\n\t\n\t\tparsed = rsingleTag.exec( data );\n\t\tscripts = !keepScripts && [];\n\t\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t\t}\n\t\n\t\tparsed = buildFragment( [ data ], context, scripts );\n\t\n\t\tif ( scripts && scripts.length ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\t\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t};\n\t\n\t\n\t/**\n\t * Load a url into a page\n\t */\n\tjQuery.fn.load = function( url, params, callback ) {\n\t\tvar selector, type, response,\n\t\t\tself = this,\n\t\t\toff = url.indexOf( \" \" );\n\t\n\t\tif ( off > -1 ) {\n\t\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\t\turl = url.slice( 0, off );\n\t\t}\n\t\n\t\t// If it's a function\n\t\tif ( jQuery.isFunction( params ) ) {\n\t\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\t\n\t\t// Otherwise, build a param string\n\t\t} else if ( params && typeof params === \"object\" ) {\n\t\t\ttype = \"POST\";\n\t\t}\n\t\n\t\t// If we have elements to modify, make the request\n\t\tif ( self.length > 0 ) {\n\t\t\tjQuery.ajax( {\n\t\t\t\turl: url,\n\t\n\t\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t\t// Make value of this field explicit since\n\t\t\t\t// user can override it through ajaxSetup method\n\t\t\t\ttype: type || \"GET\",\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t} ).done( function( responseText ) {\n\t\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\t\n\t\t\t\tself.html( selector ?\n\t\n\t\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\t\n\t\t\t\t\t// Otherwise use the full result\n\t\t\t\t\tresponseText );\n\t\n\t\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t\t// but they are ignored because response was set above.\n\t\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\t\tself.each( function() {\n\t\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\n\t\treturn this;\n\t};\n\t\n\t\n\t\n\t\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each( [\n\t\t\"ajaxStart\",\n\t\t\"ajaxStop\",\n\t\t\"ajaxComplete\",\n\t\t\"ajaxError\",\n\t\t\"ajaxSuccess\",\n\t\t\"ajaxSend\"\n\t], function( i, type ) {\n\t\tjQuery.fn[ type ] = function( fn ) {\n\t\t\treturn this.on( type, fn );\n\t\t};\n\t} );\n\t\n\t\n\t\n\t\n\tjQuery.expr.pseudos.animated = function( elem ) {\n\t\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t} ).length;\n\t};\n\t\n\t\n\t\n\t\n\t/**\n\t * Gets a window from an element\n\t */\n\tfunction getWindow( elem ) {\n\t\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n\t}\n\t\n\tjQuery.offset = {\n\t\tsetOffset: function( elem, options, i ) {\n\t\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\t\tcurElem = jQuery( elem ),\n\t\t\t\tprops = {};\n\t\n\t\t\t// Set position first, in-case top/left are set even on static elem\n\t\t\tif ( position === \"static\" ) {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\t\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\t\n\t\t\t// Need to be able to calculate position if either\n\t\t\t// top or left is auto and position is either absolute or fixed\n\t\t\tif ( calculatePosition ) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( options ) ) {\n\t\n\t\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t\t}\n\t\n\t\t\tif ( options.top != null ) {\n\t\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t\t}\n\t\t\tif ( options.left != null ) {\n\t\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t\t}\n\t\n\t\t\tif ( \"using\" in options ) {\n\t\t\t\toptions.using.call( elem, props );\n\t\n\t\t\t} else {\n\t\t\t\tcurElem.css( props );\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\toffset: function( options ) {\n\t\n\t\t\t// Preserve chaining for setter\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn options === undefined ?\n\t\t\t\t\tthis :\n\t\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tvar docElem, win, rect, doc,\n\t\t\t\telem = this[ 0 ];\n\t\n\t\t\tif ( !elem ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Support: IE <=11 only\n\t\t\t// Running getBoundingClientRect on a\n\t\t\t// disconnected node in IE throws an error\n\t\t\tif ( !elem.getClientRects().length ) {\n\t\t\t\treturn { top: 0, left: 0 };\n\t\t\t}\n\t\n\t\t\trect = elem.getBoundingClientRect();\n\t\n\t\t\t// Make sure element is not hidden (display: none)\n\t\t\tif ( rect.width || rect.height ) {\n\t\t\t\tdoc = elem.ownerDocument;\n\t\t\t\twin = getWindow( doc );\n\t\t\t\tdocElem = doc.documentElement;\n\t\n\t\t\t\treturn {\n\t\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\t\treturn rect;\n\t\t},\n\t\n\t\tposition: function() {\n\t\t\tif ( !this[ 0 ] ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar offsetParent, offset,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tparentOffset = { top: 0, left: 0 };\n\t\n\t\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t\t// because it is its only offset parent\n\t\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\n\t\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\t\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\t\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset = {\n\t\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Subtract parent offsets and element margins\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t\t};\n\t\t},\n\t\n\t\t// This method will return documentElement in the following cases:\n\t\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t\t//    documentElement of the parent window\n\t\t// 2) For the hidden or detached element\n\t\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t\t//\n\t\t// but those exceptions were never presented as a real life use-cases\n\t\t// and might be considered as more preferable results.\n\t\t//\n\t\t// This logic, however, is not guaranteed and can change at any point in the future\n\t\toffsetParent: function() {\n\t\t\treturn this.map( function() {\n\t\t\t\tvar offsetParent = this.offsetParent;\n\t\n\t\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\t\n\t\t\t\treturn offsetParent || documentElement;\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\t\tvar top = \"pageYOffset\" === prop;\n\t\n\t\tjQuery.fn[ method ] = function( val ) {\n\t\t\treturn access( this, function( elem, method, val ) {\n\t\t\t\tvar win = getWindow( elem );\n\t\n\t\t\t\tif ( val === undefined ) {\n\t\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t\t}\n\t\n\t\t\t\tif ( win ) {\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t\t);\n\t\n\t\t\t\t} else {\n\t\t\t\t\telem[ method ] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length );\n\t\t};\n\t} );\n\t\n\t// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n\t// getComputedStyle returns percent when specified for top/left/bottom/right;\n\t// rather than make the css module depend on the offset module, just check for it here\n\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\t\tfunction( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\n\t\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\tcomputed;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t} );\n\t\n\t\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\t\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\t\tfunction( defaultExtra, funcName ) {\n\t\n\t\t\t// Margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\t\n\t\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\t\tvar doc;\n\t\n\t\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\t\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn value === undefined ?\n\t\n\t\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\t\n\t\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t\t};\n\t\t} );\n\t} );\n\t\n\t\n\tjQuery.fn.extend( {\n\t\n\t\tbind: function( types, data, fn ) {\n\t\t\treturn this.on( types, null, data, fn );\n\t\t},\n\t\tunbind: function( types, fn ) {\n\t\t\treturn this.off( types, null, fn );\n\t\t},\n\t\n\t\tdelegate: function( selector, types, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn );\n\t\t},\n\t\tundelegate: function( selector, types, fn ) {\n\t\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ?\n\t\t\t\tthis.off( selector, \"**\" ) :\n\t\t\t\tthis.off( types, selector || \"**\", fn );\n\t\t}\n\t} );\n\t\n\tjQuery.parseJSON = JSON.parse;\n\t\n\t\n\t\n\t\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\t\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\t\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn jQuery;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t\n\t\n\t\n\t\n\tvar\n\t\n\t\t// Map over jQuery in case of overwrite\n\t\t_jQuery = window.jQuery,\n\t\n\t\t// Map over the $ in case of overwrite\n\t\t_$ = window.$;\n\t\n\tjQuery.noConflict = function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\t\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\t\n\t\treturn jQuery;\n\t};\n\t\n\t// Expose jQuery and $ identifiers, even in AMD\n\t// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif ( !noGlobal ) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\t\n\t\n\t\n\t\n\t\n\treturn jQuery;\n\t} );\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.THREE = global.THREE || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\t\t// Polyfills\n\t\n\t\tif ( Number.EPSILON === undefined ) {\n\t\n\t\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tif ( Math.sign === undefined ) {\n\t\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\t\n\t\t\tMath.sign = function ( x ) {\n\t\n\t\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tif ( Function.prototype.name === undefined ) {\n\t\n\t\t\t// Missing in IE9-11.\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\t\n\t\t\tObject.defineProperty( Function.prototype, 'name', {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tif ( Object.assign === undefined ) {\n\t\n\t\t\t// Missing in IE.\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t\n\t\t\t( function () {\n\t\n\t\t\t\tObject.assign = function ( target ) {\n\t\n\t\t\t\t\t'use strict';\n\t\n\t\t\t\t\tif ( target === undefined || target === null ) {\n\t\n\t\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar output = Object( target );\n\t\n\t\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\t\n\t\t\t\t\t\tvar source = arguments[ index ];\n\t\n\t\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\t\n\t\t\t\t\t\t\tfor ( var nextKey in source ) {\n\t\n\t\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\t\n\t\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn output;\n\t\n\t\t\t\t};\n\t\n\t\t\t} )();\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * https://github.com/mrdoob/eventdispatcher.js/\n\t\t */\n\t\n\t\tfunction EventDispatcher() {}\n\t\n\t\tObject.assign( EventDispatcher.prototype, {\n\t\n\t\t\taddEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\n\t\t\t\tif ( listeners[ type ] === undefined ) {\n\t\n\t\t\t\t\tlisteners[ type ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\t\n\t\t\t\t\tlisteners[ type ].push( listener );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\thasEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return false;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\n\t\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tremoveEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\t\t\tvar listenerArray = listeners[ type ];\n\t\n\t\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\t\tvar index = listenerArray.indexOf( listener );\n\t\n\t\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\t\tlistenerArray.splice( index, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tdispatchEvent: function ( event ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\t\t\tvar listenerArray = listeners[ event.type ];\n\t\n\t\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\t\tevent.target = this;\n\t\n\t\t\t\t\tvar array = [], i = 0;\n\t\t\t\t\tvar length = listenerArray.length;\n\t\n\t\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\t\tarray[ i ].call( this, event );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar REVISION = '82';\n\t\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\t\tvar CullFaceNone = 0;\n\t\tvar CullFaceBack = 1;\n\t\tvar CullFaceFront = 2;\n\t\tvar CullFaceFrontBack = 3;\n\t\tvar FrontFaceDirectionCW = 0;\n\t\tvar FrontFaceDirectionCCW = 1;\n\t\tvar BasicShadowMap = 0;\n\t\tvar PCFShadowMap = 1;\n\t\tvar PCFSoftShadowMap = 2;\n\t\tvar FrontSide = 0;\n\t\tvar BackSide = 1;\n\t\tvar DoubleSide = 2;\n\t\tvar FlatShading = 1;\n\t\tvar SmoothShading = 2;\n\t\tvar NoColors = 0;\n\t\tvar FaceColors = 1;\n\t\tvar VertexColors = 2;\n\t\tvar NoBlending = 0;\n\t\tvar NormalBlending = 1;\n\t\tvar AdditiveBlending = 2;\n\t\tvar SubtractiveBlending = 3;\n\t\tvar MultiplyBlending = 4;\n\t\tvar CustomBlending = 5;\n\t\tvar BlendingMode = {\n\t\t\tNoBlending: NoBlending,\n\t\t\tNormalBlending: NormalBlending,\n\t\t\tAdditiveBlending: AdditiveBlending,\n\t\t\tSubtractiveBlending: SubtractiveBlending,\n\t\t\tMultiplyBlending: MultiplyBlending,\n\t\t\tCustomBlending: CustomBlending\n\t\t};\n\t\tvar AddEquation = 100;\n\t\tvar SubtractEquation = 101;\n\t\tvar ReverseSubtractEquation = 102;\n\t\tvar MinEquation = 103;\n\t\tvar MaxEquation = 104;\n\t\tvar ZeroFactor = 200;\n\t\tvar OneFactor = 201;\n\t\tvar SrcColorFactor = 202;\n\t\tvar OneMinusSrcColorFactor = 203;\n\t\tvar SrcAlphaFactor = 204;\n\t\tvar OneMinusSrcAlphaFactor = 205;\n\t\tvar DstAlphaFactor = 206;\n\t\tvar OneMinusDstAlphaFactor = 207;\n\t\tvar DstColorFactor = 208;\n\t\tvar OneMinusDstColorFactor = 209;\n\t\tvar SrcAlphaSaturateFactor = 210;\n\t\tvar NeverDepth = 0;\n\t\tvar AlwaysDepth = 1;\n\t\tvar LessDepth = 2;\n\t\tvar LessEqualDepth = 3;\n\t\tvar EqualDepth = 4;\n\t\tvar GreaterEqualDepth = 5;\n\t\tvar GreaterDepth = 6;\n\t\tvar NotEqualDepth = 7;\n\t\tvar MultiplyOperation = 0;\n\t\tvar MixOperation = 1;\n\t\tvar AddOperation = 2;\n\t\tvar NoToneMapping = 0;\n\t\tvar LinearToneMapping = 1;\n\t\tvar ReinhardToneMapping = 2;\n\t\tvar Uncharted2ToneMapping = 3;\n\t\tvar CineonToneMapping = 4;\n\t\tvar UVMapping = 300;\n\t\tvar CubeReflectionMapping = 301;\n\t\tvar CubeRefractionMapping = 302;\n\t\tvar EquirectangularReflectionMapping = 303;\n\t\tvar EquirectangularRefractionMapping = 304;\n\t\tvar SphericalReflectionMapping = 305;\n\t\tvar CubeUVReflectionMapping = 306;\n\t\tvar CubeUVRefractionMapping = 307;\n\t\tvar TextureMapping = {\n\t\t\tUVMapping: UVMapping,\n\t\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t\t};\n\t\tvar RepeatWrapping = 1000;\n\t\tvar ClampToEdgeWrapping = 1001;\n\t\tvar MirroredRepeatWrapping = 1002;\n\t\tvar TextureWrapping = {\n\t\t\tRepeatWrapping: RepeatWrapping,\n\t\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t\t};\n\t\tvar NearestFilter = 1003;\n\t\tvar NearestMipMapNearestFilter = 1004;\n\t\tvar NearestMipMapLinearFilter = 1005;\n\t\tvar LinearFilter = 1006;\n\t\tvar LinearMipMapNearestFilter = 1007;\n\t\tvar LinearMipMapLinearFilter = 1008;\n\t\tvar TextureFilter = {\n\t\t\tNearestFilter: NearestFilter,\n\t\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\t\tLinearFilter: LinearFilter,\n\t\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t\t};\n\t\tvar UnsignedByteType = 1009;\n\t\tvar ByteType = 1010;\n\t\tvar ShortType = 1011;\n\t\tvar UnsignedShortType = 1012;\n\t\tvar IntType = 1013;\n\t\tvar UnsignedIntType = 1014;\n\t\tvar FloatType = 1015;\n\t\tvar HalfFloatType = 1016;\n\t\tvar UnsignedShort4444Type = 1017;\n\t\tvar UnsignedShort5551Type = 1018;\n\t\tvar UnsignedShort565Type = 1019;\n\t\tvar UnsignedInt248Type = 1020;\n\t\tvar AlphaFormat = 1021;\n\t\tvar RGBFormat = 1022;\n\t\tvar RGBAFormat = 1023;\n\t\tvar LuminanceFormat = 1024;\n\t\tvar LuminanceAlphaFormat = 1025;\n\t\tvar RGBEFormat = RGBAFormat;\n\t\tvar DepthFormat = 1026;\n\t\tvar DepthStencilFormat = 1027;\n\t\tvar RGB_S3TC_DXT1_Format = 2001;\n\t\tvar RGBA_S3TC_DXT1_Format = 2002;\n\t\tvar RGBA_S3TC_DXT3_Format = 2003;\n\t\tvar RGBA_S3TC_DXT5_Format = 2004;\n\t\tvar RGB_PVRTC_4BPPV1_Format = 2100;\n\t\tvar RGB_PVRTC_2BPPV1_Format = 2101;\n\t\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\n\t\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\n\t\tvar RGB_ETC1_Format = 2151;\n\t\tvar LoopOnce = 2200;\n\t\tvar LoopRepeat = 2201;\n\t\tvar LoopPingPong = 2202;\n\t\tvar InterpolateDiscrete = 2300;\n\t\tvar InterpolateLinear = 2301;\n\t\tvar InterpolateSmooth = 2302;\n\t\tvar ZeroCurvatureEnding = 2400;\n\t\tvar ZeroSlopeEnding = 2401;\n\t\tvar WrapAroundEnding = 2402;\n\t\tvar TrianglesDrawMode = 0;\n\t\tvar TriangleStripDrawMode = 1;\n\t\tvar TriangleFanDrawMode = 2;\n\t\tvar LinearEncoding = 3000;\n\t\tvar sRGBEncoding = 3001;\n\t\tvar GammaEncoding = 3007;\n\t\tvar RGBEEncoding = 3002;\n\t\tvar LogLuvEncoding = 3003;\n\t\tvar RGBM7Encoding = 3004;\n\t\tvar RGBM16Encoding = 3005;\n\t\tvar RGBDEncoding = 3006;\n\t\tvar BasicDepthPacking = 3200;\n\t\tvar RGBADepthPacking = 3201;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar _Math = {\n\t\n\t\t\tDEG2RAD: Math.PI / 180,\n\t\t\tRAD2DEG: 180 / Math.PI,\n\t\n\t\t\tgenerateUUID: function () {\n\t\n\t\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\t\n\t\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\t\tvar uuid = new Array( 36 );\n\t\t\t\tvar rnd = 0, r;\n\t\n\t\t\t\treturn function generateUUID() {\n\t\n\t\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\t\n\t\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\t\n\t\t\t\t\t\t\tuuid[ i ] = '-';\n\t\n\t\t\t\t\t\t} else if ( i === 14 ) {\n\t\n\t\t\t\t\t\t\tuuid[ i ] = '4';\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn uuid.join( '' );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclamp: function ( value, min, max ) {\n\t\n\t\t\t\treturn Math.max( min, Math.min( max, value ) );\n\t\n\t\t\t},\n\t\n\t\t\t// compute euclidian modulo of m % n\n\t\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\t\n\t\t\teuclideanModulo: function ( n, m ) {\n\t\n\t\t\t\treturn ( ( n % m ) + m ) % m;\n\t\n\t\t\t},\n\t\n\t\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\t\n\t\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\t\n\t\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\t\n\t\t\t},\n\t\n\t\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\t\n\t\t\tlerp: function ( x, y, t ) {\n\t\n\t\t\t\treturn ( 1 - t ) * x + t * y;\n\t\n\t\t\t},\n\t\n\t\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\t\n\t\t\tsmoothstep: function ( x, min, max ) {\n\t\n\t\t\t\tif ( x <= min ) return 0;\n\t\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\t\treturn x * x * ( 3 - 2 * x );\n\t\n\t\t\t},\n\t\n\t\t\tsmootherstep: function ( x, min, max ) {\n\t\n\t\t\t\tif ( x <= min ) return 0;\n\t\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\t\n\t\t\t},\n\t\n\t\t\trandom16: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\t\treturn Math.random();\n\t\n\t\t\t},\n\t\n\t\t\t// Random integer from <low, high> interval\n\t\n\t\t\trandInt: function ( low, high ) {\n\t\n\t\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\t\n\t\t\t},\n\t\n\t\t\t// Random float from <low, high> interval\n\t\n\t\t\trandFloat: function ( low, high ) {\n\t\n\t\t\t\treturn low + Math.random() * ( high - low );\n\t\n\t\t\t},\n\t\n\t\t\t// Random float from <-range/2, range/2> interval\n\t\n\t\t\trandFloatSpread: function ( range ) {\n\t\n\t\t\t\treturn range * ( 0.5 - Math.random() );\n\t\n\t\t\t},\n\t\n\t\t\tdegToRad: function ( degrees ) {\n\t\n\t\t\t\treturn degrees * _Math.DEG2RAD;\n\t\n\t\t\t},\n\t\n\t\t\tradToDeg: function ( radians ) {\n\t\n\t\t\t\treturn radians * _Math.RAD2DEG;\n\t\n\t\t\t},\n\t\n\t\t\tisPowerOfTwo: function ( value ) {\n\t\n\t\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\t\n\t\t\t},\n\t\n\t\t\tnearestPowerOfTwo: function ( value ) {\n\t\n\t\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\t\n\t\t\t},\n\t\n\t\t\tnextPowerOfTwo: function ( value ) {\n\t\n\t\t\t\tvalue --;\n\t\t\t\tvalue |= value >> 1;\n\t\t\t\tvalue |= value >> 2;\n\t\t\t\tvalue |= value >> 4;\n\t\t\t\tvalue |= value >> 8;\n\t\t\t\tvalue |= value >> 16;\n\t\t\t\tvalue ++;\n\t\n\t\t\t\treturn value;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tfunction Vector2( x, y ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\n\t\t}\n\t\n\t\tVector2.prototype = {\n\t\n\t\t\tconstructor: Vector2,\n\t\n\t\t\tisVector2: true,\n\t\n\t\t\tget width() {\n\t\n\t\t\t\treturn this.x;\n\t\n\t\t\t},\n\t\n\t\t\tset width( value ) {\n\t\n\t\t\t\tthis.x = value;\n\t\n\t\t\t},\n\t\n\t\t\tget height() {\n\t\n\t\t\t\treturn this.y;\n\t\n\t\t\t},\n\t\n\t\t\tset height( value ) {\n\t\n\t\t\t\tthis.y = value;\n\t\n\t\t\t},\n\t\n\t\t\t//\n\t\n\t\t\tset: function ( x, y ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( v ) {\n\t\n\t\t\t\tthis.x *= v.x;\n\t\t\t\tthis.y *= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\tthis.y *= scalar;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t\tthis.y = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivide: function ( v ) {\n\t\n\t\t\t\tthis.x /= v.x;\n\t\t\t\tthis.y /= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector2();\n\t\t\t\t\t\tmax = new Vector2();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclampLength: function ( min, max ) {\n\t\n\t\t\t\tvar length = this.length();\n\t\n\t\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t\t},\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\t\n\t\t\t},\n\t\n\t\t\tlengthManhattan: function() {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tangle: function () {\n\t\n\t\t\t\t// computes the angle in radians with respect to the positive x-axis\n\t\n\t\t\t\tvar angle = Math.atan2( this.y, this.x );\n\t\n\t\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\t\n\t\t\t\treturn angle;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\t\treturn dx * dx + dy * dy;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\t\tthis.x = attribute.array[ index ];\n\t\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateAround: function ( center, angle ) {\n\t\n\t\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\t\n\t\t\t\tvar x = this.x - center.x;\n\t\t\t\tvar y = this.y - center.y;\n\t\n\t\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\t\tthis.y = x * s + y * c + center.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author szimek / https://github.com/szimek/\n\t\t */\n\t\n\t\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: TextureIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.sourceFile = '';\n\t\n\t\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\t\tthis.mipmaps = [];\n\t\n\t\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\t\n\t\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\t\n\t\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\t\n\t\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\t\n\t\t\tthis.offset = new Vector2( 0, 0 );\n\t\t\tthis.repeat = new Vector2( 1, 1 );\n\t\n\t\t\tthis.generateMipmaps = true;\n\t\t\tthis.premultiplyAlpha = false;\n\t\t\tthis.flipY = true;\n\t\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\t\n\t\n\t\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t\t//\n\t\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\t\tthis.encoding = encoding !== undefined ? encoding :  LinearEncoding;\n\t\n\t\t\tthis.version = 0;\n\t\t\tthis.onUpdate = null;\n\t\n\t\t}\n\t\n\t\tTexture.DEFAULT_IMAGE = undefined;\n\t\tTexture.DEFAULT_MAPPING = UVMapping;\n\t\n\t\tTexture.prototype = {\n\t\n\t\t\tconstructor: Texture,\n\t\n\t\t\tisTexture: true,\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.image = source.image;\n\t\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\t\n\t\t\t\tthis.mapping = source.mapping;\n\t\n\t\t\t\tthis.wrapS = source.wrapS;\n\t\t\t\tthis.wrapT = source.wrapT;\n\t\n\t\t\t\tthis.magFilter = source.magFilter;\n\t\t\t\tthis.minFilter = source.minFilter;\n\t\n\t\t\t\tthis.anisotropy = source.anisotropy;\n\t\n\t\t\t\tthis.format = source.format;\n\t\t\t\tthis.type = source.type;\n\t\n\t\t\t\tthis.offset.copy( source.offset );\n\t\t\t\tthis.repeat.copy( source.repeat );\n\t\n\t\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\t\tthis.flipY = source.flipY;\n\t\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\t\tthis.encoding = source.encoding;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\t\n\t\t\t\t\treturn meta.textures[ this.uuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getDataURL( image ) {\n\t\n\t\t\t\t\tvar canvas;\n\t\n\t\t\t\t\tif ( image.toDataURL !== undefined ) {\n\t\n\t\t\t\t\t\tcanvas = image;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\t\tcanvas.height = image.height;\n\t\n\t\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\t\n\t\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar output = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t\t},\n\t\n\t\t\t\t\tuuid: this.uuid,\n\t\t\t\t\tname: this.name,\n\t\n\t\t\t\t\tmapping: this.mapping,\n\t\n\t\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\t\n\t\t\t\t\tminFilter: this.minFilter,\n\t\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\t\tanisotropy: this.anisotropy,\n\t\n\t\t\t\t\tflipY: this.flipY\n\t\t\t\t};\n\t\n\t\t\t\tif ( this.image !== undefined ) {\n\t\n\t\t\t\t\t// TODO: Move to THREE.Image\n\t\n\t\t\t\t\tvar image = this.image;\n\t\n\t\t\t\t\tif ( image.uuid === undefined ) {\n\t\n\t\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toutput.image = image.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmeta.textures[ this.uuid ] = output;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t},\n\t\n\t\t\ttransformUv: function ( uv ) {\n\t\n\t\t\t\tif ( this.mapping !== UVMapping )  return;\n\t\n\t\t\t\tuv.multiply( this.repeat );\n\t\t\t\tuv.add( this.offset );\n\t\n\t\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\t\n\t\t\t\t\tswitch ( this.wrapS ) {\n\t\n\t\t\t\t\t\tcase RepeatWrapping:\n\t\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\t\n\t\t\t\t\tswitch ( this.wrapT ) {\n\t\n\t\t\t\t\t\tcase RepeatWrapping:\n\t\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.flipY ) {\n\t\n\t\t\t\t\tuv.y = 1 - uv.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Texture.prototype, EventDispatcher.prototype );\n\t\n\t\tvar count = 0;\n\t\tfunction TextureIdCount() { return count++; }\n\t\n\t\t/**\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Vector4( x, y, z, w ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t\tthis.z = z || 0;\n\t\t\tthis.w = ( w !== undefined ) ? w : 1;\n\t\n\t\t}\n\t\n\t\tVector4.prototype = {\n\t\n\t\t\tconstructor: Vector4,\n\t\n\t\t\tisVector4: true,\n\t\n\t\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\t\t\tthis.w = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\t\t\tthis.z = scalar;\n\t\t\t\tthis.w = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( z ) {\n\t\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( w ) {\n\t\n\t\t\t\tthis.w = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tcase 2: return this.z;\n\t\t\t\t\tcase 3: return this.w;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\t\t\tthis.z = v.z;\n\t\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\t\t\tthis.z += v.z;\n\t\t\t\tthis.w += v.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\t\t\tthis.z += s;\n\t\t\t\tthis.w += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\tthis.z = a.z + b.z;\n\t\t\t\tthis.w = a.w + b.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\t\t\tthis.z += v.z * s;\n\t\t\t\tthis.w += v.w * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\t\t\tthis.z -= v.z;\n\t\t\t\tthis.w -= v.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\t\t\tthis.z -= s;\n\t\t\t\tthis.w -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\tthis.z = a.z - b.z;\n\t\t\t\tthis.w = a.w - b.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\tthis.y *= scalar;\n\t\t\t\t\tthis.z *= scalar;\n\t\t\t\t\tthis.w *= scalar;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t\tthis.z = 0;\n\t\t\t\t\tthis.w = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t\n\t\t\t\t// q is assumed to be normalized\n\t\n\t\t\t\tthis.w = 2 * Math.acos( q.w );\n\t\n\t\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\t\n\t\t\t\tif ( s < 0.0001 ) {\n\t\n\t\t\t\t\t this.x = 1;\n\t\t\t\t\t this.y = 0;\n\t\t\t\t\t this.z = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t this.x = q.x / s;\n\t\t\t\t\t this.y = q.y / s;\n\t\t\t\t\t this.z = q.z / s;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\t\n\t\t\t\t\tte = m.elements,\n\t\n\t\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\t\n\t\t\t\t\t// singularity found\n\t\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t\t// in leading diagonal and zero in other terms\n\t\n\t\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\t\n\t\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\t\n\t\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// otherwise this singularity is angle = 180\n\t\n\t\t\t\t\tangle = Math.PI;\n\t\n\t\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\t\n\t\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\t\n\t\t\t\t\t\t// m11 is the largest diagonal term\n\t\n\t\t\t\t\t\tif ( xx < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\t\tz = xz / x;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( yy > zz ) {\n\t\n\t\t\t\t\t\t// m22 is the largest diagonal term\n\t\n\t\t\t\t\t\tif ( yy < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\t\tz = yz / y;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\t\n\t\t\t\t\t\tif ( zz < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\tz = 0;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\t\ty = yz / z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.set( x, y, z, angle );\n\t\n\t\t\t\t\treturn this; // return 180 deg rotation\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// as we have reached here there are no singularities so we can handle normally\n\t\n\t\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\t\n\t\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\t\n\t\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t\t// caught by singularity test above, but I've left it in just in case\n\t\n\t\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\t\tthis.w = Math.min( this.w, v.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\t\tthis.w = Math.max( this.w, v.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\t\tmax = new Vector4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\t\t\tthis.z = Math.floor( this.z );\n\t\t\t\tthis.w = Math.floor( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\t\t\tthis.z = Math.ceil( this.z );\n\t\t\t\tthis.w = Math.ceil( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\t\t\tthis.z = Math.round( this.z );\n\t\t\t\tthis.w = Math.round( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\t\t\tthis.z = - this.z;\n\t\t\t\tthis.w = - this.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\t\n\t\t\t},\n\t\n\t\t\tlengthManhattan: function () {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\t\t\tthis.z = array[ offset + 2 ];\n\t\t\t\tthis.w = array[ offset + 3 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\t\tarray[ offset + 3 ] = this.w;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\t\tthis.x = attribute.array[ index ];\n\t\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\t\tthis.w = attribute.array[ index + 3 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author szimek / https://github.com/szimek/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author Marius Kintel / https://github.com/kintel\n\t\t */\n\t\n\t\t/*\n\t\t In options, we can specify:\n\t\t * Texture parameters for an auto-generated target texture\n\t\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t\t*/\n\t\tfunction WebGLRenderTarget( width, height, options ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\n\t\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\t\tthis.scissorTest = false;\n\t\n\t\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\t\n\t\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\t\n\t\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\t\n\t\t}\n\t\n\t\tObject.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisWebGLRenderTarget: true,\n\t\n\t\t\tsetSize: function ( width, height ) {\n\t\n\t\t\t\tif ( this.width !== width || this.height !== height ) {\n\t\n\t\t\t\t\tthis.width = width;\n\t\t\t\t\tthis.height = height;\n\t\n\t\t\t\t\tthis.dispose();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\t\tthis.scissor.set( 0, 0, width, height );\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.width = source.width;\n\t\t\t\tthis.height = source.height;\n\t\n\t\t\t\tthis.viewport.copy( source.viewport );\n\t\n\t\t\t\tthis.texture = source.texture.clone();\n\t\n\t\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\t\tthis.depthTexture = source.depthTexture;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com\n\t\t */\n\t\n\t\tfunction WebGLRenderTargetCube( width, height, options ) {\n\t\n\t\t\tWebGLRenderTarget.call( this, width, height, options );\n\t\n\t\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\t\tthis.activeMipMapLevel = 0;\n\t\n\t\t}\n\t\n\t\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\t\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\t\n\t\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Quaternion( x, y, z, w ) {\n\t\n\t\t\tthis._x = x || 0;\n\t\t\tthis._y = y || 0;\n\t\t\tthis._z = z || 0;\n\t\t\tthis._w = ( w !== undefined ) ? w : 1;\n\t\n\t\t}\n\t\n\t\tQuaternion.prototype = {\n\t\n\t\t\tconstructor: Quaternion,\n\t\n\t\t\tget x () {\n\t\n\t\t\t\treturn this._x;\n\t\n\t\t\t},\n\t\n\t\t\tset x ( value ) {\n\t\n\t\t\t\tthis._x = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget y () {\n\t\n\t\t\t\treturn this._y;\n\t\n\t\t\t},\n\t\n\t\t\tset y ( value ) {\n\t\n\t\t\t\tthis._y = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget z () {\n\t\n\t\t\t\treturn this._z;\n\t\n\t\t\t},\n\t\n\t\t\tset z ( value ) {\n\t\n\t\t\t\tthis._z = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget w () {\n\t\n\t\t\t\treturn this._w;\n\t\n\t\t\t},\n\t\n\t\t\tset w ( value ) {\n\t\n\t\t\t\tthis._w = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\tthis._w = w;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( quaternion ) {\n\t\n\t\t\t\tthis._x = quaternion.x;\n\t\t\t\tthis._y = quaternion.y;\n\t\t\t\tthis._z = quaternion.z;\n\t\t\t\tthis._w = quaternion.w;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromEuler: function ( euler, update ) {\n\t\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\t\n\t\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t\t//\tcontent/SpinCalc.m\n\t\n\t\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\t\n\t\t\t\tvar order = euler.order;\n\t\n\t\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\n\t\t\t\t// assumes axis is normalized\n\t\n\t\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\t\n\t\t\t\tthis._x = axis.x * s;\n\t\t\t\tthis._y = axis.y * s;\n\t\t\t\tthis._z = axis.z * s;\n\t\t\t\tthis._w = Math.cos( halfAngle );\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromRotationMatrix: function ( m ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar te = m.elements,\n\t\n\t\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\t\n\t\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\t\ts;\n\t\n\t\t\t\tif ( trace > 0 ) {\n\t\n\t\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\t\n\t\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\t\n\t\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\t\n\t\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\t\n\t\t\t\t} else if ( m22 > m33 ) {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\t\n\t\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\t\n\t\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\t\tthis._z = 0.25 * s;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromUnitVectors: function () {\n\t\n\t\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\t\n\t\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\t\n\t\t\t\tvar v1, r;\n\t\n\t\t\t\tvar EPS = 0.000001;\n\t\n\t\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\t\n\t\t\t\t\tif ( r < EPS ) {\n\t\n\t\t\t\t\t\tr = 0;\n\t\n\t\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\t\n\t\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._x = v1.x;\n\t\t\t\t\tthis._y = v1.y;\n\t\t\t\t\tthis._z = v1.z;\n\t\t\t\t\tthis._w = r;\n\t\n\t\t\t\t\treturn this.normalize();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tinverse: function () {\n\t\n\t\t\t\treturn this.conjugate().normalize();\n\t\n\t\t\t},\n\t\n\t\t\tconjugate: function () {\n\t\n\t\t\t\tthis._x *= - 1;\n\t\t\t\tthis._y *= - 1;\n\t\t\t\tthis._z *= - 1;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\tvar l = this.length();\n\t\n\t\t\t\tif ( l === 0 ) {\n\t\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = 0;\n\t\t\t\t\tthis._w = 1;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tl = 1 / l;\n\t\n\t\t\t\t\tthis._x = this._x * l;\n\t\t\t\t\tthis._y = this._y * l;\n\t\t\t\t\tthis._z = this._z * l;\n\t\t\t\t\tthis._w = this._w * l;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( q, p ) {\n\t\n\t\t\t\tif ( p !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyQuaternions( q, p );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.multiplyQuaternions( this, q );\n\t\n\t\t\t},\n\t\n\t\t\tpremultiply: function ( q ) {\n\t\n\t\t\t\treturn this.multiplyQuaternions( q, this );\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyQuaternions: function ( a, b ) {\n\t\n\t\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\n\t\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\t\n\t\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tslerp: function ( qb, t ) {\n\t\n\t\t\t\tif ( t === 0 ) return this;\n\t\t\t\tif ( t === 1 ) return this.copy( qb );\n\t\n\t\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\t\n\t\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\t\n\t\t\t\tif ( cosHalfTheta < 0 ) {\n\t\n\t\t\t\t\tthis._w = - qb._w;\n\t\t\t\t\tthis._x = - qb._x;\n\t\t\t\t\tthis._y = - qb._y;\n\t\t\t\t\tthis._z = - qb._z;\n\t\n\t\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.copy( qb );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\t\n\t\t\t\t\tthis._w = w;\n\t\t\t\t\tthis._x = x;\n\t\t\t\t\tthis._y = y;\n\t\t\t\t\tthis._z = z;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\t\n\t\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\t\n\t\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\t\n\t\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( quaternion ) {\n\t\n\t\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis._x = array[ offset ];\n\t\t\t\tthis._y = array[ offset + 1 ];\n\t\t\t\tthis._z = array[ offset + 2 ];\n\t\t\t\tthis._w = array[ offset + 3 ];\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this._x;\n\t\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\t\tarray[ offset + 3 ] = this._w;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tonChange: function ( callback ) {\n\t\n\t\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tonChangeCallback: function () {}\n\t\n\t\t};\n\t\n\t\tObject.assign( Quaternion, {\n\t\n\t\t\tslerp: function( qa, qb, qm, t ) {\n\t\n\t\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\t\n\t\t\t},\n\t\n\t\t\tslerpFlat: function(\n\t\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\t\n\t\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\t\n\t\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\t\n\t\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\t\n\t\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\t\n\t\t\t\t\tvar s = 1 - t,\n\t\n\t\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\n\t\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\t\tsqrSin = 1 - cos * cos;\n\t\n\t\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\t\n\t\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar tDir = t * dir;\n\t\n\t\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\t\tw0 = w0 * s + w1 * tDir;\n\t\n\t\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\t\tif ( s === 1 - t ) {\n\t\n\t\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\t\n\t\t\t\t\t\tx0 *= f;\n\t\t\t\t\t\ty0 *= f;\n\t\t\t\t\t\tz0 *= f;\n\t\t\t\t\t\tw0 *= f;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdst[ dstOffset ] = x0;\n\t\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author *kile / http://kile.stravaganza.org/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Vector3( x, y, z ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t\tthis.z = z || 0;\n\t\n\t\t}\n\t\n\t\tVector3.prototype = {\n\t\n\t\t\tconstructor: Vector3,\n\t\n\t\t\tisVector3: true,\n\t\n\t\t\tset: function ( x, y, z ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\t\t\tthis.z = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( z ) {\n\t\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tcase 2: return this.z;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\t\t\tthis.z = v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\t\t\tthis.z += v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\t\t\tthis.z += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\tthis.z = a.z + b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\t\t\tthis.z += v.z * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\t\t\tthis.z -= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\t\t\tthis.z -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\tthis.z = a.z - b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x *= v.x;\n\t\t\t\tthis.y *= v.y;\n\t\t\t\tthis.z *= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\tthis.y *= scalar;\n\t\t\t\t\tthis.z *= scalar;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t\tthis.z = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x * b.x;\n\t\t\t\tthis.y = a.y * b.y;\n\t\t\t\tthis.z = a.z * b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyEuler: function () {\n\t\n\t\t\t\tvar quaternion;\n\t\n\t\t\t\treturn function applyEuler( euler ) {\n\t\n\t\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\t\n\t\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyAxisAngle: function () {\n\t\n\t\t\t\tvar quaternion;\n\t\n\t\t\t\treturn function applyAxisAngle( axis, angle ) {\n\t\n\t\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\t\n\t\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyMatrix3: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 affine matrix\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyProjection: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 projection matrix\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\t\n\t\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyQuaternion: function ( q ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\t\n\t\t\t\t// calculate quat * vector\n\t\n\t\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\t\n\t\t\t\t// calculate result * inverse quat\n\t\n\t\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tproject: function () {\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\treturn function project( camera ) {\n\t\n\t\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\t\n\t\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tunproject: function () {\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\treturn function unproject( camera ) {\n\t\n\t\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\t\n\t\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttransformDirection: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t\t// vector interpreted as a direction\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\t\n\t\t\t\treturn this.normalize();\n\t\n\t\t\t},\n\t\n\t\t\tdivide: function ( v ) {\n\t\n\t\t\t\tthis.x /= v.x;\n\t\t\t\tthis.y /= v.y;\n\t\t\t\tthis.z /= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\t\tthis.z = Math.min( this.z, v.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\t\tthis.z = Math.max( this.z, v.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector3();\n\t\t\t\t\t\tmax = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclampLength: function ( min, max ) {\n\t\n\t\t\t\tvar length = this.length();\n\t\n\t\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t\t},\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\t\t\tthis.z = Math.floor( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\t\t\tthis.z = Math.ceil( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\t\t\tthis.z = Math.round( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\t\t\tthis.z = - this.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\t\n\t\t\t},\n\t\n\t\t\tlengthManhattan: function () {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tcross: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.crossVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\n\t\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\t\tthis.z = x * v.y - y * v.x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcrossVectors: function ( a, b ) {\n\t\n\t\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\t\n\t\t\t\tthis.x = ay * bz - az * by;\n\t\t\t\tthis.y = az * bx - ax * bz;\n\t\t\t\tthis.z = ax * by - ay * bx;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tprojectOnVector: function ( vector ) {\n\t\n\t\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t\t\t},\n\t\n\t\t\tprojectOnPlane: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function projectOnPlane( planeNormal ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\t\n\t\t\t\t\treturn this.sub( v1 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\treflect: function () {\n\t\n\t\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t\t// normal is assumed to have unit length\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function reflect( normal ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tangleTo: function ( v ) {\n\t\n\t\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\t\n\t\t\t\t// clamp, to handle numerical problems\n\t\n\t\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\t\n\t\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromSpherical: function( s ) {\n\t\n\t\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\t\n\t\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixPosition: function ( m ) {\n\t\n\t\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixScale: function ( m ) {\n\t\n\t\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\tthis.x = sx;\n\t\t\t\tthis.y = sy;\n\t\t\t\tthis.z = sz;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixColumn: function ( m, index ) {\n\t\n\t\t\t\tif ( typeof m === 'number' ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\t\tvar temp = m;\n\t\t\t\t\tm = index;\n\t\t\t\t\tindex = temp;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.fromArray( m.elements, index * 4 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\t\t\tthis.z = array[ offset + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\t\tarray[ offset + 2 ] = this.z;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\t\tthis.x = attribute.array[ index ];\n\t\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author jordi_ros / http://plattsoft.com\n\t\t * @author D1plo1d / http://github.com/D1plo1d\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author timknip / http://www.floorplanner.com/\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Matrix4() {\n\t\n\t\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t] );\n\t\n\t\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tMatrix4.prototype = {\n\t\n\t\t\tconstructor: Matrix4,\n\t\n\t\t\tisMatrix4: true,\n\t\n\t\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tidentity: function () {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0, 0,\n\t\t\t\t\t0, 1, 0, 0,\n\t\t\t\t\t0, 0, 1, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new Matrix4().fromArray( this.elements );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( m ) {\n\t\n\t\t\t\tthis.elements.set( m.elements );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyPosition: function ( m ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\t\tte[ 14 ] = me[ 14 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\t\tthis.set(\n\t\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t\t0,       0,       0,       1\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\textractRotation: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function extractRotation( m ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\n\t\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\n\t\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmakeRotationFromEuler: function ( euler ) {\n\t\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\t\n\t\t\t\tif ( euler.order === 'XYZ' ) {\n\t\n\t\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\t\tte[ 8 ] = d;\n\t\n\t\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\t\tte[ 9 ] = - b * c;\n\t\n\t\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'YXZ' ) {\n\t\n\t\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\t\tte[ 8 ] = a * d;\n\t\n\t\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = - b;\n\t\n\t\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'ZXY' ) {\n\t\n\t\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\t\tte[ 8 ] = de + cf * b;\n\t\n\t\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = df - ce * b;\n\t\n\t\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\t\tte[ 6 ] = b;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'ZYX' ) {\n\t\n\t\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\t\tte[ 8 ] = ae * d + bf;\n\t\n\t\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\t\tte[ 9 ] = af * d - be;\n\t\n\t\t\t\t\tte[ 2 ] = - d;\n\t\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'YZX' ) {\n\t\n\t\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\t\tte[ 8 ] = bc * f + ad;\n\t\n\t\t\t\t\tte[ 1 ] = f;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = - b * e;\n\t\n\t\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\t\tte[ 10 ] = ac - bd * f;\n\t\n\t\t\t\t} else if ( euler.order === 'XZY' ) {\n\t\n\t\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = - f;\n\t\t\t\t\tte[ 8 ] = d * e;\n\t\n\t\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = ad * f - bc;\n\t\n\t\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\t\tte[ 10 ] = bd * f + ac;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// last column\n\t\t\t\tte[ 3 ] = 0;\n\t\t\t\tte[ 7 ] = 0;\n\t\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t\t// bottom row\n\t\t\t\tte[ 12 ] = 0;\n\t\t\t\tte[ 13 ] = 0;\n\t\t\t\tte[ 14 ] = 0;\n\t\t\t\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\t\n\t\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\t\tte[ 4 ] = xy - wz;\n\t\t\t\tte[ 8 ] = xz + wy;\n\t\n\t\t\t\tte[ 1 ] = xy + wz;\n\t\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\t\tte[ 9 ] = yz - wx;\n\t\n\t\t\t\tte[ 2 ] = xz - wy;\n\t\t\t\tte[ 6 ] = yz + wx;\n\t\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\t\n\t\t\t\t// last column\n\t\t\t\tte[ 3 ] = 0;\n\t\t\t\tte[ 7 ] = 0;\n\t\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t\t// bottom row\n\t\t\t\tte[ 12 ] = 0;\n\t\t\t\tte[ 13 ] = 0;\n\t\t\t\tte[ 14 ] = 0;\n\t\t\t\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar x, y, z;\n\t\n\t\t\t\treturn function lookAt( eye, target, up ) {\n\t\n\t\t\t\t\tif ( x === undefined ) {\n\t\n\t\t\t\t\t\tx = new Vector3();\n\t\t\t\t\t\ty = new Vector3();\n\t\t\t\t\t\tz = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\t\tz.subVectors( eye, target ).normalize();\n\t\n\t\t\t\t\tif ( z.lengthSq() === 0 ) {\n\t\n\t\t\t\t\t\tz.z = 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\t\tif ( x.lengthSq() === 0 ) {\n\t\n\t\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ty.crossVectors( z, x );\n\t\n\t\n\t\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmultiply: function ( m, n ) {\n\t\n\t\t\t\tif ( n !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyMatrices( m, n );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.multiplyMatrices( this, m );\n\t\n\t\t\t},\n\t\n\t\t\tpremultiply: function ( m ) {\n\t\n\t\t\t\treturn this.multiplyMatrices( m, this );\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyMatrices: function ( a, b ) {\n\t\n\t\t\t\tvar ae = a.elements;\n\t\t\t\tvar be = b.elements;\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\t\n\t\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\t\n\t\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\t\n\t\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\t\n\t\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\t\n\t\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyToArray: function ( a, b, r ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tthis.multiplyMatrices( a, b );\n\t\n\t\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyToVector3Array: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn array;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyToBuffer: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\t\tv1.applyMatrix4( this );\n\t\n\t\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn buffer;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tdeterminant: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\t\n\t\t\t\t//TODO: make this more efficient\n\t\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\t\n\t\t\t\treturn (\n\t\t\t\t\tn41 * (\n\t\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t\t) +\n\t\t\t\t\tn42 * (\n\t\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t\t) +\n\t\t\t\t\tn43 * (\n\t\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t\t) +\n\t\t\t\t\tn44 * (\n\t\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t\t)\n\t\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\ttranspose: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar tmp;\n\t\n\t\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\t\n\t\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\t\treturn this.toArray( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tgetPosition: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function getPosition() {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\t\n\t\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetPosition: function ( v ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 12 ] = v.x;\n\t\t\t\tte[ 13 ] = v.y;\n\t\t\t\tte[ 14 ] = v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\t\n\t\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\t\tvar te = this.elements,\n\t\t\t\t\tme = m.elements,\n\t\n\t\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\t\n\t\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\t\n\t\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\t\n\t\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\t\tif ( throwOnDegenerate === true ) {\n\t\n\t\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this.identity();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar detInv = 1 / det;\n\t\n\t\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tscale: function ( v ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar x = v.x, y = v.y, z = v.z;\n\t\n\t\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetMaxScaleOnAxis: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\t\n\t\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\t\n\t\t\t},\n\t\n\t\t\tmakeTranslation: function ( x, y, z ) {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0, x,\n\t\t\t\t\t0, 1, 0, y,\n\t\t\t\t\t0, 0, 1, z,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationX: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0,  0, 0,\n\t\t\t\t\t0, c, - s, 0,\n\t\t\t\t\t0, s,  c, 0,\n\t\t\t\t\t0, 0,  0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationY: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t c, 0, s, 0,\n\t\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t\t- s, 0, c, 0,\n\t\t\t\t\t 0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationZ: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tc, - s, 0, 0,\n\t\t\t\t\ts,  c, 0, 0,\n\t\t\t\t\t0,  0, 1, 0,\n\t\t\t\t\t0,  0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationAxis: function ( axis, angle ) {\n\t\n\t\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\t\n\t\t\t\tvar c = Math.cos( angle );\n\t\t\t\tvar s = Math.sin( angle );\n\t\t\t\tvar t = 1 - c;\n\t\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\t\tvar tx = t * x, ty = t * y;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\t return this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeScale: function ( x, y, z ) {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tx, 0, 0, 0,\n\t\t\t\t\t0, y, 0, 0,\n\t\t\t\t\t0, 0, z, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcompose: function ( position, quaternion, scale ) {\n\t\n\t\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\t\tthis.scale( scale );\n\t\t\t\tthis.setPosition( position );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdecompose: function () {\n\t\n\t\t\t\tvar vector, matrix;\n\t\n\t\t\t\treturn function decompose( position, quaternion, scale ) {\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tvector = new Vector3();\n\t\t\t\t\t\tmatrix = new Matrix4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\t\n\t\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\t\tvar det = this.determinant();\n\t\t\t\t\tif ( det < 0 ) {\n\t\n\t\t\t\t\t\tsx = - sx;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\t\tposition.z = te[ 14 ];\n\t\n\t\t\t\t\t// scale the rotation part\n\t\n\t\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\t\n\t\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\t\tvar invSZ = 1 / sz;\n\t\n\t\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\t\n\t\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\t\n\t\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\t\n\t\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\t\n\t\t\t\t\tscale.x = sx;\n\t\t\t\t\tscale.y = sy;\n\t\t\t\t\tscale.z = sz;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar x = 2 * near / ( right - left );\n\t\t\t\tvar y = 2 * near / ( top - bottom );\n\t\n\t\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\t\tvar d = - 2 * far * near / ( far - near );\n\t\n\t\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\t\n\t\t\t\tvar ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );\n\t\t\t\tvar ymin = - ymax;\n\t\t\t\tvar xmin = ymin * aspect;\n\t\t\t\tvar xmax = ymax * aspect;\n\t\n\t\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\t\n\t\t\t},\n\t\n\t\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar w = 1.0 / ( right - left );\n\t\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\t\tvar p = 1.0 / ( far - near );\n\t\n\t\t\t\tvar x = ( right + left ) * w;\n\t\t\t\tvar y = ( top + bottom ) * h;\n\t\t\t\tvar z = ( far + near ) * p;\n\t\n\t\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( matrix ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = matrix.elements;\n\t\n\t\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tfor( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\n\t\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\n\t\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\t\n\t\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\t\timages = images !== undefined ? images : [];\n\t\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\t\n\t\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.flipY = false;\n\t\n\t\t}\n\t\n\t\tCubeTexture.prototype = Object.create( Texture.prototype );\n\t\tCubeTexture.prototype.constructor = CubeTexture;\n\t\n\t\tCubeTexture.prototype.isCubeTexture = true;\n\t\n\t\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\t\n\t\t\tget: function () {\n\t\n\t\t\t\treturn this.image;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tthis.image = value;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t *\n\t\t * Uniforms of a program.\n\t\t * Those form a tree structure with a special top-level container for the root,\n\t\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t\t *\n\t\t *\n\t\t * Properties of inner nodes including the top-level container:\n\t\t *\n\t\t * .seq - array of nested uniforms\n\t\t * .map - nested uniforms by name\n\t\t *\n\t\t *\n\t\t * Methods of all nodes except the top-level container:\n\t\t *\n\t\t * .setValue( gl, value, [renderer] )\n\t\t *\n\t\t * \t\tuploads a uniform value(s)\n\t\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t\t *\n\t\t *\n\t\t * Static methods of the top-level container (renderer factorizations):\n\t\t *\n\t\t * .upload( gl, seq, values, renderer )\n\t\t *\n\t\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t\t *\n\t\t * .seqWithValue( seq, values ) : filteredSeq\n\t\t *\n\t\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t\t *\n\t\t *\n\t\t * Methods of the top-level container (renderer factorizations):\n\t\t *\n\t\t * .setValue( gl, name, value )\n\t\t *\n\t\t * \t\tsets uniform with  name 'name' to 'value'\n\t\t *\n\t\t * .set( gl, obj, prop )\n\t\t *\n\t\t * \t\tsets uniform from object and property with same name than uniform\n\t\t *\n\t\t * .setOptional( gl, obj, prop )\n\t\t *\n\t\t * \t\tlike .set for an optional property of the object\n\t\t *\n\t\t */\n\t\n\t\tvar emptyTexture = new Texture();\n\t\tvar emptyCubeTexture = new CubeTexture();\n\t\n\t\t// --- Base for inner nodes (including the root) ---\n\t\n\t\tfunction UniformContainer() {\n\t\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\t\n\t\t}\n\t\n\t\t// --- Utilities ---\n\t\n\t\t// Array Caches (provide typed arrays for temporary by size)\n\t\n\t\tvar arrayCacheF32 = [];\n\t\tvar arrayCacheI32 = [];\n\t\n\t\t// Flattening for arrays of vectors and matrices\n\t\n\t\tfunction flatten( array, nBlocks, blockSize ) {\n\t\n\t\t\tvar firstElem = array[ 0 ];\n\t\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\t\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\t\n\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\t\n\t\t\t}\n\t\n\t\t\tif ( nBlocks !== 0 ) {\n\t\n\t\t\t\tfirstElem.toArray( r, 0 );\n\t\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\t\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t}\n\t\n\t\t// Texture unit allocation\n\t\n\t\tfunction allocTexUnits( renderer, n ) {\n\t\n\t\t\tvar r = arrayCacheI32[ n ];\n\t\n\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\t\n\t\t\treturn r;\n\t\n\t\t}\n\t\n\t\t// --- Setters ---\n\t\n\t\t// Note: Defining these methods externally, because they come in a bunch\n\t\t// and this way their names minify.\n\t\n\t\t// Single scalar\n\t\n\t\tfunction setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }\n\t\tfunction setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }\n\t\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\t\n\t\tfunction setValue2fv( gl, v ) {\n\t\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\t\n\t\t}\n\t\n\t\tfunction setValue3fv( gl, v ) {\n\t\n\t\t\tif ( v.x !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\telse if ( v.r !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\telse\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\t\n\t\t}\n\t\n\t\tfunction setValue4fv( gl, v ) {\n\t\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\t\n\t\t}\n\t\n\t\t// Single matrix (from flat array or MatrixN)\n\t\n\t\tfunction setValue2fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\tfunction setValue3fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\tfunction setValue4fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\t// Single texture (2D / Cube)\n\t\n\t\tfunction setValueT1( gl, v, renderer ) {\n\t\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\t\n\t\t}\n\t\n\t\tfunction setValueT6( gl, v, renderer ) {\n\t\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\t\n\t\t}\n\t\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\t\n\t\tfunction setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }\n\t\tfunction setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }\n\t\tfunction setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }\n\t\n\t\t// Helper to pick the right setter for the singular case\n\t\n\t\tfunction getSingularSetter( type ) {\n\t\n\t\t\tswitch ( type ) {\n\t\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\t\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\t\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\t\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Array of scalars\n\t\n\t\tfunction setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }\n\t\tfunction setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }\n\t\n\t\t// Array of vectors (flat or from THREE classes)\n\t\n\t\tfunction setValueV2a( gl, v ) {\n\t\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueV3a( gl, v ) {\n\t\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueV4a( gl, v ) {\n\t\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\t\n\t\t}\n\t\n\t\t// Array of matrices (flat or from THREE clases)\n\t\n\t\tfunction setValueM2a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueM3a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueM4a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\t\n\t\t}\n\t\n\t\t// Array of textures (2D / Cube)\n\t\n\t\tfunction setValueT1a( gl, v, renderer ) {\n\t\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setValueT6a( gl, v, renderer ) {\n\t\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\t\n\t\tfunction getPureArraySetter( type ) {\n\t\n\t\t\tswitch ( type ) {\n\t\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\t\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\t\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\t\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// --- Uniform Classes ---\n\t\n\t\tfunction SingleUniform( id, activeInfo, addr ) {\n\t\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\t\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t}\n\t\n\t\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\t\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\t\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t}\n\t\n\t\tfunction StructuredUniform( id ) {\n\t\n\t\t\tthis.id = id;\n\t\n\t\t\tUniformContainer.call( this ); // mix-in\n\t\n\t\t}\n\t\n\t\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\t\n\t\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t\t// are not allowed in structured uniforms.\n\t\n\t\t\tvar seq = this.seq;\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tu.setValue( gl, value[ u.id ] );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// --- Top-level ---\n\t\n\t\t// Parser - builds up the property tree from the path strings\n\t\n\t\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\t\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\t\n\t\tfunction addUniform( container, uniformObject ) {\n\t\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\t\n\t\t}\n\t\n\t\tfunction parseUniform( activeInfo, addr, container ) {\n\t\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\t\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\t\n\t\t\tfor (; ;) {\n\t\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\t\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\t\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\t\n\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\t\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\t\n\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\tnext = map[ id ];\n\t\n\t\t\t\t\tif ( next === undefined ) {\n\t\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontainer = next;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Root Container\n\t\n\t\tfunction WebGLUniforms( gl, program, renderer ) {\n\t\n\t\t\tUniformContainer.call( this );\n\t\n\t\t\tthis.renderer = renderer;\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\t\n\t\t\t\tparseUniform( info, addr, this );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\t\n\t\t\tvar v = object[ name ];\n\t\n\t\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\t\n\t\t};\n\t\n\t\n\t\t// Static interface\n\t\n\t\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ],\n\t\t\t\t\tv = values[ u.id ];\n\t\n\t\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\n\t\t\t\t\tu.setValue( gl, v.value, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\t\n\t\t\tvar r = [];\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tif ( u.id in values ) r.push( u );\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Uniform Utilities\n\t\t */\n\t\n\t\tvar UniformsUtils = {\n\t\n\t\t\tmerge: function ( uniforms ) {\n\t\n\t\t\t\tvar merged = {};\n\t\n\t\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\t\n\t\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\t\n\t\t\t\t\tfor ( var p in tmp ) {\n\t\n\t\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn merged;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function ( uniforms_src ) {\n\t\n\t\t\t\tvar uniforms_dst = {};\n\t\n\t\t\t\tfor ( var u in uniforms_src ) {\n\t\n\t\t\t\t\tuniforms_dst[ u ] = {};\n\t\n\t\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\t\n\t\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\t\n\t\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\t\n\t\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn uniforms_dst;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\t\n\t\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\t\n\t\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\t\n\t\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\t\n\t\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\t\n\t\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\t\n\t\tvar bsdfs = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\t\n\t\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\t\n\t\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\t\n\t\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\t\n\t\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\t\n\t\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\t\n\t\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\t\n\t\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\t\n\t\tvar defaultnormal_vertex = \"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\t\n\t\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\t\n\t\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\t\n\t\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\t\n\t\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\t\n\t\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\t\n\t\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\t\n\t\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\t#else\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\t#endif\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\t\n\t\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\t\n\t\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\t\n\t\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\t\n\t\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\\t\\t\\tdirectLight.color = pointLight.color;\\n\\t\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\t#include <normal_flip>\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\t#include <normal_flip>\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\t\n\t\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\t\n\t\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\t\n\t\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\t\n\t\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t \\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\t\\t\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\t\n\t\tvar logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\t\n\t\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\t\n\t\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\t\n\t\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\t\n\t\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\t\n\t\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\t\n\t\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\t\n\t\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\t\n\t\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar normal_flip = \"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\t\n\t\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\t\n\t\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\t\n\t\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\t\n\t\tvar project_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\t\n\t\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\t\n\t\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\t\n\t\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\t\n\t\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\t\n\t\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\t\n\t\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\t\n\t\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\t\n\t\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\t\n\t\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\t\n\t\tvar tonemapping_pars_fragment = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\t\n\t\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\t\n\t\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\t\n\t\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\t\n\t\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\t\n\t\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\t\n\t\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\t\n\t\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\t\n\t\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar distanceRGBA_frag = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\t\n\t\tvar distanceRGBA_vert = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\t\n\t\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\t\n\t\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\t\n\t\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight;\\n\\treflectedLight.directDiffuse = vec3( 0.0 );\\n\\treflectedLight.directSpecular = vec3( 0.0 );\\n\\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n}\\n\";\n\t\n\t\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar normal_frag = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\\t#include <logdepthbuf_fragment>\\n}\\n\";\n\t\n\t\tvar normal_vert = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvNormal = normalize( normalMatrix * normal );\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar shadow_frag = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\t\n\t\tvar shadow_vert = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar ShaderChunk = {\n\t\t\talphamap_fragment: alphamap_fragment,\n\t\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\t\talphatest_fragment: alphatest_fragment,\n\t\t\taomap_fragment: aomap_fragment,\n\t\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\t\tbegin_vertex: begin_vertex,\n\t\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\t\tbsdfs: bsdfs,\n\t\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\t\tcolor_fragment: color_fragment,\n\t\t\tcolor_pars_fragment: color_pars_fragment,\n\t\t\tcolor_pars_vertex: color_pars_vertex,\n\t\t\tcolor_vertex: color_vertex,\n\t\t\tcommon: common,\n\t\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\t\temissivemap_fragment: emissivemap_fragment,\n\t\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\t\tencodings_fragment: encodings_fragment,\n\t\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\t\tenvmap_fragment: envmap_fragment,\n\t\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\t\tenvmap_vertex: envmap_vertex,\n\t\t\tfog_fragment: fog_fragment,\n\t\t\tfog_pars_fragment: fog_pars_fragment,\n\t\t\tlightmap_fragment: lightmap_fragment,\n\t\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\t\tlights_pars: lights_pars,\n\t\t\tlights_phong_fragment: lights_phong_fragment,\n\t\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\t\tlights_physical_fragment: lights_physical_fragment,\n\t\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\t\tlights_template: lights_template,\n\t\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\t\tmap_fragment: map_fragment,\n\t\t\tmap_pars_fragment: map_pars_fragment,\n\t\t\tmap_particle_fragment: map_particle_fragment,\n\t\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\t\tnormal_flip: normal_flip,\n\t\t\tnormal_fragment: normal_fragment,\n\t\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\t\tpacking: packing,\n\t\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\t\tproject_vertex: project_vertex,\n\t\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\t\tshadowmap_vertex: shadowmap_vertex,\n\t\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\t\tskinbase_vertex: skinbase_vertex,\n\t\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\t\tskinning_vertex: skinning_vertex,\n\t\t\tskinnormal_vertex: skinnormal_vertex,\n\t\t\tspecularmap_fragment: specularmap_fragment,\n\t\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\t\ttonemapping_fragment: tonemapping_fragment,\n\t\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\t\tuv_pars_fragment: uv_pars_fragment,\n\t\t\tuv_pars_vertex: uv_pars_vertex,\n\t\t\tuv_vertex: uv_vertex,\n\t\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\t\tuv2_vertex: uv2_vertex,\n\t\t\tworldpos_vertex: worldpos_vertex,\n\t\n\t\t\tcube_frag: cube_frag,\n\t\t\tcube_vert: cube_vert,\n\t\t\tdepth_frag: depth_frag,\n\t\t\tdepth_vert: depth_vert,\n\t\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\t\tequirect_frag: equirect_frag,\n\t\t\tequirect_vert: equirect_vert,\n\t\t\tlinedashed_frag: linedashed_frag,\n\t\t\tlinedashed_vert: linedashed_vert,\n\t\t\tmeshbasic_frag: meshbasic_frag,\n\t\t\tmeshbasic_vert: meshbasic_vert,\n\t\t\tmeshlambert_frag: meshlambert_frag,\n\t\t\tmeshlambert_vert: meshlambert_vert,\n\t\t\tmeshphong_frag: meshphong_frag,\n\t\t\tmeshphong_vert: meshphong_vert,\n\t\t\tmeshphysical_frag: meshphysical_frag,\n\t\t\tmeshphysical_vert: meshphysical_vert,\n\t\t\tnormal_frag: normal_frag,\n\t\t\tnormal_vert: normal_vert,\n\t\t\tpoints_frag: points_frag,\n\t\t\tpoints_vert: points_vert,\n\t\t\tshadow_frag: shadow_frag,\n\t\t\tshadow_vert: shadow_vert\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Color( r, g, b ) {\n\t\n\t\t\tif ( g === undefined && b === undefined ) {\n\t\n\t\t\t\t// r is THREE.Color, hex or string\n\t\t\t\treturn this.set( r );\n\t\n\t\t\t}\n\t\n\t\t\treturn this.setRGB( r, g, b );\n\t\n\t\t}\n\t\n\t\tColor.prototype = {\n\t\n\t\t\tconstructor: Color,\n\t\n\t\t\tisColor: true,\n\t\n\t\t\tr: 1, g: 1, b: 1,\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tif ( (value && value.isColor) ) {\n\t\n\t\t\t\t\tthis.copy( value );\n\t\n\t\t\t\t} else if ( typeof value === 'number' ) {\n\t\n\t\t\t\t\tthis.setHex( value );\n\t\n\t\t\t\t} else if ( typeof value === 'string' ) {\n\t\n\t\t\t\t\tthis.setStyle( value );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.r = scalar;\n\t\t\t\tthis.g = scalar;\n\t\t\t\tthis.b = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetHex: function ( hex ) {\n\t\n\t\t\t\thex = Math.floor( hex );\n\t\n\t\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\t\tthis.b = ( hex & 255 ) / 255;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetRGB: function ( r, g, b ) {\n\t\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.g = g;\n\t\t\t\tthis.b = b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetHSL: function () {\n\t\n\t\t\t\tfunction hue2rgb( p, q, t ) {\n\t\n\t\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\t\treturn p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function setHSL( h, s, l ) {\n\t\n\t\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\t\n\t\t\t\t\tif ( s === 0 ) {\n\t\n\t\t\t\t\t\tthis.r = this.g = this.b = l;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\t\tvar q = ( 2 * l ) - p;\n\t\n\t\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetStyle: function ( style ) {\n\t\n\t\t\t\tfunction handleAlpha( string ) {\n\t\n\t\t\t\t\tif ( string === undefined ) return;\n\t\n\t\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tvar m;\n\t\n\t\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\t\n\t\t\t\t\t// rgb / hsl\n\t\n\t\t\t\t\tvar color;\n\t\t\t\t\tvar name = m[ 1 ];\n\t\t\t\t\tvar components = m[ 2 ];\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\t\tcase 'rgb':\n\t\t\t\t\t\tcase 'rgba':\n\t\n\t\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'hsl':\n\t\t\t\t\t\tcase 'hsla':\n\t\n\t\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\t\n\t\t\t\t\t// hex color\n\t\n\t\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\t\tvar size = hex.length;\n\t\n\t\t\t\t\tif ( size === 3 ) {\n\t\n\t\t\t\t\t\t// #ff0\n\t\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t} else if ( size === 6 ) {\n\t\n\t\t\t\t\t\t// #ff0000\n\t\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( style && style.length > 0 ) {\n\t\n\t\t\t\t\t// color keywords\n\t\t\t\t\tvar hex = ColorKeywords[ style ];\n\t\n\t\t\t\t\tif ( hex !== undefined ) {\n\t\n\t\t\t\t\t\t// red\n\t\t\t\t\t\tthis.setHex( hex );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// unknown color\n\t\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( color ) {\n\t\n\t\t\t\tthis.r = color.r;\n\t\t\t\tthis.g = color.g;\n\t\t\t\tthis.b = color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\t\n\t\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\t\n\t\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\t\n\t\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconvertGammaToLinear: function () {\n\t\n\t\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\t\tthis.r = r * r;\n\t\t\t\tthis.g = g * g;\n\t\t\t\tthis.b = b * b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconvertLinearToGamma: function () {\n\t\n\t\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\t\tthis.b = Math.sqrt( this.b );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetHex: function () {\n\t\n\t\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\t\n\t\t\t},\n\t\n\t\t\tgetHexString: function () {\n\t\n\t\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\t\n\t\t\t},\n\t\n\t\t\tgetHSL: function ( optionalTarget ) {\n\t\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\n\t\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\t\n\t\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\t\tvar max = Math.max( r, g, b );\n\t\t\t\tvar min = Math.min( r, g, b );\n\t\n\t\t\t\tvar hue, saturation;\n\t\t\t\tvar lightness = ( min + max ) / 2.0;\n\t\n\t\t\t\tif ( min === max ) {\n\t\n\t\t\t\t\thue = 0;\n\t\t\t\t\tsaturation = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar delta = max - min;\n\t\n\t\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\t\n\t\t\t\t\tswitch ( max ) {\n\t\n\t\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\thue /= 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t\thsl.h = hue;\n\t\t\t\thsl.s = saturation;\n\t\t\t\thsl.l = lightness;\n\t\n\t\t\t\treturn hsl;\n\t\n\t\t\t},\n\t\n\t\t\tgetStyle: function () {\n\t\n\t\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\t\n\t\t\t},\n\t\n\t\t\toffsetHSL: function ( h, s, l ) {\n\t\n\t\t\t\tvar hsl = this.getHSL();\n\t\n\t\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\t\n\t\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( color ) {\n\t\n\t\t\t\tthis.r += color.r;\n\t\t\t\tthis.g += color.g;\n\t\t\t\tthis.b += color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddColors: function ( color1, color2 ) {\n\t\n\t\t\t\tthis.r = color1.r + color2.r;\n\t\t\t\tthis.g = color1.g + color2.g;\n\t\t\t\tthis.b = color1.b + color2.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.r += s;\n\t\t\t\tthis.g += s;\n\t\t\t\tthis.b += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function( color ) {\n\t\n\t\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( color ) {\n\t\n\t\t\t\tthis.r *= color.r;\n\t\t\t\tthis.g *= color.g;\n\t\t\t\tthis.b *= color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tthis.r *= s;\n\t\t\t\tthis.g *= s;\n\t\t\t\tthis.b *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( color, alpha ) {\n\t\n\t\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( c ) {\n\t\n\t\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.r = array[ offset ];\n\t\t\t\tthis.g = array[ offset + 1 ];\n\t\t\t\tthis.b = array[ offset + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.r;\n\t\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\t\tarray[ offset + 2 ] = this.b;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\treturn this.getHex();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\t\n\t\t/**\n\t\t * Uniforms library for shared webgl shaders\n\t\t */\n\t\n\t\tvar UniformsLib = {\n\t\n\t\t\tcommon: {\n\t\n\t\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\t\topacity: { value: 1.0 },\n\t\n\t\t\t\tmap: { value: null },\n\t\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },\n\t\n\t\t\t\tspecularMap: { value: null },\n\t\t\t\talphaMap: { value: null },\n\t\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tflipEnvMap: { value: - 1 },\n\t\t\t\treflectivity: { value: 1.0 },\n\t\t\t\trefractionRatio: { value: 0.98 }\n\t\n\t\t\t},\n\t\n\t\t\taomap: {\n\t\n\t\t\t\taoMap: { value: null },\n\t\t\t\taoMapIntensity: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\tlightmap: {\n\t\n\t\t\t\tlightMap: { value: null },\n\t\t\t\tlightMapIntensity: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\temissivemap: {\n\t\n\t\t\t\temissiveMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tbumpmap: {\n\t\n\t\t\t\tbumpMap: { value: null },\n\t\t\t\tbumpScale: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\tnormalmap: {\n\t\n\t\t\t\tnormalMap: { value: null },\n\t\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\t\n\t\t\t},\n\t\n\t\t\tdisplacementmap: {\n\t\n\t\t\t\tdisplacementMap: { value: null },\n\t\t\t\tdisplacementScale: { value: 1 },\n\t\t\t\tdisplacementBias: { value: 0 }\n\t\n\t\t\t},\n\t\n\t\t\troughnessmap: {\n\t\n\t\t\t\troughnessMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tmetalnessmap: {\n\t\n\t\t\t\tmetalnessMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tfog: {\n\t\n\t\t\t\tfogDensity: { value: 0.00025 },\n\t\t\t\tfogNear: { value: 1 },\n\t\t\t\tfogFar: { value: 2000 },\n\t\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\t\n\t\t\t},\n\t\n\t\t\tlights: {\n\t\n\t\t\t\tambientLightColor: { value: [] },\n\t\n\t\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tcolor: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\t\tdirectionalShadowMatrix: { value: [] },\n\t\n\t\t\t\tspotLights: { value: [], properties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tdistance: {},\n\t\t\t\t\tconeCos: {},\n\t\t\t\t\tpenumbraCos: {},\n\t\t\t\t\tdecay: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tspotShadowMap: { value: [] },\n\t\t\t\tspotShadowMatrix: { value: [] },\n\t\n\t\t\t\tpointLights: { value: [], properties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdecay: {},\n\t\t\t\t\tdistance: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tpointShadowMap: { value: [] },\n\t\t\t\tpointShadowMatrix: { value: [] },\n\t\n\t\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tskyColor: {},\n\t\t\t\t\tgroundColor: {}\n\t\t\t\t} }\n\t\n\t\t\t},\n\t\n\t\t\tpoints: {\n\t\n\t\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\t\topacity: { value: 1.0 },\n\t\t\t\tsize: { value: 1.0 },\n\t\t\t\tscale: { value: 1.0 },\n\t\t\t\tmap: { value: null },\n\t\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t */\n\t\n\t\tvar ShaderLib = {\n\t\n\t\t\tbasic: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.fog\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\t\n\t\t\t},\n\t\n\t\t\tlambert: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\temissive : { value: new Color( 0x000000 ) }\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\t\n\t\t\t},\n\t\n\t\t\tphong: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\t\tUniformsLib.normalmap,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\t\tspecular : { value: new Color( 0x111111 ) },\n\t\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\t\n\t\t\t},\n\t\n\t\t\tstandard: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\t\tUniformsLib.normalmap,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\t\tmetalness: { value: 0 },\n\t\t\t\t\t\tenvMapIntensity : { value: 1 }, // temporary\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\n\t\t\t},\n\t\n\t\t\tpoints: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.points,\n\t\t\t\t\tUniformsLib.fog\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\t\tfragmentShader: ShaderChunk.points_frag\n\t\n\t\t\t},\n\t\n\t\t\tdashed: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.fog,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\tscale    : { value: 1 },\n\t\t\t\t\t\tdashSize : { value: 1 },\n\t\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\t\n\t\t\t},\n\t\n\t\t\tdepth: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.displacementmap\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\t\tfragmentShader: ShaderChunk.depth_frag\n\t\n\t\t\t},\n\t\n\t\t\tnormal: {\n\t\n\t\t\t\tuniforms: {\n\t\n\t\t\t\t\topacity : { value: 1.0 }\n\t\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\t\tfragmentShader: ShaderChunk.normal_frag\n\t\n\t\t\t},\n\t\n\t\t\t/* -------------------------------------------------------------------------\n\t\t\t//\tCube map shader\n\t\t\t ------------------------------------------------------------------------- */\n\t\n\t\t\tcube: {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\ttCube: { value: null },\n\t\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\t\tfragmentShader: ShaderChunk.cube_frag\n\t\n\t\t\t},\n\t\n\t\t\t/* -------------------------------------------------------------------------\n\t\t\t//\tCube map shader\n\t\t\t ------------------------------------------------------------------------- */\n\t\n\t\t\tequirect: {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\ttEquirect: { value: null },\n\t\t\t\t\ttFlip: { value: - 1 }\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\t\n\t\t\t},\n\t\n\t\t\tdistanceRGBA: {\n\t\n\t\t\t\tuniforms: {\n\t\n\t\t\t\t\tlightPos: { value: new Vector3() }\n\t\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tShaderLib.physical = {\n\t\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\tShaderLib.standard.uniforms,\n\t\n\t\t\t\t{\n\t\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Box2( min, max ) {\n\t\n\t\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\t\n\t\t}\n\t\n\t\tBox2.prototype = {\n\t\n\t\t\tconstructor: Box2,\n\t\n\t\t\tset: function ( min, max ) {\n\t\n\t\t\t\tthis.min.copy( min );\n\t\t\t\tthis.max.copy( max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\t\tvar v1 = new Vector2();\n\t\n\t\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( box ) {\n\t\n\t\t\t\tthis.min.copy( box.min );\n\t\t\t\tthis.max.copy( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeEmpty: function () {\n\t\n\t\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\t\tthis.max.x = this.max.y = - Infinity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tisEmpty: function () {\n\t\n\t\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tgetSize: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\t\n\t\t\t},\n\t\n\t\t\texpandByPoint: function ( point ) {\n\t\n\t\t\t\tthis.min.min( point );\n\t\t\t\tthis.max.max( point );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByVector: function ( vector ) {\n\t\n\t\t\t\tthis.min.sub( vector );\n\t\t\t\tthis.max.add( vector );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.min.addScalar( - scalar );\n\t\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsBox: function ( box ) {\n\t\n\t\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t\t// has a size dimension of 0.\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\n\t\t\t\treturn result.set(\n\t\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector2();\n\t\n\t\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersect: function ( box ) {\n\t\n\t\t\t\tthis.min.max( box.min );\n\t\t\t\tthis.max.min( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tunion: function ( box ) {\n\t\n\t\t\t\tthis.min.min( box.min );\n\t\t\t\tthis.max.max( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.min.add( offset );\n\t\t\t\tthis.max.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( box ) {\n\t\n\t\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction LensFlarePlugin( renderer, flares ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\t\tvar state = renderer.state;\n\t\n\t\t\tvar vertexBuffer, elementBuffer;\n\t\t\tvar shader, program, attributes, uniforms;\n\t\n\t\t\tvar tempTexture, occlusionTexture;\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t\t- 1,  1,  0, 1\n\t\t\t\t] );\n\t\n\t\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t0, 2, 3\n\t\t\t\t] );\n\t\n\t\t\t\t// buffers\n\t\n\t\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\t\telementBuffer    = gl.createBuffer();\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\t\t// textures\n\t\n\t\t\t\ttempTexture      = gl.createTexture();\n\t\t\t\tocclusionTexture = gl.createTexture();\n\t\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\t\tshader = {\n\t\n\t\t\t\t\tvertexShader: [\n\t\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\t\"uniform float rotation;\",\n\t\n\t\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\t\n\t\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\t\"attribute vec2 uv;\",\n\t\n\t\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t\t\"vUV = uv;\",\n\t\n\t\t\t\t\t\t\t\"vec2 pos = position;\",\n\t\n\t\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\t\n\t\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\t\n\t\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\t\n\t\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\t\n\t\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\t\n\t\t\t\t\t\t\"}\"\n\t\n\t\t\t\t\t].join( \"\\n\" ),\n\t\n\t\t\t\t\tfragmentShader: [\n\t\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\t\"uniform vec3 color;\",\n\t\n\t\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t\t// pink square\n\t\n\t\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\t\n\t\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\t\n\t\t\t\t\t\t\t// restore\n\t\n\t\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\t\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\t\n\t\t\t\t\t\t\t// flare\n\t\n\t\t\t\t\t\t\t\"} else {\",\n\t\n\t\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\t\n\t\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\t\"}\"\n\t\n\t\t\t\t\t].join( \"\\n\" )\n\t\n\t\t\t\t};\n\t\n\t\t\t\tprogram = createProgram( shader );\n\t\n\t\t\t\tattributes = {\n\t\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t\t};\n\t\n\t\t\t\tuniforms = {\n\t\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t/*\n\t\t\t * Render lens flares\n\t\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t\t *         reads these back and calculates occlusion.\n\t\t\t */\n\t\n\t\t\tthis.render = function ( scene, camera, viewport ) {\n\t\n\t\t\t\tif ( flares.length === 0 ) return;\n\t\n\t\t\t\tvar tempPosition = new Vector3();\n\t\n\t\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\t\n\t\t\t\tvar size = 16 / viewport.w,\n\t\t\t\t\tscale = new Vector2( size * invAspect, size );\n\t\n\t\t\t\tvar screenPosition = new Vector3( 1, 1, 0 ),\n\t\t\t\t\tscreenPositionPixels = new Vector2( 1, 1 );\n\t\n\t\t\t\tvar validArea = new Box2();\n\t\n\t\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tinit();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.useProgram( program );\n\t\n\t\t\t\tstate.initAttributes();\n\t\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t\t// setup gl and common used attribs/uniforms\n\t\n\t\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\t\tgl.uniform1i( uniforms.map, 1 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\t\tstate.setDepthWrite( false );\n\t\n\t\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\t\tscale.set( size * invAspect, size );\n\t\n\t\t\t\t\t// calc object screen position\n\t\n\t\t\t\t\tvar flare = flares[ i ];\n\t\n\t\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\t\n\t\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\t\n\t\t\t\t\t// setup arrays for gl programs\n\t\n\t\t\t\t\tscreenPosition.copy( tempPosition );\n\t\n\t\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\t\n\t\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\t\n\t\t\t\t\t// screen cull\n\t\n\t\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\t\n\t\t\t\t\t\t// save current RGB to temp texture\n\t\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t\t// render pink quad\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\n\t\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t\t// copy result to occlusionMap\n\t\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t\t// restore graphics\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t\t// update object positions\n\t\n\t\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\t\n\t\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\t\n\t\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tflare.updateLensFlares();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// render flares\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\t\n\t\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\t\n\t\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\t\n\t\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\t\n\t\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\t\tscale.y = size;\n\t\n\t\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\t\n\t\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\t\n\t\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\t\n\t\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore gl\n\t\n\t\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\t\tstate.setDepthWrite( true );\n\t\n\t\t\t\trenderer.resetGLState();\n\t\n\t\t\t};\n\t\n\t\t\tfunction createProgram( shader ) {\n\t\n\t\t\t\tvar program = gl.createProgram();\n\t\n\t\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\n\t\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\t\n\t\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\t\n\t\t\t\tgl.compileShader( fragmentShader );\n\t\t\t\tgl.compileShader( vertexShader );\n\t\n\t\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\t\tgl.attachShader( program, vertexShader );\n\t\n\t\t\t\tgl.linkProgram( program );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction SpritePlugin( renderer, sprites ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\t\tvar state = renderer.state;\n\t\n\t\t\tvar vertexBuffer, elementBuffer;\n\t\t\tvar program, attributes, uniforms;\n\t\n\t\t\tvar texture;\n\t\n\t\t\t// decompose matrixWorld\n\t\n\t\t\tvar spritePosition = new Vector3();\n\t\t\tvar spriteRotation = new Quaternion();\n\t\t\tvar spriteScale = new Vector3();\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t\t] );\n\t\n\t\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t0, 2, 3\n\t\t\t\t] );\n\t\n\t\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\t\telementBuffer = gl.createBuffer();\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\t\tprogram = createProgram();\n\t\n\t\t\t\tattributes = {\n\t\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t\t};\n\t\n\t\t\t\tuniforms = {\n\t\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\t\n\t\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\t\n\t\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\t\n\t\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\t\n\t\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\t\n\t\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t\t};\n\t\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = 8;\n\t\t\t\tcanvas.height = 8;\n\t\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\t\n\t\t\t\ttexture = new Texture( canvas );\n\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\t\tif ( sprites.length === 0 ) return;\n\t\n\t\t\t\t// setup gl\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tinit();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.useProgram( program );\n\t\n\t\t\t\tstate.initAttributes();\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\t\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tgl.uniform1i( uniforms.map, 0 );\n\t\n\t\t\t\tvar oldFogType = 0;\n\t\t\t\tvar sceneFogType = 0;\n\t\t\t\tvar fog = scene.fog;\n\t\n\t\t\t\tif ( fog ) {\n\t\n\t\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\t\n\t\t\t\t\tif ( (fog && fog.isFog) ) {\n\t\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\t\toldFogType = 1;\n\t\t\t\t\t\tsceneFogType = 1;\n\t\n\t\t\t\t\t} else if ( (fog && fog.isFogExp2) ) {\n\t\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\t\toldFogType = 2;\n\t\t\t\t\t\tsceneFogType = 2;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\t\toldFogType = 0;\n\t\t\t\t\tsceneFogType = 0;\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// update positions and sort\n\t\n\t\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar sprite = sprites[ i ];\n\t\n\t\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tsprites.sort( painterSortStable );\n\t\n\t\t\t\t// render all sprites\n\t\n\t\t\t\tvar scale = [];\n\t\n\t\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\t\tvar material = sprite.material;\n\t\n\t\t\t\t\tif ( material.visible === false ) continue;\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\t\n\t\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\t\n\t\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\t\tscale[ 1 ] = spriteScale.y;\n\t\n\t\t\t\t\tvar fogType = 0;\n\t\n\t\t\t\t\tif ( scene.fog && material.fog ) {\n\t\n\t\t\t\t\t\tfogType = sceneFogType;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( oldFogType !== fogType ) {\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\t\toldFogType = fogType;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\t\n\t\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\n\t\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore gl\n\t\n\t\t\t\tstate.enable( gl.CULL_FACE );\n\t\n\t\t\t\trenderer.resetGLState();\n\t\n\t\t\t};\n\t\n\t\t\tfunction createProgram() {\n\t\n\t\t\t\tvar program = gl.createProgram();\n\t\n\t\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\n\t\t\t\tgl.shaderSource( vertexShader, [\n\t\n\t\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform float rotation;',\n\t\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t\t'uniform vec2 uvScale;',\n\t\n\t\t\t\t\t'attribute vec2 position;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\t\n\t\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\t\n\t\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\t\n\t\t\t\t\t\t'vec4 finalPosition;',\n\t\n\t\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\t\n\t\t\t\t\t\t'gl_Position = finalPosition;',\n\t\n\t\t\t\t\t'}'\n\t\n\t\t\t\t].join( '\\n' ) );\n\t\n\t\t\t\tgl.shaderSource( fragmentShader, [\n\t\n\t\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t\t'uniform vec3 color;',\n\t\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t\t'uniform float opacity;',\n\t\n\t\t\t\t\t'uniform int fogType;',\n\t\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t\t'uniform float fogNear;',\n\t\t\t\t\t'uniform float fogFar;',\n\t\t\t\t\t'uniform float alphaTest;',\n\t\n\t\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\t\n\t\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\t\n\t\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\t\n\t\t\t\t\t\t'if ( fogType > 0 ) {',\n\t\n\t\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t\t'float fogFactor = 0.0;',\n\t\n\t\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\t\n\t\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\t\n\t\t\t\t\t\t\t'} else {',\n\t\n\t\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\t\n\t\t\t\t\t\t\t'}',\n\t\n\t\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\t\n\t\t\t\t\t\t'}',\n\t\n\t\t\t\t\t'}'\n\t\n\t\t\t\t].join( '\\n' ) );\n\t\n\t\t\t\tgl.compileShader( vertexShader );\n\t\t\t\tgl.compileShader( fragmentShader );\n\t\n\t\t\t\tgl.attachShader( program, vertexShader );\n\t\t\t\tgl.attachShader( program, fragmentShader );\n\t\n\t\t\t\tgl.linkProgram( program );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t\tfunction painterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\t\n\t\t\t\t\treturn a.renderOrder - b.renderOrder;\n\t\n\t\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn b.id - a.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Material() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: MaterialIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Material';\n\t\n\t\t\tthis.fog = true;\n\t\t\tthis.lights = true;\n\t\n\t\t\tthis.blending = NormalBlending;\n\t\t\tthis.side = FrontSide;\n\t\t\tthis.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\t\n\t\t\tthis.opacity = 1;\n\t\t\tthis.transparent = false;\n\t\n\t\t\tthis.blendSrc = SrcAlphaFactor;\n\t\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\t\tthis.blendEquation = AddEquation;\n\t\t\tthis.blendSrcAlpha = null;\n\t\t\tthis.blendDstAlpha = null;\n\t\t\tthis.blendEquationAlpha = null;\n\t\n\t\t\tthis.depthFunc = LessEqualDepth;\n\t\t\tthis.depthTest = true;\n\t\t\tthis.depthWrite = true;\n\t\n\t\t\tthis.clippingPlanes = null;\n\t\t\tthis.clipIntersection = false;\n\t\t\tthis.clipShadows = false;\n\t\n\t\t\tthis.colorWrite = true;\n\t\n\t\t\tthis.precision = null; // override the renderer's default precision for this material\n\t\n\t\t\tthis.polygonOffset = false;\n\t\t\tthis.polygonOffsetFactor = 0;\n\t\t\tthis.polygonOffsetUnits = 0;\n\t\n\t\t\tthis.alphaTest = 0;\n\t\t\tthis.premultipliedAlpha = false;\n\t\n\t\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\t\n\t\t\tthis.visible = true;\n\t\n\t\t\tthis._needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tMaterial.prototype = {\n\t\n\t\t\tconstructor: Material,\n\t\n\t\t\tisMaterial: true,\n\t\n\t\t\tget needsUpdate() {\n\t\n\t\t\t\treturn this._needsUpdate;\n\t\n\t\t\t},\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.update();\n\t\t\t\tthis._needsUpdate = value;\n\t\n\t\t\t},\n\t\n\t\t\tsetValues: function ( values ) {\n\t\n\t\t\t\tif ( values === undefined ) return;\n\t\n\t\t\t\tfor ( var key in values ) {\n\t\n\t\t\t\t\tvar newValue = values[ key ];\n\t\n\t\t\t\t\tif ( newValue === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar currentValue = this[ key ];\n\t\n\t\t\t\t\tif ( currentValue === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( (currentValue && currentValue.isColor) ) {\n\t\n\t\t\t\t\t\tcurrentValue.set( newValue );\n\t\n\t\t\t\t\t} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {\n\t\n\t\t\t\t\t\tcurrentValue.copy( newValue );\n\t\n\t\t\t\t\t} else if ( key === 'overdraw' ) {\n\t\n\t\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\t\tthis[ key ] = Number( newValue );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis[ key ] = newValue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar isRoot = meta === undefined;\n\t\n\t\t\t\tif ( isRoot ) {\n\t\n\t\t\t\t\tmeta = {\n\t\t\t\t\t\ttextures: {},\n\t\t\t\t\t\timages: {}\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Material',\n\t\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard Material serialization\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( (this.color && this.color.isColor) ) data.color = this.color.getHex();\n\t\n\t\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\t\n\t\t\t\tif ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();\n\t\t\t\tif ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();\n\t\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\n\t\t\t\tif ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.bumpMap && this.bumpMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.bumpScale = this.bumpScale;\n\t\n\t\t\t\t}\n\t\t\t\tif ( (this.normalMap && this.normalMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\t\n\t\t\t\t}\n\t\t\t\tif ( (this.displacementMap && this.displacementMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\t\tdata.displacementBias = this.displacementBias;\n\t\n\t\t\t\t}\n\t\t\t\tif ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\t\n\t\t\t\tif ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\n\t\t\t\tif ( (this.envMap && this.envMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\t\n\t\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\t\tif ( this.shading !== SmoothShading ) data.shading = this.shading;\n\t\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\t\n\t\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\n\t\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\t\tdata.depthTest = this.depthTest;\n\t\t\t\tdata.depthWrite = this.depthWrite;\n\t\n\t\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\t\n\t\t\t\tdata.skinning = this.skinning;\n\t\t\t\tdata.morphTargets = this.morphTargets;\n\t\n\t\t\t\t// TODO: Copied from Object3D.toJSON\n\t\n\t\t\t\tfunction extractFromCache( cache ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn values;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isRoot ) {\n\t\n\t\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\t\tif ( images.length > 0 ) data.images = images;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\tthis.fog = source.fog;\n\t\t\t\tthis.lights = source.lights;\n\t\n\t\t\t\tthis.blending = source.blending;\n\t\t\t\tthis.side = source.side;\n\t\t\t\tthis.shading = source.shading;\n\t\t\t\tthis.vertexColors = source.vertexColors;\n\t\n\t\t\t\tthis.opacity = source.opacity;\n\t\t\t\tthis.transparent = source.transparent;\n\t\n\t\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\t\tthis.blendDst = source.blendDst;\n\t\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\n\t\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\t\tthis.depthTest = source.depthTest;\n\t\t\t\tthis.depthWrite = source.depthWrite;\n\t\n\t\t\t\tthis.colorWrite = source.colorWrite;\n\t\n\t\t\t\tthis.precision = source.precision;\n\t\n\t\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\t\n\t\t\t\tthis.alphaTest = source.alphaTest;\n\t\n\t\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\n\t\t\t\tthis.overdraw = source.overdraw;\n\t\n\t\t\t\tthis.visible = source.visible;\n\t\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\t\tthis.clipIntersection = source.clipIntersection;\n\t\n\t\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\t\tdstPlanes = null;\n\t\n\t\t\t\tif ( srcPlanes !== null ) {\n\t\n\t\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\t\tdstPlanes = new Array( n );\n\t\n\t\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.clippingPlanes = dstPlanes;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'update' } );\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Material.prototype, EventDispatcher.prototype );\n\t\n\t\tvar count$1 = 0;\n\t\tfunction MaterialIdCount() { return count$1++; }\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  defines: { \"label\" : \"value\" },\n\t\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t\t *\n\t\t *  fragmentShader: <string>,\n\t\t *  vertexShader: <string>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  lights: <bool>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction ShaderMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'ShaderMaterial';\n\t\n\t\t\tthis.defines = {};\n\t\t\tthis.uniforms = {};\n\t\n\t\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\t\n\t\t\tthis.linewidth = 1;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false; // set to use scene fog\n\t\t\tthis.lights = false; // set to use scene lights\n\t\t\tthis.clipping = false; // set to use user-defined clipping planes\n\t\n\t\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\t\tthis.morphTargets = false; // set to use morph targets\n\t\t\tthis.morphNormals = false; // set to use morph normals\n\t\n\t\t\tthis.extensions = {\n\t\t\t\tderivatives: false, // set to use derivatives\n\t\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t\t};\n\t\n\t\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\t\tthis.defaultAttributeValues = {\n\t\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t\t'uv': [ 0, 0 ],\n\t\t\t\t'uv2': [ 0, 0 ]\n\t\t\t};\n\t\n\t\t\tthis.index0AttributeName = undefined;\n\t\n\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\tif ( parameters.attributes !== undefined ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setValues( parameters );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tShaderMaterial.prototype = Object.create( Material.prototype );\n\t\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\t\n\t\tShaderMaterial.prototype.isShaderMaterial = true;\n\t\n\t\tShaderMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.fragmentShader = source.fragmentShader;\n\t\t\tthis.vertexShader = source.vertexShader;\n\t\n\t\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\t\n\t\t\tthis.defines = source.defines;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\tthis.lights = source.lights;\n\t\t\tthis.clipping = source.clipping;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\tthis.extensions = source.extensions;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\t\n\t\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.uniforms = this.uniforms;\n\t\t\tdata.vertexShader = this.vertexShader;\n\t\t\tdata.fragmentShader = this.fragmentShader;\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author bhouston / https://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshDepthMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshDepthMaterial';\n\t\n\t\t\tthis.depthPacking = BasicDepthPacking;\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\t\n\t\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\t\n\t\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.depthPacking = source.depthPacking;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Box3( min, max ) {\n\t\n\t\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\t\n\t\t}\n\t\n\t\tBox3.prototype = {\n\t\n\t\t\tconstructor: Box3,\n\t\n\t\t\tisBox3: true,\n\t\n\t\t\tset: function ( min, max ) {\n\t\n\t\t\t\tthis.min.copy( min );\n\t\t\t\tthis.max.copy( max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromArray: function ( array ) {\n\t\n\t\t\t\tvar minX = + Infinity;\n\t\t\t\tvar minY = + Infinity;\n\t\t\t\tvar minZ = + Infinity;\n\t\n\t\t\t\tvar maxX = - Infinity;\n\t\t\t\tvar maxY = - Infinity;\n\t\t\t\tvar maxZ = - Infinity;\n\t\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\tvar x = array[ i ];\n\t\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\t\tvar z = array[ i + 2 ];\n\t\n\t\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\t\tif ( z < minZ ) minZ = z;\n\t\n\t\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\t\tif ( z > maxZ ) maxZ = z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\t\tthis.max.set( maxX, maxY, maxZ );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\n\t\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetFromObject: function () {\n\t\n\t\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t\t// accounting for both the object's, and children's, world transforms\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function setFromObject( object ) {\n\t\n\t\t\t\t\tvar scope = this;\n\t\n\t\t\t\t\tobject.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\t\tobject.traverse( function ( node ) {\n\t\n\t\t\t\t\t\tvar geometry = node.geometry;\n\t\n\t\t\t\t\t\tif ( geometry !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\t\n\t\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tvar array, offset, stride;\n\t\n\t\t\t\t\t\t\t\t\tif ( (attribute && attribute.isInterleavedBufferAttribute) ) {\n\t\n\t\t\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\t\t\tstride = 3;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\t\n\t\t\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( box ) {\n\t\n\t\t\t\tthis.min.copy( box.min );\n\t\t\t\tthis.max.copy( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeEmpty: function () {\n\t\n\t\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tisEmpty: function () {\n\t\n\t\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tgetSize: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\t\n\t\t\t},\n\t\n\t\t\texpandByPoint: function ( point ) {\n\t\n\t\t\t\tthis.min.min( point );\n\t\t\t\tthis.max.max( point );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByVector: function ( vector ) {\n\t\n\t\t\t\tthis.min.sub( vector );\n\t\t\t\tthis.max.add( vector );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.min.addScalar( - scalar );\n\t\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsBox: function ( box ) {\n\t\n\t\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t\t// has a size dimension of 0.\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.set(\n\t\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: ( function () {\n\t\n\t\t\t\tvar closestPoint;\n\t\n\t\t\t\treturn function intersectsSphere( sphere ) {\n\t\n\t\t\t\t\tif ( closestPoint === undefined ) closestPoint = new Vector3();\n\t\n\t\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\t\n\t\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\tif ( plane.normal.x > 0 ) {\n\t\n\t\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( plane.normal.y > 0 ) {\n\t\n\t\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( plane.normal.z > 0 ) {\n\t\n\t\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetBoundingSphere: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Sphere();\n\t\n\t\t\t\t\tthis.getCenter( result.center );\n\t\n\t\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersect: function ( box ) {\n\t\n\t\t\t\tthis.min.max( box.min );\n\t\t\t\tthis.max.min( box.max );\n\t\n\t\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tunion: function ( box ) {\n\t\n\t\t\t\tthis.min.min( box.min );\n\t\t\t\tthis.max.max( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function () {\n\t\n\t\t\t\tvar points = [\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3()\n\t\t\t\t];\n\t\n\t\t\t\treturn function applyMatrix4( matrix ) {\n\t\n\t\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\t\tif( this.isEmpty() ) return this;\n\t\n\t\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\t\n\t\t\t\t\tthis.setFromPoints( points );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.min.add( offset );\n\t\t\t\tthis.max.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( box ) {\n\t\n\t\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Sphere( center, radius ) {\n\t\n\t\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\t\n\t\t}\n\t\n\t\tSphere.prototype = {\n\t\n\t\t\tconstructor: Sphere,\n\t\n\t\t\tset: function ( center, radius ) {\n\t\n\t\t\t\tthis.center.copy( center );\n\t\t\t\tthis.radius = radius;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function () {\n\t\n\t\t\t\tvar box = new Box3();\n\t\n\t\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\t\n\t\t\t\t\tvar center = this.center;\n\t\n\t\t\t\t\tif ( optionalCenter !== undefined ) {\n\t\n\t\t\t\t\t\tcenter.copy( optionalCenter );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( sphere ) {\n\t\n\t\t\t\tthis.center.copy( sphere.center );\n\t\t\t\tthis.radius = sphere.radius;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tempty: function () {\n\t\n\t\t\t\treturn ( this.radius <= 0 );\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\tvar radiusSum = this.radius + sphere.radius;\n\t\n\t\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\treturn box.intersectsSphere( this );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t\t// the center of the sphere to the plane.\n\t\t\t\t//\n\t\t\t\t// distance = q * n - d\n\t\t\t\t//\n\t\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t\t// then there is no intersection.\n\t\n\t\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tresult.copy( point );\n\t\n\t\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\t\n\t\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\tgetBoundingBox: function ( optionalTarget ) {\n\t\n\t\t\t\tvar box = optionalTarget || new Box3();\n\t\n\t\t\t\tbox.set( this.center, this.center );\n\t\t\t\tbox.expandByScalar( this.radius );\n\t\n\t\t\t\treturn box;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.center.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( sphere ) {\n\t\n\t\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction Matrix3() {\n\t\n\t\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\t\n\t\t\t] );\n\t\n\t\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tMatrix3.prototype = {\n\t\n\t\t\tconstructor: Matrix3,\n\t\n\t\t\tisMatrix3: true,\n\t\n\t\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tidentity: function () {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().fromArray( this.elements );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( m ) {\n\t\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrix4: function( m ) {\n\t\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyToVector3Array: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn array;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyToBuffer: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\t\tv1.applyMatrix3( this );\n\t\n\t\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn buffer;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdeterminant: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\t\n\t\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\n\t\t\t},\n\t\n\t\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\t\n\t\t\t\tif ( (matrix && matrix.isMatrix4) ) {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar me = matrix.elements,\n\t\t\t\t\tte = this.elements,\n\t\n\t\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\t\n\t\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\t\n\t\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\t\n\t\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\t\tif ( throwOnDegenerate === true ) {\n\t\n\t\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this.identity();\n\t\t\t\t}\n\t\n\t\t\t\tvar detInv = 1 / det;\n\t\n\t\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\t\n\t\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\t\n\t\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranspose: function () {\n\t\n\t\t\t\tvar tmp, m = this.elements;\n\t\n\t\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\t\treturn this.toArray( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tgetNormalMatrix: function ( matrix4 ) {\n\t\n\t\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\t\n\t\t\t},\n\t\n\t\t\ttransposeIntoArray: function ( r ) {\n\t\n\t\t\t\tvar m = this.elements;\n\t\n\t\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\t\tr[ 8 ] = m[ 8 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tfor( var i = 0; i < 9; i ++ ) {\n\t\n\t\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\n\t\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\n\t\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Plane( normal, constant ) {\n\t\n\t\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\t\n\t\t}\n\t\n\t\tPlane.prototype = {\n\t\n\t\t\tconstructor: Plane,\n\t\n\t\t\tset: function ( normal, constant ) {\n\t\n\t\t\t\tthis.normal.copy( normal );\n\t\t\t\tthis.constant = constant;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponents: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis.normal.set( x, y, z );\n\t\t\t\tthis.constant = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\t\n\t\t\t\tthis.normal.copy( normal );\n\t\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCoplanarPoints: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\t\n\t\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\t\n\t\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\t\n\t\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( plane ) {\n\t\n\t\t\t\tthis.normal.copy( plane.normal );\n\t\t\t\tthis.constant = plane.constant;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\t\n\t\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\t\tthis.constant *= inverseNormalLength;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.constant *= - 1;\n\t\t\t\tthis.normal.negate();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn this.normal.dot( point ) + this.constant;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSphere: function ( sphere ) {\n\t\n\t\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\t\n\t\t\t},\n\t\n\t\t\tprojectPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\t\n\t\t\t},\n\t\n\t\t\torthoPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\t\n\t\t\t},\n\t\n\t\t\tintersectLine: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function intersectLine( line, optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tvar direction = line.delta( v1 );\n\t\n\t\t\t\t\tvar denominator = this.normal.dot( direction );\n\t\n\t\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\t\n\t\t\t\t\t\t\treturn result.copy( line.start );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\t\n\t\t\t\t\tif ( t < 0 || t > 1 ) {\n\t\n\t\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsLine: function ( line ) {\n\t\n\t\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\t\n\t\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\t\tvar endSign = this.distanceToPoint( line.end );\n\t\n\t\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\treturn box.intersectsPlane( this );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\treturn sphere.intersectsPlane( this );\n\t\n\t\t\t},\n\t\n\t\t\tcoplanarPoint: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar m1 = new Matrix3();\n\t\n\t\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\t\n\t\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\t\n\t\t\t\t\t// transform normal based on theory here:\n\t\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( plane ) {\n\t\n\t\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\tthis.planes = [\n\t\n\t\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\t\n\t\t\t];\n\t\n\t\t}\n\t\n\t\tFrustum.prototype = {\n\t\n\t\t\tconstructor: Frustum,\n\t\n\t\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\t\tplanes[ 5 ].copy( p5 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( frustum ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrix: function ( m ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\t\t\tvar me = m.elements;\n\t\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\t\n\t\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsObject: function () {\n\t\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function intersectsObject( object ) {\n\t\n\t\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSprite: function () {\n\t\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function intersectsSprite( sprite ) {\n\t\n\t\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\t\t\tvar center = sphere.center;\n\t\t\t\tvar negRadius = - sphere.radius;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\t\n\t\t\t\t\tif ( distance < negRadius ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function () {\n\t\n\t\t\t\tvar p1 = new Vector3(),\n\t\t\t\t\tp2 = new Vector3();\n\t\n\t\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\t\n\t\t\t\t\t\tvar plane = planes[ i ];\n\t\n\t\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\t\n\t\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\t\n\t\t\t\t\t\t// if both outside plane, no intersection\n\t\n\t\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\t\n\t\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {\n\t\n\t\t\tvar _gl = _renderer.context,\n\t\t\t_state = _renderer.state,\n\t\t\t_frustum = new Frustum(),\n\t\t\t_projScreenMatrix = new Matrix4(),\n\t\n\t\t\t_lightShadows = _lights.shadows,\n\t\n\t\t\t_shadowMapSize = new Vector2(),\n\t\t\t_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\t\n\t\t\t_lookTarget = new Vector3(),\n\t\t\t_lightPositionWorld = new Vector3(),\n\t\n\t\t\t_renderList = [],\n\t\n\t\t\t_MorphingFlag = 1,\n\t\t\t_SkinningFlag = 2,\n\t\n\t\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\t\n\t\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\t\n\t\t\t_materialCache = {};\n\t\n\t\t\tvar cubeDirections = [\n\t\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t\t];\n\t\n\t\t\tvar cubeUps = [\n\t\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t\t];\n\t\n\t\t\tvar cube2DViewPorts = [\n\t\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t\t];\n\t\n\t\t\t// init\n\t\n\t\t\tvar depthMaterialTemplate = new MeshDepthMaterial();\n\t\t\tdepthMaterialTemplate.depthPacking = RGBADepthPacking;\n\t\t\tdepthMaterialTemplate.clipping = true;\n\t\n\t\t\tvar distanceShader = ShaderLib[ \"distanceRGBA\" ];\n\t\t\tvar distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );\n\t\n\t\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\t\n\t\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\t\n\t\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\t\tdepthMaterial.skinning = useSkinning;\n\t\n\t\t\t\t_depthMaterials[ i ] = depthMaterial;\n\t\n\t\t\t\tvar distanceMaterial = new ShaderMaterial( {\n\t\t\t\t\tdefines: {\n\t\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t\t},\n\t\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\t\tskinning: useSkinning,\n\t\t\t\t\tclipping: true\n\t\t\t\t} );\n\t\n\t\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.enabled = false;\n\t\n\t\t\tthis.autoUpdate = true;\n\t\t\tthis.needsUpdate = false;\n\t\n\t\t\tthis.type = PCFShadowMap;\n\t\n\t\t\tthis.renderReverseSided = true;\n\t\t\tthis.renderSingleSided = true;\n\t\n\t\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\t\n\t\t\t\tif ( _lightShadows.length === 0 ) return;\n\t\n\t\t\t\t// Set GL state for depth map.\n\t\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t\t_state.disable( _gl.BLEND );\n\t\t\t\t_state.setDepthTest( true );\n\t\t\t\t_state.setScissorTest( false );\n\t\n\t\t\t\t// render depth map\n\t\n\t\t\t\tvar faceCount, isPointLight;\n\t\n\t\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\t\tvar shadow = light.shadow;\n\t\n\t\t\t\t\tif ( shadow === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar shadowCamera = shadow.camera;\n\t\n\t\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\t\n\t\t\t\t\tif ( (light && light.isPointLight) ) {\n\t\n\t\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\t\tisPointLight = true;\n\t\n\t\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\t\n\t\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t\t// following orientation:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//  xzXZ\n\t\t\t\t\t\t//   y Y\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t\t// z - Negative z direction\n\t\n\t\t\t\t\t\t// positive X\n\t\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative X\n\t\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// positive Z\n\t\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative Z\n\t\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// positive Y\n\t\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative Y\n\t\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\t\n\t\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\t\tisPointLight = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( shadow.map === null ) {\n\t\n\t\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\t\n\t\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\n\t\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( (shadow && shadow.isSpotLightShadow) ) {\n\t\n\t\t\t\t\t\tshadow.update( light );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\t\tvar shadowMatrix = shadow.matrix;\n\t\n\t\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\t\n\t\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t\t_renderer.clear();\n\t\n\t\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t\t// run a single pass if not\n\t\n\t\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\t\n\t\t\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t\t_state.viewport( vpDimensions );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\t\n\t\t\t\t\t\t// compute shadow matrix\n\t\n\t\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\t\n\t\t\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\t\t\t// set object matrices & frustum culling\n\t\n\t\t\t\t\t\t_renderList.length = 0;\n\t\n\t\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\t\n\t\t\t\t\t\t// render shadow map\n\t\t\t\t\t\t// render regular objects\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\t\tif ( (material && material.isMultiMaterial) ) {\n\t\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Restore GL state.\n\t\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\t\n\t\t\t\tscope.needsUpdate = false;\n\t\n\t\t\t};\n\t\n\t\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tvar result = null;\n\t\n\t\t\t\tvar materialVariants = _depthMaterials;\n\t\t\t\tvar customMaterial = object.customDepthMaterial;\n\t\n\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ! customMaterial ) {\n\t\n\t\t\t\t\tvar useMorphing = false;\n\t\n\t\t\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\t\n\t\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\t\n\t\t\t\t\tvar variantIndex = 0;\n\t\n\t\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\t\n\t\t\t\t\tresult = materialVariants[ variantIndex ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tresult = customMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\t\n\t\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t\t// appropriate state\n\t\n\t\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\t\n\t\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\t\n\t\t\t\t\tif ( materialsForVariant === undefined ) {\n\t\n\t\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\t\n\t\t\t\t\tif ( cachedMaterial === undefined ) {\n\t\n\t\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresult = cachedMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tresult.visible = material.visible;\n\t\t\t\tresult.wireframe = material.wireframe;\n\t\n\t\t\t\tvar side = material.side;\n\t\n\t\t\t\tif ( scope.renderSingleSided && side == DoubleSide ) {\n\t\n\t\t\t\t\tside = FrontSide;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( scope.renderReverseSided ) {\n\t\n\t\t\t\t\tif ( side === FrontSide ) side = BackSide;\n\t\t\t\t\telse if ( side === BackSide ) side = FrontSide;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tresult.side = side;\n\t\n\t\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\n\t\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\t\tresult.linewidth = material.linewidth;\n\t\n\t\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\t\n\t\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectObject( object, camera, shadowCamera ) {\n\t\n\t\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\t\n\t\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\t\n\t\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\t\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t\t_renderList.push( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Ray( origin, direction ) {\n\t\n\t\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\t\n\t\t}\n\t\n\t\tRay.prototype = {\n\t\n\t\t\tconstructor: Ray,\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\tthis.origin.copy( origin );\n\t\t\t\tthis.direction.copy( direction );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( ray ) {\n\t\n\t\t\t\tthis.origin.copy( ray.origin );\n\t\t\t\tthis.direction.copy( ray.direction );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\t\n\t\t\t},\n\t\n\t\t\tlookAt: function ( v ) {\n\t\n\t\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trecast: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function recast( t ) {\n\t\n\t\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tresult.subVectors( point, this.origin );\n\t\t\t\tvar directionDistance = result.dot( this.direction );\n\t\n\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\treturn result.copy( this.origin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceSqToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function distanceSqToPoint( point ) {\n\t\n\t\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\t\n\t\t\t\t\t// point behind the ray\n\t\n\t\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t\t\treturn v1.distanceToSquared( point );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tdistanceSqToSegment: function () {\n\t\n\t\t\t\tvar segCenter = new Vector3();\n\t\t\t\tvar segDir = new Vector3();\n\t\t\t\tvar diff = new Vector3();\n\t\n\t\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\t\n\t\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t\t// defined by v0 and v1\n\t\t\t\t\t// It can also set two optional targets :\n\t\t\t\t\t// - The closest point on the ray\n\t\t\t\t\t// - The closest point on the segment\n\t\n\t\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\t\n\t\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\t\tvar s0, s1, sqrDist, extDet;\n\t\n\t\t\t\t\tif ( det > 0 ) {\n\t\n\t\t\t\t\t\t// The ray and segment are not parallel.\n\t\n\t\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\t\textDet = segExtent * det;\n\t\n\t\t\t\t\t\tif ( s0 >= 0 ) {\n\t\n\t\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\t\n\t\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\t\n\t\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t// region 1\n\t\n\t\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 5\n\t\n\t\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 4\n\t\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 3\n\t\n\t\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 2\n\t\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// Ray and segment are parallel.\n\t\n\t\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( optionalPointOnRay ) {\n\t\n\t\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( optionalPointOnSegment ) {\n\t\n\t\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn sqrDist;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectSphere: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\t\n\t\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\t\n\t\t\t\t\tif ( d2 > radius2 ) return null;\n\t\n\t\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\t\n\t\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\t\tvar t0 = tca - thc;\n\t\n\t\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\t\tvar t1 = tca + thc;\n\t\n\t\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\t\n\t\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\t\n\t\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\t\treturn this.at( t0, optionalTarget );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPlane: function ( plane ) {\n\t\n\t\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\t\n\t\t\t\t\t\treturn 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\t\n\t\t\t\t// Return if the ray never intersects the plane\n\t\n\t\t\t\treturn t >= 0 ? t :  null;\n\t\n\t\t\t},\n\t\n\t\t\tintersectPlane: function ( plane, optionalTarget ) {\n\t\n\t\t\t\tvar t = this.distanceToPlane( plane );\n\t\n\t\t\t\tif ( t === null ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.at( t, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// check if the ray lies on the plane first\n\t\n\t\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\t\n\t\t\t\tif ( distToPoint === 0 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\t\tif ( denominator * distToPoint < 0 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tintersectBox: function ( box, optionalTarget ) {\n\t\n\t\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\t\n\t\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\t\tinvdirz = 1 / this.direction.z;\n\t\n\t\t\t\tvar origin = this.origin;\n\t\n\t\t\t\tif ( invdirx >= 0 ) {\n\t\n\t\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( invdiry >= 0 ) {\n\t\n\t\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\t\n\t\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\t\n\t\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\t\n\t\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\t\n\t\t\t\tif ( invdirz >= 0 ) {\n\t\n\t\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\t\n\t\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\t\n\t\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\t\n\t\t\t\t//return point closest to the ray (positive side)\n\t\n\t\t\t\tif ( tmax < 0 ) return null;\n\t\n\t\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: ( function () {\n\t\n\t\t\t\tvar v = new Vector3();\n\t\n\t\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tintersectTriangle: function () {\n\t\n\t\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\t\tvar diff = new Vector3();\n\t\t\t\tvar edge1 = new Vector3();\n\t\t\t\tvar edge2 = new Vector3();\n\t\t\t\tvar normal = new Vector3();\n\t\n\t\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\t\n\t\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\t\n\t\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\t\n\t\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\t\tvar sign;\n\t\n\t\t\t\t\tif ( DdN > 0 ) {\n\t\n\t\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\t\tsign = 1;\n\t\n\t\t\t\t\t} else if ( DdN < 0 ) {\n\t\n\t\t\t\t\t\tsign = - 1;\n\t\t\t\t\t\tDdN = - DdN;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\t\n\t\t\t\t\t// b1 < 0, no intersection\n\t\t\t\t\tif ( DdQxE2 < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\t\n\t\t\t\t\t// b2 < 0, no intersection\n\t\t\t\t\tif ( DdE1xQ < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\t\n\t\t\t\t\t// t < 0, no intersection\n\t\t\t\t\tif ( QdN < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Ray intersects triangle.\n\t\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyMatrix4: function ( matrix4 ) {\n\t\n\t\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\t\tthis.direction.sub( this.origin );\n\t\t\t\tthis.direction.normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( ray ) {\n\t\n\t\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Euler( x, y, z, order ) {\n\t\n\t\t\tthis._x = x || 0;\n\t\t\tthis._y = y || 0;\n\t\t\tthis._z = z || 0;\n\t\t\tthis._order = order || Euler.DefaultOrder;\n\t\n\t\t}\n\t\n\t\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\t\n\t\tEuler.DefaultOrder = 'XYZ';\n\t\n\t\tEuler.prototype = {\n\t\n\t\t\tconstructor: Euler,\n\t\n\t\t\tisEuler: true,\n\t\n\t\t\tget x () {\n\t\n\t\t\t\treturn this._x;\n\t\n\t\t\t},\n\t\n\t\t\tset x ( value ) {\n\t\n\t\t\t\tthis._x = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget y () {\n\t\n\t\t\t\treturn this._y;\n\t\n\t\t\t},\n\t\n\t\t\tset y ( value ) {\n\t\n\t\t\t\tthis._y = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget z () {\n\t\n\t\t\t\treturn this._z;\n\t\n\t\t\t},\n\t\n\t\t\tset z ( value ) {\n\t\n\t\t\t\tthis._z = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget order () {\n\t\n\t\t\t\treturn this._order;\n\t\n\t\t\t},\n\t\n\t\t\tset order ( value ) {\n\t\n\t\t\t\tthis._order = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( x, y, z, order ) {\n\t\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\tthis._order = order || this._order;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( euler ) {\n\t\n\t\t\t\tthis._x = euler._x;\n\t\t\t\tthis._y = euler._y;\n\t\t\t\tthis._z = euler._z;\n\t\t\t\tthis._order = euler._order;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\t\n\t\t\t\tvar clamp = _Math.clamp;\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar te = m.elements;\n\t\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\t\torder = order || this._order;\n\t\n\t\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._y = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._order = order;\n\t\n\t\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromQuaternion: function () {\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\treturn function setFromQuaternion( q, order, update ) {\n\t\n\t\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\t\n\t\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\t\n\t\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetFromVector3: function ( v, order ) {\n\t\n\t\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\t\n\t\t\t},\n\t\n\t\t\treorder: function () {\n\t\n\t\t\t\t// WARNING: this discards revolution information -bhouston\n\t\n\t\t\t\tvar q = new Quaternion();\n\t\n\t\t\t\treturn function reorder( newOrder ) {\n\t\n\t\t\t\t\tq.setFromEuler( this );\n\t\n\t\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tequals: function ( euler ) {\n\t\n\t\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array ) {\n\t\n\t\t\t\tthis._x = array[ 0 ];\n\t\t\t\tthis._y = array[ 1 ];\n\t\t\t\tthis._z = array[ 2 ];\n\t\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this._x;\n\t\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\t\tarray[ offset + 3 ] = this._order;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\ttoVector3: function ( optionalResult ) {\n\t\n\t\t\t\tif ( optionalResult ) {\n\t\n\t\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tonChange: function ( callback ) {\n\t\n\t\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tonChangeCallback: function () {}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Layers() {\n\t\n\t\t\tthis.mask = 1;\n\t\n\t\t}\n\t\n\t\tLayers.prototype = {\n\t\n\t\t\tconstructor: Layers,\n\t\n\t\t\tset: function ( channel ) {\n\t\n\t\t\t\tthis.mask = 1 << channel;\n\t\n\t\t\t},\n\t\n\t\t\tenable: function ( channel ) {\n\t\n\t\t\t\tthis.mask |= 1 << channel;\n\t\n\t\t\t},\n\t\n\t\t\ttoggle: function ( channel ) {\n\t\n\t\t\t\tthis.mask ^= 1 << channel;\n\t\n\t\t\t},\n\t\n\t\t\tdisable: function ( channel ) {\n\t\n\t\t\t\tthis.mask &= ~ ( 1 << channel );\n\t\n\t\t\t},\n\t\n\t\t\ttest: function ( layers ) {\n\t\n\t\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author elephantatwork / www.elephantatwork.ch\n\t\t */\n\t\n\t\tfunction Object3D() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: Object3DIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Object3D';\n\t\n\t\t\tthis.parent = null;\n\t\t\tthis.children = [];\n\t\n\t\t\tthis.up = Object3D.DefaultUp.clone();\n\t\n\t\t\tvar position = new Vector3();\n\t\t\tvar rotation = new Euler();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3( 1, 1, 1 );\n\t\n\t\t\tfunction onRotationChange() {\n\t\n\t\t\t\tquaternion.setFromEuler( rotation, false );\n\t\n\t\t\t}\n\t\n\t\t\tfunction onQuaternionChange() {\n\t\n\t\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\t\n\t\t\t}\n\t\n\t\t\trotation.onChange( onRotationChange );\n\t\t\tquaternion.onChange( onQuaternionChange );\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\tposition: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: position\n\t\t\t\t},\n\t\t\t\trotation: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: rotation\n\t\t\t\t},\n\t\t\t\tquaternion: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: quaternion\n\t\t\t\t},\n\t\t\t\tscale: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: scale\n\t\t\t\t},\n\t\t\t\tmodelViewMatrix: {\n\t\t\t\t\tvalue: new Matrix4()\n\t\t\t\t},\n\t\t\t\tnormalMatrix: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.matrixWorld = new Matrix4();\n\t\n\t\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.visible = true;\n\t\n\t\t\tthis.castShadow = false;\n\t\t\tthis.receiveShadow = false;\n\t\n\t\t\tthis.frustumCulled = true;\n\t\t\tthis.renderOrder = 0;\n\t\n\t\t\tthis.userData = {};\n\t\n\t\t\tthis.onBeforeRender = function(){}; \n\t\t\tthis.onAfterRender = function(){};\n\t\n\t\t}\n\t\n\t\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\t\tObject3D.DefaultMatrixAutoUpdate = true;\n\t\n\t\tObject.assign( Object3D.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisObject3D: true,\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\t\n\t\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t\t// assumes axis is normalized\n\t\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromEuler: function ( euler ) {\n\t\n\t\t\t\tthis.quaternion.setFromEuler( euler, true );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromMatrix: function ( m ) {\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t\t// assumes q is normalized\n\t\n\t\t\t\tthis.quaternion.copy( q );\n\t\n\t\t\t},\n\t\n\t\t\trotateOnAxis: function () {\n\t\n\t\t\t\t// rotate object on axis in object space\n\t\t\t\t// axis is assumed to be normalized\n\t\n\t\t\t\tvar q1 = new Quaternion();\n\t\n\t\t\t\treturn function rotateOnAxis( axis, angle ) {\n\t\n\t\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\t\n\t\t\t\t\tthis.quaternion.multiply( q1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateOnAxis: function () {\n\t\n\t\t\t\t// translate object by distance along axis in object space\n\t\t\t\t// axis is assumed to be normalized\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function translateOnAxis( axis, distance ) {\n\t\n\t\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\t\n\t\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateX: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\t\n\t\t\t\treturn function translateX( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateY: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\t\n\t\t\t\treturn function translateY( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateZ: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\t\n\t\t\t\treturn function translateZ( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlocalToWorld: function ( vector ) {\n\t\n\t\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\t\n\t\t\t},\n\t\n\t\t\tworldToLocal: function () {\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function worldToLocal( vector ) {\n\t\n\t\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\t\n\t\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tadd: function ( object ) {\n\t\n\t\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\t\tthis.add( arguments[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object === this ) {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( (object && object.isObject3D) ) {\n\t\n\t\t\t\t\tif ( object.parent !== null ) {\n\t\n\t\t\t\t\t\tobject.parent.remove( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.parent = this;\n\t\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\t\n\t\t\t\t\tthis.children.push( object );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tremove: function ( object ) {\n\t\n\t\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\t\tthis.remove( arguments[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar index = this.children.indexOf( object );\n\t\n\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\tobject.parent = null;\n\t\n\t\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\t\n\t\t\t\t\tthis.children.splice( index, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectById: function ( id ) {\n\t\n\t\t\t\treturn this.getObjectByProperty( 'id', id );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectByName: function ( name ) {\n\t\n\t\t\t\treturn this.getObjectByProperty( 'name', name );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectByProperty: function ( name, value ) {\n\t\n\t\t\t\tif ( this[ name ] === value ) return this;\n\t\n\t\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar child = this.children[ i ];\n\t\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\t\n\t\t\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\t\t\treturn object;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn undefined;\n\t\n\t\t\t},\n\t\n\t\t\tgetWorldPosition: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t},\n\t\n\t\t\tgetWorldQuaternion: function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar scale = new Vector3();\n\t\n\t\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Quaternion();\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldRotation: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldRotation( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Euler();\n\t\n\t\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldScale: function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldScale( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldDirection: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\traycast: function () {},\n\t\n\t\t\ttraverse: function ( callback ) {\n\t\n\t\t\t\tcallback( this );\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].traverse( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttraverseVisible: function ( callback ) {\n\t\n\t\t\t\tif ( this.visible === false ) return;\n\t\n\t\t\t\tcallback( this );\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].traverseVisible( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttraverseAncestors: function ( callback ) {\n\t\n\t\t\t\tvar parent = this.parent;\n\t\n\t\t\t\tif ( parent !== null ) {\n\t\n\t\t\t\t\tcallback( parent );\n\t\n\t\t\t\t\tparent.traverseAncestors( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrix: function () {\n\t\n\t\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\t\n\t\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: function ( force ) {\n\t\n\t\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\t\n\t\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\t\n\t\t\t\t\tif ( this.parent === null ) {\n\t\n\t\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\t\t\tforce = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update children\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\t// meta is '' when called from JSON.stringify\n\t\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\t\n\t\t\t\tvar output = {};\n\t\n\t\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t\t// not providing it implies that this is the root object\n\t\t\t\t// being serialized.\n\t\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t\t// initialize meta obj\n\t\t\t\t\tmeta = {\n\t\t\t\t\t\tgeometries: {},\n\t\t\t\t\t\tmaterials: {},\n\t\t\t\t\t\ttextures: {},\n\t\t\t\t\t\timages: {}\n\t\t\t\t\t};\n\t\n\t\t\t\t\toutput.metadata = {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Object',\n\t\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// standard Object3D serialization\n\t\n\t\t\t\tvar object = {};\n\t\n\t\t\t\tobject.uuid = this.uuid;\n\t\t\t\tobject.type = this.type;\n\t\n\t\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\t\tif ( this.visible === false ) object.visible = false;\n\t\n\t\t\t\tobject.matrix = this.matrix.toArray();\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( this.geometry !== undefined ) {\n\t\n\t\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.geometry = this.geometry.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.material !== undefined ) {\n\t\n\t\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.material = this.material.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( this.children.length > 0 ) {\n\t\n\t\t\t\t\tobject.children = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\t\n\t\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\t\tif ( images.length > 0 ) output.images = images;\n\t\n\t\t\t\t}\n\t\n\t\t\t\toutput.object = object;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t\t// extract data from the cache hash\n\t\t\t\t// remove metadata on each item\n\t\t\t\t// and return as array\n\t\t\t\tfunction extractFromCache( cache ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function ( recursive ) {\n\t\n\t\t\t\treturn new this.constructor().copy( this, recursive );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\t\tif ( recursive === undefined ) recursive = true;\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\tthis.up.copy( source.up );\n\t\n\t\t\t\tthis.position.copy( source.position );\n\t\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\t\tthis.scale.copy( source.scale );\n\t\n\t\t\t\tthis.matrix.copy( source.matrix );\n\t\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\t\n\t\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\t\n\t\t\t\tthis.visible = source.visible;\n\t\n\t\t\t\tthis.castShadow = source.castShadow;\n\t\t\t\tthis.receiveShadow = source.receiveShadow;\n\t\n\t\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\t\tthis.renderOrder = source.renderOrder;\n\t\n\t\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\t\n\t\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\t\tthis.add( child.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar count$2 = 0;\n\t\tfunction Object3DIdCount() { return count$2++; }\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Line3( start, end ) {\n\t\n\t\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\t\n\t\t}\n\t\n\t\tLine3.prototype = {\n\t\n\t\t\tconstructor: Line3,\n\t\n\t\t\tset: function ( start, end ) {\n\t\n\t\t\t\tthis.start.copy( start );\n\t\t\t\tthis.end.copy( end );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( line ) {\n\t\n\t\t\t\tthis.start.copy( line.start );\n\t\t\t\tthis.end.copy( line.end );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tdelta: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.subVectors( this.end, this.start );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceSq: function () {\n\t\n\t\t\t\treturn this.start.distanceToSquared( this.end );\n\t\n\t\t\t},\n\t\n\t\t\tdistance: function () {\n\t\n\t\t\t\treturn this.start.distanceTo( this.end );\n\t\n\t\t\t},\n\t\n\t\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t\t},\n\t\n\t\t\tclosestPointToPointParameter: function () {\n\t\n\t\t\t\tvar startP = new Vector3();\n\t\t\t\tvar startEnd = new Vector3();\n\t\n\t\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\t\n\t\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\t\n\t\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\t\n\t\t\t\t\tvar t = startEnd_startP / startEnd2;\n\t\n\t\t\t\t\tif ( clampToLine ) {\n\t\n\t\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn t;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\t\n\t\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\t\tthis.end.applyMatrix4( matrix );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( line ) {\n\t\n\t\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Triangle( a, b, c ) {\n\t\n\t\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\t\n\t\t}\n\t\n\t\tTriangle.normal = function () {\n\t\n\t\t\tvar v0 = new Vector3();\n\t\n\t\t\treturn function normal( a, b, c, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tresult.subVectors( c, b );\n\t\t\t\tv0.subVectors( a, b );\n\t\t\t\tresult.cross( v0 );\n\t\n\t\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\t\tif ( resultLengthSq > 0 ) {\n\t\n\t\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result.set( 0, 0, 0 );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t// static/instance method to calculate barycentric coordinates\n\t\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\t\tTriangle.barycoordFromPoint = function () {\n\t\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\n\t\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\t\n\t\t\t\tv0.subVectors( c, a );\n\t\t\t\tv1.subVectors( b, a );\n\t\t\t\tv2.subVectors( point, a );\n\t\n\t\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\t\tvar dot12 = v1.dot( v2 );\n\t\n\t\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t// collinear or singular triangle\n\t\t\t\tif ( denom === 0 ) {\n\t\n\t\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar invDenom = 1 / denom;\n\t\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\t\n\t\t\t\t// barycentric coordinates must always sum to 1\n\t\t\t\treturn result.set( 1 - u - v, v, u );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tTriangle.containsPoint = function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\n\t\t\treturn function containsPoint( point, a, b, c ) {\n\t\n\t\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\t\n\t\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tTriangle.prototype = {\n\t\n\t\t\tconstructor: Triangle,\n\t\n\t\t\tset: function ( a, b, c ) {\n\t\n\t\t\t\tthis.a.copy( a );\n\t\t\t\tthis.b.copy( b );\n\t\t\t\tthis.c.copy( c );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\t\n\t\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\t\tthis.c.copy( points[ i2 ] );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( triangle ) {\n\t\n\t\t\t\tthis.a.copy( triangle.a );\n\t\t\t\tthis.b.copy( triangle.b );\n\t\t\t\tthis.c.copy( triangle.c );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tarea: function () {\n\t\n\t\t\t\tvar v0 = new Vector3();\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function area() {\n\t\n\t\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\t\tv1.subVectors( this.a, this.b );\n\t\n\t\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmidpoint: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\t\n\t\t\t},\n\t\n\t\t\tnormal: function ( optionalTarget ) {\n\t\n\t\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tplane: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Plane();\n\t\n\t\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\n\t\t\t},\n\t\n\t\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\t\n\t\t\t},\n\t\n\t\t\tclosestPointToPoint: function () {\n\t\n\t\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\t\n\t\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\t\n\t\t\t\t\tif ( plane === undefined ) {\n\t\n\t\t\t\t\t\tplane = new Plane();\n\t\t\t\t\t\tedgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\t\t\t\tprojectedPoint = new Vector3();\n\t\t\t\t\t\tclosestPoint = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\t\tvar minDistance = Infinity;\n\t\n\t\t\t\t\t// project the point onto the plane of the triangle\n\t\n\t\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\t\tplane.projectPoint( point, projectedPoint );\n\t\n\t\t\t\t\t// check if the projection lies within the triangle\n\t\n\t\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\t\n\t\t\t\t\t\t// if so, this is the closest point\n\t\n\t\t\t\t\t\tresult.copy( projectedPoint );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\t\n\t\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\t\n\t\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\t\n\t\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\t\n\t\t\t\t\t\t\tif( distance < minDistance ) {\n\t\n\t\t\t\t\t\t\t\tminDistance = distance;\n\t\n\t\t\t\t\t\t\t\tresult.copy( closestPoint );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tequals: function ( triangle ) {\n\t\n\t\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\t\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\n\t\t\tthis.normal = (normal && normal.isVector3) ? normal : new Vector3();\n\t\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\t\n\t\t\tthis.color = (color && color.isColor) ? color : new Color();\n\t\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\t\n\t\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\t\n\t\t}\n\t\n\t\tFace3.prototype = {\n\t\n\t\t\tconstructor: Face3,\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.a = source.a;\n\t\t\t\tthis.b = source.b;\n\t\t\t\tthis.c = source.c;\n\t\n\t\t\t\tthis.normal.copy( source.normal );\n\t\t\t\tthis.color.copy( source.color );\n\t\n\t\t\t\tthis.materialIndex = source.materialIndex;\n\t\n\t\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  shading: THREE.SmoothShading,\n\t\t *  depthTest: <bool>,\n\t\t *  depthWrite: <bool>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshBasicMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshBasicMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // emissive\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\t\n\t\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\t\n\t\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t}\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.array = array;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\t\tthis.normalized = normalized === true;\n\t\n\t\t\tthis.dynamic = false;\n\t\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\t\tthis.version = 0;\n\t\n\t\t}\n\t\n\t\tBufferAttribute.prototype = {\n\t\n\t\t\tconstructor: BufferAttribute,\n\t\n\t\t\tisBufferAttribute: true,\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t},\n\t\n\t\t\tsetArray: function ( array ) {\n\t\n\t\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\t\tthis.array = array;\n\t\n\t\t\t},\n\t\n\t\t\tsetDynamic: function ( value ) {\n\t\n\t\t\t\tthis.dynamic = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\t\tthis.itemSize = source.itemSize;\n\t\t\t\tthis.count = source.count;\n\t\t\t\tthis.normalized = source.normalized;\n\t\n\t\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\t\tindex1 *= this.itemSize;\n\t\t\t\tindex2 *= attribute.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyArray: function ( array ) {\n\t\n\t\t\t\tthis.array.set( array );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyColorsArray: function ( colors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar color = colors[ i ];\n\t\n\t\t\t\t\tif ( color === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\t\tcolor = new Color();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\t\tarray[ offset ++ ] = color.b;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyIndicesArray: function ( indices ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar index = indices[ i ];\n\t\n\t\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\t\tarray[ offset ++ ] = index.c;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector2sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector2();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector3sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector4sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\t\tarray[ offset ++ ] = vector.w;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.array.set( value, offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetX: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize ];\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( index, x ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize ] = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetY: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( index, y ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetZ: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( index, z ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetW: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( index, w ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\t\t\tthis.array[ index + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\t\t\tthis.array[ index + 2 ] = z;\n\t\t\t\tthis.array[ index + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction Int8Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Int8Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint8Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint8Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Int16Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Int16Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint16Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint16Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Int32Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Int32Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint32Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint32Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Float32Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Float32Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Float64Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Float64Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\t// Deprecated\n\t\n\t\tfunction DynamicBufferAttribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author kile / http://kile.stravaganza.org/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Geometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Geometry';\n\t\n\t\t\tthis.vertices = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\n\t\t\tthis.morphTargets = [];\n\t\t\tthis.morphNormals = [];\n\t\n\t\t\tthis.skinWeights = [];\n\t\t\tthis.skinIndices = [];\n\t\n\t\t\tthis.lineDistances = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t// update flags\n\t\n\t\t\tthis.elementsNeedUpdate = false;\n\t\t\tthis.verticesNeedUpdate = false;\n\t\t\tthis.uvsNeedUpdate = false;\n\t\t\tthis.normalsNeedUpdate = false;\n\t\t\tthis.colorsNeedUpdate = false;\n\t\t\tthis.lineDistancesNeedUpdate = false;\n\t\t\tthis.groupsNeedUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( Geometry.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisGeometry: true,\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\t\tvertex.applyMatrix4( matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.verticesNeedUpdate = true;\n\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function () {\n\t\n\t\t\t\t// translate geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tscale: function () {\n\t\n\t\t\t\t// scale geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar obj;\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\t\n\t\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tfromBufferGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\tvar positions = attributes.position.array;\n\t\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\t\n\t\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\t\n\t\t\t\tvar tempNormals = [];\n\t\t\t\tvar tempUVs = [];\n\t\t\t\tvar tempUVs2 = [];\n\t\n\t\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\t\n\t\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\t\n\t\t\t\t\tif ( normals !== undefined ) {\n\t\n\t\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( colors !== undefined ) {\n\t\n\t\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\t\n\t\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\t\n\t\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\t\n\t\t\t\t\tscope.faces.push( face );\n\t\n\t\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( indices !== undefined ) {\n\t\n\t\t\t\t\tvar groups = geometry.groups;\n\t\n\t\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\t\n\t\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\t\n\t\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcenter: function () {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\t\n\t\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\t\treturn offset;\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\tvar center = this.boundingSphere.center;\n\t\t\t\tvar radius = this.boundingSphere.radius;\n\t\n\t\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\t\t\tmatrix.set(\n\t\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t);\n\t\n\t\t\t\tthis.applyMatrix( matrix );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\t\n\t\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ f ];\n\t\n\t\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\t\tvar vC = this.vertices[ face.c ];\n\t\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\tcb.normalize();\n\t\n\t\t\t\t\tface.normal.copy( cb );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\t\n\t\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\t\n\t\t\t\tvar v, vl, f, fl, face, vertices;\n\t\n\t\t\t\tvertices = new Array( this.vertices.length );\n\t\n\t\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\tvertices[ v ] = new Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( areaWeighted ) {\n\t\n\t\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\t\n\t\t\t\t\tvar vA, vB, vC;\n\t\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\t\tvC = this.vertices[ face.c ];\n\t\n\t\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\t\tvertices[ face.c ].add( cb );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\tvertices[ v ].normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFlatVertexNormals: function () {\n\t\n\t\t\t\tvar f, fl, face;\n\t\n\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeMorphNormals: function () {\n\t\n\t\t\t\tvar i, il, f, fl, face;\n\t\n\t\t\t\t// save original normals\n\t\t\t\t// - create temp variables on first access\n\t\t\t\t//   otherwise just copy (for faster repeated calls)\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\t\n\t\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\t\n\t\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\t\n\t\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\t\n\t\t\t\tvar tmpGeo = new Geometry();\n\t\t\t\ttmpGeo.faces = this.faces;\n\t\n\t\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t// create on first access\n\t\n\t\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\t\n\t\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\t\n\t\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\t\n\t\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\t\n\t\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\t\n\t\t\t\t\t// set vertices to morph target\n\t\n\t\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t// compute morph normals\n\t\n\t\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\t\ttmpGeo.computeVertexNormals();\n\t\n\t\t\t\t\t// store morph normals\n\t\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\t\n\t\t\t\t\t\tfaceNormal.copy( face.normal );\n\t\n\t\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore original normals\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeTangents: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeLineDistances: function () {\n\t\n\t\t\t\tvar d = 0;\n\t\t\t\tvar vertices = this.vertices;\n\t\n\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tif ( i > 0 ) {\n\t\n\t\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.lineDistances[ i ] = d;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingBox: function () {\n\t\n\t\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\t\tthis.boundingBox = new Box3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\t\n\t\t\t},\n\t\n\t\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\t\n\t\t\t\tif ( (geometry && geometry.isGeometry) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normalMatrix,\n\t\t\t\tvertexOffset = this.vertices.length,\n\t\t\t\tvertices1 = this.vertices,\n\t\t\t\tvertices2 = geometry.vertices,\n\t\t\t\tfaces1 = this.faces,\n\t\t\t\tfaces2 = geometry.faces,\n\t\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\t\tcolors1 = this.colors,\n\t\t\t\tcolors2 = geometry.colors;\n\t\n\t\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\t\n\t\t\t\tif ( matrix !== undefined ) {\n\t\n\t\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// vertices\n\t\n\t\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = vertices2[ i ];\n\t\n\t\t\t\t\tvar vertexCopy = vertex.clone();\n\t\n\t\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\t\n\t\t\t\t\tvertices1.push( vertexCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// colors\n\t\n\t\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// faces\n\t\n\t\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\t\tfaceVertexColors = face.vertexColors;\n\t\n\t\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\t\tfaceCopy.normal.copy( face.normal );\n\t\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\t\n\t\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.color.copy( face.color );\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\t\n\t\t\t\t\tfaces1.push( faceCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// uvs\n\t\n\t\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\t\n\t\t\t\t\tif ( uv === undefined ) {\n\t\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuvs1.push( uvCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmergeMesh: function ( mesh ) {\n\t\n\t\t\t\tif ( (mesh && mesh.isMesh) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\t\n\t\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\t\n\t\t\t},\n\t\n\t\t\t/*\n\t\t\t * Checks for duplicate vertices with hashmap.\n\t\t\t * Duplicated vertices are removed\n\t\t\t * and faces' vertices are updated.\n\t\t\t */\n\t\n\t\t\tmergeVertices: function () {\n\t\n\t\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\t\tvar unique = [], changes = [];\n\t\n\t\t\t\tvar v, key;\n\t\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\t\tvar i, il, face;\n\t\t\t\tvar indices, j, jl;\n\t\n\t\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tv = this.vertices[ i ];\n\t\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\t\n\t\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\t\n\t\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t\t// have to remove them from the geometry.\n\t\t\t\tvar faceIndicesToRemove = [];\n\t\n\t\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ i ];\n\t\n\t\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\t\tface.c = changes[ face.c ];\n\t\n\t\t\t\t\tindices = [ face.a, face.b, face.c ];\n\t\n\t\t\t\t\tvar dupIndex = - 1;\n\t\n\t\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\t\n\t\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\t\n\t\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\t\n\t\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\t\n\t\t\t\t\tthis.faces.splice( idx, 1 );\n\t\n\t\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Use unique set of vertices\n\t\n\t\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\t\tthis.vertices = unique;\n\t\t\t\treturn diff;\n\t\n\t\t\t},\n\t\n\t\t\tsortFacesByMaterialIndex: function () {\n\t\n\t\t\t\tvar faces = this.faces;\n\t\t\t\tvar length = faces.length;\n\t\n\t\t\t\t// tag faces\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tfaces[ i ]._id = i;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// sort faces\n\t\n\t\t\t\tfunction materialIndexSort( a, b ) {\n\t\n\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfaces.sort( materialIndexSort );\n\t\n\t\t\t\t// sort uvs\n\t\n\t\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\t\n\t\t\t\tvar newUvs1, newUvs2;\n\t\n\t\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tvar id = faces[ i ]._id;\n\t\n\t\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard Geometry serialization\n\t\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar vertices = [];\n\t\n\t\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar faces = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar normalsHash = {};\n\t\t\t\tvar colors = [];\n\t\t\t\tvar colorsHash = {};\n\t\t\t\tvar uvs = [];\n\t\t\t\tvar uvsHash = {};\n\t\n\t\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ i ];\n\t\n\t\t\t\t\tvar hasMaterial = true;\n\t\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\t\n\t\t\t\t\tvar faceType = 0;\n\t\n\t\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\t\n\t\t\t\t\tfaces.push( faceType );\n\t\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\t\tfaces.push( face.materialIndex );\n\t\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction setBit( value, position, enabled ) {\n\t\n\t\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getNormalIndex( normal ) {\n\t\n\t\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\t\n\t\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getColorIndex( color ) {\n\t\n\t\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\t\n\t\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\t\tcolors.push( color.getHex() );\n\t\n\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getUvIndex( uv ) {\n\t\n\t\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\t\n\t\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdata.data = {};\n\t\n\t\t\t\tdata.data.vertices = vertices;\n\t\t\t\tdata.data.normals = normals;\n\t\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\t\tdata.data.faces = faces;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\t/*\n\t\t\t\t// Handle primitives\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\t\treturn geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\t\t\t*/\n\t\n\t\t\t\treturn new Geometry().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.vertices = [];\n\t\t\t\tthis.faces = [];\n\t\t\t\tthis.faceVertexUvs = [ [] ];\n\t\t\t\tthis.colors = [];\n\t\n\t\t\t\tvar vertices = source.vertices;\n\t\n\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar colors = source.colors;\n\t\n\t\t\t\tfor ( var i = 0, il = colors.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar faces = source.faces;\n\t\n\t\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\t\n\t\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\t\n\t\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\tvar uv = uvs[ k ];\n\t\n\t\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar count$3 = 0;\n\t\tfunction GeometryIdCount() { return count$3++; }\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction DirectGeometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'DirectGeometry';\n\t\n\t\t\tthis.indices = [];\n\t\t\tthis.vertices = [];\n\t\t\tthis.normals = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.uvs = [];\n\t\t\tthis.uvs2 = [];\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t\tthis.morphTargets = {};\n\t\n\t\t\tthis.skinWeights = [];\n\t\t\tthis.skinIndices = [];\n\t\n\t\t\t// this.lineDistances = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t// update flags\n\t\n\t\t\tthis.verticesNeedUpdate = false;\n\t\t\tthis.normalsNeedUpdate = false;\n\t\t\tthis.colorsNeedUpdate = false;\n\t\t\tthis.uvsNeedUpdate = false;\n\t\t\tthis.groupsNeedUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( DirectGeometry.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tcomputeBoundingBox: Geometry.prototype.computeBoundingBox,\n\t\t\tcomputeBoundingSphere: Geometry.prototype.computeBoundingSphere,\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeGroups: function ( geometry ) {\n\t\n\t\t\t\tvar group;\n\t\t\t\tvar groups = [];\n\t\t\t\tvar materialIndex;\n\t\n\t\t\t\tvar faces = geometry.faces;\n\t\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\t// materials\n\t\n\t\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\t\n\t\t\t\t\t\tmaterialIndex = face.materialIndex;\n\t\n\t\t\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgroup = {\n\t\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.groups = groups;\n\t\n\t\t\t},\n\t\n\t\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\t\n\t\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\tvar morphTargetsLength = morphTargets.length;\n\t\n\t\t\t\tvar morphTargetsPosition;\n\t\n\t\t\t\tif ( morphTargetsLength > 0 ) {\n\t\n\t\t\t\t\tmorphTargetsPosition = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\t\n\t\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\t\tvar morphNormalsLength = morphNormals.length;\n\t\n\t\t\t\tvar morphTargetsNormal;\n\t\n\t\t\t\tif ( morphNormalsLength > 0 ) {\n\t\n\t\t\t\t\tmorphTargetsNormal = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\t\n\t\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skins\n\t\n\t\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\t\tvar skinWeights = geometry.skinWeights;\n\t\n\t\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\tif ( vertexColors.length === 3 ) {\n\t\n\t\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar color = face.color;\n\t\n\t\t\t\t\t\tthis.colors.push( color, color, color );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexUv === true ) {\n\t\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\t\n\t\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\t\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\t\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\t\n\t\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// morphs\n\t\n\t\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\t\n\t\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\t\n\t\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\t\n\t\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\t\n\t\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// skins\n\t\n\t\t\t\t\tif ( hasSkinIndices ) {\n\t\n\t\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasSkinWeights ) {\n\t\n\t\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.computeGroups( geometry );\n\t\n\t\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferGeometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'BufferGeometry';\n\t\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\n\t\t\tthis.morphAttributes = {};\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\tthis.drawRange = { start: 0, count: Infinity };\n\t\n\t\t}\n\t\n\t\tObject.assign( BufferGeometry.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisBufferGeometry: true,\n\t\n\t\t\tgetIndex: function () {\n\t\n\t\t\t\treturn this.index;\n\t\n\t\t\t},\n\t\n\t\t\tsetIndex: function ( index ) {\n\t\n\t\t\t\tthis.index = index;\n\t\n\t\t\t},\n\t\n\t\t\taddAttribute: function ( name, attribute ) {\n\t\n\t\t\t\tif ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\t\n\t\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( name === 'index' ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\t\tthis.setIndex( attribute );\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.attributes[ name ] = attribute;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetAttribute: function ( name ) {\n\t\n\t\t\t\treturn this.attributes[ name ];\n\t\n\t\t\t},\n\t\n\t\t\tremoveAttribute: function ( name ) {\n\t\n\t\t\t\tdelete this.attributes[ name ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddGroup: function ( start, count, materialIndex ) {\n\t\n\t\t\t\tthis.groups.push( {\n\t\n\t\t\t\t\tstart: start,\n\t\t\t\t\tcount: count,\n\t\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\t\n\t\t\t\t} );\n\t\n\t\t\t},\n\t\n\t\t\tclearGroups: function () {\n\t\n\t\t\t\tthis.groups = [];\n\t\n\t\t\t},\n\t\n\t\t\tsetDrawRange: function ( start, count ) {\n\t\n\t\t\t\tthis.drawRange.start = start;\n\t\t\t\tthis.drawRange.count = count;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tvar position = this.attributes.position;\n\t\n\t\t\t\tif ( position !== undefined ) {\n\t\n\t\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normal = this.attributes.normal;\n\t\n\t\t\t\tif ( normal !== undefined ) {\n\t\n\t\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\t\tnormal.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function () {\n\t\n\t\t\t\t// translate geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tscale: function () {\n\t\n\t\t\t\t// scale geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar obj;\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\t\n\t\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcenter: function () {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\t\n\t\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\t\treturn offset;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromObject: function ( object ) {\n\t\n\t\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( (object && object.isPoints) || (object && object.isLine) ) {\n\t\n\t\t\t\t\tvar positions = new Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\t\tvar colors = new Float32Attribute( geometry.colors.length * 3, 3 );\n\t\n\t\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\t\n\t\t\t\t\t\tvar lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );\n\t\n\t\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (object && object.isMesh) ) {\n\t\n\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\tthis.fromGeometry( geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdateFromObject: function ( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( (object && object.isMesh) ) {\n\t\n\t\t\t\t\tvar direct = geometry.__directGeometry;\n\t\n\t\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\t\n\t\t\t\t\t\tdirect = undefined;\n\t\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( direct === undefined ) {\n\t\n\t\t\t\t\t\treturn this.fromGeometry( geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\t\tgeometry = direct;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attribute;\n\t\n\t\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.position;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.normal;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.color;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvsNeedUpdate ) {\n\t\n\t\t\t\t\tattribute = this.attributes.uv;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\t\n\t\t\t\t\tattribute = this.attributes.lineDistance;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.groupsNeedUpdate ) {\n\t\n\t\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\t\n\t\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\t\n\t\t\t},\n\t\n\t\t\tfromDirectGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\t\n\t\t\t\tif ( geometry.normals.length > 0 ) {\n\t\n\t\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.colors.length > 0 ) {\n\t\n\t\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvs.length > 0 ) {\n\t\n\t\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvs2.length > 0 ) {\n\t\n\t\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.indices.length > 0 ) {\n\t\n\t\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// groups\n\t\n\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tfor ( var name in geometry.morphTargets ) {\n\t\n\t\t\t\t\tvar array = [];\n\t\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\t\n\t\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\n\t\t\t\t\t\tvar attribute = new Float32Attribute( morphTarget.length * 3, 3 );\n\t\n\t\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphAttributes[ name ] = array;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skinning\n\t\n\t\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\t\n\t\t\t\t\tvar skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\t\n\t\t\t\t\tvar skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingBox: function () {\n\t\n\t\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\t\tthis.boundingBox = new Box3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar positions = this.attributes.position.array;\n\t\n\t\t\t\tif ( positions !== undefined ) {\n\t\n\t\t\t\t\tthis.boundingBox.setFromArray( positions );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.boundingBox.makeEmpty();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\t\tvar box = new Box3();\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\treturn function computeBoundingSphere() {\n\t\n\t\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar positions = this.attributes.position;\n\t\n\t\t\t\t\tif ( positions ) {\n\t\n\t\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\t\tvar center = this.boundingSphere.center;\n\t\n\t\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\t\tbox.getCenter( center );\n\t\n\t\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\t\n\t\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\t// backwards compatibility\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function () {\n\t\n\t\t\t\tvar index = this.index;\n\t\t\t\tvar attributes = this.attributes;\n\t\t\t\tvar groups = this.groups;\n\t\n\t\t\t\tif ( attributes.position ) {\n\t\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( attributes.normal === undefined ) {\n\t\n\t\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// reset existing normals to zero\n\t\n\t\t\t\t\t\tvar array = attributes.normal.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tarray[ i ] = 0;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar normals = attributes.normal.array;\n\t\n\t\t\t\t\tvar vA, vB, vC,\n\t\n\t\t\t\t\tpA = new Vector3(),\n\t\t\t\t\tpB = new Vector3(),\n\t\t\t\t\tpC = new Vector3(),\n\t\n\t\t\t\t\tcb = new Vector3(),\n\t\t\t\t\tab = new Vector3();\n\t\n\t\t\t\t\t// indexed elements\n\t\n\t\t\t\t\tif ( index ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar group = groups[ j ];\n\t\n\t\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\t\n\t\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\t\n\t\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\t\n\t\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\t\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.normalizeNormals();\n\t\n\t\t\t\t\tattributes.normal.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmerge: function ( geometry, offset ) {\n\t\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\t\n\t\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\t\tvar attributeArray1 = attribute1.array;\n\t\n\t\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\t\tvar attributeArray2 = attribute2.array;\n\t\n\t\t\t\t\tvar attributeSize = attribute2.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnormalizeNormals: function () {\n\t\n\t\t\t\tvar normals = this.attributes.normal.array;\n\t\n\t\t\t\tvar x, y, z, n;\n\t\n\t\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\t\n\t\t\t\t\tx = normals[ i ];\n\t\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\t\tz = normals[ i + 2 ];\n\t\n\t\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\t\n\t\t\t\t\tnormals[ i ] *= n;\n\t\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\t\tnormals[ i + 2 ] *= n;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoNonIndexed: function () {\n\t\n\t\t\t\tif ( this.index === null ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar geometry2 = new BufferGeometry();\n\t\n\t\t\t\tvar indices = this.index.array;\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ name ];\n\t\n\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\n\t\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\t\n\t\t\t\t\tvar index = 0, index2 = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tindex = indices[ i ] * itemSize;\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\t\n\t\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry2;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard BufferGeometry serialization\n\t\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdata.data = { attributes: {} };\n\t\n\t\t\t\tvar index = this.index;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\t\n\t\t\t\t\tdata.data.index = {\n\t\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\t\tarray: array\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ key ];\n\t\n\t\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\t\n\t\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\t\tarray: array,\n\t\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = this.groups;\n\t\n\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingSphere = this.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== null ) {\n\t\n\t\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\t/*\n\t\t\t\t// Handle primitives\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\t\treturn geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\t\t\t*/\n\t\n\t\t\t\treturn new BufferGeometry().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tvar index = source.index;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = source.attributes;\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = source.groups;\n\t\n\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tBufferGeometry.MaxIndex = 65535;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author jonobr1 / http://jonobr1.com/\n\t\t */\n\t\n\t\tfunction Mesh( geometry, material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Mesh';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t\tthis.drawMode = TrianglesDrawMode;\n\t\n\t\t\tthis.updateMorphTargets();\n\t\n\t\t}\n\t\n\t\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Mesh,\n\t\n\t\t\tisMesh: true,\n\t\n\t\t\tsetDrawMode: function ( value ) {\n\t\n\t\t\t\tthis.drawMode = value;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.drawMode = source.drawMode;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMorphTargets: function () {\n\t\n\t\t\t\tvar morphTargets = this.geometry.morphTargets;\n\t\n\t\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\t\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\t\n\t\t\t\t\tfor ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\t\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ morphTargets[ m ].name ] = m;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\tvar vA = new Vector3();\n\t\t\t\tvar vB = new Vector3();\n\t\t\t\tvar vC = new Vector3();\n\t\n\t\t\t\tvar tempA = new Vector3();\n\t\t\t\tvar tempB = new Vector3();\n\t\t\t\tvar tempC = new Vector3();\n\t\n\t\t\t\tvar uvA = new Vector2();\n\t\t\t\tvar uvB = new Vector2();\n\t\t\t\tvar uvC = new Vector2();\n\t\n\t\t\t\tvar barycoord = new Vector3();\n\t\n\t\t\t\tvar intersectionPoint = new Vector3();\n\t\t\t\tvar intersectionPointWorld = new Vector3();\n\t\n\t\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\t\n\t\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\t\n\t\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\t\n\t\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\t\n\t\t\t\t\treturn uv1.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\t\n\t\t\t\t\tvar intersect;\n\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\tif ( material.side === BackSide ) {\n\t\n\t\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( intersect === null ) return null;\n\t\n\t\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\t\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\t\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\t\tobject: object\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\t\n\t\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\t\tvC.fromArray( positions, c * 3 );\n\t\n\t\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\t\n\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\t\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\t\tintersection.faceIndex = a;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn intersection;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar material = this.material;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t\tif ( material === undefined ) return;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\t// Check boundingBox before continuing\n\t\n\t\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar uvs, intersection;\n\t\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\tvar a, b, c;\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\t\n\t\t\t\t\t\t\tuvs = attributes.uv.array;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\t\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\t\tc = a + 2;\n\t\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\t\tvar isFaceMaterial = (material && material.isMultiMaterial);\n\t\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\t\n\t\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\t\n\t\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\t\n\t\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\t\tfvC = vertices[ face.c ];\n\t\n\t\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\t\n\t\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\t\n\t\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\t\n\t\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\t\n\t\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\t\n\t\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\t\n\t\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\t\tvC.add( fvC );\n\t\n\t\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\t\tfvC = vC;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\t\n\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\t\n\t\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'BoxBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\t// segments\n\t\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\t\n\t\t\t// these are used to calculate buffer length\n\t\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t\t// offset variables\n\t\t\tvar vertexBufferOffset = 0;\n\t\t\tvar uvBufferOffset = 0;\n\t\t\tvar indexBufferOffset = 0;\n\t\t\tvar numberOfVertices = 0;\n\t\n\t\t\t// group variables\n\t\t\tvar groupStart = 0;\n\t\n\t\t\t// build each side of the box geometry\n\t\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\t\n\t\t\t// build geometry\n\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction calculateVertexCount( w, h, d ) {\n\t\n\t\t\t\tvar vertices = 0;\n\t\n\t\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\t\n\t\t\t\treturn vertices;\n\t\n\t\t\t}\n\t\n\t\t\tfunction calculateIndexCount( w, h, d ) {\n\t\n\t\t\t\tvar index = 0;\n\t\n\t\t\t\t// calculate the amount of squares for each side\n\t\t\t\tindex += w * h * 2; // xy\n\t\t\t\tindex += w * d * 2; // xz\n\t\t\t\tindex += d * h * 2; // zy\n\t\n\t\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\t\n\t\t\t}\n\t\n\t\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\t\n\t\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\t\tvar segmentHeight = height / gridY;\n\t\n\t\t\t\tvar widthHalf = width / 2;\n\t\t\t\tvar heightHalf = height / 2;\n\t\t\t\tvar depthHalf = depth / 2;\n\t\n\t\t\t\tvar gridX1 = gridX + 1;\n\t\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\t\tvar vertexCounter = 0;\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\t\n\t\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\t\n\t\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\t\tvector[ w ] = depthHalf;\n\t\n\t\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\t\n\t\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t\t// uvs\n\t\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\t\t\t// update offsets and counters\n\t\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\t\tvertexCounter += 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// 1. you need three indices to draw a single face\n\t\t\t\t// 2. a single segment consists of two faces\n\t\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\t\n\t\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\t\t// indices\n\t\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\t\t// face one\n\t\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t\t\t// face two\n\t\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t\t\t// update offsets and counters\n\t\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t\t// update total number of vertices\n\t\t\t\tnumberOfVertices += vertexCounter;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t\t */\n\t\n\t\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'PlaneBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\n\t\t\tvar width_half = width / 2;\n\t\t\tvar height_half = height / 2;\n\t\n\t\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\t\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\tvar segment_width = width / gridX;\n\t\t\tvar segment_height = height / gridY;\n\t\n\t\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\t\n\t\t\tvar offset = 0;\n\t\t\tvar offset2 = 0;\n\t\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\tvar y = iy * segment_height - height_half;\n\t\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\tvar x = ix * segment_width - width_half;\n\t\n\t\t\t\t\tvertices[ offset ] = x;\n\t\t\t\t\tvertices[ offset + 1 ] = - y;\n\t\n\t\t\t\t\tnormals[ offset + 2 ] = 1;\n\t\n\t\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\t\toffset += 3;\n\t\t\t\t\toffset2 += 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\toffset = 0;\n\t\n\t\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\t\n\t\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\tindices[ offset ] = a;\n\t\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\t\tindices[ offset + 2 ] = d;\n\t\n\t\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\t\tindices[ offset + 5 ] = d;\n\t\n\t\t\t\t\toffset += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction Camera() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Camera';\n\t\n\t\t\tthis.matrixWorldInverse = new Matrix4();\n\t\t\tthis.projectionMatrix = new Matrix4();\n\t\n\t\t}\n\t\n\t\tCamera.prototype = Object.create( Object3D.prototype );\n\t\tCamera.prototype.constructor = Camera;\n\t\n\t\tCamera.prototype.isCamera = true;\n\t\n\t\tCamera.prototype.getWorldDirection = function () {\n\t\n\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tCamera.prototype.lookAt = function () {\n\t\n\t\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\t\n\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\tm1.lookAt( this.position, vector, this.up );\n\t\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tCamera.prototype.clone = function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t};\n\t\n\t\tCamera.prototype.copy = function ( source ) {\n\t\n\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author greggman / http://games.greggman.com/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\t\n\t\t\tCamera.call( this );\n\t\n\t\t\tthis.type = 'PerspectiveCamera';\n\t\n\t\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\t\tthis.zoom = 1;\n\t\n\t\t\tthis.near = near !== undefined ? near : 0.1;\n\t\t\tthis.far = far !== undefined ? far : 2000;\n\t\t\tthis.focus = 10;\n\t\n\t\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\t\tthis.view = null;\n\t\n\t\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t}\n\t\n\t\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\t\n\t\t\tconstructor: PerspectiveCamera,\n\t\n\t\t\tisPerspectiveCamera: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tCamera.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.fov = source.fov;\n\t\t\t\tthis.zoom = source.zoom;\n\t\n\t\t\t\tthis.near = source.near;\n\t\t\t\tthis.far = source.far;\n\t\t\t\tthis.focus = source.focus;\n\t\n\t\t\t\tthis.aspect = source.aspect;\n\t\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\t\tthis.filmOffset = source.filmOffset;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t\t *\n\t\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t\t * a 35mm (full frame) camera.\n\t\t\t *\n\t\t\t * Values for focal length and film gauge must have the same unit.\n\t\t\t */\n\t\t\tsetFocalLength: function ( focalLength ) {\n\t\n\t\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\t\n\t\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t\t */\n\t\t\tgetFocalLength: function () {\n\t\n\t\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\t\n\t\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\t\n\t\t\t},\n\t\n\t\t\tgetEffectiveFOV: function () {\n\t\n\t\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\t\n\t\t\t},\n\t\n\t\t\tgetFilmWidth: function () {\n\t\n\t\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\t\n\t\t\t},\n\t\n\t\t\tgetFilmHeight: function () {\n\t\n\t\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t\t * multi-monitor/multi-machine setups.\n\t\t\t *\n\t\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t\t * the monitors are in grid like this\n\t\t\t *\n\t\t\t *   +---+---+---+\n\t\t\t *   | A | B | C |\n\t\t\t *   +---+---+---+\n\t\t\t *   | D | E | F |\n\t\t\t *   +---+---+---+\n\t\t\t *\n\t\t\t * then for each monitor you would call it like this\n\t\t\t *\n\t\t\t *   var w = 1920;\n\t\t\t *   var h = 1080;\n\t\t\t *   var fullWidth = w * 3;\n\t\t\t *   var fullHeight = h * 2;\n\t\t\t *\n\t\t\t *   --A--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t\t *   --B--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t\t *   --C--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t\t *   --D--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t\t *   --E--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t\t *   --F--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t\t *\n\t\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t\t */\n\t\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\t\tthis.aspect = fullWidth / fullHeight;\n\t\n\t\t\t\tthis.view = {\n\t\t\t\t\tfullWidth: fullWidth,\n\t\t\t\t\tfullHeight: fullHeight,\n\t\t\t\t\toffsetX: x,\n\t\t\t\t\toffsetY: y,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t};\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tclearViewOffset: function() {\n\t\n\t\t\t\tthis.view = null;\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\t\tvar near = this.near,\n\t\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\t\theight = 2 * top,\n\t\t\t\t\twidth = this.aspect * height,\n\t\t\t\t\tleft = - 0.5 * width,\n\t\t\t\t\tview = this.view;\n\t\n\t\t\t\tif ( view !== null ) {\n\t\n\t\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\t\tfullHeight = view.fullHeight;\n\t\n\t\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\t\theight *= view.height / fullHeight;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar skew = this.filmOffset;\n\t\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\t\n\t\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.fov = this.fov;\n\t\t\t\tdata.object.zoom = this.zoom;\n\t\n\t\t\t\tdata.object.near = this.near;\n\t\t\t\tdata.object.far = this.far;\n\t\t\t\tdata.object.focus = this.focus;\n\t\n\t\t\t\tdata.object.aspect = this.aspect;\n\t\n\t\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\t\tdata.object.filmOffset = this.filmOffset;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author arose / http://github.com/arose\n\t\t */\n\t\n\t\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\t\n\t\t\tCamera.call( this );\n\t\n\t\t\tthis.type = 'OrthographicCamera';\n\t\n\t\t\tthis.zoom = 1;\n\t\t\tthis.view = null;\n\t\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bottom;\n\t\n\t\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t}\n\t\n\t\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\t\n\t\t\tconstructor: OrthographicCamera,\n\t\n\t\t\tisOrthographicCamera: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tCamera.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.left = source.left;\n\t\t\t\tthis.right = source.right;\n\t\t\t\tthis.top = source.top;\n\t\t\t\tthis.bottom = source.bottom;\n\t\t\t\tthis.near = source.near;\n\t\t\t\tthis.far = source.far;\n\t\n\t\t\t\tthis.zoom = source.zoom;\n\t\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\t\tthis.view = {\n\t\t\t\t\tfullWidth: fullWidth,\n\t\t\t\t\tfullHeight: fullHeight,\n\t\t\t\t\toffsetX: x,\n\t\t\t\t\toffsetY: y,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t};\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tclearViewOffset: function() {\n\t\n\t\t\t\tthis.view = null;\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\t\n\t\t\t\tvar left = cx - dx;\n\t\t\t\tvar right = cx + dx;\n\t\t\t\tvar top = cy + dy;\n\t\t\t\tvar bottom = cy - dy;\n\t\n\t\t\t\tif ( this.view !== null ) {\n\t\n\t\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\t\n\t\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.zoom = this.zoom;\n\t\t\t\tdata.object.left = this.left;\n\t\t\t\tdata.object.right = this.right;\n\t\t\t\tdata.object.top = this.top;\n\t\t\t\tdata.object.bottom = this.bottom;\n\t\t\t\tdata.object.near = this.near;\n\t\t\t\tdata.object.far = this.far;\n\t\n\t\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\t\n\t\t\tvar mode;\n\t\n\t\t\tfunction setMode( value ) {\n\t\n\t\t\t\tmode = value;\n\t\n\t\t\t}\n\t\n\t\t\tvar type, size;\n\t\n\t\t\tfunction setIndex( index ) {\n\t\n\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t\t\tsize = 4;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\t\tsize = 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction render( start, count ) {\n\t\n\t\t\t\tgl.drawElements( mode, count, type, start * size );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderInstances( geometry, start, count ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tsetMode: setMode,\n\t\t\t\tsetIndex: setIndex,\n\t\t\t\trender: render,\n\t\t\t\trenderInstances: renderInstances\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\t\n\t\t\tvar mode;\n\t\n\t\t\tfunction setMode( value ) {\n\t\n\t\t\t\tmode = value;\n\t\n\t\t\t}\n\t\n\t\t\tfunction render( start, count ) {\n\t\n\t\t\t\tgl.drawArrays( mode, start, count );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderInstances( geometry ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar position = geometry.attributes.position;\n\t\n\t\t\t\tvar count = 0;\n\t\n\t\t\t\tif ( (position && position.isInterleavedBufferAttribute) ) {\n\t\n\t\t\t\t\tcount = position.data.count;\n\t\n\t\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tcount = position.count;\n\t\n\t\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tsetMode: setMode,\n\t\t\t\trender: render,\n\t\t\t\trenderInstances: renderInstances\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLLights() {\n\t\n\t\t\tvar lights = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( light ) {\n\t\n\t\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn lights[ light.id ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar uniforms;\n\t\n\t\t\t\t\tswitch ( light.type ) {\n\t\n\t\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlights[ light.id ] = uniforms;\n\t\n\t\t\t\t\treturn uniforms;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction addLineNumbers( string ) {\n\t\n\t\t\tvar lines = string.split( '\\n' );\n\t\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\t\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn lines.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction WebGLShader( gl, type, string ) {\n\t\n\t\t\tvar shader = gl.createShader( type );\n\t\n\t\t\tgl.shaderSource( shader, string );\n\t\t\tgl.compileShader( shader );\n\t\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\t\n\t\t\t}\n\t\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\t\n\t\t\t}\n\t\n\t\t\t// --enable-privileged-webgl-extension\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\t\n\t\t\treturn shader;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar programIdCount = 0;\n\t\n\t\tfunction getEncodingComponents( encoding ) {\n\t\n\t\t\tswitch ( encoding ) {\n\t\n\t\t\t\tcase LinearEncoding:\n\t\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\t\tcase sRGBEncoding:\n\t\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\t\tcase RGBEEncoding:\n\t\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\t\tcase RGBM7Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\t\tcase RGBM16Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\t\tcase RGBDEncoding:\n\t\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\t\tcase GammaEncoding:\n\t\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\t\n\t\t\tvar toneMappingName;\n\t\n\t\t\tswitch ( toneMapping ) {\n\t\n\t\t\t\tcase LinearToneMapping:\n\t\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase ReinhardToneMapping:\n\t\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase CineonToneMapping:\n\t\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\t\n\t\t\t}\n\t\n\t\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\t\n\t\t}\n\t\n\t\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\t\n\t\t\textensions = extensions || {};\n\t\n\t\t\tvar chunks = [\n\t\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t\t];\n\t\n\t\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction generateDefines( defines ) {\n\t\n\t\t\tvar chunks = [];\n\t\n\t\t\tfor ( var name in defines ) {\n\t\n\t\t\t\tvar value = defines[ name ];\n\t\n\t\t\t\tif ( value === false ) continue;\n\t\n\t\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\t\n\t\t\t}\n\t\n\t\t\treturn chunks.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\t\n\t\t\tvar attributes = {};\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\t\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\n\t\n\t\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\t\tvar name = info.name;\n\t\n\t\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\t\n\t\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\t\n\t\t\t}\n\t\n\t\t\treturn attributes;\n\t\n\t\t}\n\t\n\t\tfunction filterEmptyLine( string ) {\n\t\n\t\t\treturn string !== '';\n\t\n\t\t}\n\t\n\t\tfunction replaceLightNums( string, parameters ) {\n\t\n\t\t\treturn string\n\t\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\t\n\t\t}\n\t\n\t\tfunction parseIncludes( string ) {\n\t\n\t\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\t\n\t\t\tfunction replace( match, include ) {\n\t\n\t\t\t\tvar replace = ShaderChunk[ include ];\n\t\n\t\t\t\tif ( replace === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn parseIncludes( replace );\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction unrollLoops( string ) {\n\t\n\t\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\t\n\t\t\tfunction replace( match, start, end, snippet ) {\n\t\n\t\t\t\tvar unroll = '';\n\t\n\t\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\t\n\t\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn unroll;\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction WebGLProgram( renderer, code, material, parameters ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\n\t\t\tvar extensions = material.extensions;\n\t\t\tvar defines = material.defines;\n\t\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\t\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\t\n\t\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\t\n\t\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\t\n\t\t\t}\n\t\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\n\t\t\tif ( parameters.envMap ) {\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.combine ) {\n\t\n\t\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase MixOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase AddOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\t\n\t\t\t// console.log( 'building new program ' );\n\t\n\t\t\t//\n\t\n\t\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\t\n\t\t\tvar customDefines = generateDefines( defines );\n\t\n\t\t\t//\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar prefixVertex, prefixFragment;\n\t\n\t\t\tif ( material.isRawShaderMaterial ) {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\t\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t'attribute vec3 position;',\n\t\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'#ifdef USE_COLOR',\n\t\n\t\t\t\t\t'\tattribute vec3 color;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\t\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\n\t\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\t\n\t\t\t\t\t'\t#else',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\t\n\t\t\t\t\t'\t#endif',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_SKINNING',\n\t\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\t\t\t\t'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\t\n\t\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\t\n\t\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\t\n\t\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t}\n\t\n\t\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\t\n\t\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\t\n\t\t\tif ( ! material.isShaderMaterial ) {\n\t\n\t\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\t\n\t\t\t}\n\t\n\t\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\t\n\t\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\t\n\t\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\t\n\t\t\tgl.attachShader( program, glVertexShader );\n\t\t\tgl.attachShader( program, glFragmentShader );\n\t\n\t\t\t// Force a particular attribute to index 0.\n\t\n\t\t\tif ( material.index0AttributeName !== undefined ) {\n\t\n\t\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\t\n\t\t\t} else if ( parameters.morphTargets === true ) {\n\t\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\t\n\t\t\t}\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\t\n\t\t\tvar runnable = true;\n\t\t\tvar haveDiagnostics = true;\n\t\n\t\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\t\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\t\n\t\t\t\trunnable = false;\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\t\n\t\t\t} else if ( programLog !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\t\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\t\n\t\t\t\thaveDiagnostics = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( haveDiagnostics ) {\n\t\n\t\t\t\tthis.diagnostics = {\n\t\n\t\t\t\t\trunnable: runnable,\n\t\t\t\t\tmaterial: material,\n\t\n\t\t\t\t\tprogramLog: programLog,\n\t\n\t\t\t\t\tvertexShader: {\n\t\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfragmentShader: {\n\t\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t// clean up\n\t\n\t\t\tgl.deleteShader( glVertexShader );\n\t\t\tgl.deleteShader( glFragmentShader );\n\t\n\t\t\t// set up caching for uniform locations\n\t\n\t\t\tvar cachedUniforms;\n\t\n\t\t\tthis.getUniforms = function() {\n\t\n\t\t\t\tif ( cachedUniforms === undefined ) {\n\t\n\t\t\t\t\tcachedUniforms =\n\t\t\t\t\t\t\tnew WebGLUniforms( gl, program, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedUniforms;\n\t\n\t\t\t};\n\t\n\t\t\t// set up caching for attribute locations\n\t\n\t\t\tvar cachedAttributes;\n\t\n\t\t\tthis.getAttributes = function() {\n\t\n\t\t\t\tif ( cachedAttributes === undefined ) {\n\t\n\t\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedAttributes;\n\t\n\t\t\t};\n\t\n\t\t\t// free resource\n\t\n\t\t\tthis.destroy = function() {\n\t\n\t\t\t\tgl.deleteProgram( program );\n\t\t\t\tthis.program = undefined;\n\t\n\t\t\t};\n\t\n\t\t\t// DEPRECATED\n\t\n\t\t\tObject.defineProperties( this, {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\t\treturn this.getUniforms();\n\t\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tattributes: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\t\treturn this.getAttributes();\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\n\t\t\t//\n\t\n\t\t\tthis.id = programIdCount ++;\n\t\t\tthis.code = code;\n\t\t\tthis.usedTimes = 1;\n\t\t\tthis.program = program;\n\t\t\tthis.vertexShader = glVertexShader;\n\t\t\tthis.fragmentShader = glFragmentShader;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLPrograms( renderer, capabilities ) {\n\t\n\t\t\tvar programs = [];\n\t\n\t\t\tvar shaderIDs = {\n\t\t\t\tMeshDepthMaterial: 'depth',\n\t\t\t\tMeshNormalMaterial: 'normal',\n\t\t\t\tMeshBasicMaterial: 'basic',\n\t\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\t\tMeshPhongMaterial: 'phong',\n\t\t\t\tMeshStandardMaterial: 'physical',\n\t\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\t\tLineBasicMaterial: 'basic',\n\t\t\t\tLineDashedMaterial: 'dashed',\n\t\t\t\tPointsMaterial: 'points'\n\t\t\t};\n\t\n\t\t\tvar parameterNames = [\n\t\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\"\n\t\t\t];\n\t\n\t\n\t\t\tfunction allocateBones( object ) {\n\t\n\t\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\t\n\t\t\t\t\treturn 1024;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// default for when object is not specified\n\t\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t\t//\n\t\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t\t//    (up to 54 should be safe)\n\t\n\t\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\t\n\t\t\t\t\tvar maxBones = nVertexMatrices;\n\t\n\t\t\t\t\tif ( object !== undefined && (object && object.isSkinnedMesh) ) {\n\t\n\t\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\t\n\t\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn maxBones;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\t\n\t\t\t\tvar encoding;\n\t\n\t\t\t\tif ( ! map ) {\n\t\n\t\t\t\t\tencoding = LinearEncoding;\n\t\n\t\t\t\t} else if ( (map && map.isTexture) ) {\n\t\n\t\t\t\t\tencoding = map.encoding;\n\t\n\t\t\t\t} else if ( (map && map.isWebGLRenderTarget) ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\tencoding = map.texture.encoding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\t\n\t\t\t\t\tencoding = GammaEncoding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn encoding;\n\t\n\t\t\t}\n\t\n\t\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {\n\t\n\t\t\t\tvar shaderID = shaderIDs[ material.type ];\n\t\n\t\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t\t// (not to blow over maxLights budget)\n\t\n\t\t\t\tvar maxBones = allocateBones( object );\n\t\t\t\tvar precision = renderer.getPrecision();\n\t\n\t\t\t\tif ( material.precision !== null ) {\n\t\n\t\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\t\n\t\t\t\t\tif ( precision !== material.precision ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\t\n\t\t\t\tvar parameters = {\n\t\n\t\t\t\t\tshaderID: shaderID,\n\t\n\t\t\t\t\tprecision: precision,\n\t\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\t\tmap: !! material.map,\n\t\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\t\talphaMap: !! material.alphaMap,\n\t\n\t\t\t\t\tcombine: material.combine,\n\t\n\t\t\t\t\tvertexColors: material.vertexColors,\n\t\n\t\t\t\t\tfog: !! fog,\n\t\t\t\t\tuseFog: material.fog,\n\t\t\t\t\tfogExp: (fog && fog.isFogExp2),\n\t\n\t\t\t\t\tflatShading: material.shading === FlatShading,\n\t\n\t\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\t\n\t\t\t\t\tskinning: material.skinning,\n\t\t\t\t\tmaxBones: maxBones,\n\t\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\t\n\t\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\t\n\t\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\t\tnumHemiLights: lights.hemi.length,\n\t\n\t\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\t\tnumClipIntersection: nClipIntersection,\n\t\n\t\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\t\n\t\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\t\n\t\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\t\n\t\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\t\tflipSided: material.side === BackSide,\n\t\n\t\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\t\n\t\t\t\t};\n\t\n\t\t\t\treturn parameters;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getProgramCode = function ( material, parameters ) {\n\t\n\t\t\t\tvar array = [];\n\t\n\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\tarray.push( parameters.shaderID );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\t\tarray.push( material.vertexShader );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.defines !== undefined ) {\n\t\n\t\t\t\t\tfor ( var name in material.defines ) {\n\t\n\t\t\t\t\t\tarray.push( name );\n\t\t\t\t\t\tarray.push( material.defines[ name ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\t\n\t\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array.join();\n\t\n\t\t\t};\n\t\n\t\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\t\n\t\t\t\tvar program;\n\t\n\t\t\t\t// Check if code has been already compiled\n\t\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\t\n\t\t\t\t\tvar programInfo = programs[ p ];\n\t\n\t\t\t\t\tif ( programInfo.code === code ) {\n\t\n\t\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t\t++ program.usedTimes;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tprogram = new WebGLProgram( renderer, code, material, parameters );\n\t\t\t\t\tprograms.push( program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t};\n\t\n\t\t\tthis.releaseProgram = function( program ) {\n\t\n\t\t\t\tif ( -- program.usedTimes === 0 ) {\n\t\n\t\t\t\t\t// Remove from unordered set\n\t\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\t\tprograms.pop();\n\t\n\t\t\t\t\t// Free WebGL resources\n\t\t\t\t\tprogram.destroy();\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\t\tthis.programs = programs;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLGeometries( gl, properties, info ) {\n\t\n\t\t\tvar geometries = {};\n\t\n\t\t\tfunction onGeometryDispose( event ) {\n\t\n\t\t\t\tvar geometry = event.target;\n\t\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\t\n\t\t\t\tif ( buffergeometry.index !== null ) {\n\t\n\t\t\t\t\tdeleteAttribute( buffergeometry.index );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdeleteAttributes( buffergeometry.attributes );\n\t\n\t\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\t\tdelete geometries[ geometry.id ];\n\t\n\t\t\t\t// TODO\n\t\n\t\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\t\tif ( property.wireframe ) {\n\t\n\t\t\t\t\tdeleteAttribute( property.wireframe );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.delete( geometry );\n\t\n\t\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\t\n\t\t\t\tif ( bufferproperty.wireframe ) {\n\t\n\t\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.delete( buffergeometry );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinfo.memory.geometries --;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\tfunction deleteAttribute( attribute ) {\n\t\n\t\t\t\tvar buffer = getAttributeBuffer( attribute );\n\t\n\t\t\t\tif ( buffer !== undefined ) {\n\t\n\t\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\t\tremoveAttributeBuffer( attribute );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction deleteAttributes( attributes ) {\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tdeleteAttribute( attributes[ name ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction removeAttributeBuffer( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\tproperties.delete( attribute.data );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tproperties.delete( attribute );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( object ) {\n\t\n\t\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn geometries[ geometry.id ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\t\t\tvar buffergeometry;\n\t\n\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\tbuffergeometry = geometry;\n\t\n\t\t\t\t\t} else if ( geometry.isGeometry ) {\n\t\n\t\t\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\t\n\t\t\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\t\n\t\t\t\t\tinfo.memory.geometries ++;\n\t\n\t\t\t\t\treturn buffergeometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLObjects( gl, properties, info ) {\n\t\n\t\t\tvar geometries = new WebGLGeometries( gl, properties, info );\n\t\n\t\t\t//\n\t\n\t\t\tfunction update( object ) {\n\t\n\t\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\t\n\t\t\t\tvar geometry = geometries.get( object );\n\t\n\t\t\t\tif ( object.geometry.isGeometry ) {\n\t\n\t\t\t\t\tgeometry.updateFromObject( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph targets\n\t\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\t\tfor ( var name in morphAttributes ) {\n\t\n\t\t\t\t\tvar array = morphAttributes[ name ];\n\t\n\t\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateAttribute( attribute, bufferType ) {\n\t\n\t\t\t\tvar data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;\n\t\n\t\t\t\tvar attributeProperties = properties.get( data );\n\t\n\t\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\t\n\t\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\t\n\t\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\t\n\t\t\t\tgl.bufferData( bufferType, data.array, usage );\n\t\n\t\t\t\tattributeProperties.version = data.version;\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\t\tif ( data.dynamic === false ) {\n\t\n\t\t\t\t\tgl.bufferData( bufferType, data.array, gl.STATIC_DRAW );\n\t\n\t\t\t\t} else if ( data.updateRange.count === - 1 ) {\n\t\n\t\t\t\t\t// Not using update ranges\n\t\n\t\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\t\n\t\t\t\t} else if ( data.updateRange.count === 0 ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\t\n\t\t\t\t\tdata.updateRange.count = 0; // reset range\n\t\n\t\t\t\t}\n\t\n\t\t\t\tattributeProperties.version = data.version;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getWireframeAttribute( geometry ) {\n\t\n\t\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\t\tif ( property.wireframe !== undefined ) {\n\t\n\t\t\t\t\treturn property.wireframe;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar indices = [];\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar position = attributes.position;\n\t\n\t\t\t\t// console.time( 'wireframe' );\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tvar edges = {};\n\t\t\t\t\tvar array = index.array;\n\t\n\t\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\t\tvar c = array[ i + 2 ];\n\t\n\t\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar array = attributes.position.array;\n\t\n\t\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\t\tvar c = i + 2;\n\t\n\t\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// console.timeEnd( 'wireframe' );\n\t\n\t\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar attribute = new BufferAttribute( new TypeArray( indices ), 1 );\n\t\n\t\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t\tproperty.wireframe = attribute;\n\t\n\t\t\t\treturn attribute;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tgetAttributeBuffer: getAttributeBuffer,\n\t\t\t\tgetWireframeAttribute: getWireframeAttribute,\n\t\n\t\t\t\tupdate: update\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\t\n\t\t\tvar _infoMemory = info.memory;\n\t\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\t\n\t\t\t//\n\t\n\t\t\tfunction clampToMaxSize( image, maxSize ) {\n\t\n\t\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\t\n\t\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t\t// premultiplied alpha.\n\t\n\t\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\t\n\t\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\t\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\t\treturn canvas;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t}\n\t\n\t\t\tfunction isPowerOfTwo( image ) {\n\t\n\t\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\t\n\t\t\t}\n\t\n\t\t\tfunction makePowerOfTwo( image ) {\n\t\n\t\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\t\n\t\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = _Math.nearestPowerOfTwo( image.width );\n\t\t\t\t\tcanvas.height = _Math.nearestPowerOfTwo( image.height );\n\t\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\t\treturn canvas;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t}\n\t\n\t\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\t\n\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;\n\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\t// Fallback filters for non-power-of-2 textures\n\t\n\t\t\tfunction filterFallback( f ) {\n\t\n\t\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\t\n\t\t\t\t\treturn _gl.NEAREST;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn _gl.LINEAR;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction onTextureDispose( event ) {\n\t\n\t\t\t\tvar texture = event.target;\n\t\n\t\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\tdeallocateTexture( texture );\n\t\n\t\t\t\t_infoMemory.textures --;\n\t\n\t\n\t\t\t}\n\t\n\t\t\tfunction onRenderTargetDispose( event ) {\n\t\n\t\t\t\tvar renderTarget = event.target;\n\t\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\t\tdeallocateRenderTarget( renderTarget );\n\t\n\t\t\t\t_infoMemory.textures --;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction deallocateTexture( texture ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t// cube texture\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// 2D texture\n\t\n\t\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// remove all webgl properties\n\t\t\t\tproperties.delete( texture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction deallocateRenderTarget( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\t\tif ( ! renderTarget ) return;\n\t\n\t\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\t\trenderTarget.depthTexture.dispose();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.delete( renderTarget.texture );\n\t\t\t\tproperties.delete( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\n\t\n\t\t\tfunction setTexture2D( texture, slot ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\tvar image = texture.image;\n\t\n\t\t\t\t\tif ( image === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\t\n\t\t\t\t\t} else if ( image.complete === false ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureCube( texture, slot ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.image.length === 6 ) {\n\t\n\t\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\t\n\t\t\t\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\n\t\t\t\t\t\tvar isCompressed = (texture && texture.isCompressedTexture);\n\t\t\t\t\t\tvar isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);\n\t\n\t\t\t\t\t\tvar cubeImage = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( ! isCompressed ) {\n\t\n\t\t\t\t\t\t\t\tif ( isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\t\n\t\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\n\t\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\n\t\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\t\n\t\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\t\tif ( extension ) {\n\t\n\t\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\t\n\t\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\t\n\t\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\t\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\t\n\t\t\t\t\ttextureProperties.__webglInit = true;\n\t\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\n\t\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\t\n\t\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\t\n\t\t\t\t\timage = makePowerOfTwo( image );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\t\n\t\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\t\n\t\t\t\tif ( (texture && texture.isDepthTexture) ) {\n\t\n\t\t\t\t\t// populate depth texture with dummy data\n\t\n\t\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\t\n\t\t\t\t\tif ( texture.type === FloatType ) {\n\t\n\t\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\n\t\t\t\t\t} else if ( _isWebGL2 ) {\n\t\n\t\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\t\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\t\n\t\t\t\t} else if ( (texture && texture.isDataTexture) ) {\n\t\n\t\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (texture && texture.isCompressedTexture) ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\t\n\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// regular Texture (image, video, canvas)\n\t\n\t\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\n\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t}\n\t\n\t\t\t// Render targets\n\t\n\t\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\t\n\t\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\t\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\t\n\t\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\tif ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {\n\t\n\t\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t\t}\n\t\n\t\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\t\n\t\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\n\t\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\t\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\t\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthrow new Error('Unknown depthTexture format')\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Setup GL resources for a non-texture depth buffer\n\t\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\n\t\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\t\n\t\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Set up GL resources for the render target\n\t\t\tfunction setupRenderTarget( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\t\n\t\t\t\t// Setup framebuffer\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Setup color buffer\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\t\n\t\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Setup depth and stencil buffers\n\t\n\t\t\t\tif ( renderTarget.depthBuffer ) {\n\t\n\t\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\t\n\t\t\t\tvar texture = renderTarget.texture;\n\t\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\t\ttexture.minFilter !== NearestFilter &&\n\t\t\t\t\t\ttexture.minFilter !== LinearFilter ) {\n\t\n\t\t\t\t\tvar target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\t\n\t\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\t\tstate.bindTexture( target, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setTexture2D = setTexture2D;\n\t\t\tthis.setTextureCube = setTextureCube;\n\t\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author fordacious / fordacious.github.io\n\t\t */\n\t\n\t\tfunction WebGLProperties() {\n\t\n\t\t\tvar properties = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( object ) {\n\t\n\t\t\t\t\tvar uuid = object.uuid;\n\t\t\t\t\tvar map = properties[ uuid ];\n\t\n\t\t\t\t\tif ( map === undefined ) {\n\t\n\t\t\t\t\t\tmap = {};\n\t\t\t\t\t\tproperties[ uuid ] = map;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn map;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tdelete: function ( object ) {\n\t\n\t\t\t\t\tdelete properties[ object.uuid ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tclear: function () {\n\t\n\t\t\t\t\tproperties = {};\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLState( gl, extensions, paramThreeToGL ) {\n\t\n\t\t\tfunction ColorBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar color = new Vector4();\n\t\t\t\tvar currentColorMask = null;\n\t\t\t\tvar currentColorClear = new Vector4();\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetMask: function ( colorMask ) {\n\t\n\t\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\t\tcurrentColorMask = colorMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( r, g, b, a ) {\n\t\n\t\t\t\t\t\tcolor.set( r, g, b, a );\n\t\n\t\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\t\n\t\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\t\tcurrentColorClear.copy( color );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\t\tcurrentColorClear.set( 0, 0, 0, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction DepthBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar currentDepthMask = null;\n\t\t\t\tvar currentDepthFunc = null;\n\t\t\t\tvar currentDepthClear = null;\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetTest: function ( depthTest ) {\n\t\n\t\t\t\t\t\tif ( depthTest ) {\n\t\n\t\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetMask: function ( depthMask ) {\n\t\n\t\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetFunc: function ( depthFunc ) {\n\t\n\t\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\t\n\t\t\t\t\t\t\tif ( depthFunc ) {\n\t\n\t\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\t\n\t\t\t\t\t\t\t\t\tcase NeverDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase LessDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase EqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase GreaterDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( depth ) {\n\t\n\t\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\t\n\t\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\t\tcurrentDepthClear = depth;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\t\tcurrentDepthClear = null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction StencilBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar currentStencilMask = null;\n\t\t\t\tvar currentStencilFunc = null;\n\t\t\t\tvar currentStencilRef = null;\n\t\t\t\tvar currentStencilFuncMask = null;\n\t\t\t\tvar currentStencilFail  = null;\n\t\t\t\tvar currentStencilZFail = null;\n\t\t\t\tvar currentStencilZPass = null;\n\t\t\t\tvar currentStencilClear = null;\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetTest: function ( stencilTest ) {\n\t\n\t\t\t\t\t\tif ( stencilTest ) {\n\t\n\t\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetMask: function ( stencilMask ) {\n\t\n\t\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\t\n\t\t\t\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\t\n\t\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\t\n\t\t\t\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\t\n\t\t\t\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( stencil ) {\n\t\n\t\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\t\n\t\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\t\tcurrentStencilClear = stencil;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\t\tcurrentStencilClear = null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar colorBuffer = new ColorBuffer();\n\t\t\tvar depthBuffer = new DepthBuffer();\n\t\t\tvar stencilBuffer = new StencilBuffer();\n\t\n\t\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\t\n\t\t\tvar capabilities = {};\n\t\n\t\t\tvar compressedTextureFormats = null;\n\t\n\t\t\tvar currentBlending = null;\n\t\t\tvar currentBlendEquation = null;\n\t\t\tvar currentBlendSrc = null;\n\t\t\tvar currentBlendDst = null;\n\t\t\tvar currentBlendEquationAlpha = null;\n\t\t\tvar currentBlendSrcAlpha = null;\n\t\t\tvar currentBlendDstAlpha = null;\n\t\t\tvar currentPremultipledAlpha = false;\n\t\n\t\t\tvar currentFlipSided = null;\n\t\t\tvar currentCullFace = null;\n\t\n\t\t\tvar currentLineWidth = null;\n\t\n\t\t\tvar currentPolygonOffsetFactor = null;\n\t\t\tvar currentPolygonOffsetUnits = null;\n\t\n\t\t\tvar currentScissorTest = null;\n\t\n\t\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\n\t\t\tvar currentTextureSlot = null;\n\t\t\tvar currentBoundTextures = {};\n\t\n\t\t\tvar currentScissor = new Vector4();\n\t\t\tvar currentViewport = new Vector4();\n\t\n\t\t\tfunction createTexture( type, target, count ) {\n\t\n\t\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\t\tvar texture = gl.createTexture();\n\t\n\t\t\t\tgl.bindTexture( type, texture );\n\t\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\n\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\t\n\t\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t}\n\t\n\t\t\tvar emptyTextures = {};\n\t\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\t\n\t\t\t//\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tclearColor( 0, 0, 0, 1 );\n\t\t\t\tclearDepth( 1 );\n\t\t\t\tclearStencil( 0 );\n\t\n\t\t\t\tenable( gl.DEPTH_TEST );\n\t\t\t\tsetDepthFunc( LessEqualDepth );\n\t\n\t\t\t\tsetFlipSided( false );\n\t\t\t\tsetCullFace( CullFaceBack );\n\t\t\t\tenable( gl.CULL_FACE );\n\t\n\t\t\t\tenable( gl.BLEND );\n\t\t\t\tsetBlending( NormalBlending );\n\t\n\t\t\t}\n\t\n\t\t\tfunction initAttributes() {\n\t\n\t\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tnewAttributes[ i ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enableAttribute( attribute ) {\n\t\n\t\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\t\n\t\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\t\tattributeDivisors[ attribute ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {\n\t\n\t\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\t\n\t\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction disableUnusedAttributes() {\n\t\n\t\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\t\n\t\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\t\n\t\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enable( id ) {\n\t\n\t\t\t\tif ( capabilities[ id ] !== true ) {\n\t\n\t\t\t\t\tgl.enable( id );\n\t\t\t\t\tcapabilities[ id ] = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction disable( id ) {\n\t\n\t\t\t\tif ( capabilities[ id ] !== false ) {\n\t\n\t\t\t\t\tgl.disable( id );\n\t\t\t\t\tcapabilities[ id ] = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getCompressedTextureFormats() {\n\t\n\t\t\t\tif ( compressedTextureFormats === null ) {\n\t\n\t\t\t\t\tcompressedTextureFormats = [];\n\t\n\t\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\t\n\t\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn compressedTextureFormats;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\t\n\t\t\t\tif ( blending !== NoBlending ) {\n\t\n\t\t\t\t\tenable( gl.BLEND );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.BLEND );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\t\n\t\t\t\t\tif ( blending === AdditiveBlending ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( blending === SubtractiveBlending ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( blending === MultiplyBlending ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentBlending = blending;\n\t\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( blending === CustomBlending ) {\n\t\n\t\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\t\n\t\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\t\n\t\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\t\n\t\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\t\tcurrentBlendDst = null;\n\t\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\t\tcurrentBlendDstAlpha = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// TODO Deprecate\n\t\n\t\t\tfunction setColorWrite( colorWrite ) {\n\t\n\t\t\t\tcolorBuffer.setMask( colorWrite );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDepthTest( depthTest ) {\n\t\n\t\t\t\tdepthBuffer.setTest( depthTest );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDepthWrite( depthWrite ) {\n\t\n\t\t\t\tdepthBuffer.setMask( depthWrite );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDepthFunc( depthFunc ) {\n\t\n\t\t\t\tdepthBuffer.setFunc( depthFunc );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilTest( stencilTest ) {\n\t\n\t\t\t\tstencilBuffer.setTest( stencilTest );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilWrite( stencilWrite ) {\n\t\n\t\t\t\tstencilBuffer.setMask( stencilWrite );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\t\tstencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\t\tstencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction setFlipSided( flipSided ) {\n\t\n\t\t\t\tif ( currentFlipSided !== flipSided ) {\n\t\n\t\t\t\t\tif ( flipSided ) {\n\t\n\t\t\t\t\t\tgl.frontFace( gl.CW );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.frontFace( gl.CCW );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentFlipSided = flipSided;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setCullFace( cullFace ) {\n\t\n\t\t\t\tif ( cullFace !== CullFaceNone ) {\n\t\n\t\t\t\t\tenable( gl.CULL_FACE );\n\t\n\t\t\t\t\tif ( cullFace !== currentCullFace ) {\n\t\n\t\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\t\n\t\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.CULL_FACE );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentCullFace = cullFace;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setLineWidth( width ) {\n\t\n\t\t\t\tif ( width !== currentLineWidth ) {\n\t\n\t\t\t\t\tgl.lineWidth( width );\n\t\n\t\t\t\t\tcurrentLineWidth = width;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\t\n\t\t\t\tif ( polygonOffset ) {\n\t\n\t\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\t\n\t\t\t\t\t\tgl.polygonOffset( factor, units );\n\t\n\t\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getScissorTest() {\n\t\n\t\t\t\treturn currentScissorTest;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setScissorTest( scissorTest ) {\n\t\n\t\t\t\tcurrentScissorTest = scissorTest;\n\t\n\t\t\t\tif ( scissorTest ) {\n\t\n\t\t\t\t\tenable( gl.SCISSOR_TEST );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.SCISSOR_TEST );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// texture\n\t\n\t\t\tfunction activeTexture( webglSlot ) {\n\t\n\t\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\t\n\t\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\t\n\t\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\t\tcurrentTextureSlot = webglSlot;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction bindTexture( webglType, webglTexture ) {\n\t\n\t\t\t\tif ( currentTextureSlot === null ) {\n\t\n\t\t\t\t\tactiveTexture();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\t\n\t\t\t\tif ( boundTexture === undefined ) {\n\t\n\t\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\t\n\t\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\t\n\t\t\t\t\tboundTexture.type = webglType;\n\t\t\t\t\tboundTexture.texture = webglTexture;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction compressedTexImage2D() {\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\t\n\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\tconsole.error( error );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction texImage2D() {\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\t\n\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\tconsole.error( error );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// TODO Deprecate\n\t\n\t\t\tfunction clearColor( r, g, b, a ) {\n\t\n\t\t\t\tcolorBuffer.setClear( r, g, b, a );\n\t\n\t\t\t}\n\t\n\t\t\tfunction clearDepth( depth ) {\n\t\n\t\t\t\tdepthBuffer.setClear( depth );\n\t\n\t\t\t}\n\t\n\t\t\tfunction clearStencil( stencil ) {\n\t\n\t\t\t\tstencilBuffer.setClear( stencil );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction scissor( scissor ) {\n\t\n\t\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\t\n\t\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\t\tcurrentScissor.copy( scissor );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction viewport( viewport ) {\n\t\n\t\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\t\n\t\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\t\tcurrentViewport.copy( viewport );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction reset() {\n\t\n\t\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\t\n\t\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\t\n\t\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcapabilities = {};\n\t\n\t\t\t\tcompressedTextureFormats = null;\n\t\n\t\t\t\tcurrentTextureSlot = null;\n\t\t\t\tcurrentBoundTextures = {};\n\t\n\t\t\t\tcurrentBlending = null;\n\t\n\t\t\t\tcurrentFlipSided = null;\n\t\t\t\tcurrentCullFace = null;\n\t\n\t\t\t\tcolorBuffer.reset();\n\t\t\t\tdepthBuffer.reset();\n\t\t\t\tstencilBuffer.reset();\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tbuffers: {\n\t\t\t\t\tcolor: colorBuffer,\n\t\t\t\t\tdepth: depthBuffer,\n\t\t\t\t\tstencil: stencilBuffer\n\t\t\t\t},\n\t\n\t\t\t\tinit: init,\n\t\t\t\tinitAttributes: initAttributes,\n\t\t\t\tenableAttribute: enableAttribute,\n\t\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\t\tenable: enable,\n\t\t\t\tdisable: disable,\n\t\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\t\n\t\t\t\tsetBlending: setBlending,\n\t\n\t\t\t\tsetColorWrite: setColorWrite,\n\t\t\t\tsetDepthTest: setDepthTest,\n\t\t\t\tsetDepthWrite: setDepthWrite,\n\t\t\t\tsetDepthFunc: setDepthFunc,\n\t\t\t\tsetStencilTest: setStencilTest,\n\t\t\t\tsetStencilWrite: setStencilWrite,\n\t\t\t\tsetStencilFunc: setStencilFunc,\n\t\t\t\tsetStencilOp: setStencilOp,\n\t\n\t\t\t\tsetFlipSided: setFlipSided,\n\t\t\t\tsetCullFace: setCullFace,\n\t\n\t\t\t\tsetLineWidth: setLineWidth,\n\t\t\t\tsetPolygonOffset: setPolygonOffset,\n\t\n\t\t\t\tgetScissorTest: getScissorTest,\n\t\t\t\tsetScissorTest: setScissorTest,\n\t\n\t\t\t\tactiveTexture: activeTexture,\n\t\t\t\tbindTexture: bindTexture,\n\t\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\t\ttexImage2D: texImage2D,\n\t\n\t\t\t\tclearColor: clearColor,\n\t\t\t\tclearDepth: clearDepth,\n\t\t\t\tclearStencil: clearStencil,\n\t\n\t\t\t\tscissor: scissor,\n\t\t\t\tviewport: viewport,\n\t\n\t\t\t\treset: reset\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\t\n\t\t\tvar maxAnisotropy;\n\t\n\t\t\tfunction getMaxAnisotropy() {\n\t\n\t\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\t\n\t\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmaxAnisotropy = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn maxAnisotropy;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getMaxPrecision( precision ) {\n\t\n\t\t\t\tif ( precision === 'highp' ) {\n\t\n\t\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\t\treturn 'highp';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprecision = 'mediump';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( precision === 'mediump' ) {\n\t\n\t\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\t\treturn 'mediump';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn 'lowp';\n\t\n\t\t\t}\n\t\n\t\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\t\tvar maxPrecision = getMaxPrecision( precision );\n\t\n\t\t\tif ( maxPrecision !== precision ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\t\tprecision = maxPrecision;\n\t\n\t\t\t}\n\t\n\t\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );\n\t\n\t\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\t\n\t\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\t\n\t\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\t\n\t\t\treturn {\n\t\n\t\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\t\tgetMaxPrecision: getMaxPrecision,\n\t\n\t\t\t\tprecision: precision,\n\t\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\n\t\t\t\tmaxTextures: maxTextures,\n\t\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\t\tmaxCubemapSize: maxCubemapSize,\n\t\n\t\t\t\tmaxAttributes: maxAttributes,\n\t\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\t\tmaxVaryings: maxVaryings,\n\t\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\t\n\t\t\t\tvertexTextures: vertexTextures,\n\t\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\t\tfloatVertexTextures: floatVertexTextures\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLExtensions( gl ) {\n\t\n\t\t\tvar extensions = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( name ) {\n\t\n\t\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn extensions[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar extension;\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\textension = gl.getExtension( name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\textensions[ name ] = extension;\n\t\n\t\t\t\t\treturn extension;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction WebGLClipping() {\n\t\n\t\t\tvar scope = this,\n\t\n\t\t\t\tglobalState = null,\n\t\t\t\tnumGlobalPlanes = 0,\n\t\t\t\tlocalClippingEnabled = false,\n\t\t\t\trenderingShadows = false,\n\t\n\t\t\t\tplane = new Plane(),\n\t\t\t\tviewNormalMatrix = new Matrix3(),\n\t\n\t\t\t\tuniform = { value: null, needsUpdate: false };\n\t\n\t\t\tthis.uniform = uniform;\n\t\t\tthis.numPlanes = 0;\n\t\t\tthis.numIntersection = 0;\n\t\n\t\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\t\n\t\t\t\tvar enabled =\n\t\t\t\t\tplanes.length !== 0 ||\n\t\t\t\t\tenableLocalClipping ||\n\t\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\t\tlocalClippingEnabled;\n\t\n\t\t\t\tlocalClippingEnabled = enableLocalClipping;\n\t\n\t\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\t\tnumGlobalPlanes = planes.length;\n\t\n\t\t\t\treturn enabled;\n\t\n\t\t\t};\n\t\n\t\t\tthis.beginShadows = function() {\n\t\n\t\t\t\trenderingShadows = true;\n\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t};\n\t\n\t\t\tthis.endShadows = function() {\n\t\n\t\t\t\trenderingShadows = false;\n\t\t\t\tresetGlobalState();\n\t\n\t\t\t};\n\t\n\t\t\tthis.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\t\n\t\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t\t// there's no local clipping\n\t\n\t\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t\t// there's no global clipping\n\t\n\t\t\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tresetGlobalState();\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\t\tlGlobal = nGlobal * 4,\n\t\n\t\t\t\t\t\tdstArray = cache.clippingState || null;\n\t\n\t\t\t\t\tuniform.value = dstArray; // ensure unique state\n\t\n\t\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\t\n\t\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\t\n\t\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\t\tthis.numPlanes += nGlobal;\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t};\n\t\n\t\t\tfunction resetGlobalState() {\n\t\n\t\t\t\tif ( uniform.value !== globalState ) {\n\t\n\t\t\t\t\tuniform.value = globalState;\n\t\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\t\tscope.numIntersection = 0;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\t\n\t\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\t\tdstArray = null;\n\t\n\t\t\t\tif ( nPlanes !== 0 ) {\n\t\n\t\t\t\t\tdstArray = uniform.value;\n\t\n\t\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\t\n\t\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\t\n\t\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\t\n\t\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\t\n\t\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\t\n\t\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\t\n\t\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuniform.value = dstArray;\n\t\t\t\t\tuniform.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.numPlanes = nPlanes;\n\t\t\t\t\n\t\t\t\treturn dstArray;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author szimek / https://github.com/szimek/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction WebGLRenderer( parameters ) {\n\t\n\t\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\t\n\t\t\tparameters = parameters || {};\n\t\n\t\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\t\n\t\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\t\n\t\t\tvar lights = [];\n\t\n\t\t\tvar opaqueObjects = [];\n\t\t\tvar opaqueObjectsLastIndex = - 1;\n\t\t\tvar transparentObjects = [];\n\t\t\tvar transparentObjectsLastIndex = - 1;\n\t\n\t\t\tvar morphInfluences = new Float32Array( 8 );\n\t\n\t\t\tvar sprites = [];\n\t\t\tvar lensFlares = [];\n\t\n\t\t\t// public properties\n\t\n\t\t\tthis.domElement = _canvas;\n\t\t\tthis.context = null;\n\t\n\t\t\t// clearing\n\t\n\t\t\tthis.autoClear = true;\n\t\t\tthis.autoClearColor = true;\n\t\t\tthis.autoClearDepth = true;\n\t\t\tthis.autoClearStencil = true;\n\t\n\t\t\t// scene graph\n\t\n\t\t\tthis.sortObjects = true;\n\t\n\t\t\t// user-defined clipping\n\t\n\t\t\tthis.clippingPlanes = [];\n\t\t\tthis.localClippingEnabled = false;\n\t\n\t\t\t// physically based shading\n\t\n\t\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\t\tthis.gammaInput = false;\n\t\t\tthis.gammaOutput = false;\n\t\n\t\t\t// physical lights\n\t\n\t\t\tthis.physicallyCorrectLights = false;\n\t\n\t\t\t// tone mapping\n\t\n\t\t\tthis.toneMapping = LinearToneMapping;\n\t\t\tthis.toneMappingExposure = 1.0;\n\t\t\tthis.toneMappingWhitePoint = 1.0;\n\t\n\t\t\t// morphs\n\t\n\t\t\tthis.maxMorphTargets = 8;\n\t\t\tthis.maxMorphNormals = 4;\n\t\n\t\t\t// internal properties\n\t\n\t\t\tvar _this = this,\n\t\n\t\t\t// internal state cache\n\t\n\t\t\t_currentProgram = null,\n\t\t\t_currentRenderTarget = null,\n\t\t\t_currentFramebuffer = null,\n\t\t\t_currentMaterialId = - 1,\n\t\t\t_currentGeometryProgram = '',\n\t\t\t_currentCamera = null,\n\t\n\t\t\t_currentScissor = new Vector4(),\n\t\t\t_currentScissorTest = null,\n\t\n\t\t\t_currentViewport = new Vector4(),\n\t\n\t\t\t//\n\t\n\t\t\t_usedTextureUnits = 0,\n\t\n\t\t\t//\n\t\n\t\t\t_clearColor = new Color( 0x000000 ),\n\t\t\t_clearAlpha = 0,\n\t\n\t\t\t_width = _canvas.width,\n\t\t\t_height = _canvas.height,\n\t\n\t\t\t_pixelRatio = 1,\n\t\n\t\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t\t_scissorTest = false,\n\t\n\t\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\t\n\t\t\t// frustum\n\t\n\t\t\t_frustum = new Frustum(),\n\t\n\t\t\t// clipping\n\t\n\t\t\t_clipping = new WebGLClipping(),\n\t\t\t_clippingEnabled = false,\n\t\t\t_localClippingEnabled = false,\n\t\n\t\t\t_sphere = new Sphere(),\n\t\n\t\t\t// camera matrices cache\n\t\n\t\t\t_projScreenMatrix = new Matrix4(),\n\t\n\t\t\t_vector3 = new Vector3(),\n\t\n\t\t\t// light arrays cache\n\t\n\t\t\t_lights = {\n\t\n\t\t\t\thash: '',\n\t\n\t\t\t\tambient: [ 0, 0, 0 ],\n\t\t\t\tdirectional: [],\n\t\t\t\tdirectionalShadowMap: [],\n\t\t\t\tdirectionalShadowMatrix: [],\n\t\t\t\tspot: [],\n\t\t\t\tspotShadowMap: [],\n\t\t\t\tspotShadowMatrix: [],\n\t\t\t\tpoint: [],\n\t\t\t\tpointShadowMap: [],\n\t\t\t\tpointShadowMatrix: [],\n\t\t\t\themi: [],\n\t\n\t\t\t\tshadows: []\n\t\n\t\t\t},\n\t\n\t\t\t// info\n\t\n\t\t\t_infoRender = {\n\t\n\t\t\t\tcalls: 0,\n\t\t\t\tvertices: 0,\n\t\t\t\tfaces: 0,\n\t\t\t\tpoints: 0\n\t\n\t\t\t};\n\t\n\t\t\tthis.info = {\n\t\n\t\t\t\trender: _infoRender,\n\t\t\t\tmemory: {\n\t\n\t\t\t\t\tgeometries: 0,\n\t\t\t\t\ttextures: 0\n\t\n\t\t\t\t},\n\t\t\t\tprograms: null\n\t\n\t\t\t};\n\t\n\t\n\t\t\t// initialize\n\t\n\t\t\tvar _gl;\n\t\n\t\t\ttry {\n\t\n\t\t\t\tvar attributes = {\n\t\t\t\t\talpha: _alpha,\n\t\t\t\t\tdepth: _depth,\n\t\t\t\t\tstencil: _stencil,\n\t\t\t\t\tantialias: _antialias,\n\t\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t\t};\n\t\n\t\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\t\n\t\t\t\tif ( _gl === null ) {\n\t\n\t\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\t\n\t\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthrow 'Error creating WebGL context.';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\t\n\t\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\t\n\t\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\t\n\t\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t\t} catch ( error ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\t\n\t\t\t}\n\t\n\t\t\tvar extensions = new WebGLExtensions( _gl );\n\t\n\t\t\textensions.get( 'WEBGL_depth_texture' );\n\t\t\textensions.get( 'OES_texture_float' );\n\t\t\textensions.get( 'OES_texture_float_linear' );\n\t\t\textensions.get( 'OES_texture_half_float' );\n\t\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\t\textensions.get( 'OES_standard_derivatives' );\n\t\t\textensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\t\tBufferGeometry.MaxIndex = 4294967296;\n\t\n\t\t\t}\n\t\n\t\t\tvar capabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\t\n\t\t\tvar state = new WebGLState( _gl, extensions, paramThreeToGL );\n\t\t\tvar properties = new WebGLProperties();\n\t\t\tvar textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\t\tvar objects = new WebGLObjects( _gl, properties, this.info );\n\t\t\tvar programCache = new WebGLPrograms( this, capabilities );\n\t\t\tvar lightCache = new WebGLLights();\n\t\n\t\t\tthis.info.programs = programCache.programs;\n\t\n\t\t\tvar bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\t\tvar indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\t\n\t\t\t//\n\t\n\t\t\tvar backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\t\tvar backgroundCamera2 = new PerspectiveCamera();\n\t\t\tvar backgroundPlaneMesh = new Mesh(\n\t\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t\t);\n\t\t\tvar backgroundBoxShader = ShaderLib[ 'cube' ];\n\t\t\tvar backgroundBoxMesh = new Mesh(\n\t\t\t\tnew BoxBufferGeometry( 5, 5, 5 ),\n\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\t\tside: BackSide,\n\t\t\t\t\tdepthTest: false,\n\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\tfog: false\n\t\t\t\t} )\n\t\t\t);\n\t\n\t\t\t//\n\t\n\t\t\tfunction getTargetPixelRatio() {\n\t\n\t\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\t\n\t\t\t}\n\t\n\t\t\tfunction glClearColor( r, g, b, a ) {\n\t\n\t\t\t\tif ( _premultipliedAlpha === true ) {\n\t\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.clearColor( r, g, b, a );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDefaultGLState() {\n\t\n\t\t\t\tstate.init();\n\t\n\t\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t}\n\t\n\t\t\tfunction resetGLState() {\n\t\n\t\t\t\t_currentProgram = null;\n\t\t\t\t_currentCamera = null;\n\t\n\t\t\t\t_currentGeometryProgram = '';\n\t\t\t\t_currentMaterialId = - 1;\n\t\n\t\t\t\tstate.reset();\n\t\n\t\t\t}\n\t\n\t\t\tsetDefaultGLState();\n\t\n\t\t\tthis.context = _gl;\n\t\t\tthis.capabilities = capabilities;\n\t\t\tthis.extensions = extensions;\n\t\t\tthis.properties = properties;\n\t\t\tthis.state = state;\n\t\n\t\t\t// shadow map\n\t\n\t\t\tvar shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );\n\t\n\t\t\tthis.shadowMap = shadowMap;\n\t\n\t\n\t\t\t// Plugins\n\t\n\t\t\tvar spritePlugin = new SpritePlugin( this, sprites );\n\t\t\tvar lensFlarePlugin = new LensFlarePlugin( this, lensFlares );\n\t\n\t\t\t// API\n\t\n\t\t\tthis.getContext = function () {\n\t\n\t\t\t\treturn _gl;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getContextAttributes = function () {\n\t\n\t\t\t\treturn _gl.getContextAttributes();\n\t\n\t\t\t};\n\t\n\t\t\tthis.forceContextLoss = function () {\n\t\n\t\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\t\n\t\t\t};\n\t\n\t\t\tthis.getMaxAnisotropy = function () {\n\t\n\t\t\t\treturn capabilities.getMaxAnisotropy();\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPrecision = function () {\n\t\n\t\t\t\treturn capabilities.precision;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPixelRatio = function () {\n\t\n\t\t\t\treturn _pixelRatio;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setPixelRatio = function ( value ) {\n\t\n\t\t\t\tif ( value === undefined ) return;\n\t\n\t\t\t\t_pixelRatio = value;\n\t\n\t\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getSize = function () {\n\t\n\t\t\t\treturn {\n\t\t\t\t\twidth: _width,\n\t\t\t\t\theight: _height\n\t\t\t\t};\n\t\n\t\t\t};\n\t\n\t\t\tthis.setSize = function ( width, height, updateStyle ) {\n\t\n\t\t\t\t_width = width;\n\t\t\t\t_height = height;\n\t\n\t\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t\t_canvas.height = height * _pixelRatio;\n\t\n\t\t\t\tif ( updateStyle !== false ) {\n\t\n\t\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t\t_canvas.style.height = height + 'px';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setViewport( 0, 0, width, height );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setViewport = function ( x, y, width, height ) {\n\t\n\t\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setScissor = function ( x, y, width, height ) {\n\t\n\t\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setScissorTest = function ( boolean ) {\n\t\n\t\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\t\n\t\t\t};\n\t\n\t\t\t// Clearing\n\t\n\t\t\tthis.getClearColor = function () {\n\t\n\t\t\t\treturn _clearColor;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setClearColor = function ( color, alpha ) {\n\t\n\t\t\t\t_clearColor.set( color );\n\t\n\t\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getClearAlpha = function () {\n\t\n\t\t\t\treturn _clearAlpha;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setClearAlpha = function ( alpha ) {\n\t\n\t\t\t\t_clearAlpha = alpha;\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clear = function ( color, depth, stencil ) {\n\t\n\t\t\t\tvar bits = 0;\n\t\n\t\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\t\n\t\t\t\t_gl.clear( bits );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearColor = function () {\n\t\n\t\t\t\tthis.clear( true, false, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearDepth = function () {\n\t\n\t\t\t\tthis.clear( false, true, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearStencil = function () {\n\t\n\t\t\t\tthis.clear( false, false, true );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\t\n\t\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\t\tthis.clear( color, depth, stencil );\n\t\n\t\t\t};\n\t\n\t\t\t// Reset\n\t\n\t\t\tthis.resetGLState = resetGLState;\n\t\n\t\t\tthis.dispose = function() {\n\t\n\t\t\t\ttransparentObjects = [];\n\t\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\t\topaqueObjects = [];\n\t\t\t\topaqueObjectsLastIndex = -1;\n\t\n\t\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t\t};\n\t\n\t\t\t// Events\n\t\n\t\t\tfunction onContextLost( event ) {\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t\tresetGLState();\n\t\t\t\tsetDefaultGLState();\n\t\n\t\t\t\tproperties.clear();\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMaterialDispose( event ) {\n\t\n\t\t\t\tvar material = event.target;\n\t\n\t\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t\tdeallocateMaterial( material );\n\t\n\t\t\t}\n\t\n\t\t\t// Buffer deallocation\n\t\n\t\t\tfunction deallocateMaterial( material ) {\n\t\n\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t\tproperties.delete( material );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction releaseMaterialProgramReference( material ) {\n\t\n\t\t\t\tvar programInfo = properties.get( material ).program;\n\t\n\t\t\t\tmaterial.program = undefined;\n\t\n\t\t\t\tif ( programInfo !== undefined ) {\n\t\n\t\t\t\t\tprogramCache.releaseProgram( programInfo );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Buffer rendering\n\t\n\t\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\t\n\t\t\t\tstate.initAttributes();\n\t\n\t\t\t\tvar buffers = properties.get( object );\n\t\n\t\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\t\n\t\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\t\tif ( object.hasPositions ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasNormals ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\t\n\t\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t\t     ! material.isMeshStandardMaterial &&\n\t\t\t\t\t       material.shading === FlatShading ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\t\tvar array = object.normalArray;\n\t\n\t\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\t\n\t\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\t\n\t\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\t\n\t\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.normal );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasUvs && material.map ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.color );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\t\n\t\t\t\tobject.count = 0;\n\t\n\t\t\t};\n\t\n\t\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\t\n\t\t\t\tsetMaterial( material );\n\t\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\t\n\t\t\t\tvar updateBuffers = false;\n\t\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\t\n\t\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\t\n\t\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph targets\n\t\n\t\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\t\n\t\t\t\tif ( morphTargetInfluences !== undefined ) {\n\t\n\t\t\t\t\tvar activeInfluences = [];\n\t\n\t\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\t\n\t\t\t\t\tif ( activeInfluences.length > 8 ) {\n\t\n\t\t\t\t\t\tactiveInfluences.length = 8;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\t\n\t\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\t\n\t\t\t\t\t\t\tvar index = influence[ 1 ];\n\t\n\t\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmorphInfluences[ i ] = 0.0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\t\n\t\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar position = geometry.attributes.position;\n\t\t\t\tvar rangeFactor = 1;\n\t\n\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\t\t\t\trangeFactor = 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar renderer;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\t\trenderer.setIndex( index );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer = bufferRenderer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( updateBuffers ) {\n\t\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar dataCount = 0;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tdataCount = index.count;\n\t\n\t\t\t\t} else if ( position !== undefined ) {\n\t\n\t\t\t\t\tdataCount = position.count;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\t\n\t\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\t\n\t\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\t\n\t\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\t\n\t\t\t\tif ( drawCount === 0 ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( object.isMesh ) {\n\t\n\t\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tswitch ( object.drawMode ) {\n\t\n\t\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t} else if ( object.isLine ) {\n\t\n\t\t\t\t\tvar lineWidth = material.linewidth;\n\t\n\t\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\t\n\t\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\t\n\t\t\t\t\tif ( object.isLineSegments ) {\n\t\n\t\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object.isPoints ) {\n\t\n\t\t\t\t\trenderer.setMode( _gl.POINTS );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\t\n\t\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\t\n\t\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer.render( drawStart, drawCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\t\n\t\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\t\n\t\t\t\tstate.initAttributes();\n\t\n\t\t\t\tvar geometryAttributes = geometry.attributes;\n\t\n\t\t\t\tvar programAttributes = program.getAttributes();\n\t\n\t\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\t\n\t\t\t\tfor ( var name in programAttributes ) {\n\t\n\t\t\t\t\tvar programAttribute = programAttributes[ name ];\n\t\n\t\t\t\t\tif ( programAttribute >= 0 ) {\n\t\n\t\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\t\n\t\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\t\n\t\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\t\n\t\t\t\t\t\t\t\tconsole.warn( \"Unsupported data buffer format: Float64Array\" );\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.SHORT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.INT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.BYTE;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\t\n\t\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\t\n\t\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\t\n\t\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tswitch ( value.length ) {\n\t\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t}\n\t\n\t\t\t// Sorting\n\t\n\t\t\tfunction absNumericalSort( a, b ) {\n\t\n\t\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\t\n\t\t\t}\n\t\n\t\t\tfunction painterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\t\n\t\t\t\t\treturn a.material.program.id - b.material.program.id;\n\t\n\t\t\t\t} else if ( a.material.id !== b.material.id ) {\n\t\n\t\t\t\t\treturn a.material.id - b.material.id;\n\t\n\t\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn a.z - b.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction reversePainterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t\t} if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Rendering\n\t\n\t\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\t\n\t\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// reset caching for this frame\n\t\n\t\t\t\t_currentGeometryProgram = '';\n\t\t\t\t_currentMaterialId = - 1;\n\t\t\t\t_currentCamera = null;\n\t\n\t\t\t\t// update scene graph\n\t\n\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\n\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\t\n\t\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\t\n\t\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\tlights.length = 0;\n\t\n\t\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\t\ttransparentObjectsLastIndex = - 1;\n\t\n\t\t\t\tsprites.length = 0;\n\t\t\t\tlensFlares.length = 0;\n\t\n\t\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\t\n\t\t\t\tprojectObject( scene, camera );\n\t\n\t\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\t\n\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\t\n\t\t\t\tsetupShadows( lights );\n\t\n\t\t\t\tshadowMap.render( scene, camera );\n\t\n\t\t\t\tsetupLights( lights, camera );\n\t\n\t\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\t\n\t\t\t\t//\n\t\n\t\t\t\t_infoRender.calls = 0;\n\t\t\t\t_infoRender.vertices = 0;\n\t\t\t\t_infoRender.faces = 0;\n\t\t\t\t_infoRender.points = 0;\n\t\n\t\t\t\tif ( renderTarget === undefined ) {\n\t\n\t\t\t\t\trenderTarget = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setRenderTarget( renderTarget );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar background = scene.background;\n\t\n\t\t\t\tif ( background === null ) {\n\t\n\t\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t\t} else if ( background && background.isColor ) {\n\t\n\t\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\t\t\t\tforceClear = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClear || forceClear ) {\n\t\n\t\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( background && background.isCubeTexture ) {\n\t\n\t\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\t\n\t\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\t\n\t\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\t\n\t\t\t\t\tobjects.update( backgroundBoxMesh );\n\t\n\t\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\t\n\t\t\t\t} else if ( background && background.isTexture ) {\n\t\n\t\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\t\n\t\t\t\t\tobjects.update( backgroundPlaneMesh );\n\t\n\t\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( scene.overrideMaterial ) {\n\t\n\t\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\t\n\t\t\t\t\trenderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\t\trenderObjects( transparentObjects, scene, camera, overrideMaterial );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// opaque pass (front-to-back order)\n\t\n\t\t\t\t\tstate.setBlending( NoBlending );\n\t\t\t\t\trenderObjects( opaqueObjects, scene, camera );\n\t\n\t\t\t\t\t// transparent pass (back-to-front order)\n\t\n\t\t\t\t\trenderObjects( transparentObjects, scene, camera );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// custom render plugins (post pass)\n\t\n\t\t\t\tspritePlugin.render( scene, camera );\n\t\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\t\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\t\n\t\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\t\n\t\t\t\tstate.setDepthTest( true );\n\t\t\t\tstate.setDepthWrite( true );\n\t\t\t\tstate.setColorWrite( true );\n\t\n\t\t\t\t// _gl.finish();\n\t\n\t\t\t};\n\t\n\t\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\t\n\t\t\t\tvar array, index;\n\t\n\t\t\t\t// allocate the next position in the appropriate array\n\t\n\t\t\t\tif ( material.transparent ) {\n\t\n\t\t\t\t\tarray = transparentObjects;\n\t\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tarray = opaqueObjects;\n\t\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// recycle existing render item or grow the array\n\t\n\t\t\t\tvar renderItem = array[ index ];\n\t\n\t\t\t\tif ( renderItem !== undefined ) {\n\t\n\t\t\t\t\trenderItem.id = object.id;\n\t\t\t\t\trenderItem.object = object;\n\t\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\t\trenderItem.material = material;\n\t\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\t\trenderItem.group = group;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderItem = {\n\t\t\t\t\t\tid: object.id,\n\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\t\tgroup: group\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// assert( index === array.length );\n\t\t\t\t\tarray.push( renderItem );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// TODO Duplicated code (Frustum)\n\t\n\t\t\tfunction isObjectViewable( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\t\tapplyMatrix4( object.matrixWorld );\n\t\n\t\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t\t}\n\t\n\t\t\tfunction isSpriteViewable( sprite ) {\n\t\n\t\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t\t}\n\t\n\t\t\tfunction isSphereViewable( sphere ) {\n\t\n\t\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\t\n\t\t\t\tvar numPlanes = _clipping.numPlanes;\n\t\n\t\t\t\tif ( numPlanes === 0 ) return true;\n\t\n\t\t\t\tvar planes = _this.clippingPlanes,\n\t\n\t\t\t\t\tcenter = sphere.center,\n\t\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\t\ti = 0;\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\t\n\t\t\t\t} while ( ++ i !== numPlanes );\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectObject( object, camera ) {\n\t\n\t\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\t\n\t\t\t\tif ( visible ) {\n\t\n\t\t\t\t\tif ( object.isLight ) {\n\t\n\t\t\t\t\t\tlights.push( object );\n\t\n\t\t\t\t\t} else if ( object.isSprite ) {\n\t\n\t\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\t\n\t\t\t\t\t\t\tsprites.push( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( object.isLensFlare ) {\n\t\n\t\t\t\t\t\tlensFlares.push( object );\n\t\n\t\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\t\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\t\n\t\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\t\n\t\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\t\n\t\t\t\t\t\t\tobject.skeleton.update();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\t\n\t\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\t\n\t\t\t\t\t\t\t\tif ( material.isMultiMaterial ) {\n\t\n\t\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tprojectObject( children[ i ], camera );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\t\n\t\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar renderItem = renderList[ i ];\n\t\n\t\t\t\t\tvar object = renderItem.object;\n\t\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\t\tvar group = renderItem.group;\n\t\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\t\n\t\t\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\t\n\t\t\t\t\tif ( object.isImmediateRenderObject ) {\n\t\n\t\t\t\t\t\tsetMaterial( material );\n\t\n\t\t\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\t\n\t\t\t\t\t\t_currentGeometryProgram = '';\n\t\n\t\t\t\t\t\tobject.render( function ( object ) {\n\t\n\t\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\t\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\t\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction initMaterial( material, fog, object ) {\n\t\n\t\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\t\n\t\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\t\n\t\t\t\tvar program = materialProperties.program;\n\t\t\t\tvar programChange = true;\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\t// new material\n\t\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t\t} else if ( program.code !== code ) {\n\t\n\t\t\t\t\t// changed glsl or parameters\n\t\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\t\n\t\t\t\t\t// same glsl and uniform list\n\t\t\t\t\treturn;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// only rebuild uniform list\n\t\t\t\t\tprogramChange = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( programChange ) {\n\t\n\t\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\t\n\t\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\t\n\t\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\t\n\t\t\t\t\tmaterialProperties.program = program;\n\t\t\t\t\tmaterial.program = program;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\t\n\t\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\t\n\t\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.morphNormals ) {\n\t\n\t\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\t\n\t\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\t\n\t\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t\t     ! material.isRawShaderMaterial ||\n\t\t\t\t       material.clipping === true ) {\n\t\n\t\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterialProperties.fog = fog;\n\t\n\t\t\t\t// store the light setup it was created for\n\t\n\t\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\t\n\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t// wire up the material to this renderer's lighting state\n\t\n\t\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\t\n\t\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\t\tuniformsList =\n\t\t\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\t\n\t\t\t\tmaterialProperties.uniformsList = uniformsList;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setMaterial( material ) {\n\t\n\t\t\t\tmaterial.side === DoubleSide\n\t\t\t\t\t? state.disable( _gl.CULL_FACE )\n\t\t\t\t\t: state.enable( _gl.CULL_FACE );\n\t\n\t\t\t\tstate.setFlipSided( material.side === BackSide );\n\t\n\t\t\t\tmaterial.transparent === true\n\t\t\t\t\t? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t\t: state.setBlending( NoBlending );\n\t\n\t\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setProgram( camera, fog, material, object ) {\n\t\n\t\t\t\t_usedTextureUnits = 0;\n\t\n\t\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\t\tif ( _clippingEnabled ) {\n\t\n\t\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\t\n\t\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\t\n\t\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.needsUpdate === false ) {\n\t\n\t\t\t\t\tif ( materialProperties.program === undefined ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes || \n\t\t \t\t\t\t  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.needsUpdate ) {\n\t\n\t\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\t\tmaterial.needsUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar refreshProgram = false;\n\t\t\t\tvar refreshMaterial = false;\n\t\t\t\tvar refreshLights = false;\n\t\n\t\t\t\tvar program = materialProperties.program,\n\t\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\t\tif ( program.id !== _currentProgram ) {\n\t\n\t\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t\t_currentProgram = program.id;\n\t\n\t\t\t\t\trefreshProgram = true;\n\t\t\t\t\trefreshMaterial = true;\n\t\t\t\t\trefreshLights = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.id !== _currentMaterialId ) {\n\t\n\t\t\t\t\t_currentMaterialId = material.id;\n\t\n\t\t\t\t\trefreshMaterial = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\t\n\t\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\t\n\t\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\t\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\tif ( camera !== _currentCamera ) {\n\t\n\t\t\t\t\t\t_currentCamera = camera;\n\t\n\t\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t\t// the next material that does gets activated:\n\t\n\t\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// load material specific uniforms\n\t\t\t\t\t// (shader material also gets them for the sake of genericity)\n\t\n\t\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t\t     material.envMap ) {\n\t\n\t\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\t\n\t\t\t\t\t\tif ( uCamPos !== undefined ) {\n\t\n\t\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t\t     material.isMeshBasicMaterial ||\n\t\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t\t     material.isShaderMaterial ||\n\t\t\t\t\t     material.skinning ) {\n\t\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t\t// not sure why, but otherwise weird things happen\n\t\n\t\t\t\tif ( material.skinning ) {\n\t\n\t\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\t\n\t\t\t\t\tvar skeleton = object.skeleton;\n\t\n\t\t\t\t\tif ( skeleton ) {\n\t\n\t\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\t\n\t\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( refreshMaterial ) {\n\t\n\t\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t\t// the current material requires lighting info\n\t\n\t\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t\t// values\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t\t// the GL state when required\n\t\n\t\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// refresh uniforms common to several materials\n\t\n\t\t\t\t\tif ( fog && material.fog ) {\n\t\n\t\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.isMeshBasicMaterial ||\n\t\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t\t     material.isMeshDepthMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// refresh single material specific uniforms\n\t\n\t\t\t\t\tif ( material.isLineBasicMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isLineDashedMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isPointsMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshPhysicalMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\t\n\t\t\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\t\n\t\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tWebGLUniforms.upload(\n\t\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// common matrices\n\t\n\t\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t\t// Uniforms (refresh uniforms objects)\n\t\n\t\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\t\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\n\t\t\t\tif ( material.emissive ) {\n\t\n\t\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\n\t\t\t\tif ( material.aoMap ) {\n\t\n\t\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\t\n\t\t\t\tvar uvScaleMap;\n\t\n\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\tuvScaleMap = material.map;\n\t\n\t\t\t\t} else if ( material.specularMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\t\n\t\t\t\t} else if ( material.displacementMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\t\n\t\t\t\t} else if ( material.normalMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\t\n\t\t\t\t} else if ( material.bumpMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\t\n\t\t\t\t} else if ( material.roughnessMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.roughnessMap;\n\t\n\t\t\t\t} else if ( material.metalnessMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.metalnessMap;\n\t\n\t\t\t\t} else if ( material.alphaMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\t\n\t\t\t\t} else if ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvScaleMap !== undefined ) {\n\t\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\t\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\t\tvar repeat = uvScaleMap.repeat;\n\t\n\t\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\n\t\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\t\n\t\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsLine( uniforms, material ) {\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsDash( uniforms, material ) {\n\t\n\t\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\t\tuniforms.scale.value = material.scale;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\t\tuniforms.scale.value = _height * 0.5;\n\t\n\t\t\t\tuniforms.map.value = material.map;\n\t\n\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\tvar offset = material.map.offset;\n\t\t\t\t\tvar repeat = material.map.repeat;\n\t\n\t\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\t\n\t\t\t\tuniforms.fogColor.value = fog.color;\n\t\n\t\t\t\tif ( fog.isFog ) {\n\t\n\t\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\t\tuniforms.fogFar.value = fog.far;\n\t\n\t\t\t\t} else if ( fog.isFogExp2 ) {\n\t\n\t\t\t\t\tuniforms.fogDensity.value = fog.density;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\t\n\t\t\t\tuniforms.specular.value = material.specular;\n\t\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\t\n\t\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\t\tuniforms.metalness.value = material.metalness;\n\t\n\t\t\t\tif ( material.roughnessMap ) {\n\t\n\t\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.metalnessMap ) {\n\t\n\t\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.envMap ) {\n\t\n\t\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\t\n\t\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\t\n\t\t\t\trefreshUniformsStandard( uniforms, material );\n\t\n\t\t\t}\n\t\n\t\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\t\n\t\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\t\n\t\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\n\t\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\t\n\t\t\t}\n\t\n\t\t\t// Lighting\n\t\n\t\t\tfunction setupShadows( lights ) {\n\t\n\t\t\t\tvar lightShadowsLength = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar light = lights[ i ];\n\t\n\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_lights.shadows.length = lightShadowsLength;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setupLights( lights, camera ) {\n\t\n\t\t\t\tvar l, ll, light,\n\t\t\t\tr = 0, g = 0, b = 0,\n\t\t\t\tcolor,\n\t\t\t\tintensity,\n\t\t\t\tdistance,\n\t\t\t\tshadowMap,\n\t\n\t\t\t\tviewMatrix = camera.matrixWorldInverse,\n\t\n\t\t\t\tdirectionalLength = 0,\n\t\t\t\tpointLength = 0,\n\t\t\t\tspotLength = 0,\n\t\t\t\themiLength = 0;\n\t\n\t\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\t\n\t\t\t\t\tlight = lights[ l ];\n\t\n\t\t\t\t\tcolor = light.color;\n\t\t\t\t\tintensity = light.intensity;\n\t\t\t\t\tdistance = light.distance;\n\t\n\t\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\t\n\t\t\t\t\tif ( light.isAmbientLight ) {\n\t\n\t\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\t\tb += color.b * intensity;\n\t\n\t\t\t\t\t} else if ( light.isDirectionalLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\t\n\t\t\t\t\t} else if ( light.isSpotLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\t\tuniforms.distance = distance;\n\t\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\t\n\t\t\t\t\t} else if ( light.isPointLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\t\n\t\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\t\n\t\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new Matrix4();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\t\n\t\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\t\n\t\t\t\t\t} else if ( light.isHemisphereLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\t\tuniforms.direction.normalize();\n\t\n\t\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\t\n\t\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t\t_lights.ambient[ 2 ] = b;\n\t\n\t\t\t\t_lights.directional.length = directionalLength;\n\t\t\t\t_lights.spot.length = spotLength;\n\t\t\t\t_lights.point.length = pointLength;\n\t\t\t\t_lights.hemi.length = hemiLength;\n\t\n\t\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\t\n\t\t\t}\n\t\n\t\t\t// GL state setting\n\t\n\t\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\t\n\t\t\t\tstate.setCullFace( cullFace );\n\t\t\t\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\n\t\n\t\t\t};\n\t\n\t\t\t// Textures\n\t\n\t\t\tfunction allocTextureUnit() {\n\t\n\t\t\t\tvar textureUnit = _usedTextureUnits;\n\t\n\t\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\t\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_usedTextureUnits += 1;\n\t\n\t\t\t\treturn textureUnit;\n\t\n\t\t\t}\n\t\n\t\t\tthis.allocTextureUnit = allocTextureUnit;\n\t\n\t\t\t// this.setTexture2D = setTexture2D;\n\t\t\tthis.setTexture2D = ( function() {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\treturn function setTexture2D( texture, slot ) {\n\t\n\t\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\t\n\t\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.setTexture = ( function() {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\treturn function setTexture( texture, slot ) {\n\t\n\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.setTextureCube = ( function() {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\treturn function setTextureCube( texture, slot ) {\n\t\n\t\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\t\n\t\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t\t// TODO: unify these code paths\n\t\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\t\n\t\t\t\t\t\t// CompressedTexture can have Array in image :/\n\t\n\t\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\t\n\t\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.getCurrentRenderTarget = function() {\n\t\n\t\t\t\treturn _currentRenderTarget;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setRenderTarget = function ( renderTarget ) {\n\t\n\t\t\t\t_currentRenderTarget = renderTarget;\n\t\n\t\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\t\n\t\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\t\tvar framebuffer;\n\t\n\t\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\t\n\t\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tframebuffer = null;\n\t\n\t\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t\t_currentScissorTest = _scissorTest;\n\t\n\t\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\t\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t\t_currentFramebuffer = framebuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.scissor( _currentScissor );\n\t\t\t\tstate.setScissorTest( _currentScissorTest );\n\t\n\t\t\t\tstate.viewport( _currentViewport );\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\t\n\t\t\t\tif ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\n\t\t\t\tif ( framebuffer ) {\n\t\n\t\t\t\t\tvar restore = false;\n\t\n\t\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\t\t\trestore = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\t\tvar textureType = texture.type;\n\t\n\t\t\t\t\t\tif ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t\t     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t\t     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\t\n\t\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\n\t\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\t\n\t\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} finally {\n\t\n\t\t\t\t\t\tif ( restore ) {\n\t\n\t\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\t// Map three.js constants to WebGL constants\n\t\n\t\t\tfunction paramThreeToGL( p ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( p === RepeatWrapping ) return _gl.REPEAT;\n\t\t\t\tif ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\t\tif ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\t\n\t\t\t\tif ( p === NearestFilter ) return _gl.NEAREST;\n\t\t\t\tif ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\t\tif ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\t\n\t\t\t\tif ( p === LinearFilter ) return _gl.LINEAR;\n\t\t\t\tif ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\t\tif ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\t\n\t\t\t\tif ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\t\tif ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\t\tif ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\t\tif ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\t\n\t\t\t\tif ( p === ByteType ) return _gl.BYTE;\n\t\t\t\tif ( p === ShortType ) return _gl.SHORT;\n\t\t\t\tif ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\t\tif ( p === IntType ) return _gl.INT;\n\t\t\t\tif ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\t\tif ( p === FloatType ) return _gl.FLOAT;\n\t\n\t\t\t\tif ( p === HalfFloatType ) {\n\t\n\t\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === AlphaFormat ) return _gl.ALPHA;\n\t\t\t\tif ( p === RGBFormat ) return _gl.RGB;\n\t\t\t\tif ( p === RGBAFormat ) return _gl.RGBA;\n\t\t\t\tif ( p === LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\t\tif ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\t\tif ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\t\t\tif ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;\n\t\n\t\t\t\tif ( p === AddEquation ) return _gl.FUNC_ADD;\n\t\t\t\tif ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\t\tif ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\t\n\t\t\t\tif ( p === ZeroFactor ) return _gl.ZERO;\n\t\t\t\tif ( p === OneFactor ) return _gl.ONE;\n\t\t\t\tif ( p === SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\t\tif ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\t\tif ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\t\tif ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\t\tif ( p === DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\t\tif ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\t\n\t\t\t\tif ( p === DstColorFactor ) return _gl.DST_COLOR;\n\t\t\t\tif ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\t\tif ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\t\n\t\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\t\t p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === RGB_ETC1_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\t\n\t\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === UnsignedInt248Type ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn 0;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction FogExp2 ( color, density ) {\n\t\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.color = new Color( color );\n\t\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\t\n\t\t}\n\t\n\t\tFogExp2.prototype.isFogExp2 = true;\n\t\n\t\tFogExp2.prototype.clone = function () {\n\t\n\t\t\treturn new FogExp2( this.color.getHex(), this.density );\n\t\n\t\t};\n\t\n\t\tFogExp2.prototype.toJSON = function ( meta ) {\n\t\n\t\t\treturn {\n\t\t\t\ttype: 'FogExp2',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tdensity: this.density\n\t\t\t};\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Fog ( color, near, far ) {\n\t\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.color = new Color( color );\n\t\n\t\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\t\n\t\t}\n\t\n\t\tFog.prototype.isFog = true;\n\t\n\t\tFog.prototype.clone = function () {\n\t\n\t\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\t\n\t\t};\n\t\n\t\tFog.prototype.toJSON = function ( meta ) {\n\t\n\t\t\treturn {\n\t\t\t\ttype: 'Fog',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tnear: this.near,\n\t\t\t\tfar: this.far\n\t\t\t};\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Scene () {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Scene';\n\t\n\t\t\tthis.background = null;\n\t\t\tthis.fog = null;\n\t\t\tthis.overrideMaterial = null;\n\t\n\t\t\tthis.autoUpdate = true; // checked by the renderer\n\t\n\t\t}\n\t\n\t\tScene.prototype = Object.create( Object3D.prototype );\n\t\n\t\tScene.prototype.constructor = Scene;\n\t\n\t\tScene.prototype.copy = function ( source, recursive ) {\n\t\n\t\t\tObject3D.prototype.copy.call( this, source, recursive );\n\t\n\t\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\t\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tScene.prototype.toJSON = function ( meta ) {\n\t\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction LensFlare( texture, size, distance, blending, color ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.lensFlares = [];\n\t\n\t\t\tthis.positionScreen = new Vector3();\n\t\t\tthis.customUpdateCallback = undefined;\n\t\n\t\t\tif ( texture !== undefined ) {\n\t\n\t\t\t\tthis.add( texture, size, distance, blending, color );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: LensFlare,\n\t\n\t\t\tisLensFlare: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\t\n\t\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\t\n\t\t\t\tif ( size === undefined ) size = - 1;\n\t\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\t\tif ( color === undefined ) color = new Color( 0xffffff );\n\t\t\t\tif ( blending === undefined ) blending = NormalBlending;\n\t\n\t\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\t\n\t\t\t\tthis.lensFlares.push( {\n\t\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\t\tcolor: color,\t\t// color\n\t\t\t\t\tblending: blending\t// blending\n\t\t\t\t} );\n\t\n\t\t\t},\n\t\n\t\t\t/*\n\t\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t\t */\n\t\n\t\t\tupdateLensFlares: function () {\n\t\n\t\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\t\tvar flare;\n\t\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\t\tvar vecY = - this.positionScreen.y * 2;\n\t\n\t\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\t\n\t\t\t\t\tflare = this.lensFlares[ f ];\n\t\n\t\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\t\n\t\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *\tuvOffset: new THREE.Vector2(),\n\t\t *\tuvScale: new THREE.Vector2()\n\t\t * }\n\t\t */\n\t\n\t\tfunction SpriteMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'SpriteMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.rotation = 0;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\t\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\t\n\t\tSpriteMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.rotation = source.rotation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Sprite( material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Sprite';\n\t\n\t\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\t\n\t\t}\n\t\n\t\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Sprite,\n\t\n\t\t\tisSprite: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar matrixPosition = new Vector3();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\t\n\t\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\t\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\t\tpoint: this.position,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LOD() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'LOD';\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\tlevels: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: []\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\n\t\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: LOD,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source, false );\n\t\n\t\t\t\tvar levels = source.levels;\n\t\n\t\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddLevel: function ( object, distance ) {\n\t\n\t\t\t\tif ( distance === undefined ) distance = 0;\n\t\n\t\t\t\tdistance = Math.abs( distance );\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\tif ( distance < levels[ l ].distance ) {\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\t\n\t\t\t\tthis.add( object );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectForDistance: function ( distance ) {\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tif ( distance < levels[ i ].distance ) {\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn levels[ i - 1 ].object;\n\t\n\t\t\t},\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar matrixPosition = new Vector3();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\t\n\t\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\treturn function update( camera ) {\n\t\n\t\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\t\tif ( levels.length > 1 ) {\n\t\n\t\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\t\n\t\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\t\n\t\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\t\n\t\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.levels = [];\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\t\tdistance: level.distance\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.image = { data: data, width: width, height: height };\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\n\t\t\tthis.generateMipmaps  = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\n\t\t}\n\t\n\t\tDataTexture.prototype = Object.create( Texture.prototype );\n\t\tDataTexture.prototype.constructor = DataTexture;\n\t\n\t\tDataTexture.prototype.isDataTexture = true;\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author michael guerrero / http://realitymeltdown.com\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction Skeleton( bones, boneInverses, useVertexTexture ) {\n\t\n\t\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\t\n\t\t\tthis.identityMatrix = new Matrix4();\n\t\n\t\t\t// copy the bone array\n\t\n\t\t\tbones = bones || [];\n\t\n\t\t\tthis.bones = bones.slice( 0 );\n\t\n\t\t\t// create a bone texture or an array of floats\n\t\n\t\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\t\n\t\n\t\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\t\tsize = _Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\t\tsize = Math.max( size, 4 );\n\t\n\t\t\t\tthis.boneTextureWidth = size;\n\t\t\t\tthis.boneTextureHeight = size;\n\t\n\t\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\t\tthis.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\t\n\t\t\t}\n\t\n\t\t\t// use the supplied bone inverses or calculate the inverses\n\t\n\t\t\tif ( boneInverses === undefined ) {\n\t\n\t\t\t\tthis.calculateInverses();\n\t\n\t\t\t} else {\n\t\n\t\t\t\tif ( this.bones.length === boneInverses.length ) {\n\t\n\t\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\t\n\t\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tObject.assign( Skeleton.prototype, {\n\t\n\t\t\tcalculateInverses: function () {\n\t\n\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tvar inverse = new Matrix4();\n\t\n\t\t\t\t\tif ( this.bones[ b ] ) {\n\t\n\t\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.boneInverses.push( inverse );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tpose: function () {\n\t\n\t\t\t\tvar bone;\n\t\n\t\t\t\t// recover the bind-time world matrices\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// compute the local matrices, positions, rotations and scales\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\t\n\t\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdate: ( function () {\n\t\n\t\t\t\tvar offsetMatrix = new Matrix4();\n\t\n\t\t\t\treturn function update() {\n\t\n\t\t\t\t\t// flatten bone matrices to array\n\t\n\t\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\t\t// compute the offset between the current and the original transform\n\t\n\t\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\t\n\t\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction Bone( skin ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Bone';\n\t\n\t\t\tthis.skin = skin;\n\t\n\t\t}\n\t\n\t\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Bone,\n\t\n\t\t\tisBone: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.skin = source.skin;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction SkinnedMesh( geometry, material, useVertexTexture ) {\n\t\n\t\t\tMesh.call( this, geometry, material );\n\t\n\t\t\tthis.type = 'SkinnedMesh';\n\t\n\t\t\tthis.bindMode = \"attached\";\n\t\t\tthis.bindMatrix = new Matrix4();\n\t\t\tthis.bindMatrixInverse = new Matrix4();\n\t\n\t\t\t// init bones\n\t\n\t\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t\t// convenience) for THREE.SkinnedMesh to do this.\n\t\n\t\t\tvar bones = [];\n\t\n\t\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\t\n\t\t\t\tvar bone, gbone;\n\t\n\t\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\t\tbone = new Bone( this );\n\t\t\t\t\tbones.push( bone );\n\t\n\t\t\t\t\tbone.name = gbone.name;\n\t\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\t\n\t\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis.add( bones[ b ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.normalizeSkinWeights();\n\t\n\t\t\tthis.updateMatrixWorld( true );\n\t\t\tthis.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\t\n\t\t}\n\t\n\t\n\t\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\t\n\t\t\tconstructor: SkinnedMesh,\n\t\n\t\t\tisSkinnedMesh: true,\n\t\n\t\t\tbind: function( skeleton, bindMatrix ) {\n\t\n\t\t\t\tthis.skeleton = skeleton;\n\t\n\t\t\t\tif ( bindMatrix === undefined ) {\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.skeleton.calculateInverses();\n\t\n\t\t\t\t\tbindMatrix = this.matrixWorld;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\t\n\t\t\t},\n\t\n\t\t\tpose: function () {\n\t\n\t\t\t\tthis.skeleton.pose();\n\t\n\t\t\t},\n\t\n\t\t\tnormalizeSkinWeights: function () {\n\t\n\t\t\t\tif ( (this.geometry && this.geometry.isGeometry) ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\t\n\t\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\t\n\t\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\t\tsw.multiplyScalar( scale );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\tvar vec = new Vector4();\n\t\n\t\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\t\n\t\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\t\n\t\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\t\tvec.w = skinWeight.getW( i );\n\t\n\t\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\t\n\t\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\t\tvec.multiplyScalar( scale );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: function( force ) {\n\t\n\t\t\t\tMesh.prototype.updateMatrixWorld.call( this, true );\n\t\n\t\t\t\tif ( this.bindMode === \"attached\" ) {\n\t\n\t\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\t\n\t\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\t\n\t\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function() {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  linewidth: <float>,\n\t\t *  linecap: \"round\",\n\t\t *  linejoin: \"round\"\n\t\t * }\n\t\t */\n\t\n\t\tfunction LineBasicMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'LineBasicMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.linecap = 'round';\n\t\t\tthis.linejoin = 'round';\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\t\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\t\n\t\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\t\n\t\tLineBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.linewidth = source.linewidth;\n\t\t\tthis.linecap = source.linecap;\n\t\t\tthis.linejoin = source.linejoin;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Line( geometry, material, mode ) {\n\t\n\t\t\tif ( mode === 1 ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\t\treturn new LineSegments( geometry, material );\n\t\n\t\t\t}\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Line';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t}\n\t\n\t\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Line,\n\t\n\t\t\tisLine: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\t\tvar precisionSq = precision * precision;\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\tvar vStart = new Vector3();\n\t\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\t\tvar interRay = new Vector3();\n\t\t\t\t\tvar step = (this && this.isLineSegments) ? 2 : 1;\n\t\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\t\n\t\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\t\n\t\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\t\n\t\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar nbVertices = vertices.length;\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\t\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\t\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LineSegments( geometry, material ) {\n\t\n\t\t\tLine.call( this, geometry, material );\n\t\n\t\t\tthis.type = 'LineSegments';\n\t\n\t\t}\n\t\n\t\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\t\n\t\t\tconstructor: LineSegments,\n\t\n\t\t\tisLineSegments: true\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  size: <float>,\n\t\t *  sizeAttenuation: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction PointsMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'PointsMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.size = 1;\n\t\t\tthis.sizeAttenuation = true;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tPointsMaterial.prototype = Object.create( Material.prototype );\n\t\tPointsMaterial.prototype.constructor = PointsMaterial;\n\t\n\t\tPointsMaterial.prototype.isPointsMaterial = true;\n\t\n\t\tPointsMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.size = source.size;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Points( geometry, material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Points';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t}\n\t\n\t\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Points,\n\t\n\t\t\tisPoints: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar object = this;\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\t\tvar position = new Vector3();\n\t\n\t\t\t\t\tfunction testPoint( point, index ) {\n\t\n\t\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\t\n\t\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\t\n\t\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tobject: object\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\n\t\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\t\n\t\t\t\t\t\t\t\ttestPoint( position, a );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\t\n\t\t\t\t\t\t\t\ttestPoint( position, i );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Group() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Group';\n\t\n\t\t}\n\t\n\t\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Group\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.generateMipmaps = false;\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tfunction update() {\n\t\n\t\t\t\trequestAnimationFrame( update );\n\t\n\t\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\t\n\t\t\t\t\tscope.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tupdate();\n\t\n\t\t}\n\t\n\t\tVideoTexture.prototype = Object.create( Texture.prototype );\n\t\tVideoTexture.prototype.constructor = VideoTexture;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.image = { width: width, height: height };\n\t\t\tthis.mipmaps = mipmaps;\n\t\n\t\t\t// no flipping for cube textures\n\t\t\t// (also flipping doesn't work for compressed textures )\n\t\n\t\t\tthis.flipY = false;\n\t\n\t\t\t// can't generate mipmaps for compressed textures\n\t\t\t// mips must be embedded in DDS files\n\t\n\t\t\tthis.generateMipmaps = false;\n\t\n\t\t}\n\t\n\t\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\t\tCompressedTexture.prototype.constructor = CompressedTexture;\n\t\n\t\tCompressedTexture.prototype.isCompressedTexture = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\t\tCanvasTexture.prototype.constructor = CanvasTexture;\n\t\n\t\t/**\n\t\t * @author Matt DesLauriers / @mattdesl\n\t\t * @author atix / arthursilber.de\n\t\t */\n\t\n\t\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\t\n\t\t\tformat = format !== undefined ? format : DepthFormat;\n\t\n\t\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\t\n\t\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )\n\t\n\t\t\t}\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.image = { width: width, height: height };\n\t\n\t\t\tthis.type = type !== undefined ? type : UnsignedShortType;\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\n\t\t\tthis.flipY = false;\n\t\t\tthis.generateMipmaps\t= false;\n\t\n\t\t}\n\t\n\t\tDepthTexture.prototype = Object.create( Texture.prototype );\n\t\tDepthTexture.prototype.constructor = DepthTexture;\n\t\tDepthTexture.prototype.isDepthTexture = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WireframeGeometry( geometry ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\t\treturn a - b;\n\t\n\t\t\t}\n\t\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar numEdges = 0;\n\t\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\t\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\t\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\t\n\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\tif ( geometry.index !== null ) {\n\t\n\t\t\t\t\t// Indexed BufferGeometry\n\t\n\t\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\tvar numEdges = 0;\n\t\n\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// allocate maximal size\n\t\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\t\n\t\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\t\n\t\t\t\t\t\tvar group = groups[ o ];\n\t\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\t\n\t\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// non-indexed BufferGeometry\n\t\n\t\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\t\tvar numTris = numEdges / 3;\n\t\n\t\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\t\n\t\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\t\n\t\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * Parametric Surfaces Geometry\n\t\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t\t */\n\t\n\t\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'ParametricBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t};\n\t\n\t\t\t// generate vertices and uvs\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\tvar i, j, p;\n\t\t\tvar u, v;\n\t\n\t\t\tvar sliceCount = slices + 1;\n\t\n\t\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\t\n\t\t\t\tv = i / stacks;\n\t\n\t\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\t\n\t\t\t\t\tu = j / slices;\n\t\n\t\t\t\t\tp = func( u, v );\n\t\t\t\t\tvertices.push( p.x, p.y, p.z );\n\t\n\t\t\t\t\tuvs.push( u, v );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tvar indices = [];\n\t\t\tvar a, b, c, d;\n\t\n\t\t\tfor ( i = 0; i < stacks; i ++ ) {\n\t\n\t\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\t\n\t\t\t\t\ta = i * sliceCount + j;\n\t\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\t\n\t\t\t\t\t// faces one and two\n\t\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\t\n\t\t\t// generate normals\n\t\n\t\t\tthis.computeVertexNormals();\n\t\n\t\t}\n\t\n\t\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\t\n\t\t/**\n\t\t * @author zz85 / https://github.com/zz85\n\t\t *\n\t\t * Parametric Surfaces Geometry\n\t\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t\t */\n\t\n\t\tfunction ParametricGeometry( func, slices, stacks ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ParametricGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\t\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'PolyhedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tradius = radius || 1;\n\t\t\tdetail = detail || 0;\n\t\n\t\t\t// default buffer data\n\t\n\t\t\tvar vertexBuffer = [];\n\t\t\tvar uvBuffer = [];\n\t\n\t\t\t// the subdivision creates the vertex buffer data\n\t\n\t\t\tsubdivide( detail );\n\t\n\t\t\t// all vertices should lie on a conceptual sphere with a given radius\n\t\n\t\t\tappplyRadius( radius );\n\t\n\t\t\t// finally, create the uv data\n\t\n\t\t\tgenerateUVs();\n\t\n\t\t\t// build non-indexed geometry\n\t\n\t\t\tthis.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );\n\t\t\tthis.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );\n\t\t\tthis.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );\n\t\t\tthis.normalizeNormals();\n\t\n\t\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction subdivide( detail ) {\n\t\n\t\t\t\tvar a = new Vector3();\n\t\t\t\tvar b = new Vector3();\n\t\t\t\tvar c = new Vector3();\n\t\n\t\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\t\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t// get the vertices of the face\n\t\n\t\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\t\n\t\t\t\t\t// perform subdivision\n\t\n\t\t\t\t\tsubdivideFace( a, b, c, detail );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction subdivideFace( a, b, c, detail ) {\n\t\n\t\t\t\tvar cols = Math.pow( 2, detail );\n\t\n\t\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\t\n\t\t\t\tvar v = [];\n\t\n\t\t\t\tvar i, j;\n\t\n\t\t\t\t// construct all of the vertices for this subdivision\n\t\n\t\t\t\tfor ( i = 0 ; i <= cols; i ++ ) {\n\t\n\t\t\t\t\tv[ i ] = [];\n\t\n\t\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\t\n\t\t\t\t\tvar rows = cols - i;\n\t\n\t\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\t\n\t\t\t\t\t\tif ( j === 0 && i === cols ) {\n\t\n\t\t\t\t\t\t\tv[ i ][ j ] = aj;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// construct all of the faces\n\t\n\t\t\t\tfor ( i = 0; i < cols ; i ++ ) {\n\t\n\t\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\t\n\t\t\t\t\t\tvar k = Math.floor( j / 2 );\n\t\n\t\t\t\t\t\tif ( j % 2 === 0 ) {\n\t\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction appplyRadius( radius ) {\n\t\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\t\n\t\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\t\n\t\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\t\n\t\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\t\n\t\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateUVs() {\n\t\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\t\n\t\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\t\n\t\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\t\tuvBuffer.push( u, 1 - v );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcorrectUVs();\n\t\n\t\t\t\tcorrectSeam();\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctSeam() {\n\t\n\t\t\t\t// handle case when face straddles the seam, see #3269\n\t\n\t\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\t\n\t\t\t\t\t// uv data of a single face\n\t\n\t\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\t\n\t\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\t\n\t\t\t\t\t// 0.9 is somewhat arbitrary\n\t\n\t\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\t\n\t\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushVertex( vertex ) {\n\t\n\t\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t}\n\t\n\t\t\tfunction getVertexByIndex( index, vertex ) {\n\t\n\t\t\t\tvar stride = index * 3;\n\t\n\t\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\t\tvertex.z = vertices[ stride + 2 ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctUVs() {\n\t\n\t\t\t\tvar a = new Vector3();\n\t\t\t\tvar b = new Vector3();\n\t\t\t\tvar c = new Vector3();\n\t\n\t\t\t\tvar centroid = new Vector3();\n\t\n\t\t\t\tvar uvA = new Vector2();\n\t\t\t\tvar uvB = new Vector2();\n\t\t\t\tvar uvC = new Vector2();\n\t\n\t\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\t\n\t\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\t\n\t\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\t\n\t\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\t\n\t\t\t\t\tvar azi = azimuth( centroid );\n\t\n\t\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctUV( uv, stride, vector, azimuth  ) {\n\t\n\t\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\t\n\t\t\t\t\tuvBuffer[ stride ] =  uv.x - 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\t\n\t\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\t\n\t\t\tfunction azimuth( vector ) {\n\t\n\t\t\t\treturn Math.atan2( vector.z, - vector.x );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Angle above the XZ plane.\n\t\n\t\t\tfunction inclination( vector ) {\n\t\n\t\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar vertices = [\n\t\t\t\t1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'TetrahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t */\n\t\n\t\tfunction TetrahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TetrahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction OctahedronBufferGeometry( radius,detail ) {\n\t\n\t\t\tvar vertices = [\n\t\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'OctahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t */\n\t\n\t\tfunction OctahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'OctahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\n\t\t\tvar vertices = [\n\t\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'IcosahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t */\n\t\n\t\tfunction IcosahedronGeometry( radius, detail ) {\n\t\n\t\t \tGeometry.call( this );\n\t\n\t\t\tthis.type = 'IcosahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\t\tvar r = 1 / t;\n\t\n\t\t\tvar vertices = [\n\t\n\t\t\t\t// (±1, ±1, ±1)\n\t\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t\t 1,  1, - 1,     1,  1,  1,\n\t\n\t\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t\t 0,  r, - t,     0,  r,  t,\n\t\n\t\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t\t r, - t,  0,     r,  t,  0,\n\t\n\t\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t\t- t,  0,  r,     t,  0,  r\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'DodecahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Abe Pazos / https://hamoid.com\n\t\t */\n\t\n\t\tfunction DodecahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'DodecahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\t\n\t\t/**\n\t\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'PolyhedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * Creates a tube which extrudes along a 3d spline.\n\t\t *\n\t\t */\n\t\n\t\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TubeBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\n\t\t\ttubularSegments = tubularSegments || 64;\n\t\t\tradius = radius || 1;\n\t\t\tradialSegments = radialSegments || 8;\n\t\t\tclosed = closed || false;\n\t\n\t\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\t\n\t\t\t// expose internals\n\t\n\t\t\tthis.tangents = frames.tangents;\n\t\t\tthis.normals = frames.normals;\n\t\t\tthis.binormals = frames.binormals;\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\n\t\t\tvar i, j;\n\t\n\t\t\t// buffer\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\t\tvar indices = [];\n\t\n\t\t\t// create buffer data\n\t\n\t\t\tgenerateBufferData();\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', Float32Attribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\t\n\t\t\t// functions\n\t\n\t\t\tfunction generateBufferData() {\n\t\n\t\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tgenerateSegment( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t\t// at the regular position on the given path\n\t\t\t\t//\n\t\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\t\n\t\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\t\n\t\t\t\t// uvs are generated in a separate function.\n\t\t\t\t// this makes it easy compute correct values for closed geometries\n\t\n\t\t\t\tgenerateUVs();\n\t\n\t\t\t\t// finally create faces\n\t\n\t\t\t\tgenerateIndices();\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateSegment( i ) {\n\t\n\t\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\t\n\t\t\t\tvar P = path.getPointAt( i / tubularSegments );\n\t\n\t\t\t\t// retrieve corresponding normal and binormal\n\t\n\t\t\t\tvar N = frames.normals[ i ];\n\t\t\t\tvar B = frames.binormals[ i ];\n\t\n\t\t\t\t// generate normals and vertices for the current segment\n\t\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t\tvar sin =   Math.sin( v );\n\t\t\t\t\tvar cos = - Math.cos( v );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\t\tnormal.normalize();\n\t\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\t\tvertex.z = P.z + radius * normal.z;\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateIndices() {\n\t\n\t\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t\t\t// faces\n\t\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateUVs() {\n\t\n\t\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\t\tuv.y = j / radialSegments;\n\t\n\t\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t\t * @author WestLangley / https://github.com/WestLangley\n\t\t * @author zz85 / https://github.com/zz85\n\t\t * @author miningold / https://github.com/miningold\n\t\t * @author jonobr1 / https://github.com/jonobr1\n\t\t *\n\t\t * Creates a tube which extrudes along a 3d spline.\n\t\t */\n\t\n\t\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TubeGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\n\t\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\t\n\t\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\t\n\t\t\t// expose internals\n\t\n\t\t\tthis.tangents = bufferGeometry.tangents;\n\t\t\tthis.normals = bufferGeometry.normals;\n\t\t\tthis.binormals = bufferGeometry.binormals;\n\t\n\t\t\t// create geometry\n\t\n\t\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTubeGeometry.prototype.constructor = TubeGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t\t */\n\t\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusKnotBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\n\t\t\tradius = radius || 100;\n\t\t\ttube = tube || 40;\n\t\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\tp = p || 2;\n\t\t\tq = q || 3;\n\t\n\t\t\t// used to calculate buffer length\n\t\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// helper variables\n\t\t\tvar i, j, index = 0, indexOffset = 0;\n\t\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\n\t\t\tvar P1 = new Vector3();\n\t\t\tvar P2 = new Vector3();\n\t\n\t\t\tvar B = new Vector3();\n\t\t\tvar T = new Vector3();\n\t\t\tvar N = new Vector3();\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\t\n\t\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\t\n\t\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\t\n\t\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\t\n\t\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\t\n\t\t\t\t// calculate orthonormal basis\n\t\n\t\t\t\tT.subVectors( P2, P1 );\n\t\t\t\tN.addVectors( P2, P1 );\n\t\t\t\tB.crossVectors( T, N );\n\t\t\t\tN.crossVectors( B, T );\n\t\n\t\t\t\t// normalize B, N. T can be ignored, we don't use it\n\t\n\t\t\t\tB.normalize();\n\t\t\t\tN.normalize();\n\t\n\t\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\t\n\t\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\t\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\t\tvar cy = tube * Math.sin( v );\n\t\n\t\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\t\n\t\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\t// this function calculates the current position on the torus curve\n\t\n\t\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\t\n\t\t\t\tvar cu = Math.cos( u );\n\t\t\t\tvar su = Math.sin( u );\n\t\t\t\tvar quOverP = q / p * u;\n\t\t\t\tvar cs = Math.cos( quOverP );\n\t\n\t\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode\n\t\t */\n\t\n\t\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusKnotGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\n\t\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\t\n\t\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\n\t\t\tradius = radius || 100;\n\t\t\ttube = tube || 40;\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\t\tarc = arc || Math.PI * 2;\n\t\n\t\t\t// used to calculate buffer length\n\t\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t\t// offset variables\n\t\t\tvar vertexBufferOffset = 0;\n\t\t\tvar uvBufferOffset = 0;\n\t\t\tvar indexBufferOffset = 0;\n\t\n\t\t\t// helper variables\n\t\t\tvar center = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\n\t\t\tvar j, i;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\t\tvertex.z = tube * Math.sin( v );\n\t\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\t\n\t\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\t\n\t\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\t\n\t\t\t\t\t// update offsets\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t\t// update offset\n\t\t\t\t\tindexBufferOffset += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t\t */\n\t\n\t\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\t\n\t\t}\n\t\n\t\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTorusGeometry.prototype.constructor = TorusGeometry;\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tvar ShapeUtils = {\n\t\n\t\t\t// calculate area of the contour polygon\n\t\n\t\t\tarea: function ( contour ) {\n\t\n\t\t\t\tvar n = contour.length;\n\t\t\t\tvar a = 0.0;\n\t\n\t\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\t\n\t\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn a * 0.5;\n\t\n\t\t\t},\n\t\n\t\t\ttriangulate: ( function () {\n\t\n\t\t\t\t/**\n\t\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t\t * See original code and more information here:\n\t\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t\t *\n\t\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t\t * www.actionsnippet.com\n\t\t\t\t *\n\t\t\t\t * ported to javascript by Joshua Koo\n\t\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t\t *\n\t\t\t\t */\n\t\n\t\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\t\n\t\t\t\t\tvar p;\n\t\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\t\tvar cx, cy, px, py;\n\t\n\t\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\t\tay = contour[ verts[ u ] ].y;\n\t\n\t\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\t\tby = contour[ verts[ v ] ].y;\n\t\n\t\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\t\tcy = contour[ verts[ w ] ].y;\n\t\n\t\t\t\t\tif ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;\n\t\n\t\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\t\n\t\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\t\tcX = bx - ax;  cY = by - ay;\n\t\n\t\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\t\n\t\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\t\n\t\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\t\n\t\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\t\n\t\t\t\t\t\t// see if p is inside triangle abc\n\t\n\t\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\t\n\t\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// takes in an contour array and returns\n\t\n\t\t\t\treturn function triangulate( contour, indices ) {\n\t\n\t\t\t\t\tvar n = contour.length;\n\t\n\t\t\t\t\tif ( n < 3 ) return null;\n\t\n\t\t\t\t\tvar result = [],\n\t\t\t\t\t\tverts = [],\n\t\t\t\t\t\tvertIndices = [];\n\t\n\t\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\t\n\t\t\t\t\tvar u, v, w;\n\t\n\t\t\t\t\tif ( ShapeUtils.area( contour ) > 0.0 ) {\n\t\n\t\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar nv = n;\n\t\n\t\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\t\n\t\t\t\t\tvar count = 2 * nv;   /* error detection */\n\t\n\t\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\t\n\t\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\t\n\t\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\t\n\t\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\t\n\t\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\t\n\t\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\t\treturn result;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\t\n\t\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\t\n\t\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\t\n\t\t\t\t\t\t\tvar a, b, c, s, t;\n\t\n\t\t\t\t\t\t\t/* true names of the vertices */\n\t\n\t\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\t\tc = verts[ w ];\n\t\n\t\t\t\t\t\t\t/* output Triangle */\n\t\n\t\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\t\tcontour[ c ] ] );\n\t\n\t\n\t\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\t\n\t\t\t\t\t\t\t/* remove v from the remaining polygon */\n\t\n\t\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\t\n\t\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tnv --;\n\t\n\t\t\t\t\t\t\t/* reset error detection counter */\n\t\n\t\t\t\t\t\t\tcount = 2 * nv;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t}\n\t\n\t\t\t} )(),\n\t\n\t\t\ttriangulateShape: function ( contour, holes ) {\n\t\n\t\t\t\tfunction removeDupEndPts(points) {\n\t\n\t\t\t\t\tvar l = points.length;\n\t\n\t\t\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\t\t\tpoints.pop();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tremoveDupEndPts( contour );\n\t\t\t\tholes.forEach( removeDupEndPts );\n\t\n\t\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\t\n\t\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\t\n\t\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\t\n\t\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\t\n\t\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\t\n\t\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\t\n\t\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t// not parallel\n\t\n\t\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\t\tif ( limit > 0 ) {\n\t\n\t\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\t\n\t\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( perpSeg2 === limit ) {\n\t\n\t\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\t\n\t\t\t\t\t\t// return real intersection point\n\t\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\t\n\t\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t\t// both segments are points\n\t\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\t\n\t\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\t\tif ( seg1Pt ) {\n\t\n\t\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\t\tif ( seg2Pt ) {\n\t\n\t\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\t\tif ( seg1dx !== 0 ) {\n\t\n\t\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\t\n\t\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\t\n\t\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\t\treturn [ seg2min ];\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\t\n\t\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\t\treturn [ seg1min ];\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\t\n\t\t\t\t\t// The order of legs is important\n\t\n\t\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\t\n\t\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\t\n\t\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t// angle != 180 deg.\n\t\n\t\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\t\n\t\t\t\t\t\tif ( from2toAngle > 0 ) {\n\t\n\t\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tfunction removeHoles( contour, holes ) {\n\t\n\t\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\t\tvar hole;\n\t\n\t\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\t\n\t\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\t\n\t\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\t\n\t\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\t\n\t\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\t\n\t\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\t\n\t\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\t\n\t\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn\ttrue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\t\n\t\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar indepHoles = [];\n\t\n\t\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\t\n\t\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\t\ttmpHole1, tmpHole2;\n\t\n\t\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\t\tindepHoles.push( h );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\t\twhile ( indepHoles.length > 0 ) {\n\t\n\t\t\t\t\t\tcounter --;\n\t\t\t\t\t\tif ( counter < 0 ) {\n\t\n\t\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\t\n\t\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\t\tholeIndex\t= - 1;\n\t\n\t\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\t\n\t\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\t\n\t\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\t\n\t\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\t\n\t\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\t\n\t\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\t\n\t\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\t\n\t\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\t\n\t\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tvar i, il, f, face,\n\t\t\t\t\tkey, index,\n\t\t\t\t\tallPointsMap = {};\n\t\n\t\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\t\n\t\t\t\tvar allpoints = contour.concat();\n\t\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\t\n\t\t\t\t// prepare all points map\n\t\n\t\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\t\n\t\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tallPointsMap[ key ] = i;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\t\n\t\t\t\tvar triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\t\n\t\t\t\t// check all face vertices against all points map\n\t\n\t\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tface = triangles[ i ];\n\t\n\t\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\t\n\t\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\t\n\t\t\t\t\t\tindex = allPointsMap[ key ];\n\t\n\t\t\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\t\t\tface[ f ] = index;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn triangles.concat();\n\t\n\t\t\t},\n\t\n\t\t\tisClockWise: function ( pts ) {\n\t\n\t\t\t\treturn ShapeUtils.area( pts ) < 0;\n\t\n\t\t\t},\n\t\n\t\t\t// Bezier Curves formulas obtained from\n\t\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\t\n\t\t\t// Quad Bezier Functions\n\t\n\t\t\tb2: ( function () {\n\t\n\t\t\t\tfunction b2p0( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn k * k * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b2p1( t, p ) {\n\t\n\t\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b2p2( t, p ) {\n\t\n\t\t\t\t\treturn t * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function b2( t, p0, p1, p2 ) {\n\t\n\t\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\t// Cubic Bezier Functions\n\t\n\t\t\tb3: ( function () {\n\t\n\t\t\t\tfunction b3p0( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn k * k * k * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b3p1( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn 3 * k * k * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b3p2( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn 3 * k * t * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b3p3( t, p ) {\n\t\n\t\t\t\t\treturn t * t * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t * Creates extruded geometry from a path shape.\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *  curveSegments: <int>, // number of points on the curves\n\t\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t\t *  amount: <int>, // Depth to extrude the shape\n\t\t *\n\t\t *  bevelEnabled: <bool>, // turn on bevel\n\t\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t\t *  bevelSegments: <int>, // number of bevel layers\n\t\t *\n\t\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t\t *\n\t\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t\t *\n\t\t * }\n\t\t **/\n\t\n\t\tfunction ExtrudeGeometry( shapes, options ) {\n\t\n\t\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\t\n\t\t\t\tshapes = [];\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ExtrudeGeometry';\n\t\n\t\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\t\n\t\t\tthis.addShapeList( shapes, options );\n\t\n\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t// can't really use automatic vertex normals\n\t\t\t// as then front and back sides get smoothed too\n\t\t\t// should do separate smoothing just for sides\n\t\n\t\t\t//this.computeVertexNormals();\n\t\n\t\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\t\n\t\t}\n\t\n\t\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\t\n\t\tExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\t\tvar sl = shapes.length;\n\t\n\t\t\tfor ( var s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\tvar shape = shapes[ s ];\n\t\t\t\tthis.addShape( shape, options );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\t\n\t\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\t\n\t\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\t\n\t\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\n\t\t\tvar extrudePath = options.extrudePath;\n\t\t\tvar extrudePts, extrudeByPath = false;\n\t\n\t\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\t\n\t\t\tvar splineTube, binormal, normal, position2;\n\t\t\tif ( extrudePath ) {\n\t\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\t\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\t\n\t\t\t\t// SETUP TNB variables\n\t\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\t\n\t\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\t\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\t\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\t\n\t\t\t}\n\t\n\t\t\t// Safeguards if bevels are not enabled\n\t\n\t\t\tif ( ! bevelEnabled ) {\n\t\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\n\t\t\t}\n\t\n\t\t\t// Variables initialization\n\t\n\t\t\tvar ahole, h, hl; // looping of holes\n\t\t\tvar scope = this;\n\t\n\t\t\tvar shapesOffset = this.vertices.length;\n\t\n\t\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\t\tvar vertices = shapePoints.shape;\n\t\t\tvar holes = shapePoints.holes;\n\t\n\t\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\t\n\t\t\tif ( reverse ) {\n\t\n\t\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\t\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t\t/* Vertices */\n\t\n\t\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\tvertices = vertices.concat( ahole );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\t\n\t\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\t\n\t\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\t\n\t\t\t}\n\t\n\t\t\tvar b, bs, t, z,\n\t\t\t\tvert, vlen = vertices.length,\n\t\t\t\tface, flen = faces.length;\n\t\n\t\n\t\t\t// Find directions for point movement\n\t\n\t\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\t\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\t\n\t\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\t\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\t\n\t\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\t\n\t\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\t\n\t\t\t\t// check for collinear edges\n\t\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t// not collinear\n\t\n\t\t\t\t\t// length of vectors for normalizing\n\t\n\t\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\t\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\t\n\t\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\t\n\t\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\t\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\t\n\t\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\t\t// vector from inPt to intersection point\n\t\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\t\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\t\n\t\t\t\t\t\treturn\tnew Vector2( v_trans_x, v_trans_y );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// handle special case of collinear edges\n\t\n\t\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\t\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( direction_eq ) {\n\t\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn\tnew Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar contourMovements = [];\n\t\n\t\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\t\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\t\n\t\t\t}\n\t\n\t\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\toneHoleMovements = [];\n\t\n\t\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\t\n\t\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\t\n\t\t\t\tt = b / bevelSegments;\n\t\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\t\n\t\t\t\t// contract shape\n\t\n\t\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// expand holes\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tbs = bevelSize;\n\t\n\t\t\t// Back facing vertices\n\t\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\t\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\t\n\t\t\tvar s;\n\t\n\t\t\tfor ( s = 1; s <= steps; s ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\t\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Add bevel segments planes\n\t\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\t\n\t\t\t\tt = b / bevelSegments;\n\t\t\t\tz = bevelThickness * Math.cos ( t * Math.PI / 2 );\n\t\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\t\n\t\t\t\t// contract shape\n\t\n\t\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// expand holes\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t/* Faces */\n\t\n\t\t\t// Top and bottom faces\n\t\n\t\t\tbuildLidFaces();\n\t\n\t\t\t// Sides faces\n\t\n\t\t\tbuildSideFaces();\n\t\n\t\n\t\t\t/////  Internal functions\n\t\n\t\t\tfunction buildLidFaces() {\n\t\n\t\t\t\tif ( bevelEnabled ) {\n\t\n\t\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\t\tvar offset = vlen * layer;\n\t\n\t\t\t\t\t// Bottom faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\t\n\t\t\t\t\t// Top faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Bottom faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Top faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Create faces for the z-sides of the shape\n\t\n\t\t\tfunction buildSideFaces() {\n\t\n\t\t\t\tvar layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\t\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\t\n\t\t\t\tvar j, k;\n\t\t\t\ti = contour.length;\n\t\n\t\t\t\twhile ( -- i >= 0 ) {\n\t\n\t\t\t\t\tj = i;\n\t\t\t\t\tk = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\t\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\t\n\t\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\t\n\t\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\t\n\t\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\t\n\t\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction v( x, y, z ) {\n\t\n\t\t\t\tscope.vertices.push( new Vector3( x, y, z ) );\n\t\n\t\t\t}\n\t\n\t\t\tfunction f3( a, b, c ) {\n\t\n\t\t\t\ta += shapesOffset;\n\t\t\t\tb += shapesOffset;\n\t\t\t\tc += shapesOffset;\n\t\n\t\t\t\tscope.faces.push( new Face3( a, b, c, null, null, 0 ) );\n\t\n\t\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\t\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\t\n\t\t\t}\n\t\n\t\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\t\n\t\t\t\ta += shapesOffset;\n\t\t\t\tb += shapesOffset;\n\t\t\t\tc += shapesOffset;\n\t\t\t\td += shapesOffset;\n\t\n\t\t\t\tscope.faces.push( new Face3( a, b, d, null, null, 1 ) );\n\t\t\t\tscope.faces.push( new Face3( b, c, d, null, null, 1 ) );\n\t\n\t\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\t\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tExtrudeGeometry.WorldUVGenerator = {\n\t\n\t\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\t\n\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\tvar a = vertices[ indexA ];\n\t\t\t\tvar b = vertices[ indexB ];\n\t\t\t\tvar c = vertices[ indexC ];\n\t\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.x, a.y ),\n\t\t\t\t\tnew Vector2( b.x, b.y ),\n\t\t\t\t\tnew Vector2( c.x, c.y )\n\t\t\t\t];\n\t\n\t\t\t},\n\t\n\t\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\t\n\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\tvar a = vertices[ indexA ];\n\t\t\t\tvar b = vertices[ indexB ];\n\t\t\t\tvar c = vertices[ indexC ];\n\t\t\t\tvar d = vertices[ indexD ];\n\t\n\t\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\t\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew Vector2( a.x, 1 - a.z ),\n\t\t\t\t\t\tnew Vector2( b.x, 1 - b.z ),\n\t\t\t\t\t\tnew Vector2( c.x, 1 - c.z ),\n\t\t\t\t\t\tnew Vector2( d.x, 1 - d.z )\n\t\t\t\t\t];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew Vector2( a.y, 1 - a.z ),\n\t\t\t\t\t\tnew Vector2( b.y, 1 - b.z ),\n\t\t\t\t\t\tnew Vector2( c.y, 1 - c.z ),\n\t\t\t\t\t\tnew Vector2( d.y, 1 - d.z )\n\t\t\t\t\t];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * Text = 3D Text\n\t\t *\n\t\t * parameters = {\n\t\t *  font: <THREE.Font>, // font\n\t\t *\n\t\t *  size: <float>, // size of the text\n\t\t *  height: <float>, // thickness to extrude text\n\t\t *  curveSegments: <int>, // number of points on the curves\n\t\t *\n\t\t *  bevelEnabled: <bool>, // turn on bevel\n\t\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t\t *  bevelSize: <float> // how far from text outline is bevel\n\t\t * }\n\t\t */\n\t\n\t\tfunction TextGeometry( text, parameters ) {\n\t\n\t\t\tparameters = parameters || {};\n\t\n\t\t\tvar font = parameters.font;\n\t\n\t\t\tif ( (font && font.isFont) === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\t\treturn new Geometry();\n\t\n\t\t\t}\n\t\n\t\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\t\n\t\t\t// translate parameters to ExtrudeGeometry API\n\t\n\t\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\t\n\t\t\t// defaults\n\t\n\t\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\t\n\t\t\tExtrudeGeometry.call( this, shapes, parameters );\n\t\n\t\t\tthis.type = 'TextGeometry';\n\t\n\t\t}\n\t\n\t\tTextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );\n\t\tTextGeometry.prototype.constructor = TextGeometry;\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t * based on THREE.SphereGeometry\n\t\t */\n\t\n\t\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'SphereBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tradius = radius || 50;\n\t\n\t\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\t\n\t\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\t\n\t\t\tvar thetaEnd = thetaStart + thetaLength;\n\t\n\t\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\t\n\t\t\tvar positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\tvar index = 0, vertices = [], normal = new Vector3();\n\t\n\t\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\t\tvar verticesRow = [];\n\t\n\t\t\t\tvar v = y / heightSegments;\n\t\n\t\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\t\n\t\t\t\t\tvar u = x / widthSegments;\n\t\n\t\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\n\t\t\t\t\tnormal.set( px, py, pz ).normalize();\n\t\n\t\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\t\tverticesRow.push( index );\n\t\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvertices.push( verticesRow );\n\t\n\t\t\t}\n\t\n\t\t\tvar indices = [];\n\t\n\t\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\t\n\t\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\t\n\t\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', positions );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\t\n\t\t}\n\t\n\t\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'SphereGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\t\n\t\t}\n\t\n\t\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\t\tSphereGeometry.prototype.constructor = SphereGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'RingBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tinnerRadius = innerRadius || 20;\n\t\t\touterRadius = outerRadius || 50;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\t\n\t\t\t// these are used to calculate buffer length\n\t\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// some helper variables\n\t\t\tvar index = 0, indexOffset = 0, segment;\n\t\t\tvar radius = innerRadius;\n\t\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\t\tvar j, i;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t// values are generate from the inside of the ring to the outside\n\t\n\t\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\t\n\t\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// increase the radius for next row of vertices\n\t\t\t\tradius += radiusStep;\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\t\n\t\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\t\n\t\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\t\n\t\t\t\t\tsegment = i + thetaSegmentLevel;\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = segment;\n\t\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\t\tvar d = segment + 1;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t}\n\t\n\t\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Kaleb Murphy\n\t\t */\n\t\n\t\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'RingGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\t\n\t\t}\n\t\n\t\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\t\tRingGeometry.prototype.constructor = RingGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t\t */\n\t\n\t\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'PlaneGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\t\n\t\t}\n\t\n\t\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\t\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t // points - to create a closed torus, one must use a set of points\n\t\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t\t // segments - the number of circumference segments to create\n\t\t // phiStart - the starting radian\n\t\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t\t //    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\t\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'LatheBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\n\t\t\tsegments = Math.floor( segments ) || 12;\n\t\t\tphiStart = phiStart || 0;\n\t\t\tphiLength = phiLength || Math.PI * 2;\n\t\n\t\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\t\n\t\t\t// these are used to calculate buffer length\n\t\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\t\tvar indexCount = segments * points.length * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// helper variables\n\t\t\tvar index = 0, indexOffset = 0, base;\n\t\t\tvar inverseSegments = 1.0 / segments;\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\t\tvar i, j;\n\t\n\t\t\t// generate vertices and uvs\n\t\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\t\n\t\t\t\tvar sin = Math.sin( phi );\n\t\t\t\tvar cos = Math.cos( phi );\n\t\n\t\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = i / segments;\n\t\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( i = 0; i < segments; i ++ ) {\n\t\n\t\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t\tbase = j + i * points.length;\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = base;\n\t\t\t\t\tvar b = base + points.length;\n\t\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\t\tvar d = base + 1;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\t// generate normals\n\t\n\t\t\tthis.computeVertexNormals();\n\t\n\t\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t\t// because the corresponding vertices are identical (but still have different UVs).\n\t\n\t\t\tif( phiLength === Math.PI * 2 ) {\n\t\n\t\t\t\tvar normals = this.attributes.normal.array;\n\t\t\t\tvar n1 = new Vector3();\n\t\t\t\tvar n2 = new Vector3();\n\t\t\t\tvar n = new Vector3();\n\t\n\t\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\t\tbase = segments * points.length * 3;\n\t\n\t\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\t\n\t\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\t\tn1.z = normals[ j + 2 ];\n\t\n\t\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\t\tn2.z = normals[ base + j + 2 ];\n\t\n\t\t\t\t\t// average normals\n\t\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\t\n\t\t\t\t\t// assign the new values to both normals\n\t\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\t\n\t\t\t\t} // next row\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\t\n\t\t/**\n\t\t * @author astrodud / http://astrodud.isgreat.org/\n\t\t * @author zz85 / https://github.com/zz85\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\t// points - to create a closed torus, one must use a set of points\n\t\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t\t// segments - the number of circumference segments to create\n\t\t// phiStart - the starting radian\n\t\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t\t//    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\t\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'LatheGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\t\tLatheGeometry.prototype.constructor = LatheGeometry;\n\t\n\t\t/**\n\t\t * @author jonobr1 / http://jonobr1.com\n\t\t *\n\t\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t\t * ExtrudeGeometry.\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t\t *\n\t\t *\tmaterial: <int> // material index for front and back faces\n\t\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t\t *\n\t\t * }\n\t\t **/\n\t\n\t\tfunction ShapeGeometry( shapes, options ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ShapeGeometry';\n\t\n\t\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\t\n\t\t\tthis.addShapeList( shapes, options );\n\t\n\t\t\tthis.computeFaceNormals();\n\t\n\t\t}\n\t\n\t\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\t\n\t\t/**\n\t\t * Add an array of shapes to THREE.ShapeGeometry.\n\t\t */\n\t\tShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\t\n\t\t\t\tthis.addShape( shapes[ i ], options );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t\t */\n\t\tShapeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\t\tif ( options === undefined ) options = {};\n\t\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\t\tvar material = options.material;\n\t\t\tvar uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\t\n\t\t\t//\n\t\n\t\t\tvar i, l, hole;\n\t\n\t\t\tvar shapesOffset = this.vertices.length;\n\t\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\t\tvar vertices = shapePoints.shape;\n\t\t\tvar holes = shapePoints.holes;\n\t\n\t\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\t\n\t\t\tif ( reverse ) {\n\t\n\t\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\t\n\t\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\thole = holes[ i ];\n\t\n\t\t\t\t\tif ( ShapeUtils.isClockWise( hole ) ) {\n\t\n\t\t\t\t\t\tholes[ i ] = hole.reverse();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treverse = false;\n\t\n\t\t\t}\n\t\n\t\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t\t// Vertices\n\t\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\t\thole = holes[ i ];\n\t\t\t\tvertices = vertices.concat( hole );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar vert, vlen = vertices.length;\n\t\t\tvar face, flen = faces.length;\n\t\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\tvert = vertices[ i ];\n\t\n\t\t\t\tthis.vertices.push( new Vector3( vert.x, vert.y, 0 ) );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\tface = faces[ i ];\n\t\n\t\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\t\tvar c = face[ 2 ] + shapesOffset;\n\t\n\t\t\t\tthis.faces.push( new Face3( a, b, c, null, null, material ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\t\n\t\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\t\n\t\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\t\treturn a - b;\n\t\n\t\t\t}\n\t\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\tvar geometry2;\n\t\n\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\tgeometry2 = new Geometry();\n\t\t\t\tgeometry2.fromBufferGeometry( geometry );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgeometry2 = geometry.clone();\n\t\n\t\t\t}\n\t\n\t\t\tgeometry2.mergeVertices();\n\t\t\tgeometry2.computeFaceNormals();\n\t\n\t\t\tvar vertices = geometry2.vertices;\n\t\t\tvar faces = geometry2.faces;\n\t\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\thash[ key ].face2 = i;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar coords = [];\n\t\n\t\t\tfor ( var key in hash ) {\n\t\n\t\t\t\tvar h = hash[ key ];\n\t\n\t\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\t\n\t\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\t\tcoords.push( vertex.x );\n\t\t\t\t\tcoords.push( vertex.y );\n\t\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\t\tcoords.push( vertex.x );\n\t\t\t\t\tcoords.push( vertex.y );\n\t\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );\n\t\n\t\t}\n\t\n\t\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'CylinderBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\t\theight = height !== undefined ? height : 100;\n\t\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\n\t\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\t\n\t\t\t// used to calculate buffer length\n\t\n\t\t\tvar nbCap = 0;\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\t\n\t\t\t}\n\t\n\t\t\tvar vertexCount = calculateVertexCount();\n\t\t\tvar indexCount = calculateIndexCount();\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar index = 0,\n\t\t\t    indexOffset = 0,\n\t\t\t    indexArray = [],\n\t\t\t    halfHeight = height / 2;\n\t\n\t\t\t// group variables\n\t\t\tvar groupStart = 0;\n\t\n\t\t\t// generate geometry\n\t\n\t\t\tgenerateTorso();\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction calculateVertexCount() {\n\t\n\t\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\t\n\t\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn count;\n\t\n\t\t\t}\n\t\n\t\t\tfunction calculateIndexCount() {\n\t\n\t\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\t\n\t\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\t\tcount += radialSegments * nbCap * 3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn count;\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateTorso() {\n\t\n\t\t\t\tvar x, y;\n\t\t\t\tvar normal = new Vector3();\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\t// this will be used to calculate the normal\n\t\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\t\n\t\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\t\t\tvar indexRow = [];\n\t\n\t\t\t\t\tvar v = y / heightSegments;\n\t\n\t\t\t\t\t// calculate the radius of the current row\n\t\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\t\n\t\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\t\tvar u = x / radialSegments;\n\t\n\t\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\n\t\t\t\t\t\t// vertex\n\t\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t\t// uv\n\t\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\t\tindexRow.push( index );\n\t\n\t\t\t\t\t\t// increase index\n\t\t\t\t\t\tindex ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\t\tindexArray.push( indexRow );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// generate indices\n\t\n\t\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\t\n\t\t\t\t\t\t// face one\n\t\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t\t// face two\n\t\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t\t// update counters\n\t\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateCap( top ) {\n\t\n\t\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\t\n\t\t\t\tvar uv = new Vector2();\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\t\n\t\t\t\t// save the index of the first center vertex\n\t\t\t\tcenterIndexStart = index;\n\t\n\t\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t\t// we must generate a center vertex per face/segment\n\t\n\t\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = 0.5;\n\t\t\t\t\tuv.y = 0.5;\n\t\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// save the index of the last center vertex\n\t\t\t\tcenterIndexEnd = index;\n\t\n\t\t\t\t// now we generate the surrounding vertices, normals and uvs\n\t\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar u = x / radialSegments;\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// generate indices\n\t\n\t\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\t\tvar i = centerIndexEnd + x;\n\t\n\t\t\t\t\tif ( top === true ) {\n\t\n\t\t\t\t\t\t// face top\n\t\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// face bottom\n\t\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'CylinderGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\t\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\t\n\t\t/**\n\t\t * @author abelnation / http://github.com/abelnation\n\t\t */\n\t\n\t\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\t\n\t\t\tthis.type = 'ConeGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\t\tConeGeometry.prototype.constructor = ConeGeometry;\n\t\n\t\t/**\n\t\t * @author: abelnation / http://github.com/abelnation\n\t\t */\n\t\n\t\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\t\n\t\t\tthis.type = 'ConeBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\t\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'CircleBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tradius = radius || 50;\n\t\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\t\tvar vertices = segments + 2;\n\t\n\t\t\tvar positions = new Float32Array( vertices * 3 );\n\t\t\tvar normals = new Float32Array( vertices * 3 );\n\t\t\tvar uvs = new Float32Array( vertices * 2 );\n\t\n\t\t\t// center data is already zero, but need to set a few extras\n\t\t\tnormals[ 2 ] = 1.0;\n\t\t\tuvs[ 0 ] = 0.5;\n\t\t\tuvs[ 1 ] = 0.5;\n\t\n\t\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\t\n\t\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\t\n\t\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\t\n\t\t\t\tnormals[ i + 2 ] = 1; // normal z\n\t\n\t\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\t\n\t\t\t}\n\t\n\t\t\tvar indices = [];\n\t\n\t\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\tindices.push( i, i + 1, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\t\n\t\t}\n\t\n\t\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\t\n\t\t/**\n\t\t * @author hughes\n\t\t */\n\t\n\t\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'CircleGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\t\n\t\t}\n\t\n\t\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\t\tCircleGeometry.prototype.constructor = CircleGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t\t */\n\t\n\t\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'BoxGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\t\tBoxGeometry.prototype.constructor = BoxGeometry;\n\t\n\t\n\t\n\t\tvar Geometries = Object.freeze({\n\t\t\tWireframeGeometry: WireframeGeometry,\n\t\t\tParametricGeometry: ParametricGeometry,\n\t\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\t\tOctahedronGeometry: OctahedronGeometry,\n\t\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\t\tTubeGeometry: TubeGeometry,\n\t\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\t\tTorusGeometry: TorusGeometry,\n\t\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\t\tTextGeometry: TextGeometry,\n\t\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\t\tSphereGeometry: SphereGeometry,\n\t\t\tRingGeometry: RingGeometry,\n\t\t\tRingBufferGeometry: RingBufferGeometry,\n\t\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\t\tPlaneGeometry: PlaneGeometry,\n\t\t\tLatheGeometry: LatheGeometry,\n\t\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\t\tShapeGeometry: ShapeGeometry,\n\t\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\t\tEdgesGeometry: EdgesGeometry,\n\t\t\tConeGeometry: ConeGeometry,\n\t\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\t\tCylinderGeometry: CylinderGeometry,\n\t\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\t\tCircleGeometry: CircleGeometry,\n\t\t\tBoxBufferGeometry: BoxBufferGeometry,\n\t\t\tBoxGeometry: BoxGeometry\n\t\t});\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ShadowMaterial() {\n\t\n\t\t\tShaderMaterial.call( this, {\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib[ \"lights\" ],\n\t\t\t\t\t{\n\t\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t\t}\n\t\t\t\t] ),\n\t\t\t\tvertexShader: ShaderChunk[ 'shadow_vert' ],\n\t\t\t\tfragmentShader: ShaderChunk[ 'shadow_frag' ]\n\t\t\t} );\n\t\n\t\t\tthis.lights = true;\n\t\t\tthis.transparent = true;\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\topacity: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t\t},\n\t\t\t\t\tset: function ( value ) {\n\t\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\t\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\t\n\t\tShadowMaterial.prototype.isShadowMaterial = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction RawShaderMaterial( parameters ) {\n\t\n\t\t\tShaderMaterial.call( this, parameters );\n\t\n\t\t\tthis.type = 'RawShaderMaterial';\n\t\n\t\t}\n\t\n\t\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\t\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\t\n\t\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction MultiMaterial( materials ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.type = 'MultiMaterial';\n\t\n\t\t\tthis.materials = materials instanceof Array ? materials : [];\n\t\n\t\t\tthis.visible = true;\n\t\n\t\t}\n\t\n\t\tMultiMaterial.prototype = {\n\t\n\t\t\tconstructor: MultiMaterial,\n\t\n\t\t\tisMultiMaterial: true,\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar output = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.2,\n\t\t\t\t\t\ttype: 'material',\n\t\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t\t},\n\t\t\t\t\tuuid: this.uuid,\n\t\t\t\t\ttype: this.type,\n\t\t\t\t\tmaterials: []\n\t\t\t\t};\n\t\n\t\t\t\tvar materials = this.materials;\n\t\n\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\t\tdelete material.metadata;\n\t\n\t\t\t\t\toutput.materials.push( material );\n\t\n\t\t\t\t}\n\t\n\t\t\t\toutput.visible = this.visible;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\tvar material = new this.constructor();\n\t\n\t\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\t\n\t\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterial.visible = this.visible;\n\t\n\t\t\t\treturn material;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  roughness: <float>,\n\t\t *  metalness: <float>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  bumpMap: new THREE.Texture( <Image> ),\n\t\t *  bumpScale: <float>,\n\t\t *\n\t\t *  normalMap: new THREE.Texture( <Image> ),\n\t\t *  normalScale: <Vector2>,\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  envMapIntensity: <float>\n\t\t *\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshStandardMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\t\tthis.type = 'MeshStandardMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\t\tthis.roughness = 0.5;\n\t\t\tthis.metalness = 0.5;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalScale = new Vector2( 1, 1 );\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.roughnessMap = null;\n\t\n\t\t\tthis.metalnessMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.envMapIntensity = 1.0;\n\t\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\t\n\t\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\t\n\t\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.roughness = source.roughness;\n\t\t\tthis.metalness = source.metalness;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.roughnessMap = source.roughnessMap;\n\t\n\t\t\tthis.metalnessMap = source.metalnessMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.envMapIntensity = source.envMapIntensity;\n\t\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *  reflectivity: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshPhysicalMaterial( parameters ) {\n\t\n\t\t\tMeshStandardMaterial.call( this );\n\t\n\t\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\t\tthis.type = 'MeshPhysicalMaterial';\n\t\n\t\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\t\n\t\t\tthis.clearCoat = 0.0;\n\t\t\tthis.clearCoatRoughness = 0.0;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\t\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\t\n\t\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\t\n\t\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\n\t\t\tthis.clearCoat = source.clearCoat;\n\t\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  specular: <hex>,\n\t\t *  shininess: <float>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  bumpMap: new THREE.Texture( <Image> ),\n\t\t *  bumpScale: <float>,\n\t\t *\n\t\t *  normalMap: new THREE.Texture( <Image> ),\n\t\t *  normalScale: <Vector2>,\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshPhongMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshPhongMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\t\tthis.specular = new Color( 0x111111 );\n\t\t\tthis.shininess = 30;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalScale = new Vector2( 1, 1 );\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\t\n\t\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\t\n\t\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.specular.copy( source.specular );\n\t\t\tthis.shininess = source.shininess;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshNormalMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this, parameters );\n\t\n\t\t\tthis.type = 'MeshNormalMaterial';\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\t\n\t\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\t\n\t\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshLambertMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshLambertMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\t\n\t\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\t\n\t\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  linewidth: <float>,\n\t\t *\n\t\t *  scale: <float>,\n\t\t *  dashSize: <float>,\n\t\t *  gapSize: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction LineDashedMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'LineDashedMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.linewidth = 1;\n\t\n\t\t\tthis.scale = 1;\n\t\t\tthis.dashSize = 3;\n\t\t\tthis.gapSize = 1;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tLineDashedMaterial.prototype = Object.create( Material.prototype );\n\t\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\t\n\t\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\t\n\t\tLineDashedMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.linewidth = source.linewidth;\n\t\n\t\t\tthis.scale = source.scale;\n\t\t\tthis.dashSize = source.dashSize;\n\t\t\tthis.gapSize = source.gapSize;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\n\t\n\t\tvar Materials = Object.freeze({\n\t\t\tShadowMaterial: ShadowMaterial,\n\t\t\tSpriteMaterial: SpriteMaterial,\n\t\t\tRawShaderMaterial: RawShaderMaterial,\n\t\t\tShaderMaterial: ShaderMaterial,\n\t\t\tPointsMaterial: PointsMaterial,\n\t\t\tMultiMaterial: MultiMaterial,\n\t\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\t\tLineDashedMaterial: LineDashedMaterial,\n\t\t\tLineBasicMaterial: LineBasicMaterial,\n\t\t\tMaterial: Material\n\t\t});\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar Cache = {\n\t\n\t\t\tenabled: false,\n\t\n\t\t\tfiles: {},\n\t\n\t\t\tadd: function ( key, file ) {\n\t\n\t\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\t\n\t\t\t\tthis.files[ key ] = file;\n\t\n\t\t\t},\n\t\n\t\t\tget: function ( key ) {\n\t\n\t\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\t\n\t\t\t\treturn this.files[ key ];\n\t\n\t\t\t},\n\t\n\t\t\tremove: function ( key ) {\n\t\n\t\t\t\tdelete this.files[ key ];\n\t\n\t\t\t},\n\t\n\t\t\tclear: function () {\n\t\n\t\t\t\tthis.files = {};\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\t\n\t\t\tthis.onStart = undefined;\n\t\t\tthis.onLoad = onLoad;\n\t\t\tthis.onProgress = onProgress;\n\t\t\tthis.onError = onError;\n\t\n\t\t\tthis.itemStart = function ( url ) {\n\t\n\t\t\t\titemsTotal ++;\n\t\n\t\t\t\tif ( isLoading === false ) {\n\t\n\t\t\t\t\tif ( scope.onStart !== undefined ) {\n\t\n\t\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tisLoading = true;\n\t\n\t\t\t};\n\t\n\t\t\tthis.itemEnd = function ( url ) {\n\t\n\t\t\t\titemsLoaded ++;\n\t\n\t\t\t\tif ( scope.onProgress !== undefined ) {\n\t\n\t\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( itemsLoaded === itemsTotal ) {\n\t\n\t\t\t\t\tisLoading = false;\n\t\n\t\t\t\t\tif ( scope.onLoad !== undefined ) {\n\t\n\t\t\t\t\t\tscope.onLoad();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.itemError = function ( url ) {\n\t\n\t\t\t\tif ( scope.onError !== undefined ) {\n\t\n\t\t\t\t\tscope.onError( url );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tvar DefaultLoadingManager = new LoadingManager();\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction XHRLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( XHRLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( url === undefined ) url = '';\n\t\n\t\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar cached = Cache.get( url );\n\t\n\t\t\t\tif ( cached !== undefined ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\tsetTimeout( function () {\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, 0 );\n\t\n\t\t\t\t\treturn cached;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Check for data: URI\n\t\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\t\n\t\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\t\tif ( dataUriRegexResult ) {\n\t\n\t\t\t\t\tvar mimeType = dataUriRegexResult[1];\n\t\t\t\t\tvar isBase64 = !!dataUriRegexResult[2];\n\t\t\t\t\tvar data = dataUriRegexResult[3];\n\t\n\t\t\t\t\tdata = window.decodeURIComponent(data);\n\t\n\t\t\t\t\tif( isBase64 ) {\n\t\t\t\t\t\tdata = window.atob(data);\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tvar response;\n\t\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\t\n\t\t\t\t\t\tswitch ( responseType ) {\n\t\n\t\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\t\tcase 'blob':\n\t\n\t\t\t\t\t\t\t \tresponse = new ArrayBuffer( data.length );\n\t\t\t\t\t\t\t\tvar view = new Uint8Array( response );\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\t\n\t\t\t\t\t\t\t\t\tresponse = new Blob( [ response ], { \"type\" : mimeType } );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'document':\n\t\n\t\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'json':\n\t\n\t\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tdefault: // 'text' or other\n\t\n\t\t\t\t\t\t\t\tresponse = data;\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\t\twindow.setTimeout( function() {\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t}, 0);\n\t\n\t\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\t\twindow.setTimeout( function() {\n\t\n\t\t\t\t\t\t\tif ( onError ) onError( error );\n\t\n\t\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t\t}, 0);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\t\trequest.open( 'GET', url, true );\n\t\n\t\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\t\n\t\t\t\t\t\tvar response = event.target.response;\n\t\n\t\t\t\t\t\tCache.add( url, response );\n\t\n\t\t\t\t\t\tif ( this.status === 200 ) {\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t} else if ( this.status === 0 ) {\n\t\n\t\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, false );\n\t\n\t\t\t\t\tif ( onProgress !== undefined ) {\n\t\n\t\t\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\t\n\t\t\t\t\t\t\tonProgress( event );\n\t\n\t\t\t\t\t\t}, false );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\t\n\t\t\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t}, false );\n\t\n\t\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\t\n\t\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );\n\t\n\t\t\t\t\trequest.send( null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\treturn request;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetResponseType: function ( value ) {\n\t\n\t\t\t\tthis.responseType = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t *\n\t\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t\t */\n\t\n\t\tfunction CompressedTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\t// override in sub classes\n\t\t\tthis._parser = null;\n\t\n\t\t}\n\t\n\t\tObject.assign( CompressedTextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar images = [];\n\t\n\t\t\t\tvar texture = new CompressedTexture();\n\t\t\t\ttexture.image = images;\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\t\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\tloaded += 1;\n\t\n\t\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( Array.isArray( url ) ) {\n\t\n\t\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\t\n\t\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\t\n\t\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\t\tif ( texDatas.isCubemap ) {\n\t\n\t\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\t\n\t\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\t\n\t\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\t\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author Nikos M. / https://github.com/foo123/\n\t\t *\n\t\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t\t */\n\t\n\t\tvar DataTextureLoader = BinaryTextureLoader;\n\t\tfunction BinaryTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\t// override in sub classes\n\t\t\tthis._parser = null;\n\t\n\t\t}\n\t\n\t\tObject.assign( BinaryTextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar texture = new DataTexture();\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar texData = scope._parser( buffer );\n\t\n\t\t\t\t\tif ( ! texData ) return;\n\t\n\t\t\t\t\tif ( undefined !== texData.image ) {\n\t\n\t\t\t\t\t\ttexture.image = texData.image;\n\t\n\t\t\t\t\t} else if ( undefined !== texData.data ) {\n\t\n\t\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\t\ttexture.image.data = texData.data;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\t\n\t\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\t\n\t\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\t\n\t\t\t\t\tif ( undefined !== texData.format ) {\n\t\n\t\t\t\t\t\ttexture.format = texData.format;\n\t\n\t\t\t\t\t}\n\t\t\t\t\tif ( undefined !== texData.type ) {\n\t\n\t\t\t\t\t\ttexture.type = texData.type;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\t\n\t\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\t\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ImageLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( ImageLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\t\timage.onload = function () {\n\t\n\t\t\t\t\timage.onload = null;\n\t\n\t\t\t\t\tURL.revokeObjectURL( image.src );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( image );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t};\n\t\t\t\timage.onerror = onError;\n\t\n\t\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\t\n\t\t\t\t\timage.src = url;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar loader = new XHRLoader();\n\t\t\t\t\tloader.setPath( this.path );\n\t\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\t\tloader.load( url, function ( blob ) {\n\t\n\t\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CubeTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( CubeTextureLoader.prototype, {\n\t\n\t\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar texture = new CubeTexture();\n\t\n\t\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\t\tloader.setPath( this.path );\n\t\n\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\t\n\t\t\t\t\t\ttexture.images[ i ] = image;\n\t\n\t\t\t\t\t\tloaded ++;\n\t\n\t\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, undefined, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\t\n\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction TextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( TextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar texture = new Texture();\n\t\n\t\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.load( url, function ( image ) {\n\t\n\t\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\t\n\t\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\t\ttexture.image = image;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) {\n\t\n\t\t\t\t\t\tonLoad( texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Light( color, intensity ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Light';\n\t\n\t\t\tthis.color = new Color( color );\n\t\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\t\n\t\t\tthis.receiveShadow = undefined;\n\t\n\t\t}\n\t\n\t\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Light,\n\t\n\t\t\tisLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.color.copy( source.color );\n\t\t\t\tthis.intensity = source.intensity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.color = this.color.getHex();\n\t\t\t\tdata.object.intensity = this.intensity;\n\t\n\t\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\t\n\t\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\t\n\t\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\t\n\t\t\tLight.call( this, skyColor, intensity );\n\t\n\t\t\tthis.type = 'HemisphereLight';\n\t\n\t\t\tthis.castShadow = undefined;\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.groundColor = new Color( groundColor );\n\t\n\t\t}\n\t\n\t\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: HemisphereLight,\n\t\n\t\t\tisHemisphereLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.groundColor.copy( source.groundColor );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LightShadow( camera ) {\n\t\n\t\t\tthis.camera = camera;\n\t\n\t\t\tthis.bias = 0;\n\t\t\tthis.radius = 1;\n\t\n\t\t\tthis.mapSize = new Vector2( 512, 512 );\n\t\n\t\t\tthis.map = null;\n\t\t\tthis.matrix = new Matrix4();\n\t\n\t\t}\n\t\n\t\tObject.assign( LightShadow.prototype, {\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.camera = source.camera.clone();\n\t\n\t\t\t\tthis.bias = source.bias;\n\t\t\t\tthis.radius = source.radius;\n\t\n\t\t\t\tthis.mapSize.copy( source.mapSize );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar object = {};\n\t\n\t\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\t\n\t\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\t\tdelete object.camera.matrix;\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction SpotLightShadow() {\n\t\n\t\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\t\n\t\t\tconstructor: SpotLightShadow,\n\t\n\t\t\tisSpotLightShadow: true,\n\t\n\t\t\tupdate: function ( light ) {\n\t\n\t\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\t\tvar far = light.distance || 500;\n\t\n\t\t\t\tvar camera = this.camera;\n\t\n\t\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\t\n\t\t\t\t\tcamera.fov = fov;\n\t\t\t\t\tcamera.aspect = aspect;\n\t\t\t\t\tcamera.far = far;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'SpotLight';\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.target = new Object3D();\n\t\n\t\t\tObject.defineProperty( this, 'power', {\n\t\t\t\tget: function () {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t\t},\n\t\t\t\tset: function ( power ) {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\t\tthis.shadow = new SpotLightShadow();\n\t\n\t\t}\n\t\n\t\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: SpotLight,\n\t\n\t\t\tisSpotLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.distance = source.distance;\n\t\t\t\tthis.angle = source.angle;\n\t\t\t\tthis.penumbra = source.penumbra;\n\t\t\t\tthis.decay = source.decay;\n\t\n\t\t\t\tthis.target = source.target.clone();\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\n\t\tfunction PointLight( color, intensity, distance, decay ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'PointLight';\n\t\n\t\t\tObject.defineProperty( this, 'power', {\n\t\t\t\tget: function () {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\treturn this.intensity * 4 * Math.PI;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( power ) {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: PointLight,\n\t\n\t\t\tisPointLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.distance = source.distance;\n\t\t\t\tthis.decay = source.decay;\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction DirectionalLightShadow( light ) {\n\t\n\t\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\t\n\t\t\tconstructor: DirectionalLightShadow\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction DirectionalLight( color, intensity ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'DirectionalLight';\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.target = new Object3D();\n\t\n\t\t\tthis.shadow = new DirectionalLightShadow();\n\t\n\t\t}\n\t\n\t\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: DirectionalLight,\n\t\n\t\t\tisDirectionalLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.target = source.target.clone();\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AmbientLight( color, intensity ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'AmbientLight';\n\t\n\t\t\tthis.castShadow = undefined;\n\t\n\t\t}\n\t\n\t\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: AmbientLight,\n\t\n\t\t\tisAmbientLight: true,\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t */\n\t\n\t\tvar AnimationUtils = {\n\t\n\t\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\t\tarraySlice: function( array, from, to ) {\n\t\n\t\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\t\n\t\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array.slice( from, to );\n\t\n\t\t\t},\n\t\n\t\t\t// converts an array to a specific type\n\t\t\tconvertArray: function( array, type, forceClone ) {\n\t\n\t\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\t\n\t\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\t\n\t\t\t\t\treturn new type( array ); // create typed array\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\t\n\t\t\t},\n\t\n\t\t\tisTypedArray: function( object ) {\n\t\n\t\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t\t! ( object instanceof DataView );\n\t\n\t\t\t},\n\t\n\t\t\t// returns an array by which times and values can be sorted\n\t\t\tgetKeyframeOrder: function( times ) {\n\t\n\t\t\t\tfunction compareTime( i, j ) {\n\t\n\t\t\t\t\treturn times[ i ] - times[ j ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar n = times.length;\n\t\t\t\tvar result = new Array( n );\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\t\n\t\t\t\tresult.sort( compareTime );\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\t\tsortedArray: function( values, stride, order ) {\n\t\n\t\t\t\tvar nValues = values.length;\n\t\t\t\tvar result = new values.constructor( nValues );\n\t\n\t\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\t\n\t\t\t\t\tvar srcOffset = order[ i ] * stride;\n\t\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// function for parsing AOS keyframe formats\n\t\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\t\n\t\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\t\n\t\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( key === undefined ) return; // no data\n\t\n\t\t\t\tvar value = key[ valuePropertyName ];\n\t\t\t\tif ( value === undefined ) return; // no data\n\t\n\t\t\t\tif ( Array.isArray( value ) ) {\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t\t// ...assume THREE.Math-ish\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalue.toArray( values, values.length );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise push as-is\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalues.push( value );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Abstract base class of interpolants over parametric samples.\n\t\t *\n\t\t * The parameter domain is one dimensional, typically the time or a path\n\t\t * along a curve defined by the data.\n\t\t *\n\t\t * The sample values can have any dimensionality and derived classes may\n\t\t * apply special interpretations to the data.\n\t\t *\n\t\t * This class provides the interval seek in a Template Method, deferring\n\t\t * the actual interpolation to derived classes.\n\t\t *\n\t\t * Time complexity is O(1) for linear access crossing at most two points\n\t\t * and O(log N) for random access, where N is the number of positions.\n\t\t *\n\t\t * References:\n\t\t *\n\t\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction Interpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tthis.parameterPositions = parameterPositions;\n\t\t\tthis._cachedIndex = 0;\n\t\n\t\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\t\tthis.sampleValues = sampleValues;\n\t\t\tthis.valueSize = sampleSize;\n\t\n\t\t}\n\t\n\t\tInterpolant.prototype = {\n\t\n\t\t\tconstructor: Interpolant,\n\t\n\t\t\tevaluate: function( t ) {\n\t\n\t\t\t\tvar pp = this.parameterPositions,\n\t\t\t\t\ti1 = this._cachedIndex,\n\t\n\t\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\tvalidate_interval: {\n\t\n\t\t\t\t\tseek: {\n\t\n\t\t\t\t\t\tvar right;\n\t\n\t\t\t\t\t\tlinear_scan: {\n\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t//- slower code:\n\t\t//-\n\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\t\n\t\t\t\t\t\t\t\t\t\t// after end\n\t\n\t\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t//- slower code:\n\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\t\n\t\t\t\t\t\t\t\t// looping?\n\t\n\t\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( t < t1global ) {\n\t\n\t\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\t\tt0 = t1global;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// linear reverse scan\n\t\n\t\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// before start\n\t\n\t\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// the interval is valid\n\t\n\t\t\t\t\t\t\tbreak validate_interval;\n\t\n\t\t\t\t\t\t} // linear scan\n\t\n\t\t\t\t\t\t// binary search\n\t\n\t\t\t\t\t\twhile ( i1 < right ) {\n\t\n\t\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\t\n\t\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\t\n\t\t\t\t\t\t\t\tright = mid;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\ti1 = mid + 1;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\t\t\t// check boundary cases, again\n\t\n\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} // seek\n\t\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\n\t\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\t\n\t\t\t\t} // validate_interval\n\t\n\t\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\t\n\t\t\t},\n\t\n\t\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t\t// Note: The indirection allows central control of many interpolants.\n\t\n\t\t\t// --- Protected interface\n\t\n\t\t\tDefaultSettings_: {},\n\t\n\t\t\tgetSettings_: function() {\n\t\n\t\t\t\treturn this.settings || this.DefaultSettings_;\n\t\n\t\t\t},\n\t\n\t\t\tcopySampleValue_: function( index ) {\n\t\n\t\t\t\t// copies a sample value to the result buffer\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\toffset = index * stride;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] = values[ offset + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// Template methods for derived classes:\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t\t// implementations shall return this.resultBuffer\n\t\n\t\t\t},\n\t\n\t\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\t\t// empty\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Interpolant.prototype, {\n\t\n\t\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\t\tInterpolant.prototype.copySampleValue_,\n\t\n\t\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\t\tInterpolant.prototype.copySampleValue_\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Fast and simple cubic spline interpolant.\n\t\t *\n\t\t * It was derived from a Hermitian construction setting the first derivative\n\t\t * at each sample position to the linear slope between neighboring positions\n\t\t * over their parameter interval.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction CubicInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t\tthis._weightPrev = -0;\n\t\t\tthis._offsetPrev = -0;\n\t\t\tthis._weightNext = -0;\n\t\t\tthis._offsetNext = -0;\n\t\n\t\t}\n\t\n\t\tCubicInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: CubicInterpolant,\n\t\n\t\t\tDefaultSettings_: {\n\t\n\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\n\t\t\t},\n\t\n\t\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\t\tvar pp = this.parameterPositions,\n\t\t\t\t\tiPrev = i1 - 2,\n\t\t\t\t\tiNext = i1 + 1,\n\t\n\t\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\t\ttNext = pp[ iNext ];\n\t\n\t\t\t\tif ( tPrev === undefined ) {\n\t\n\t\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\t\n\t\t\t\t\t\tcase ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase WrapAroundEnding:\n\t\n\t\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\t\ttPrev = t1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tNext === undefined ) {\n\t\n\t\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\t\n\t\t\t\t\t\tcase ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase WrapAroundEnding:\n\t\n\t\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\t\ttNext = t0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\t\tstride = this.valueSize;\n\t\n\t\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\t\tthis._offsetNext = iNext * stride;\n\t\n\t\t\t},\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\t\n\t\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\t\tpp = p * p,\n\t\t\t\t\tppp = pp * p;\n\t\n\t\t\t\t// evaluate polynomials\n\t\n\t\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\t\n\t\t\t\t// combine data linearly\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] =\n\t\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\t\tsN * values[ oN + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction LinearInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tLinearInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: LinearInterpolant,\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toffset1 = i1 * stride,\n\t\t\t\t\toffset0 = offset1 - stride,\n\t\n\t\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\t\tweight0 = 1 - weight1;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] =\n\t\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Interpolant that evaluates to the sample value at the position preceeding\n\t\t * the parameter.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction DiscreteInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tDiscreteInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: DiscreteInterpolant,\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar KeyframeTrackPrototype;\n\t\n\t\tKeyframeTrackPrototype = {\n\t\n\t\t\tTimeBufferType: Float32Array,\n\t\t\tValueBufferType: Float32Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateLinear,\n\t\n\t\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\t\n\t\t\t\treturn new DiscreteInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\t\treturn new LinearInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\t\n\t\t\t\treturn new CubicInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tsetInterpolation: function( interpolation ) {\n\t\n\t\t\t\tvar factoryMethod;\n\t\n\t\t\t\tswitch ( interpolation ) {\n\t\n\t\t\t\t\tcase InterpolateDiscrete:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase InterpolateLinear:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase InterpolateSmooth:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( factoryMethod === undefined ) {\n\t\n\t\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\t\n\t\t\t\t\tif ( this.createInterpolant === undefined ) {\n\t\n\t\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tconsole.warn( message );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.createInterpolant = factoryMethod;\n\t\n\t\t\t},\n\t\n\t\t\tgetInterpolation: function() {\n\t\n\t\t\t\tswitch ( this.createInterpolant ) {\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\t\n\t\t\t\t\t\treturn InterpolateDiscrete;\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\t\n\t\t\t\t\t\treturn InterpolateLinear;\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\t\n\t\t\t\t\t\treturn InterpolateSmooth;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetValueSize: function() {\n\t\n\t\t\t\treturn this.values.length / this.times.length;\n\t\n\t\t\t},\n\t\n\t\t\t// move all keyframes either forwards or backwards in time\n\t\t\tshift: function( timeOffset ) {\n\t\n\t\t\t\tif( timeOffset !== 0.0 ) {\n\t\n\t\t\t\t\tvar times = this.times;\n\t\n\t\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\ttimes[ i ] += timeOffset;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\t\tscale: function( timeScale ) {\n\t\n\t\t\t\tif( timeScale !== 1.0 ) {\n\t\n\t\t\t\t\tvar times = this.times;\n\t\n\t\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\ttimes[ i ] *= timeScale;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\t\ttrim: function( startTime, endTime ) {\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tnKeys = times.length,\n\t\t\t\t\tfrom = 0,\n\t\t\t\t\tto = nKeys - 1;\n\t\n\t\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\t\n\t\t\t\t++ to; // inclusive -> exclusive bound\n\t\n\t\t\t\tif( from !== 0 || to !== nKeys ) {\n\t\n\t\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\t\n\t\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\t\tthis.values = AnimationUtils.\n\t\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\t\tvalidate: function() {\n\t\n\t\t\t\tvar valid = true;\n\t\n\t\t\t\tvar valueSize = this.getValueSize();\n\t\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\t\n\t\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\t\tvalid = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tvalues = this.values,\n\t\n\t\t\t\t\tnKeys = times.length;\n\t\n\t\t\t\tif( nKeys === 0 ) {\n\t\n\t\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\t\tvalid = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar prevTime = null;\n\t\n\t\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\t\n\t\t\t\t\tvar currTime = times[ i ];\n\t\n\t\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\t\n\t\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\t\n\t\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprevTime = currTime;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( values !== undefined ) {\n\t\n\t\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tvar value = values[ i ];\n\t\n\t\t\t\t\t\t\tif ( isNaN( value ) ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn valid;\n\t\n\t\t\t},\n\t\n\t\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\t\toptimize: function() {\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tvalues = this.values,\n\t\t\t\t\tstride = this.getValueSize(),\n\t\n\t\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\t\n\t\t\t\t\twriteIndex = 1,\n\t\t\t\t\tlastIndex = times.length - 1;\n\t\n\t\t\t\tfor( var i = 1; i < lastIndex; ++ i ) {\n\t\n\t\t\t\t\tvar keep = false;\n\t\n\t\t\t\t\tvar time = times[ i ];\n\t\t\t\t\tvar timeNext = times[ i + 1 ];\n\t\n\t\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\t\n\t\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\t\n\t\t\t\t\t\tif ( ! smoothInterpolation ) {\n\t\n\t\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\n\t\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\t\toffsetN = offset + stride;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\t\n\t\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\t\n\t\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else keep = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// in-place compaction\n\t\n\t\t\t\t\tif ( keep ) {\n\t\n\t\t\t\t\t\tif ( i !== writeIndex ) {\n\t\n\t\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\t\n\t\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j )\n\t\n\t\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// flush last keyframe (compaction looks ahead)\n\t\n\t\t\t\tif ( lastIndex > 0 ) {\n\t\n\t\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\t\n\t\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )\n\t\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( writeIndex !== times.length ) {\n\t\n\t\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tfunction KeyframeTrackConstructor( name, times, values, interpolation ) {\n\t\n\t\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\t\n\t\t\tif( times === undefined || times.length === 0 ) {\n\t\n\t\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\t\n\t\t\t}\n\t\n\t\t\tthis.name = name;\n\t\n\t\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\t\n\t\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\t\n\t\t\tthis.validate();\n\t\t\tthis.optimize();\n\t\n\t\t}\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of vectored keyframe values.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tVectorKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: VectorKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'vector'\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Spherical linear unit quaternion interpolant.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction QuaternionLinearInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tQuaternionLinearInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: QuaternionLinearInterpolant,\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toffset = i1 * stride,\n\t\n\t\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\t\n\t\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\t\n\t\t\t\t\tQuaternion.slerpFlat( result, 0,\n\t\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of quaternion keyframe values.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tQuaternionKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: QuaternionKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'quaternion',\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\tDefaultInterpolation: InterpolateLinear,\n\t\n\t\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\t\treturn new QuaternionLinearInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of numeric keyframe values.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tNumberKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: NumberKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'number',\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track that interpolates Strings\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tStringKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: StringKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'string',\n\t\t\tValueBufferType: Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateDiscrete,\n\t\n\t\t\tInterpolantFactoryMethodLinear: undefined,\n\t\n\t\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of Boolean keyframe values.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction BooleanKeyframeTrack( name, times, values ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values );\n\t\n\t\t}\n\t\n\t\tBooleanKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: BooleanKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'bool',\n\t\t\tValueBufferType: Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateDiscrete,\n\t\n\t\t\tInterpolantFactoryMethodLinear: undefined,\n\t\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t\t// Note: Actually this track could have a optimized / compressed\n\t\t\t// representation of a single value and a custom interpolant that\n\t\t\t// computes \"firstValue ^ isOdd( index )\".\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of keyframe values that represent color.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tColorKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: ColorKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'color'\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\n\t\t\t// Note: Very basic implementation and nothing special yet.\n\t\t\t// However, this is the place for color space parameterization.\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A timed sequence of keyframes for a specific property.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.apply( this, arguments );\n\t\n\t\t}\n\t\n\t\tKeyframeTrack.prototype = KeyframeTrackPrototype;\n\t\tKeyframeTrackPrototype.constructor = KeyframeTrack;\n\t\n\t\t// Static methods:\n\t\n\t\tObject.assign( KeyframeTrack, {\n\t\n\t\t\t// Serialization (in static context, because of constructor invocation\n\t\t\t// and automatic invocation of .toJSON):\n\t\n\t\t\tparse: function( json ) {\n\t\n\t\t\t\tif( json.type === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\t\n\t\t\t\tif ( json.times === undefined ) {\n\t\n\t\t\t\t\tvar times = [], values = [];\n\t\n\t\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\t\n\t\t\t\t\tjson.times = times;\n\t\t\t\t\tjson.values = values;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// derived classes can define a static parse method\n\t\t\t\tif ( trackType.parse !== undefined ) {\n\t\n\t\t\t\t\treturn trackType.parse( json );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\t\treturn new trackType(\n\t\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function( track ) {\n\t\n\t\t\t\tvar trackType = track.constructor;\n\t\n\t\t\t\tvar json;\n\t\n\t\t\t\t// derived classes can define a static toJSON method\n\t\t\t\tif ( trackType.toJSON !== undefined ) {\n\t\n\t\t\t\t\tjson = trackType.toJSON( track );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\t\tjson = {\n\t\n\t\t\t\t\t\t'name': track.name,\n\t\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t\tvar interpolation = track.getInterpolation();\n\t\n\t\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\tjson.interpolation = interpolation;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tjson.type = track.ValueTypeName; // mandatory\n\t\n\t\t\t\treturn json;\n\t\n\t\t\t},\n\t\n\t\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\t\n\t\t\t\tswitch( typeName.toLowerCase() ) {\n\t\n\t\t\t\t\tcase \"scalar\":\n\t\t\t\t\tcase \"double\":\n\t\t\t\t\tcase \"float\":\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\tcase \"integer\":\n\t\n\t\t\t\t\t\treturn NumberKeyframeTrack;\n\t\n\t\t\t\t\tcase \"vector\":\n\t\t\t\t\tcase \"vector2\":\n\t\t\t\t\tcase \"vector3\":\n\t\t\t\t\tcase \"vector4\":\n\t\n\t\t\t\t\t\treturn VectorKeyframeTrack;\n\t\n\t\t\t\t\tcase \"color\":\n\t\n\t\t\t\t\t\treturn ColorKeyframeTrack;\n\t\n\t\t\t\t\tcase \"quaternion\":\n\t\n\t\t\t\t\t\treturn QuaternionKeyframeTrack;\n\t\n\t\t\t\t\tcase \"bool\":\n\t\t\t\t\tcase \"boolean\":\n\t\n\t\t\t\t\t\treturn BooleanKeyframeTrack;\n\t\n\t\t\t\t\tcase \"string\":\n\t\n\t\t\t\t\t\treturn StringKeyframeTrack;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Reusable set of Tracks that represent an animation.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t */\n\t\n\t\tfunction AnimationClip( name, duration, tracks ) {\n\t\n\t\t\tthis.name = name;\n\t\t\tthis.tracks = tracks;\n\t\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\t// this means it should figure out its duration by scanning the tracks\n\t\t\tif ( this.duration < 0 ) {\n\t\n\t\t\t\tthis.resetDuration();\n\t\n\t\t\t}\n\t\n\t\t\tthis.optimize();\n\t\n\t\t}\n\t\n\t\tAnimationClip.prototype = {\n\t\n\t\t\tconstructor: AnimationClip,\n\t\n\t\t\tresetDuration: function() {\n\t\n\t\t\t\tvar tracks = this.tracks,\n\t\t\t\t\tduration = 0;\n\t\n\t\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar track = this.tracks[ i ];\n\t\n\t\t\t\t\tduration = Math.max(\n\t\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.duration = duration;\n\t\n\t\t\t},\n\t\n\t\t\ttrim: function() {\n\t\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\toptimize: function() {\n\t\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\t\tthis.tracks[ i ].optimize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// Static methods:\n\t\n\t\tObject.assign( AnimationClip, {\n\t\n\t\t\tparse: function( json ) {\n\t\n\t\t\t\tvar tracks = [],\n\t\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\t\n\t\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\t\n\t\t\t},\n\t\n\t\n\t\t\ttoJSON: function( clip ) {\n\t\n\t\t\t\tvar tracks = [],\n\t\t\t\t\tclipTracks = clip.tracks;\n\t\n\t\t\t\tvar json = {\n\t\n\t\t\t\t\t'name': clip.name,\n\t\t\t\t\t'duration': clip.duration,\n\t\t\t\t\t'tracks': tracks\n\t\n\t\t\t\t};\n\t\n\t\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn json;\n\t\n\t\t\t},\n\t\n\t\n\t\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\t\n\t\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\t\tvar tracks = [];\n\t\n\t\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\t\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\ttimes.push(\n\t\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\t\n\t\t\t\t\tvalues.push( 0, 1, 0 );\n\t\n\t\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\t\n\t\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\t\n\t\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\t\tvalues.push( values[ 0 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttracks.push(\n\t\t\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t\t}\n\t\n\t\t\t\treturn new AnimationClip( name, -1, tracks );\n\t\n\t\t\t},\n\t\n\t\t\tfindByName: function( objectOrClipArray, name ) {\n\t\n\t\t\t\tvar clipArray = objectOrClipArray;\n\t\n\t\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\t\n\t\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\t\n\t\t\t\t\tif ( clipArray[ i ].name === name ) {\n\t\n\t\t\t\t\t\treturn clipArray[ i ];\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\t\n\t\t\t\tvar animationToMorphTargets = {};\n\t\n\t\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\t\n\t\t\t\t// sort morph target names into animation groups based\n\t\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\t\n\t\t\t\t\tif ( parts && parts.length > 1 ) {\n\t\n\t\t\t\t\t\tvar name = parts[ 1 ];\n\t\n\t\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\t\tif ( ! animationMorphTargets ) {\n\t\n\t\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar clips = [];\n\t\n\t\t\t\tfor ( var name in animationToMorphTargets ) {\n\t\n\t\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn clips;\n\t\n\t\t\t},\n\t\n\t\t\t// parse the animation.hierarchy format\n\t\t\tparseAnimation: function( animation, bones ) {\n\t\n\t\t\t\tif ( ! animation ) {\n\t\n\t\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\t\n\t\t\t\t\t// only return track if there are actually keys.\n\t\t\t\t\tif ( animationKeys.length !== 0 ) {\n\t\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\tAnimationUtils.flattenJSON(\n\t\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\t\n\t\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\t\tif ( times.length !== 0 ) {\n\t\n\t\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar tracks = [];\n\t\n\t\t\t\tvar clipName = animation.name || 'default';\n\t\t\t\t// automatic length determination in AnimationClip.\n\t\t\t\tvar duration = animation.length || -1;\n\t\t\t\tvar fps = animation.fps || 30;\n\t\n\t\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\t\n\t\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\t\n\t\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\t\n\t\t\t\t\t// skip empty tracks\n\t\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\t\n\t\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\t\n\t\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\t\n\t\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\t\n\t\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\t\n\t\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\t\n\t\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// ...assume skeletal animation\n\t\n\t\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tracks.length === 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\t\n\t\t\t\treturn clip;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction MaterialLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\t\tthis.textures = {};\n\t\n\t\t}\n\t\n\t\tObject.assign( MaterialLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTextures: function ( value ) {\n\t\n\t\t\t\tthis.textures = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tvar textures = this.textures;\n\t\n\t\t\t\tfunction getTexture( name ) {\n\t\n\t\t\t\t\tif ( textures[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn textures[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar material = new Materials[ json.type ]();\n\t\n\t\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\t\n\t\t\t\t// for PointsMaterial\n\t\n\t\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\t\n\t\t\t\t// maps\n\t\n\t\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\n\t\t\t\tif ( json.alphaMap !== undefined ) {\n\t\n\t\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\t\tmaterial.transparent = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\t\n\t\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\t\tif ( json.normalScale !== undefined ) {\n\t\n\t\t\t\t\tvar normalScale = json.normalScale;\n\t\n\t\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\t\n\t\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\t\n\t\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\t\n\t\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\t\n\t\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\t\n\t\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\n\t\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\n\t\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\n\t\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\t\n\t\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\t\n\t\t\t\t// MultiMaterial\n\t\n\t\t\t\tif ( json.materials !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn material;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferGeometryLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( BufferGeometryLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\t\tvar index = json.data.index;\n\t\n\t\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t\t'Float64Array': Float64Array\n\t\t\t\t};\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = json.data.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\t\n\t\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\t\n\t\t\t\tif ( groups !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingSphere = json.data.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== undefined ) {\n\t\n\t\t\t\t\tvar center = new Vector3();\n\t\n\t\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\t\n\t\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Loader() {\n\t\n\t\t\tthis.onLoadStart = function () {};\n\t\t\tthis.onLoadProgress = function () {};\n\t\t\tthis.onLoadComplete = function () {};\n\t\n\t\t}\n\t\n\t\tLoader.prototype = {\n\t\n\t\t\tconstructor: Loader,\n\t\n\t\t\tcrossOrigin: undefined,\n\t\n\t\t\textractUrlBase: function ( url ) {\n\t\n\t\t\t\tvar parts = url.split( '/' );\n\t\n\t\t\t\tif ( parts.length === 1 ) return './';\n\t\n\t\t\t\tparts.pop();\n\t\n\t\t\t\treturn parts.join( '/' ) + '/';\n\t\n\t\t\t},\n\t\n\t\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\t\n\t\t\t\tvar array = [];\n\t\n\t\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\t\n\t\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tcreateMaterial: ( function () {\n\t\n\t\t\t\tvar color, textureLoader, materialLoader;\n\t\n\t\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\t\n\t\t\t\t\tif ( color === undefined ) color = new Color();\n\t\t\t\t\tif ( textureLoader === undefined ) textureLoader = new TextureLoader();\n\t\t\t\t\tif ( materialLoader === undefined ) materialLoader = new MaterialLoader();\n\t\n\t\t\t\t\t// convert from old material format\n\t\n\t\t\t\t\tvar textures = {};\n\t\n\t\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\t\n\t\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\t\n\t\t\t\t\t\tvar texture;\n\t\n\t\t\t\t\t\tif ( loader !== null ) {\n\t\n\t\t\t\t\t\t\ttexture = loader.load( fullPath );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( repeat !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\t\n\t\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( offset !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( wrap !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( anisotropy !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar uuid = _Math.generateUUID();\n\t\n\t\t\t\t\t\ttextures[ uuid ] = texture;\n\t\n\t\t\t\t\t\treturn uuid;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tvar json = {\n\t\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t\t};\n\t\n\t\t\t\t\tfor ( var name in m ) {\n\t\n\t\t\t\t\t\tvar value = m[ name ];\n\t\n\t\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\t\n\t\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\t\n\t\t\t\t\tmaterialLoader.setTextures( textures );\n\t\n\t\t\t\t\treturn materialLoader.parse( json );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t};\n\t\n\t\tLoader.Handlers = {\n\t\n\t\t\thandlers: [],\n\t\n\t\t\tadd: function ( regex, loader ) {\n\t\n\t\t\t\tthis.handlers.push( regex, loader );\n\t\n\t\t\t},\n\t\n\t\t\tget: function ( file ) {\n\t\n\t\t\t\tvar handlers = this.handlers;\n\t\n\t\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\t\tvar loader  = handlers[ i + 1 ];\n\t\n\t\t\t\t\tif ( regex.test( file ) ) {\n\t\n\t\t\t\t\t\treturn loader;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction JSONLoader( manager ) {\n\t\n\t\t\tif ( typeof manager === 'boolean' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\t\tmanager = undefined;\n\t\n\t\t\t}\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\tthis.withCredentials = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( JSONLoader.prototype, {\n\t\n\t\t\tload: function( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\t\tvar metadata = json.metadata;\n\t\n\t\t\t\t\tif ( metadata !== undefined ) {\n\t\n\t\t\t\t\t\tvar type = metadata.type;\n\t\n\t\t\t\t\t\tif ( type !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\t\tonLoad( object.geometry, object.materials );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\t\tthis.texturePath = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json, texturePath ) {\n\t\n\t\t\t\tvar geometry = new Geometry(),\n\t\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\t\n\t\t\t\tparseModel( scale );\n\t\n\t\t\t\tparseSkin();\n\t\t\t\tparseMorphing( scale );\n\t\t\t\tparseAnimations();\n\t\n\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\tfunction parseModel( scale ) {\n\t\n\t\t\t\t\tfunction isBitSet( value, position ) {\n\t\n\t\t\t\t\t\treturn value & ( 1 << position );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar i, j, fi,\n\t\n\t\t\t\t\toffset, zLength,\n\t\n\t\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\t\n\t\t\t\t\ttype,\n\t\t\t\t\tisQuad,\n\t\t\t\t\thasMaterial,\n\t\t\t\t\thasFaceVertexUv,\n\t\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\t\thasFaceColor, hasFaceVertexColor,\n\t\n\t\t\t\tvertex, face, faceA, faceB, hex, normal,\n\t\n\t\t\t\t\tuvLayer, uv, u, v,\n\t\n\t\t\t\t\tfaces = json.faces,\n\t\t\t\t\tvertices = json.vertices,\n\t\t\t\t\tnormals = json.normals,\n\t\t\t\t\tcolors = json.colors,\n\t\n\t\t\t\t\tnUvLayers = 0;\n\t\n\t\t\t\t\tif ( json.uvs !== undefined ) {\n\t\n\t\t\t\t\t\t// disregard empty arrays\n\t\n\t\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tzLength = vertices.length;\n\t\n\t\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\t\tvertex = new Vector3();\n\t\n\t\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\t\n\t\t\t\t\t\tgeometry.vertices.push( vertex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tzLength = faces.length;\n\t\n\t\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\t\ttype = faces[ offset ++ ];\n\t\n\t\n\t\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\t\n\t\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\t\n\t\t\t\t\t\tif ( isQuad ) {\n\t\n\t\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\t\toffset += 4;\n\t\n\t\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\t\n\t\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t\t);\n\t\n\t\n\t\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\t\tgeometry.faces.push( faceB );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\n\t\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.faces.push( face );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseSkin() {\n\t\n\t\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\t\n\t\t\t\t\tif ( json.skinWeights ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.skinIndices ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.bones = json.bones;\n\t\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseMorphing( scale ) {\n\t\n\t\t\t\t\tif ( json.morphTargets !== undefined ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\t\n\t\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\t\n\t\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\t\n\t\t\t\t\t\t\t\tdstVertices.push( vertex );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\t\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseAnimations() {\n\t\n\t\t\t\t\tvar outputAnimations = [];\n\t\n\t\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\t\tvar animations = [];\n\t\n\t\t\t\t\tif ( json.animation !== undefined ) {\n\t\n\t\t\t\t\t\tanimations.push( json.animation );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.animations !== undefined ) {\n\t\n\t\t\t\t\t\tif ( json.animations.length ) {\n\t\n\t\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tanimations.push( json.animations );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// parse implicit morph animations\n\t\t\t\t\tif ( geometry.morphTargets ) {\n\t\n\t\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\t\n\t\t\t\t\treturn { geometry: geometry };\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\t\n\t\t\t\t\treturn { geometry: geometry, materials: materials };\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ObjectLoader ( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\t\tthis.texturePath = '';\n\t\n\t\t}\n\t\n\t\tObject.assign( ObjectLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( this.texturePath === '' ) {\n\t\n\t\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\t\tthis.texturePath = value;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json, onLoad ) {\n\t\n\t\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\t\n\t\t\t\tvar images = this.parseImages( json.images, function () {\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t\t} );\n\t\n\t\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\t\n\t\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\t\n\t\t\t\tif ( json.animations ) {\n\t\n\t\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t},\n\t\n\t\t\tparseGeometries: function ( json ) {\n\t\n\t\t\t\tvar geometries = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar geometry;\n\t\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\t\tcase 'RingBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'BufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'Geometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\t\n\t\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgeometry.uuid = data.uuid;\n\t\n\t\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\n\t\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometries;\n\t\n\t\t\t},\n\t\n\t\t\tparseMaterials: function ( json, textures ) {\n\t\n\t\t\t\tvar materials = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\t\tloader.setTextures( textures );\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\t\tmaterials[ material.uuid ] = material;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn materials;\n\t\n\t\t\t},\n\t\n\t\t\tparseAnimations: function ( json ) {\n\t\n\t\t\t\tvar animations = [];\n\t\n\t\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\t\n\t\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\t\n\t\t\t\t\tanimations.push( clip );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn animations;\n\t\n\t\t\t},\n\t\n\t\t\tparseImages: function ( json, onLoad ) {\n\t\n\t\t\t\tvar scope = this;\n\t\t\t\tvar images = {};\n\t\n\t\t\t\tfunction loadImage( url ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\treturn loader.load( url, function () {\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, undefined, function () {\n\t\n\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json !== undefined && json.length > 0 ) {\n\t\n\t\t\t\t\tvar manager = new LoadingManager( onLoad );\n\t\n\t\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\t\n\t\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn images;\n\t\n\t\t\t},\n\t\n\t\t\tparseTextures: function ( json, images ) {\n\t\n\t\t\t\tfunction parseConstant( value, type ) {\n\t\n\t\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\t\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\t\n\t\t\t\t\treturn type[ value ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar textures = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\t\tif ( data.image === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\ttexture.uuid = data.uuid;\n\t\n\t\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\n\t\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );\n\t\n\t\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\t\tif ( data.wrap !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );\n\t\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );\n\t\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );\n\t\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\n\t\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\t\n\t\t\t\t\t\ttextures[ data.uuid ] = texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn textures;\n\t\n\t\t\t},\n\t\n\t\t\tparseObject: function () {\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\n\t\t\t\treturn function parseObject( data, geometries, materials ) {\n\t\n\t\t\t\t\tvar object;\n\t\n\t\t\t\t\tfunction getGeometry( name ) {\n\t\n\t\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn geometries[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfunction getMaterial( name ) {\n\t\n\t\t\t\t\t\tif ( name === undefined ) return undefined;\n\t\n\t\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn materials[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\t\tcase 'Scene':\n\t\n\t\t\t\t\t\t\tobject = new Scene();\n\t\n\t\t\t\t\t\t\tif ( data.background !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\t\n\t\t\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( data.fog !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\t\n\t\t\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\t\n\t\t\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\t\n\t\t\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PerspectiveCamera':\n\t\n\t\t\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\t\n\t\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'OrthographicCamera':\n\t\n\t\t\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'AmbientLight':\n\t\n\t\t\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'DirectionalLight':\n\t\n\t\t\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointLight':\n\t\n\t\t\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'SpotLight':\n\t\n\t\t\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'HemisphereLight':\n\t\n\t\t\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Mesh':\n\t\n\t\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\t\tvar material = getMaterial( data.material );\n\t\n\t\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\t\n\t\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'LOD':\n\t\n\t\t\t\t\t\t\tobject = new LOD();\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Line':\n\t\n\t\t\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'LineSegments':\n\t\n\t\t\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\t\tcase 'Points':\n\t\n\t\t\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Sprite':\n\t\n\t\t\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Group':\n\t\n\t\t\t\t\t\t\tobject = new Group();\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tobject = new Object3D();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.uuid = data.uuid;\n\t\n\t\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\t\tif ( data.matrix !== undefined ) {\n\t\n\t\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\t\n\t\t\t\t\tif ( data.shadow ) {\n\t\n\t\t\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\n\t\t\t\t\tif ( data.children !== undefined ) {\n\t\n\t\t\t\t\t\tfor ( var child in data.children ) {\n\t\n\t\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.type === 'LOD' ) {\n\t\n\t\t\t\t\t\tvar levels = data.levels;\n\t\n\t\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\t\n\t\t\t\t\t\t\tif ( child !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn object;\n\t\n\t\t\t\t};\n\t\n\t\t\t}()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Extensible curve object\n\t\t *\n\t\t * Some common of Curve methods\n\t\t * .getPoint(t), getTangent(t)\n\t\t * .getPointAt(u), getTangentAt(u)\n\t\t * .getPoints(), .getSpacedPoints()\n\t\t * .getLength()\n\t\t * .updateArcLengths()\n\t\t *\n\t\t * This following classes subclasses THREE.Curve:\n\t\t *\n\t\t * -- 2d classes --\n\t\t * THREE.LineCurve\n\t\t * THREE.QuadraticBezierCurve\n\t\t * THREE.CubicBezierCurve\n\t\t * THREE.SplineCurve\n\t\t * THREE.ArcCurve\n\t\t * THREE.EllipseCurve\n\t\t *\n\t\t * -- 3d classes --\n\t\t * THREE.LineCurve3\n\t\t * THREE.QuadraticBezierCurve3\n\t\t * THREE.CubicBezierCurve3\n\t\t * THREE.SplineCurve3\n\t\t *\n\t\t * A series of curves can be represented as a THREE.CurvePath\n\t\t *\n\t\t **/\n\t\n\t\t/**************************************************************\n\t\t *\tAbstract Curve base class\n\t\t **************************************************************/\n\t\n\t\tfunction Curve() {}\n\t\n\t\tCurve.prototype = {\n\t\n\t\t\tconstructor: Curve,\n\t\n\t\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t\t//\t- t [0 .. 1]\n\t\n\t\t\tgetPoint: function ( t ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\t// Get point at relative position in curve according to arc length\n\t\t\t// - u [0 .. 1]\n\t\n\t\t\tgetPointAt: function ( u ) {\n\t\n\t\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\t\treturn this.getPoint( t );\n\t\n\t\t\t},\n\t\n\t\t\t// Get sequence of points using getPoint( t )\n\t\n\t\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t// Get sequence of points using getPointAt( u )\n\t\n\t\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t// Get total curve arc length\n\t\n\t\t\tgetLength: function () {\n\t\n\t\t\t\tvar lengths = this.getLengths();\n\t\t\t\treturn lengths[ lengths.length - 1 ];\n\t\n\t\t\t},\n\t\n\t\t\t// Get list of cumulative segment lengths\n\t\n\t\t\tgetLengths: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\t\n\t\t\t\tif ( this.cacheArcLengths\n\t\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t\t&& ! this.needsUpdate ) {\n\t\n\t\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\t\treturn this.cacheArcLengths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.needsUpdate = false;\n\t\n\t\t\t\tvar cache = [];\n\t\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\t\tvar p, sum = 0;\n\t\n\t\t\t\tcache.push( 0 );\n\t\n\t\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\t\n\t\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\t\tcache.push( sum );\n\t\t\t\t\tlast = current;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cacheArcLengths = cache;\n\t\n\t\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\t\n\t\t\t},\n\t\n\t\t\tupdateArcLengths: function() {\n\t\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\tthis.getLengths();\n\t\n\t\t\t},\n\t\n\t\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\t\n\t\t\tgetUtoTmapping: function ( u, distance ) {\n\t\n\t\t\t\tvar arcLengths = this.getLengths();\n\t\n\t\t\t\tvar i = 0, il = arcLengths.length;\n\t\n\t\t\t\tvar targetArcLength; // The targeted u distance value to get\n\t\n\t\t\t\tif ( distance ) {\n\t\n\t\t\t\t\ttargetArcLength = distance;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//var time = Date.now();\n\t\n\t\t\t\t// binary search for the index with largest value smaller than target u distance\n\t\n\t\t\t\tvar low = 0, high = il - 1, comparison;\n\t\n\t\t\t\twhile ( low <= high ) {\n\t\n\t\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\t\n\t\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\t\n\t\t\t\t\tif ( comparison < 0 ) {\n\t\n\t\t\t\t\t\tlow = i + 1;\n\t\n\t\t\t\t\t} else if ( comparison > 0 ) {\n\t\n\t\t\t\t\t\thigh = i - 1;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\thigh = i;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t// DONE\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\ti = high;\n\t\n\t\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\t\n\t\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\t\n\t\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\t\treturn t;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\t\n\t\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\t\n\t\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\t\n\t\t\t\t// determine where we are between the 'before' and 'after' points\n\t\n\t\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\t\n\t\t\t\t// add that fractional amount to t\n\t\n\t\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\t\n\t\t\t\treturn t;\n\t\n\t\t\t},\n\t\n\t\t\t// Returns a unit vector tangent at t\n\t\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t\t// which seems to give a reasonable approximation\n\t\n\t\t\tgetTangent: function( t ) {\n\t\n\t\t\t\tvar delta = 0.0001;\n\t\t\t\tvar t1 = t - delta;\n\t\t\t\tvar t2 = t + delta;\n\t\n\t\t\t\t// Capping in case of danger\n\t\n\t\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\t\tif ( t2 > 1 ) t2 = 1;\n\t\n\t\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\t\tvar pt2 = this.getPoint( t2 );\n\t\n\t\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\t\treturn vec.normalize();\n\t\n\t\t\t},\n\t\n\t\t\tgetTangentAt: function ( u ) {\n\t\n\t\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\t\treturn this.getTangent( t );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\t\n\t\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\t\n\t\t\t\tvar normal = new Vector3();\n\t\n\t\t\t\tvar tangents = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar binormals = [];\n\t\n\t\t\t\tvar vec = new Vector3();\n\t\t\t\tvar mat = new Matrix4();\n\t\n\t\t\t\tvar i, u, theta;\n\t\n\t\t\t\t// compute the tangent vectors for each segment on the curve\n\t\n\t\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\t\t\tu = i / segments;\n\t\n\t\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\t\ttangents[ i ].normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t\t// and in the direction of the minimum tangent xyz component\n\t\n\t\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\t\tvar min = Number.MAX_VALUE;\n\t\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\t\n\t\t\t\tif ( tx <= min ) {\n\t\n\t\t\t\t\tmin = tx;\n\t\t\t\t\tnormal.set( 1, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ty <= min ) {\n\t\n\t\t\t\t\tmin = ty;\n\t\t\t\t\tnormal.set( 0, 1, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tz <= min ) {\n\t\n\t\t\t\t\tnormal.set( 0, 0, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\t\n\t\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t\n\t\n\t\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\t\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\t\n\t\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\t\n\t\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\t\n\t\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tvec.normalize();\n\t\n\t\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\t\n\t\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\t\n\t\t\t\tif ( closed === true ) {\n\t\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\t\ttheta /= segments;\n\t\n\t\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\t\n\t\t\t\t\t\ttheta = - theta;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\t\t\t// twist a little...\n\t\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\ttangents: tangents,\n\t\t\t\t\tnormals: normals,\n\t\t\t\t\tbinormals: binormals\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// TODO: Transformation for Curves?\n\t\n\t\t/**************************************************************\n\t\t *\t3D Curves\n\t\t **************************************************************/\n\t\n\t\t// A Factory method for creating new curve subclasses\n\t\n\t\tCurve.create = function ( constructor, getPointFunc ) {\n\t\n\t\t\tconstructor.prototype = Object.create( Curve.prototype );\n\t\t\tconstructor.prototype.constructor = constructor;\n\t\t\tconstructor.prototype.getPoint = getPointFunc;\n\t\n\t\t\treturn constructor;\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tLine\n\t\t **************************************************************/\n\t\n\t\tfunction LineCurve( v1, v2 ) {\n\t\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t}\n\t\n\t\tLineCurve.prototype = Object.create( Curve.prototype );\n\t\tLineCurve.prototype.constructor = LineCurve;\n\t\n\t\tLineCurve.prototype.isLineCurve = true;\n\t\n\t\tLineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tif ( t === 1 ) {\n\t\n\t\t\t\treturn this.v2.clone();\n\t\n\t\t\t}\n\t\n\t\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\t// Line curve is linear, so we can overwrite default getPointAt\n\t\n\t\tLineCurve.prototype.getPointAt = function ( u ) {\n\t\n\t\t\treturn this.getPoint( u );\n\t\n\t\t};\n\t\n\t\tLineCurve.prototype.getTangent = function( t ) {\n\t\n\t\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\t\n\t\t\treturn tangent.normalize();\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t **/\n\t\n\t\t/**************************************************************\n\t\t *\tCurved Path - a curve path is simply a array of connected\n\t\t *  curves, but retains the api of a curve\n\t\t **************************************************************/\n\t\n\t\tfunction CurvePath() {\n\t\n\t\t\tthis.curves = [];\n\t\n\t\t\tthis.autoClose = false; // Automatically closes the path\n\t\n\t\t}\n\t\n\t\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\t\n\t\t\tconstructor: CurvePath,\n\t\n\t\t\tadd: function ( curve ) {\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t},\n\t\n\t\t\tclosePath: function () {\n\t\n\t\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\t\n\t\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\t\n\t\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// To get accurate point with reference to\n\t\t\t// entire path distance at time t,\n\t\t\t// following has to be done:\n\t\n\t\t\t// 1. Length of each sub path have to be known\n\t\t\t// 2. Locate and identify type of curve\n\t\t\t// 3. Get t for the curve\n\t\t\t// 4. Return curve.getPointAt(t')\n\t\n\t\t\tgetPoint: function ( t ) {\n\t\n\t\t\t\tvar d = t * this.getLength();\n\t\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\t\tvar i = 0;\n\t\n\t\t\t\t// To think about boundaries points.\n\t\n\t\t\t\twhile ( i < curveLengths.length ) {\n\t\n\t\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\t\n\t\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\t\tvar curve = this.curves[ i ];\n\t\n\t\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\t\n\t\t\t\t\t\treturn curve.getPointAt( u );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ti ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\t\n\t\t\t},\n\t\n\t\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t\t// getPoint() depends on getLength\n\t\n\t\t\tgetLength: function () {\n\t\n\t\t\t\tvar lens = this.getCurveLengths();\n\t\t\t\treturn lens[ lens.length - 1 ];\n\t\n\t\t\t},\n\t\n\t\t\t// cacheLengths must be recalculated.\n\t\t\tupdateArcLengths: function () {\n\t\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\tthis.cacheLengths = null;\n\t\t\t\tthis.getLengths();\n\t\n\t\t\t},\n\t\n\t\t\t// Compute lengths and cache them\n\t\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\t\n\t\t\tgetCurveLengths: function () {\n\t\n\t\t\t\t// We use cache values if curves and cache array are same length\n\t\n\t\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\t\n\t\t\t\t\treturn this.cacheLengths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Get length of sub-curve\n\t\t\t\t// Push sums into cached array\n\t\n\t\t\t\tvar lengths = [], sums = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\t\tlengths.push( sums );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cacheLengths = lengths;\n\t\n\t\t\t\treturn lengths;\n\t\n\t\t\t},\n\t\n\t\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = 40;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClose ) {\n\t\n\t\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\t\tdivisions = divisions || 12;\n\t\n\t\t\t\tvar points = [], last;\n\t\n\t\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\t\n\t\t\t\t\tvar curve = curves[ i ];\n\t\t\t\t\tvar resolution = (curve && curve.isEllipseCurve) ? divisions * 2\n\t\t\t\t\t\t: (curve && curve.isLineCurve) ? 1\n\t\t\t\t\t\t: (curve && curve.isSplineCurve) ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\t\n\t\t\t\t\tvar pts = curve.getPoints( resolution );\n\t\n\t\t\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\t\n\t\t\t\t\t\tvar point = pts[ j ];\n\t\n\t\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\t\n\t\t\t\t\t\tpoints.push( point );\n\t\t\t\t\t\tlast = point;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t/**************************************************************\n\t\t\t *\tCreate Geometries Helpers\n\t\t\t **************************************************************/\n\t\n\t\t\t/// Generate geometry from path points (for Line or Points objects)\n\t\n\t\t\tcreatePointsGeometry: function ( divisions ) {\n\t\n\t\t\t\tvar pts = this.getPoints( divisions );\n\t\t\t\treturn this.createGeometry( pts );\n\t\n\t\t\t},\n\t\n\t\t\t// Generate geometry from equidistant sampling along the path\n\t\n\t\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\t\n\t\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\t\treturn this.createGeometry( pts );\n\t\n\t\t\t},\n\t\n\t\t\tcreateGeometry: function ( points ) {\n\t\n\t\t\t\tvar geometry = new Geometry();\n\t\n\t\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar point = points[ i ];\n\t\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**************************************************************\n\t\t *\tEllipse curve\n\t\t **************************************************************/\n\t\n\t\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\tthis.aX = aX;\n\t\t\tthis.aY = aY;\n\t\n\t\t\tthis.xRadius = xRadius;\n\t\t\tthis.yRadius = yRadius;\n\t\n\t\t\tthis.aStartAngle = aStartAngle;\n\t\t\tthis.aEndAngle = aEndAngle;\n\t\n\t\t\tthis.aClockwise = aClockwise;\n\t\n\t\t\tthis.aRotation = aRotation || 0;\n\t\n\t\t}\n\t\n\t\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\t\tEllipseCurve.prototype.constructor = EllipseCurve;\n\t\n\t\tEllipseCurve.prototype.isEllipseCurve = true;\n\t\n\t\tEllipseCurve.prototype.getPoint = function( t ) {\n\t\n\t\t\tvar twoPi = Math.PI * 2;\n\t\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\t\n\t\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\t\n\t\t\tif ( deltaAngle < Number.EPSILON ) {\n\t\n\t\t\t\tif ( samePoints ) {\n\t\n\t\t\t\t\tdeltaAngle = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdeltaAngle = twoPi;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.aClockwise === true && ! samePoints ) {\n\t\n\t\t\t\tif ( deltaAngle === twoPi ) {\n\t\n\t\t\t\t\tdeltaAngle = - twoPi;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\t\n\t\t\tif ( this.aRotation !== 0 ) {\n\t\n\t\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\t\tvar sin = Math.sin( this.aRotation );\n\t\n\t\t\t\tvar tx = x - this.aX;\n\t\t\t\tvar ty = y - this.aY;\n\t\n\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\t\ty = tx * sin + ty * cos + this.aY;\n\t\n\t\t\t}\n\t\n\t\t\treturn new Vector2( x, y );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tvar CurveUtils = {\n\t\n\t\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\t\n\t\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\t\n\t\t\t},\n\t\n\t\t\t// Puay Bing, thanks for helping with this derivative!\n\t\n\t\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t\t3 * t * t * p3;\n\t\n\t\t\t},\n\t\n\t\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\t// To check if my formulas are correct\n\t\n\t\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\t\n\t\t\t\treturn h00 + h10 + h01 + h11;\n\t\n\t\t\t},\n\t\n\t\t\t// Catmull-Rom\n\t\n\t\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\t\n\t\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\t\tvar t2 = t * t;\n\t\t\t\tvar t3 = t * t2;\n\t\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tSpline curve\n\t\t **************************************************************/\n\t\n\t\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\t\n\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\t\n\t\t}\n\t\n\t\tSplineCurve.prototype = Object.create( Curve.prototype );\n\t\tSplineCurve.prototype.constructor = SplineCurve;\n\t\n\t\tSplineCurve.prototype.isSplineCurve = true;\n\t\n\t\tSplineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\t\n\t\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\t\tvar interpolate = CurveUtils.interpolate;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t\t);\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tCubic Bezier curve\n\t\t **************************************************************/\n\t\n\t\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\n\t\t}\n\t\n\t\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\t\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\t\n\t\tCubicBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tvar b3 = ShapeUtils.b3;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t\t);\n\t\n\t\t};\n\t\n\t\tCubicBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\t\tvar tangentCubicBezier = CurveUtils.tangentCubicBezier;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t\t).normalize();\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tQuadratic Bezier curve\n\t\t **************************************************************/\n\t\n\t\n\t\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t}\n\t\n\t\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\t\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\t\n\t\n\t\tQuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tvar b2 = ShapeUtils.b2;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t\t);\n\t\n\t\t};\n\t\n\t\n\t\tQuadraticBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\t\tvar tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t\t).normalize();\n\t\n\t\t};\n\t\n\t\tvar PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {\n\t\n\t\t\tfromPoints: function ( vectors ) {\n\t\n\t\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\t\n\t\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmoveTo: function ( x, y ) {\n\t\n\t\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\t\n\t\t\t},\n\t\n\t\t\tlineTo: function ( x, y ) {\n\t\n\t\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( x, y );\n\t\n\t\t\t},\n\t\n\t\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\n\t\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\t\tnew Vector2( aX, aY )\n\t\t\t\t);\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\n\t\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\t\tnew Vector2( aX, aY )\n\t\t\t\t);\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\t\n\t\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\t\n\t\t\t\tvar curve = new SplineCurve( npts );\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\t\n\t\t\t},\n\t\n\t\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\t\n\t\t\t},\n\t\n\t\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t\t},\n\t\n\t\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t\t},\n\t\n\t\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t\t\tif ( this.curves.length > 0 ) {\n\t\n\t\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\t\n\t\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\t\n\t\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\t\tthis.currentPoint.copy( lastPoint );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Defines a 2d shape plane using paths.\n\t\t **/\n\t\n\t\t// STEP 1 Create a path.\n\t\t// STEP 2 Turn path into shape.\n\t\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t\t// STEP 3a - Extract points from each shape, turn to vertices\n\t\t// STEP 3b - Triangulate each shape, add faces.\n\t\n\t\tfunction Shape() {\n\t\n\t\t\tPath.apply( this, arguments );\n\t\n\t\t\tthis.holes = [];\n\t\n\t\t}\n\t\n\t\tShape.prototype = Object.assign( Object.create( PathPrototype ), {\n\t\n\t\t\tconstructor: Shape,\n\t\n\t\t\tgetPointsHoles: function ( divisions ) {\n\t\n\t\t\t\tvar holesPts = [];\n\t\n\t\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn holesPts;\n\t\n\t\t\t},\n\t\n\t\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\t\n\t\t\textractAllPoints: function ( divisions ) {\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\t\tholes: this.getPointsHoles( divisions )\n\t\n\t\t\t\t};\n\t\n\t\t\t},\n\t\n\t\t\textractPoints: function ( divisions ) {\n\t\n\t\t\t\treturn this.extractAllPoints( divisions );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Creates free form 2d path using series of points, lines or curves.\n\t\t *\n\t\t **/\n\t\n\t\tfunction Path( points ) {\n\t\n\t\t\tCurvePath.call( this );\n\t\t\tthis.currentPoint = new Vector2();\n\t\n\t\t\tif ( points ) {\n\t\n\t\t\t\tthis.fromPoints( points );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tPath.prototype = PathPrototype;\n\t\tPathPrototype.constructor = Path;\n\t\n\t\n\t\t// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\t\tfunction ShapePath() {\n\t\t\tthis.subPaths = [];\n\t\t\tthis.currentPath = null;\n\t\t}\n\t\n\t\tShapePath.prototype = {\n\t\t\tmoveTo: function ( x, y ) {\n\t\t\t\tthis.currentPath = new Path();\n\t\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\t\tthis.currentPath.moveTo( x, y );\n\t\t\t},\n\t\t\tlineTo: function ( x, y ) {\n\t\t\t\tthis.currentPath.lineTo( x, y );\n\t\t\t},\n\t\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\t\t},\n\t\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\t\t},\n\t\t\tsplineThru: function ( pts ) {\n\t\t\t\tthis.currentPath.splineThru( pts );\n\t\t\t},\n\t\n\t\t\ttoShapes: function ( isCCW, noHoles ) {\n\t\n\t\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\t\n\t\t\t\t\tvar shapes = [];\n\t\n\t\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\t\n\t\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\n\t\t\t\t\t\tshapes.push( tmpShape );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn shapes;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\t\n\t\t\t\t\tvar polyLen = inPolygon.length;\n\t\n\t\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\t\tvar inside = false;\n\t\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\t\n\t\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\t\n\t\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\t\n\t\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\t\n\t\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\t\n\t\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\t\n\t\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t\t// continue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn\tinside;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\t\n\t\t\t\tvar subPaths = this.subPaths;\n\t\t\t\tif ( subPaths.length === 0 ) return [];\n\t\n\t\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\t\n\t\t\t\tif ( subPaths.length === 1 ) {\n\t\n\t\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\t\ttmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\t\tshapes.push( tmpShape );\n\t\t\t\t\treturn shapes;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\t\n\t\t\t\t// console.log(\"Holes first\", holesFirst);\n\t\n\t\t\t\tvar betterShapeHoles = [];\n\t\t\t\tvar newShapes = [];\n\t\t\t\tvar newShapeHoles = [];\n\t\t\t\tvar mainIdx = 0;\n\t\t\t\tvar tmpPoints;\n\t\n\t\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\t\tsolid = isCCW ? ! solid : solid;\n\t\n\t\t\t\t\tif ( solid ) {\n\t\n\t\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\t\n\t\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\t\n\t\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\t\t\t//console.log('cw', i);\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\t\n\t\t\t\t\t\t//console.log('ccw', i);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\t\tif ( newShapes.length > 1 ) {\n\t\n\t\t\t\t\tvar ambiguous = false;\n\t\t\t\t\tvar toChange = [];\n\t\n\t\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\t\n\t\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\t\tvar hole_unassigned = true;\n\t\n\t\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tambiguous = true;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\t\tif ( toChange.length > 0 ) {\n\t\n\t\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar tmpHoles;\n\t\n\t\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\t\n\t\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\t\tshapes.push( tmpShape );\n\t\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\t\n\t\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//console.log(\"shape\", shapes);\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Font( data ) {\n\t\n\t\t\tthis.data = data;\n\t\n\t\t}\n\t\n\t\tObject.assign( Font.prototype, {\n\t\n\t\t\tisFont: true,\n\t\n\t\t\tgenerateShapes: function ( text, size, divisions ) {\n\t\n\t\t\t\tfunction createPaths( text ) {\n\t\n\t\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\t\tvar offset = 0;\n\t\n\t\t\t\t\tvar paths = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\t\toffset += ret.offset;\n\t\n\t\t\t\t\t\tpaths.push( ret.path );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn paths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction createPath( c, scale, offset ) {\n\t\n\t\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\t\n\t\t\t\t\tif ( ! glyph ) return;\n\t\n\t\t\t\t\tvar path = new ShapePath();\n\t\n\t\t\t\t\tvar pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;\n\t\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\t\n\t\t\t\t\tif ( glyph.o ) {\n\t\n\t\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\t\n\t\t\t\t\t\t\tvar action = outline[ i ++ ];\n\t\n\t\t\t\t\t\t\tswitch ( action ) {\n\t\n\t\t\t\t\t\t\t\tcase 'm': // moveTo\n\t\n\t\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 'l': // lineTo\n\t\n\t\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\t\n\t\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\t\n\t\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( size === undefined ) size = 100;\n\t\t\t\tif ( divisions === undefined ) divisions = 4;\n\t\n\t\t\t\tvar data = this.data;\n\t\n\t\t\t\tvar paths = createPaths( text );\n\t\t\t\tvar shapes = [];\n\t\n\t\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\t\n\t\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction FontLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( FontLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tvar json;\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tjson = JSON.parse( text );\n\t\n\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar font = scope.parse( json );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( font );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\treturn new Font( json );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar context;\n\t\n\t\tfunction getAudioContext() {\n\t\n\t\t\tif ( context === undefined ) {\n\t\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\t\n\t\t\t}\n\t\n\t\t\treturn context;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t\t */\n\t\n\t\tfunction AudioLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( AudioLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar context = getAudioContext();\n\t\n\t\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\t\n\t\t\t\t\t\tonLoad( audioBuffer );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction StereoCamera() {\n\t\n\t\t\tthis.type = 'StereoCamera';\n\t\n\t\t\tthis.aspect = 1;\n\t\n\t\t\tthis.eyeSep = 0.064;\n\t\n\t\t\tthis.cameraL = new PerspectiveCamera();\n\t\t\tthis.cameraL.layers.enable( 1 );\n\t\t\tthis.cameraL.matrixAutoUpdate = false;\n\t\n\t\t\tthis.cameraR = new PerspectiveCamera();\n\t\t\tthis.cameraR.layers.enable( 2 );\n\t\t\tthis.cameraR.matrixAutoUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( StereoCamera.prototype, {\n\t\n\t\t\tupdate: ( function () {\n\t\n\t\t\t\tvar instance, focus, fov, aspect, near, far, zoom;\n\t\n\t\t\t\tvar eyeRight = new Matrix4();\n\t\t\t\tvar eyeLeft = new Matrix4();\n\t\n\t\t\t\treturn function update( camera ) {\n\t\n\t\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom;\n\t\n\t\t\t\t\tif ( needsUpdate ) {\n\t\n\t\t\t\t\t\tinstance = this;\n\t\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\t\tnear = camera.near;\n\t\t\t\t\t\tfar = camera.far;\n\t\t\t\t\t\tzoom = camera.zoom;\n\t\n\t\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\t\n\t\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\t\tvar eyeSep = this.eyeSep / 2;\n\t\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\t\tvar xmin, xmax;\n\t\n\t\t\t\t\t\t// translate xOffset\n\t\n\t\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\t\n\t\t\t\t\t\t// for left eye\n\t\n\t\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\t\n\t\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t\t// for right eye\n\t\n\t\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\t\n\t\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Camera for rendering cube maps\n\t\t *\t- renders scene into axis-aligned cube\n\t\t *\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction CubeCamera( near, far, cubeResolution ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'CubeCamera';\n\t\n\t\t\tvar fov = 90, aspect = 1;\n\t\n\t\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\t\tthis.add( cameraPX );\n\t\n\t\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\t\tthis.add( cameraNX );\n\t\n\t\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\t\tthis.add( cameraPY );\n\t\n\t\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\t\tthis.add( cameraNY );\n\t\n\t\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\t\tthis.add( cameraPZ );\n\t\n\t\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\t\tthis.add( cameraNZ );\n\t\n\t\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\t\n\t\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\t\n\t\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\t\n\t\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\t\n\t\t\t\tvar renderTarget = this.renderTarget;\n\t\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\t\n\t\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\n\t\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\t\n\t\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\t\n\t\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\t\n\t\t\t\trenderer.setRenderTarget( null );\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\t\tCubeCamera.prototype.constructor = CubeCamera;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AudioListener() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'AudioListener';\n\t\n\t\t\tthis.context = getAudioContext();\n\t\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect( this.context.destination );\n\t\n\t\t\tthis.filter = null;\n\t\n\t\t}\n\t\n\t\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: AudioListener,\n\t\n\t\t\tgetInput: function () {\n\t\n\t\t\t\treturn this.gain;\n\t\n\t\t\t},\n\t\n\t\t\tremoveFilter: function ( ) {\n\t\n\t\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\t\tthis.filter = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetFilter: function () {\n\t\n\t\t\t\treturn this.filter;\n\t\n\t\t\t},\n\t\n\t\t\tsetFilter: function ( value ) {\n\t\n\t\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.context.destination );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.filter = value;\n\t\t\t\tthis.gain.connect( this.filter );\n\t\t\t\tthis.filter.connect( this.context.destination );\n\t\n\t\t\t},\n\t\n\t\t\tgetMasterVolume: function () {\n\t\n\t\t\t\treturn this.gain.gain.value;\n\t\n\t\t\t},\n\t\n\t\t\tsetMasterVolume: function ( value ) {\n\t\n\t\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar quaternion = new Quaternion();\n\t\t\t\tvar scale = new Vector3();\n\t\n\t\t\t\tvar orientation = new Vector3();\n\t\n\t\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\t\tvar listener = this.context.listener;\n\t\t\t\t\tvar up = this.up;\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\t\n\t\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t\t */\n\t\n\t\tfunction Audio( listener ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Audio';\n\t\n\t\t\tthis.context = listener.context;\n\t\t\tthis.source = this.context.createBufferSource();\n\t\t\tthis.source.onended = this.onEnded.bind( this );\n\t\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect( listener.getInput() );\n\t\n\t\t\tthis.autoplay = false;\n\t\n\t\t\tthis.startTime = 0;\n\t\t\tthis.playbackRate = 1;\n\t\t\tthis.isPlaying = false;\n\t\t\tthis.hasPlaybackControl = true;\n\t\t\tthis.sourceType = 'empty';\n\t\n\t\t\tthis.filters = [];\n\t\n\t\t}\n\t\n\t\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Audio,\n\t\n\t\t\tgetOutput: function () {\n\t\n\t\t\t\treturn this.gain;\n\t\n\t\t\t},\n\t\n\t\t\tsetNodeSource: function ( audioNode ) {\n\t\n\t\t\t\tthis.hasPlaybackControl = false;\n\t\t\t\tthis.sourceType = 'audioNode';\n\t\t\t\tthis.source = audioNode;\n\t\t\t\tthis.connect();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetBuffer: function ( audioBuffer ) {\n\t\n\t\t\t\tthis.source.buffer = audioBuffer;\n\t\t\t\tthis.sourceType = 'buffer';\n\t\n\t\t\t\tif ( this.autoplay ) this.play();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tplay: function () {\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar source = this.context.createBufferSource();\n\t\n\t\t\t\tsource.buffer = this.source.buffer;\n\t\t\t\tsource.loop = this.source.loop;\n\t\t\t\tsource.onended = this.source.onended;\n\t\t\t\tsource.start( 0, this.startTime );\n\t\t\t\tsource.playbackRate.value = this.playbackRate;\n\t\n\t\t\t\tthis.isPlaying = true;\n\t\n\t\t\t\tthis.source = source;\n\t\n\t\t\t\treturn this.connect();\n\t\n\t\t\t},\n\t\n\t\t\tpause: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.startTime = this.context.currentTime;\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.startTime = 0;\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconnect: function () {\n\t\n\t\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\t\n\t\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.source.connect( this.getOutput() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdisconnect: function () {\n\t\n\t\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\t\n\t\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.source.disconnect( this.getOutput() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetFilters: function () {\n\t\n\t\t\t\treturn this.filters;\n\t\n\t\t\t},\n\t\n\t\t\tsetFilters: function ( value ) {\n\t\n\t\t\t\tif ( ! value ) value = [];\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.disconnect();\n\t\t\t\t\tthis.filters = value;\n\t\t\t\t\tthis.connect();\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.filters = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetFilter: function () {\n\t\n\t\t\t\treturn this.getFilters()[ 0 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetFilter: function ( filter ) {\n\t\n\t\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\t\n\t\t\t},\n\t\n\t\t\tsetPlaybackRate: function ( value ) {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.playbackRate = value;\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetPlaybackRate: function () {\n\t\n\t\t\t\treturn this.playbackRate;\n\t\n\t\t\t},\n\t\n\t\t\tonEnded: function () {\n\t\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t},\n\t\n\t\t\tgetLoop: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.source.loop;\n\t\n\t\t\t},\n\t\n\t\t\tsetLoop: function ( value ) {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.loop = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetVolume: function () {\n\t\n\t\t\t\treturn this.gain.gain.value;\n\t\n\t\t\t},\n\t\n\t\n\t\t\tsetVolume: function ( value ) {\n\t\n\t\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction PositionalAudio( listener ) {\n\t\n\t\t\tAudio.call( this, listener );\n\t\n\t\t\tthis.panner = this.context.createPanner();\n\t\t\tthis.panner.connect( this.gain );\n\t\n\t\t}\n\t\n\t\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\t\n\t\t\tconstructor: PositionalAudio,\n\t\n\t\t\tgetOutput: function () {\n\t\n\t\t\t\treturn this.panner;\n\t\n\t\t\t},\n\t\n\t\t\tgetRefDistance: function () {\n\t\n\t\t\t\treturn this.panner.refDistance;\n\t\n\t\t\t},\n\t\n\t\t\tsetRefDistance: function ( value ) {\n\t\n\t\t\t\tthis.panner.refDistance = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetRolloffFactor: function () {\n\t\n\t\t\t\treturn this.panner.rolloffFactor;\n\t\n\t\t\t},\n\t\n\t\t\tsetRolloffFactor: function ( value ) {\n\t\n\t\t\t\tthis.panner.rolloffFactor = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetDistanceModel: function () {\n\t\n\t\t\t\treturn this.panner.distanceModel;\n\t\n\t\t\t},\n\t\n\t\t\tsetDistanceModel: function ( value ) {\n\t\n\t\t\t\tthis.panner.distanceModel = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetMaxDistance: function () {\n\t\n\t\t\t\treturn this.panner.maxDistance;\n\t\n\t\t\t},\n\t\n\t\t\tsetMaxDistance: function ( value ) {\n\t\n\t\t\t\tthis.panner.maxDistance = value;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\n\t\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AudioAnalyser( audio, fftSize ) {\n\t\n\t\t\tthis.analyser = audio.context.createAnalyser();\n\t\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\t\n\t\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\t\n\t\t\taudio.getOutput().connect( this.analyser );\n\t\n\t\t}\n\t\n\t\tObject.assign( AudioAnalyser.prototype, {\n\t\n\t\t\tgetFrequencyData: function () {\n\t\n\t\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\t\n\t\t\t\treturn this.data;\n\t\n\t\t\t},\n\t\n\t\t\tgetAverageFrequency: function () {\n\t\n\t\t\t\tvar value = 0, data = this.getFrequencyData();\n\t\n\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\t\tvalue += data[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn value / data.length;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Buffered scene graph property that allows weighted accumulation.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\t\n\t\t\tthis.binding = binding;\n\t\t\tthis.valueSize = valueSize;\n\t\n\t\t\tvar bufferType = Float64Array,\n\t\t\t\tmixFunction;\n\t\n\t\t\tswitch ( typeName ) {\n\t\n\t\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\t\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'bool':\n\t\n\t\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\t\n\t\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\t\n\t\t\t}\n\t\n\t\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t\t//\n\t\t\t// interpolators can use .buffer as their .result\n\t\t\t// the data then goes to 'incoming'\n\t\t\t//\n\t\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t\t// the cumulative result and are compared to detect\n\t\t\t// changes\n\t\t\t//\n\t\t\t// 'orig' stores the original state of the property\n\t\n\t\t\tthis._mixBufferRegion = mixFunction;\n\t\n\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\tthis.useCount = 0;\n\t\t\tthis.referenceCount = 0;\n\t\n\t\t}\n\t\n\t\tPropertyMixer.prototype = {\n\t\n\t\t\tconstructor: PropertyMixer,\n\t\n\t\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\t\taccumulate: function( accuIndex, weight ) {\n\t\n\t\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t\t// the weight and shouldn't have made the call in the first place\n\t\n\t\t\t\tvar buffer = this.buffer,\n\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\t\n\t\t\t\tif ( currentWeight === 0 ) {\n\t\n\t\t\t\t\t// accuN := incoming * weight\n\t\n\t\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentWeight = weight;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// accuN := accuN + incoming * weight\n\t\n\t\t\t\t\tcurrentWeight += weight;\n\t\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cumulativeWeight = currentWeight;\n\t\n\t\t\t},\n\t\n\t\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\t\tapply: function( accuIndex ) {\n\t\n\t\t\t\tvar stride = this.valueSize,\n\t\t\t\t\tbuffer = this.buffer,\n\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\t\tweight = this.cumulativeWeight,\n\t\n\t\t\t\t\tbinding = this.binding;\n\t\n\t\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\t\tif ( weight < 1 ) {\n\t\n\t\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\t\n\t\t\t\t\tvar originalValueOffset = stride * 3;\n\t\n\t\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\t\n\t\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\t\n\t\t\t\t\t\t// value has changed -> update scene graph\n\t\n\t\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// remember the state of the bound property and copy it to both accus\n\t\t\tsaveOriginalState: function() {\n\t\n\t\t\t\tvar binding = this.binding;\n\t\n\t\t\t\tvar buffer = this.buffer,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toriginalValueOffset = stride * 3;\n\t\n\t\t\t\tbinding.getValue( buffer, originalValueOffset );\n\t\n\t\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\t},\n\t\n\t\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\t\trestoreOriginalState: function() {\n\t\n\t\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// mix functions\n\t\n\t\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tif ( t >= 0.5 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tQuaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\t\n\t\t\t},\n\t\n\t\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tvar s = 1 - t;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tvar j = dstOffset + i;\n\t\n\t\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * A reference to a real property in the scene graph.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\t\n\t\t\tthis.path = path;\n\t\t\tthis.parsedPath = parsedPath ||\n\t\t\t\t\tPropertyBinding.parseTrackName( path );\n\t\n\t\t\tthis.node = PropertyBinding.findNode(\n\t\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\t\n\t\t\tthis.rootNode = rootNode;\n\t\n\t\t}\n\t\n\t\tPropertyBinding.prototype = {\n\t\n\t\t\tconstructor: PropertyBinding,\n\t\n\t\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\t\n\t\t\t\tthis.bind();\n\t\t\t\tthis.getValue( targetArray, offset );\n\t\n\t\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t\t// prototype version of these methods with one that represents\n\t\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t\t// become no-ops.\n\t\n\t\t\t},\n\t\n\t\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\t\n\t\t\t\tthis.bind();\n\t\t\t\tthis.setValue( sourceArray, offset );\n\t\n\t\t\t},\n\t\n\t\t\t// create getter / setter pair for a property in the scene graph\n\t\t\tbind: function() {\n\t\n\t\t\t\tvar targetObject = this.node,\n\t\t\t\t\tparsedPath = this.parsedPath,\n\t\n\t\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\t\n\t\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\t\ttargetObject = PropertyBinding.findNode(\n\t\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\t\n\t\t\t\t\tthis.node = targetObject;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// set fail state so we can just 'return' on error\n\t\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\t\tthis.setValue = this._setValue_unavailable;\n\t\n\t\t \t\t// ensure there is a value node\n\t\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( objectName ) {\n\t\n\t\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\t\n\t\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\t\tswitch ( objectName ) {\n\t\n\t\t\t\t\t\tcase 'materials':\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.material ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'bones':\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t\t// and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\t\n\t\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\t\n\t\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\tif ( objectIndex !== undefined ) {\n\t\n\t\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// resolve property\n\t\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\t\n\t\t\t\tif ( nodeProperty === undefined ) {\n\t\n\t\t\t\t\tvar nodeName = parsedPath.nodeName;\n\t\n\t\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// determine versioning scheme\n\t\t\t\tvar versioning = this.Versioning.None;\n\t\n\t\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\t\n\t\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\t\n\t\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// determine how the property gets bound\n\t\t\t\tvar bindingType = this.BindingType.Direct;\n\t\n\t\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\t\n\t\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tif ( ! targetObject.geometry ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\t\n\t\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\t\tthis.propertyIndex = propertyIndex;\n\t\n\t\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\t\n\t\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\t\n\t\t\t\t\tbindingType = this.BindingType.EntireArray;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.propertyName = propertyName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// select getter / setter\n\t\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\t\n\t\t\t},\n\t\n\t\t\tunbind: function() {\n\t\n\t\t\t\tthis.node = null;\n\t\n\t\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\t\tthis.setValue = this._setValue_unbound;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\t\n\t\t\t// these are used to \"bind\" a nonexistent property\n\t\t\t_getValue_unavailable: function() {},\n\t\t\t_setValue_unavailable: function() {},\n\t\n\t\t\t// initial state of these methods that calls 'bind'\n\t\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\t\n\t\t\tBindingType: {\n\t\t\t\tDirect: 0,\n\t\t\t\tEntireArray: 1,\n\t\t\t\tArrayElement: 2,\n\t\t\t\tHasFromToArray: 3\n\t\t\t},\n\t\n\t\t\tVersioning: {\n\t\t\t\tNone: 0,\n\t\t\t\tNeedsUpdate: 1,\n\t\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t\t},\n\t\n\t\t\tGetterByBindingType: [\n\t\n\t\t\t\tfunction getValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_array( buffer, offset ) {\n\t\n\t\t\t\t\tvar source = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_toArray( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t],\n\t\n\t\t\tSetterByBindingTypeAndVersioning: [\n\t\n\t\t\t\t[\n\t\t\t\t\t// Direct\n\t\n\t\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// EntireArray\n\t\n\t\t\t\t\tfunction setValue_array( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// ArrayElement\n\t\n\t\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// HasToFromArray\n\t\n\t\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t]\n\t\n\t\t\t]\n\t\n\t\t} );\n\t\n\t\tPropertyBinding.Composite =\n\t\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\t\n\t\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\t\tPropertyBinding.parseTrackName( path );\n\t\n\t\t\tthis._targetGroup = targetGroup;\n\t\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\t\n\t\t};\n\t\n\t\tPropertyBinding.Composite.prototype = {\n\t\n\t\t\tconstructor: PropertyBinding.Composite,\n\t\n\t\t\tgetValue: function( array, offset ) {\n\t\n\t\t\t\tthis.bind(); // bind all binding\n\t\n\t\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\t\n\t\t\t\t// and only call .getValue on the first\n\t\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue: function( array, offset ) {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].setValue( array, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tbind: function() {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].bind();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tunbind: function() {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].unbind();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tPropertyBinding.create = function( root, path, parsedPath ) {\n\t\n\t\t\tif ( ! ( (root && root.isAnimationObjectGroup) ) ) {\n\t\n\t\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tPropertyBinding.parseTrackName = function( trackName ) {\n\t\n\t\t\t// matches strings in the form of:\n\t\t\t//    nodeName.property\n\t\t\t//    nodeName.property[accessor]\n\t\t\t//    nodeName.material.property[accessor]\n\t\t\t//    uuid.property[accessor]\n\t\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t\t//    parentName/nodeName.property\n\t\t\t//    parentName/parentName/nodeName.property[index]\n\t\t\t//    .bone[Armature.DEF_cog].position\n\t\t\t//    scene:helium_balloon_model:helium_balloon_model.position\n\t\t\t// created and tested via https://regex101.com/#javascript\n\t\n\t\t\tvar re = /^((?:\\w+[\\/:])*)(\\w+)?(?:\\.(\\w+)(?:\\[(.+)\\])?)?\\.(\\w+)(?:\\[(.+)\\])?$/;\n\t\t\tvar matches = re.exec( trackName );\n\t\n\t\t\tif ( ! matches ) {\n\t\n\t\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\t\n\t\t\t}\n\t\n\t\t\tvar results = {\n\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\tnodeName: matches[ 2 ], \t// allowed to be null, specified root node.\n\t\t\t\tobjectName: matches[ 3 ],\n\t\t\t\tobjectIndex: matches[ 4 ],\n\t\t\t\tpropertyName: matches[ 5 ],\n\t\t\t\tpropertyIndex: matches[ 6 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t\t};\n\t\n\t\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\t\n\t\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\t\n\t\t\t}\n\t\n\t\t\treturn results;\n\t\n\t\t};\n\t\n\t\tPropertyBinding.findNode = function( root, nodeName ) {\n\t\n\t\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\t\n\t\t\t\treturn root;\n\t\n\t\t\t}\n\t\n\t\t\t// search into skeleton bones.\n\t\t\tif ( root.skeleton ) {\n\t\n\t\t\t\tvar searchSkeleton = function( skeleton ) {\n\t\n\t\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\t\n\t\t\t\t\t\tif ( bone.name === nodeName ) {\n\t\n\t\t\t\t\t\t\treturn bone;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar bone = searchSkeleton( root.skeleton );\n\t\n\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\treturn bone;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// search into node subtree.\n\t\t\tif ( root.children ) {\n\t\n\t\t\t\tvar searchNodeSubtree = function( children ) {\n\t\n\t\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar childNode = children[ i ];\n\t\n\t\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\t\n\t\t\t\t\t\t\treturn childNode;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\t\n\t\t\t\t\t\tif ( result ) return result;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\t\n\t\t\t\tif ( subTreeNode ) {\n\t\n\t\t\t\t\treturn subTreeNode;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * A group of objects that receives a shared animation state.\n\t\t *\n\t\t * Usage:\n\t\t *\n\t\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t\t *\n\t\t * \t-\tInstead pass this object as 'root'.\n\t\t *\n\t\t * \t-\tYou can also add and remove objects later when the mixer\n\t\t * \t\tis running.\n\t\t *\n\t\t * Note:\n\t\t *\n\t\t *  \tObjects of this class appear as one object to the mixer,\n\t\t *  \tso cache control of the individual objects must be done\n\t\t *  \ton the group.\n\t\t *\n\t\t * Limitation:\n\t\t *\n\t\t * \t- \tThe animated properties must be compatible among the\n\t\t * \t\tall objects in the group.\n\t\t *\n\t\t *  -\tA single property can either be controlled through a\n\t\t *  \ttarget group or directly, but not both.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction AnimationObjectGroup( var_args ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\t// cached objects followed by the active ones\n\t\t\tthis._objects = Array.prototype.slice.call( arguments );\n\t\n\t\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t\t// note: read by PropertyBinding.Composite\n\t\n\t\t\tvar indices = {};\n\t\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tindices[ arguments[ i ].uuid ] = i;\n\t\n\t\t\t}\n\t\n\t\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.stats = {\n\t\n\t\t\t\tobjects: {\n\t\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t\t},\n\t\n\t\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tAnimationObjectGroup.prototype = {\n\t\n\t\t\tconstructor: AnimationObjectGroup,\n\t\n\t\t\tisAnimationObjectGroup: true,\n\t\n\t\t\tadd: function( var_args ) {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tpaths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index === undefined ) {\n\t\n\t\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\t\n\t\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\t\tobjects.push( object );\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\t\tnew PropertyBinding(\n\t\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\tvar knownObject = objects[ index ];\n\t\n\t\t\t\t\t\t// move existing object to the ACTIVE region\n\t\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\n\t\t\t\t\t\t\tif ( binding === undefined ) {\n\t\n\t\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t\t// or may not exist\n\t\n\t\t\t\t\t\t\t\tbinding = new PropertyBinding(\n\t\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\t\n\t\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\t\n\t\t\t\t\t} // else the object is already where we want it to be\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\tremove: function( var_args ) {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\t\n\t\t\t\t\t\t// move existing object into the CACHED region\n\t\n\t\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\t\n\t\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\t// remove & forget\n\t\t\tuncache: function( var_args ) {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\t\n\t\t\t\t\t\tif ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\t\n\t\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\t\n\t\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// object is active, just swap with the last and pop\n\t\n\t\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\t\n\t\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} // cached or active\n\t\n\t\t\t\t\t} // if object is known\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\t\n\t\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t\t// according to the contained objects in the group\n\t\n\t\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\t\tbindings = this._bindings;\n\t\n\t\t\t\tif ( index !== undefined ) return bindings[ index ];\n\t\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tobjects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tbindingsForPath = new Array( nObjects );\n\t\n\t\t\t\tindex = bindings.length;\n\t\n\t\t\t\tindicesByPath[ path ] = index;\n\t\n\t\t\t\tpaths.push( path );\n\t\t\t\tparsedPaths.push( parsedPath );\n\t\t\t\tbindings.push( bindingsForPath );\n\t\n\t\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = objects[ i ];\n\t\n\t\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\t\tnew PropertyBinding( object, path, parsedPath );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn bindingsForPath;\n\t\n\t\t\t},\n\t\n\t\t\tunsubscribe_: function( path ) {\n\t\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t\t// update the array previously obtained with 'subscribe_'\n\t\n\t\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\tindex = indicesByPath[ path ];\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tvar paths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\t\n\t\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\t\n\t\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\t\tbindings.pop();\n\t\n\t\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\t\tparsedPaths.pop();\n\t\n\t\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\t\tpaths.pop();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t\t * objects.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t *\n\t\t */\n\t\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\t\n\t\t\tthis._mixer = mixer;\n\t\t\tthis._clip = clip;\n\t\t\tthis._localRoot = localRoot || null;\n\t\n\t\t\tvar tracks = clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tinterpolants = new Array( nTracks );\n\t\n\t\t\tvar interpolantSettings = {\n\t\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\t\t};\n\t\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\t\tinterpolants[ i ] = interpolant;\n\t\t\t\tinterpolant.settings = interpolantSettings;\n\t\n\t\t\t}\n\t\n\t\t\tthis._interpolantSettings = interpolantSettings;\n\t\n\t\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\t\n\t\t\t// inside: PropertyMixer (managed by the mixer)\n\t\t\tthis._propertyBindings = new Array( nTracks );\n\t\n\t\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\t\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._weightInterpolant = null;\n\t\n\t\t\tthis.loop = LoopRepeat;\n\t\t\tthis._loopCount = -1;\n\t\n\t\t\t// global mixer time when the action is to be started\n\t\t\t// it's set back to 'null' upon start of the action\n\t\t\tthis._startTime = null;\n\t\n\t\t\t// scaled local time of the action\n\t\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\t\tthis.time = 0;\n\t\n\t\t\tthis.timeScale = 1;\n\t\t\tthis._effectiveTimeScale = 1;\n\t\n\t\t\tthis.weight = 1;\n\t\t\tthis._effectiveWeight = 1;\n\t\n\t\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\t\n\t\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\t\n\t\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\t\n\t\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\t\n\t\t}\n\t\n\t\tAnimationAction.prototype = {\n\t\n\t\t\tconstructor: AnimationAction,\n\t\n\t\t\t// State & Scheduling\n\t\n\t\t\tplay: function() {\n\t\n\t\t\t\tthis._mixer._activateAction( this );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function() {\n\t\n\t\t\t\tthis._mixer._deactivateAction( this );\n\t\n\t\t\t\treturn this.reset();\n\t\n\t\t\t},\n\t\n\t\t\treset: function() {\n\t\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.enabled = true;\n\t\n\t\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\t\tthis._startTime = null;\t// forget scheduling\n\t\n\t\t\t\treturn this.stopFading().stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\tisRunning: function() {\n\t\n\t\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\t\n\t\t\t},\n\t\n\t\t\t// return true when play has been called\n\t\t\tisScheduled: function() {\n\t\n\t\t\t\treturn this._mixer._isActiveAction( this );\n\t\n\t\t\t},\n\t\n\t\t\tstartAt: function( time ) {\n\t\n\t\t\t\tthis._startTime = time;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetLoop: function( mode, repetitions ) {\n\t\n\t\t\t\tthis.loop = mode;\n\t\t\t\tthis.repetitions = repetitions;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Weight\n\t\n\t\t\t// set the weight stopping any scheduled fading\n\t\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t\t// method does *not* change .enabled, because it would be confusing\n\t\t\tsetEffectiveWeight: function( weight ) {\n\t\n\t\t\t\tthis.weight = weight;\n\t\n\t\t\t\t// note: same logic as when updated at runtime\n\t\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\t\n\t\t\t\treturn this.stopFading();\n\t\n\t\t\t},\n\t\n\t\t\t// return the weight considering fading and .enabled\n\t\t\tgetEffectiveWeight: function() {\n\t\n\t\t\t\treturn this._effectiveWeight;\n\t\n\t\t\t},\n\t\n\t\t\tfadeIn: function( duration ) {\n\t\n\t\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\t\n\t\t\t},\n\t\n\t\t\tfadeOut: function( duration ) {\n\t\n\t\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\t\n\t\t\t},\n\t\n\t\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\t\n\t\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\t\tthis.fadeIn( duration );\n\t\n\t\t\t\tif( warp ) {\n\t\n\t\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\t\n\t\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\t\n\t\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\t\n\t\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\t\n\t\t\t},\n\t\n\t\t\tstopFading: function() {\n\t\n\t\t\t\tvar weightInterpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( weightInterpolant !== null ) {\n\t\n\t\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Time Scale Control\n\t\n\t\t\t// set the weight stopping any scheduled warping\n\t\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t\t// method does *not* change .paused, because it would be confusing\n\t\t\tsetEffectiveTimeScale: function( timeScale ) {\n\t\n\t\t\t\tthis.timeScale = timeScale;\n\t\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\t// return the time scale considering warping and .paused\n\t\t\tgetEffectiveTimeScale: function() {\n\t\n\t\t\t\treturn this._effectiveTimeScale;\n\t\n\t\t\t},\n\t\n\t\t\tsetDuration: function( duration ) {\n\t\n\t\t\t\tthis.timeScale = this._clip.duration / duration;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\tsyncWith: function( action ) {\n\t\n\t\t\t\tthis.time = action.time;\n\t\t\t\tthis.timeScale = action.timeScale;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\thalt: function( duration ) {\n\t\n\t\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\t\n\t\t\t},\n\t\n\t\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\t\n\t\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\t\n\t\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\t\ttimes[ 0 ] = now;\n\t\t\t\ttimes[ 1 ] = now + duration;\n\t\n\t\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstopWarping: function() {\n\t\n\t\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\tif ( timeScaleInterpolant !== null ) {\n\t\n\t\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Object Accessors\n\t\n\t\t\tgetMixer: function() {\n\t\n\t\t\t\treturn this._mixer;\n\t\n\t\t\t},\n\t\n\t\t\tgetClip: function() {\n\t\n\t\t\t\treturn this._clip;\n\t\n\t\t\t},\n\t\n\t\t\tgetRoot: function() {\n\t\n\t\t\t\treturn this._localRoot || this._mixer._root;\n\t\n\t\t\t},\n\t\n\t\t\t// Interna\n\t\n\t\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t\t// called by the mixer\n\t\n\t\t\t\tvar startTime = this._startTime;\n\t\n\t\t\t\tif ( startTime !== null ) {\n\t\n\t\t\t\t\t// check for scheduled start of action\n\t\n\t\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\t\n\t\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// start\n\t\n\t\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// apply time scale and advance time\n\t\n\t\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\t\tvar clipTime = this._updateTime( deltaTime );\n\t\n\t\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t\t// an effective weight of 0\n\t\n\t\t\t\tvar weight = this._updateWeight( time );\n\t\n\t\t\t\tif ( weight > 0 ) {\n\t\n\t\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\t\tvar propertyMixers = this._propertyBindings;\n\t\n\t\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_updateWeight: function( time ) {\n\t\n\t\t\t\tvar weight = 0;\n\t\n\t\t\t\tif ( this.enabled ) {\n\t\n\t\t\t\t\tweight = this.weight;\n\t\t\t\t\tvar interpolant = this._weightInterpolant;\n\t\n\t\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\t\tweight *= interpolantValue;\n\t\n\t\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\t\tthis.stopFading();\n\t\n\t\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\t\n\t\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\t\tthis.enabled = false;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._effectiveWeight = weight;\n\t\t\t\treturn weight;\n\t\n\t\t\t},\n\t\n\t\t\t_updateTimeScale: function( time ) {\n\t\n\t\t\t\tvar timeScale = 0;\n\t\n\t\t\t\tif ( ! this.paused ) {\n\t\n\t\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\t\ttimeScale *= interpolantValue;\n\t\n\t\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\t\tthis.stopWarping();\n\t\n\t\t\t\t\t\t\tif ( timeScale === 0 ) {\n\t\n\t\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\t\tthis.paused = true;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\t\treturn timeScale;\n\t\n\t\t\t},\n\t\n\t\t\t_updateTime: function( deltaTime ) {\n\t\n\t\t\t\tvar time = this.time + deltaTime;\n\t\n\t\t\t\tif ( deltaTime === 0 ) return time;\n\t\n\t\t\t\tvar duration = this._clip.duration,\n\t\n\t\t\t\t\tloop = this.loop,\n\t\t\t\t\tloopCount = this._loopCount;\n\t\n\t\t\t\tif ( loop === LoopOnce ) {\n\t\n\t\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t\t// just started\n\t\n\t\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\t\tthis._setEndings( true, true, false );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\thandle_stop: {\n\t\n\t\t\t\t\t\tif ( time >= duration ) {\n\t\n\t\t\t\t\t\t\ttime = duration;\n\t\n\t\t\t\t\t\t} else if ( time < 0 ) {\n\t\n\t\t\t\t\t\t\ttime = 0;\n\t\n\t\t\t\t\t\t} else break handle_stop;\n\t\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else { // repetitive Repeat or PingPong\n\t\n\t\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\t\n\t\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t\t// just started\n\t\n\t\t\t\t\t\tif ( deltaTime >= 0 ) {\n\t\n\t\t\t\t\t\t\tloopCount = 0;\n\t\n\t\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t\t// so leave loopCount at -1\n\t\n\t\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t\t// wrap around\n\t\n\t\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\t\ttime -= duration * loopDelta;\n\t\n\t\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\t\n\t\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\t\n\t\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\t\n\t\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\t\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// keep running\n\t\n\t\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t\t// entering the last round\n\t\n\t\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tthis._loopCount = loopCount;\n\t\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t\t// invert time for the \"pong round\"\n\t\n\t\t\t\t\t\tthis.time = time;\n\t\t\t\t\t\treturn duration - time;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.time = time;\n\t\t\t\treturn time;\n\t\n\t\t\t},\n\t\n\t\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\t\n\t\t\t\tvar settings = this._interpolantSettings;\n\t\n\t\t\t\tif ( pingPong ) {\n\t\n\t\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\t\n\t\t\t\t\tif ( atStart ) {\n\t\n\t\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( atEnd ) {\n\t\n\t\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\t\n\t\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\t\tinterpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\t\tthis._weightInterpolant = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * Player for AnimationClips.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction AnimationMixer( root ) {\n\t\n\t\t\tthis._root = root;\n\t\t\tthis._initMemoryManager();\n\t\t\tthis._accuIndex = 0;\n\t\n\t\t\tthis.time = 0;\n\t\n\t\t\tthis.timeScale = 1.0;\n\t\n\t\t}\n\t\n\t\tObject.assign( AnimationMixer.prototype, EventDispatcher.prototype, {\n\t\n\t\t\t// return an action for a clip optionally using a custom root target\n\t\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t\t// previously unknown clip/root combination is specified)\n\t\t\tclipAction: function( clip, optionalRoot ) {\n\t\n\t\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\t\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\t\tprototypeAction = null;\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\tvar existingAction =\n\t\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\t\n\t\t\t\t\tif ( existingAction !== undefined ) {\n\t\n\t\t\t\t\t\treturn existingAction;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t\t// the bindings again but can just copy\n\t\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\t\n\t\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\t\tif ( clipObject === null )\n\t\t\t\t\t\tclipObject = prototypeAction._clip;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// clip must be known when specified via string\n\t\t\t\tif ( clipObject === null ) return null;\n\t\n\t\t\t\t// allocate all resources required to run it\n\t\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\t\n\t\t\t\tthis._bindAction( newAction, prototypeAction );\n\t\n\t\t\t\t// and make the action known to the memory manager\n\t\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\t\n\t\t\t\treturn newAction;\n\t\n\t\t\t},\n\t\n\t\t\t// get an existing action\n\t\t\texistingAction: function( clip, optionalRoot ) {\n\t\n\t\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\t\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\t// deactivates all previously scheduled actions\n\t\t\tstopAllAction: function() {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\t\tthis._nActiveActions = 0;\n\t\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\t\tactions[ i ].reset();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].useCount = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// advance the time and update apply the animation\n\t\t\tupdate: function( deltaTime ) {\n\t\n\t\t\t\tdeltaTime *= this.timeScale;\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tnActions = this._nActiveActions,\n\t\n\t\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\t\n\t\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\t\n\t\t\t\t// run active actions\n\t\n\t\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\t\tvar action = actions[ i ];\n\t\n\t\t\t\t\tif ( action.enabled ) {\n\t\n\t\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update scene graph\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].apply( accuIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// return this mixer's root target object\n\t\t\tgetRoot: function() {\n\t\n\t\t\t\treturn this._root;\n\t\n\t\t\t},\n\t\n\t\t\t// free all resources specific to a particular clip\n\t\t\tuncacheClip: function( clip ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t\t// just throw away\n\t\n\t\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\t\n\t\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar action = actionsToRemove[ i ];\n\t\n\t\t\t\t\t\tthis._deactivateAction( action );\n\t\n\t\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\t\n\t\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\t\tactions.pop();\n\t\n\t\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// free all resources specific to a particular root target object\n\t\t\tuncacheRoot: function( root ) {\n\t\n\t\t\t\tvar rootUuid = root.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip;\n\t\n\t\t\t\tfor ( var clipUuid in actionsByClip ) {\n\t\n\t\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\t\n\t\t\t\t\tif ( action !== undefined ) {\n\t\n\t\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( bindingByName !== undefined ) {\n\t\n\t\t\t\t\tfor ( var trackName in bindingByName ) {\n\t\n\t\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// remove a targeted clip from the cache\n\t\t\tuncacheAction: function( clip, optionalRoot ) {\n\t\n\t\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\t\n\t\t\t\tif ( action !== null ) {\n\t\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t// Implementation details:\n\t\n\t\tObject.assign( AnimationMixer.prototype, {\n\t\n\t\t\t_bindAction: function( action, prototypeAction ) {\n\t\n\t\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( bindingsByName === undefined ) {\n\t\n\t\t\t\t\tbindingsByName = {};\n\t\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\t\n\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbinding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\t\t// existing binding, make sure the cache knows\n\t\n\t\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\t\n\t\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\t\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_activateAction: function( action ) {\n\t\n\t\t\t\tif ( ! this._isActiveAction( action ) ) {\n\t\n\t\t\t\t\tif ( action._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t\t// appears to be still using it -> rebind\n\t\n\t\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\t\n\t\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t\t// increment reference counts / sort out state\n\t\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\t\n\t\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\t\tbinding.saveOriginalState();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._lendAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_deactivateAction: function( action ) {\n\t\n\t\t\t\tif ( this._isActiveAction( action ) ) {\n\t\n\t\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\t\n\t\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\t\tthis._takeBackBinding( binding );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._takeBackAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// Memory manager\n\t\n\t\t\t_initMemoryManager: function() {\n\t\n\t\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\t\tthis._nActiveActions = 0;\n\t\n\t\t\t\tthis._actionsByClip = {};\n\t\t\t\t// inside:\n\t\t\t\t// {\n\t\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t\t// }\n\t\n\t\n\t\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\t\n\t\n\t\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\t\tthis._nActiveControlInterpolants = 0;\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tthis.stats = {\n\t\n\t\t\t\t\tactions: {\n\t\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t\t},\n\t\t\t\t\tbindings: {\n\t\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t\t},\n\t\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t},\n\t\n\t\t\t// Memory management for AnimationAction objects\n\t\n\t\t\t_isActiveAction: function( action ) {\n\t\n\t\t\t\tvar index = action._cacheIndex;\n\t\t\t\treturn index !== null && index < this._nActiveActions;\n\t\n\t\t\t},\n\t\n\t\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip === undefined ) {\n\t\n\t\t\t\t\tactionsForClip = {\n\t\n\t\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\t\tactionByRoot: {}\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t\taction._byClipCacheIndex = 0;\n\t\n\t\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\t\n\t\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\t\tknownActions.push( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t\taction._cacheIndex = actions.length;\n\t\t\t\tactions.push( action );\n\t\n\t\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveAction: function( action ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\t\tcacheIndex = action._cacheIndex;\n\t\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\t\n\t\t\t\taction._cacheIndex = null;\n\t\n\t\n\t\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\t\n\t\t\t\t\tlastKnownAction =\n\t\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\t\n\t\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\t\n\t\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\t\tknownActionsForClip.pop();\n\t\n\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\n\t\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\t\n\t\t\t\tdelete actionByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( knownActionsForClip.length === 0 ) {\n\t\n\t\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveBindingsForAction: function( action ) {\n\t\n\t\t\t\tvar bindings = action._propertyBindings;\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\t\n\t\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_lendAction: function( action ) {\n\t\n\t\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t\t// [  active actions >| inactive actions ]\n\t\t\t\t//                 s        a\n\t\t\t\t//                  <-swap->\n\t\t\t\t//                 a        s\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\t\n\t\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\t\n\t\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\t\tactions[ lastActiveIndex ] = action;\n\t\n\t\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackAction: function( action ) {\n\t\n\t\t\t\t// [  active actions  | inactive actions ]\n\t\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t\t//        a        s\n\t\t\t\t//         <-swap->\n\t\t\t\t//        s        a\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\t\n\t\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\t\n\t\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\t\tactions[ firstInactiveIndex ] = action;\n\t\n\t\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\t\tactions[ prevIndex ] = lastActiveAction;\n\t\n\t\t\t},\n\t\n\t\t\t// Memory management for PropertyMixer objects\n\t\n\t\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\t\n\t\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\t\tbindings = this._bindings;\n\t\n\t\t\t\tif ( bindingByName === undefined ) {\n\t\n\t\t\t\t\tbindingByName = {};\n\t\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tbindingByName[ trackName ] = binding;\n\t\n\t\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\t\tbindings.push( binding );\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveBinding: function( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tpropBinding = binding.binding,\n\t\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\t\ttrackName = propBinding.path,\n\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\t\tcacheIndex = binding._cacheIndex;\n\t\n\t\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\t\tbindings.pop();\n\t\n\t\t\t\tdelete bindingByName[ trackName ];\n\t\n\t\t\t\tremove_empty_map: {\n\t\n\t\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\t\n\t\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_lendBinding: function( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\t\n\t\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\t\n\t\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\t\tbindings[ lastActiveIndex ] = binding;\n\t\n\t\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackBinding: function( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\t\n\t\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\t\n\t\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\t\tbindings[ firstInactiveIndex ] = binding;\n\t\n\t\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// Memory management of Interpolants for weight and time scale\n\t\n\t\t\t_lendControlInterpolant: function() {\n\t\n\t\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\t\n\t\t\t\tif ( interpolant === undefined ) {\n\t\n\t\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\t\n\t\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn interpolant;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackControlInterpolant: function( interpolant ) {\n\t\n\t\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\t\n\t\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\t\n\t\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\t\n\t\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\t\n\t\t\t},\n\t\n\t\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Uniform( value ) {\n\t\n\t\t\tif ( typeof value === 'string' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\t\tvalue = arguments[ 1 ];\n\t\n\t\t\t}\n\t\n\t\t\tthis.value = value;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedBufferGeometry() {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'InstancedBufferGeometry';\n\t\t\tthis.maxInstancedCount = undefined;\n\t\n\t\t}\n\t\n\t\tInstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tInstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;\n\t\n\t\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\t\n\t\tInstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {\n\t\n\t\t\tthis.groups.push( {\n\t\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex\n\t\n\t\t\t} );\n\t\n\t\t};\n\t\n\t\tInstancedBufferGeometry.prototype.copy = function ( source ) {\n\t\n\t\t\tvar index = source.index;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = source.attributes;\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar groups = source.groups;\n\t\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.data = interleavedBuffer;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.offset = offset;\n\t\n\t\t\tthis.normalized = normalized === true;\n\t\n\t\t}\n\t\n\t\n\t\tInterleavedBufferAttribute.prototype = {\n\t\n\t\t\tconstructor: InterleavedBufferAttribute,\n\t\n\t\t\tisInterleavedBufferAttribute: true,\n\t\n\t\t\tget count() {\n\t\n\t\t\t\treturn this.data.count;\n\t\n\t\t\t},\n\t\n\t\t\tget array() {\n\t\n\t\t\t\treturn this.data.array;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( index, x ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( index, y ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( index, z ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( index, w ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetX: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\t\n\t\t\t},\n\t\n\t\t\tgetY: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\t\n\t\t\t},\n\t\n\t\t\tgetZ: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\t\n\t\t\t},\n\t\n\t\t\tgetW: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\t\tthis.data.array[ index + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\t\tthis.data.array[ index + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InterleavedBuffer( array, stride ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.array = array;\n\t\t\tthis.stride = stride;\n\t\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\t\n\t\t\tthis.dynamic = false;\n\t\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\t\tthis.version = 0;\n\t\n\t\t}\n\t\n\t\tInterleavedBuffer.prototype = {\n\t\n\t\t\tconstructor: InterleavedBuffer,\n\t\n\t\t\tisInterleavedBuffer: true,\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t},\n\t\n\t\t\tsetArray: function ( array ) {\n\t\n\t\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\t\tthis.array = array;\n\t\n\t\t\t},\n\t\n\t\t\tsetDynamic: function ( value ) {\n\t\n\t\t\t\tthis.dynamic = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\t\tthis.count = source.count;\n\t\t\t\tthis.stride = source.stride;\n\t\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\t\tindex1 *= this.stride;\n\t\t\t\tindex2 *= attribute.stride;\n\t\n\t\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.array.set( value, offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\t\n\t\t\tInterleavedBuffer.call( this, array, stride );\n\t\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t\t}\n\t\n\t\tInstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );\n\t\tInstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;\n\t\n\t\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\t\n\t\tInstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\t\n\t\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\t\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\t\n\t\t\tBufferAttribute.call( this, array, itemSize );\n\t\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t\t}\n\t\n\t\tInstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tInstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;\n\t\n\t\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\t\n\t\tInstancedBufferAttribute.prototype.copy = function ( source ) {\n\t\n\t\t\tBufferAttribute.prototype.copy.call( this, source );\n\t\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author bhouston / http://clara.io/\n\t\t * @author stephomi / http://stephaneginier.com/\n\t\t */\n\t\n\t\tfunction Raycaster( origin, direction, near, far ) {\n\t\n\t\t\tthis.ray = new Ray( origin, direction );\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\tthis.near = near || 0;\n\t\t\tthis.far = far || Infinity;\n\t\n\t\t\tthis.params = {\n\t\t\t\tMesh: {},\n\t\t\t\tLine: {},\n\t\t\t\tLOD: {},\n\t\t\t\tPoints: { threshold: 1 },\n\t\t\t\tSprite: {}\n\t\t\t};\n\t\n\t\t\tObject.defineProperties( this.params, {\n\t\t\t\tPointCloud: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\t\treturn this.Points;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tfunction ascSort( a, b ) {\n\t\n\t\t\treturn a.distance - b.distance;\n\t\n\t\t}\n\t\n\t\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tobject.raycast( raycaster, intersects );\n\t\n\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tRaycaster.prototype = {\n\t\n\t\t\tconstructor: Raycaster,\n\t\n\t\t\tlinePrecision: 1,\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\t\tthis.ray.set( origin, direction );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCamera: function ( coords, camera ) {\n\t\n\t\t\t\tif ( (camera && camera.isPerspectiveCamera) ) {\n\t\n\t\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\n\t\t\t\t} else if ( (camera && camera.isOrthographicCamera) ) {\n\t\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tintersectObject: function ( object, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tintersectObject( object, this, intersects, recursive );\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t},\n\t\n\t\t\tintersectObjects: function ( objects, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tif ( Array.isArray( objects ) === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\t\treturn intersects;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Clock( autoStart ) {\n\t\n\t\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\t\n\t\t\tthis.startTime = 0;\n\t\t\tthis.oldTime = 0;\n\t\t\tthis.elapsedTime = 0;\n\t\n\t\t\tthis.running = false;\n\t\n\t\t}\n\t\n\t\tClock.prototype = {\n\t\n\t\t\tconstructor: Clock,\n\t\n\t\t\tstart: function () {\n\t\n\t\t\t\tthis.startTime = ( performance || Date ).now();\n\t\n\t\t\t\tthis.oldTime = this.startTime;\n\t\t\t\tthis.elapsedTime = 0;\n\t\t\t\tthis.running = true;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function () {\n\t\n\t\t\t\tthis.getElapsedTime();\n\t\t\t\tthis.running = false;\n\t\n\t\t\t},\n\t\n\t\t\tgetElapsedTime: function () {\n\t\n\t\t\t\tthis.getDelta();\n\t\t\t\treturn this.elapsedTime;\n\t\n\t\t\t},\n\t\n\t\t\tgetDelta: function () {\n\t\n\t\t\t\tvar diff = 0;\n\t\n\t\t\t\tif ( this.autoStart && ! this.running ) {\n\t\n\t\t\t\t\tthis.start();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.running ) {\n\t\n\t\t\t\t\tvar newTime = ( performance || Date ).now();\n\t\n\t\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\t\tthis.oldTime = newTime;\n\t\n\t\t\t\t\tthis.elapsedTime += diff;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn diff;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Spline from Tween.js, slightly optimized (and trashed)\n\t\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t\t *\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Spline( points ) {\n\t\n\t\t\tthis.points = points;\n\t\n\t\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\t\tpoint, intPoint, weight, w2, w3,\n\t\t\tpa, pb, pc, pd;\n\t\n\t\t\tthis.initFromArray = function ( a ) {\n\t\n\t\t\t\tthis.points = [];\n\t\n\t\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\t\n\t\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPoint = function ( k ) {\n\t\n\t\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\t\n\t\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\t\tc[ 1 ] = intPoint;\n\t\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\t\n\t\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\t\tpd = this.points[ c[ 3 ] ];\n\t\n\t\t\t\tw2 = weight * weight;\n\t\t\t\tw3 = weight * w2;\n\t\n\t\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\t\n\t\t\t\treturn v3;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getControlPointsArray = function () {\n\t\n\t\t\t\tvar i, p, l = this.points.length,\n\t\t\t\t\tcoords = [];\n\t\n\t\t\t\tfor ( i = 0; i < l; i ++ ) {\n\t\n\t\t\t\t\tp = this.points[ i ];\n\t\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn coords;\n\t\n\t\t\t};\n\t\n\t\t\t// approximate length by summing linear segments\n\t\n\t\t\tthis.getLength = function ( nSubDivisions ) {\n\t\n\t\t\t\tvar i, index, nSamples, position,\n\t\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\t\toldPosition = new Vector3(),\n\t\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\t\tchunkLengths = [],\n\t\t\t\t\ttotalLength = 0;\n\t\n\t\t\t\t// first point has 0 length\n\t\n\t\t\t\tchunkLengths[ 0 ] = 0;\n\t\n\t\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\t\n\t\t\t\tnSamples = this.points.length * nSubDivisions;\n\t\n\t\t\t\toldPosition.copy( this.points[ 0 ] );\n\t\n\t\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\t\n\t\t\t\t\tindex = i / nSamples;\n\t\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\ttmpVec.copy( position );\n\t\n\t\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\t\n\t\t\t\t\toldPosition.copy( position );\n\t\n\t\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\t\tintPoint = Math.floor( point );\n\t\n\t\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\t\n\t\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\t\toldIntPoint = intPoint;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// last point ends with total length\n\t\n\t\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\t\n\t\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\t\n\t\t\t};\n\t\n\t\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\t\n\t\t\t\tvar i, j,\n\t\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\t\trealDistance,\n\t\t\t\t\tsampling, position,\n\t\t\t\t\tnewpoints = [],\n\t\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\t\tsl = this.getLength();\n\t\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\t\n\t\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\t\n\t\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\t\n\t\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\t\n\t\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\t\n\t\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\t\n\t\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\t\n\t\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\t\n\t\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.points = newpoints;\n\t\n\t\t\t};\n\t\n\t\t\t// Catmull-Rom\n\t\n\t\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\t\n\t\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\t\n\t\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t\t *\n\t\t * The poles (phi) are at the positive and negative y axis.\n\t\t * The equator starts at positive z.\n\t\t */\n\t\n\t\tfunction Spherical( radius, phi, theta ) {\n\t\n\t\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t\tSpherical.prototype = {\n\t\n\t\t\tconstructor: Spherical,\n\t\n\t\t\tset: function ( radius, phi, theta ) {\n\t\n\t\t\t\tthis.radius = radius;\n\t\t\t\tthis.phi = phi;\n\t\t\t\tthis.theta = theta;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( other ) {\n\t\n\t\t\t\tthis.radius = other.radius;\n\t\t\t\tthis.phi = other.phi;\n\t\t\t\tthis.theta = other.theta;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\t\tmakeSafe: function() {\n\t\n\t\t\t\tvar EPS = 0.000001;\n\t\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromVector3: function( vec3 ) {\n\t\n\t\t\t\tthis.radius = vec3.length();\n\t\n\t\t\t\tif ( this.radius === 0 ) {\n\t\n\t\t\t\t\tthis.theta = 0;\n\t\t\t\t\tthis.phi = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t};\n\t\n\t\t/**\r\n\t\t * @author alteredq / http://alteredqualia.com/\r\n\t\t */\r\n\t\r\n\t\tfunction MorphBlendMesh( geometry, material ) {\n\t\r\n\t\t\tMesh.call( this, geometry, material );\r\n\t\r\n\t\t\tthis.animationsMap = {};\r\n\t\t\tthis.animationsList = [];\r\n\t\r\n\t\t\t// prepare default animation\r\n\t\t\t// (all frames played together in 1 second)\r\n\t\r\n\t\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\t\r\n\t\t\tvar name = \"__default\";\r\n\t\r\n\t\t\tvar startFrame = 0;\r\n\t\t\tvar endFrame = numFrames - 1;\r\n\t\r\n\t\t\tvar fps = numFrames / 1;\r\n\t\r\n\t\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\t\tthis.setAnimationWeight( name, 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tMorphBlendMesh.prototype = Object.create( Mesh.prototype );\r\n\t\tMorphBlendMesh.prototype.constructor = MorphBlendMesh;\r\n\t\r\n\t\tMorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\t\r\n\t\t\tvar animation = {\r\n\t\r\n\t\t\t\tstart: start,\r\n\t\t\t\tend: end,\r\n\t\r\n\t\t\t\tlength: end - start + 1,\r\n\t\r\n\t\t\t\tfps: fps,\r\n\t\t\t\tduration: ( end - start ) / fps,\r\n\t\r\n\t\t\t\tlastFrame: 0,\r\n\t\t\t\tcurrentFrame: 0,\r\n\t\r\n\t\t\t\tactive: false,\r\n\t\r\n\t\t\t\ttime: 0,\r\n\t\t\t\tdirection: 1,\r\n\t\t\t\tweight: 1,\r\n\t\r\n\t\t\t\tdirectionBackwards: false,\r\n\t\t\t\tmirroredLoop: false\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tthis.animationsMap[ name ] = animation;\r\n\t\t\tthis.animationsList.push( animation );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\t\r\n\t\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\t\r\n\t\t\tvar firstAnimation, frameRanges = {};\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\r\n\t\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\t\tvar chunks = morph.name.match( pattern );\r\n\t\r\n\t\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\t\r\n\t\t\t\t\tvar name = chunks[ 1 ];\r\n\t\r\n\t\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\t\tvar range = frameRanges[ name ];\r\n\t\r\n\t\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\t\tif ( i > range.end ) range.end = i;\r\n\t\r\n\t\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var name in frameRanges ) {\r\n\t\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\t\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.firstAnimation = firstAnimation;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.direction = 1;\r\n\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.direction = - 1;\r\n\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.fps = fps;\r\n\t\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.duration = duration;\r\n\t\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.weight = weight;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.time = time;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\t\r\n\t\t\tvar time = 0;\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\ttime = animation.time;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn time;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\t\r\n\t\t\tvar duration = - 1;\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tduration = animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn duration;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.time = 0;\r\n\t\t\t\tanimation.active = true;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.active = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.update = function ( delta ) {\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar animation = this.animationsList[ i ];\r\n\t\r\n\t\t\t\tif ( ! animation.active ) continue;\r\n\t\r\n\t\t\t\tvar frameTime = animation.duration / animation.length;\r\n\t\r\n\t\t\t\tanimation.time += animation.direction * delta;\r\n\t\r\n\t\t\t\tif ( animation.mirroredLoop ) {\r\n\t\r\n\t\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\tanimation.direction *= - 1;\r\n\t\r\n\t\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\t\r\n\t\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\t\r\n\t\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\t\tvar weight = animation.weight;\r\n\t\r\n\t\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\t\tanimation.currentFrame = keyframe;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\t\r\n\t\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\t\r\n\t\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction ImmediateRenderObject( material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.material = material;\n\t\t\tthis.render = function ( renderCallback ) {};\n\t\n\t\t}\n\t\n\t\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\t\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\t\n\t\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\t\n\t\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t\t//\n\t\n\t\t\tvar nNormals = 0;\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\t\n\t\t\t\tnNormals = objGeometry.faces.length * 3;\n\t\n\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\t\n\t\t\t\tnNormals = objGeometry.attributes.normal.count;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t\t//\n\t\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\t\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\t\n\t\tVertexNormalsHelper.prototype.update = ( function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar normalMatrix = new Matrix3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\t\n\t\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\t\n\t\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\t\n\t\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\tvar objPos = objGeometry.attributes.position;\n\t\n\t\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\t\n\t\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\t\n\t\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\t\n\t\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction SpotLightHelper( light ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = [\n\t\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t\t0, 0, 0,   0, - 1,   1\n\t\t\t];\n\t\n\t\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\t\n\t\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\t\n\t\t\t\tpositions.push(\n\t\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { fog: false } );\n\t\n\t\t\tthis.cone = new LineSegments( geometry, material );\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\t\n\t\tSpotLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.cone.geometry.dispose();\n\t\t\tthis.cone.material.dispose();\n\t\n\t\t};\n\t\n\t\tSpotLightHelper.prototype.update = function () {\n\t\n\t\t\tvar vector = new Vector3();\n\t\t\tvar vector2 = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\t\n\t\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\t\n\t\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\n\t\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\t\n\t\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author Sean Griffin / http://twitter.com/sgrif\n\t\t * @author Michael Guerrero / http://realitymeltdown.com\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction SkeletonHelper( object ) {\n\t\n\t\t\tthis.bones = this.getBoneList( object );\n\t\n\t\t\tvar geometry = new Geometry();\n\t\n\t\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\t\n\t\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\t\tgeometry.colors.push( new Color( 0, 0, 1 ) );\n\t\t\t\t\tgeometry.colors.push( new Color( 0, 1, 0 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.dynamic = true;\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t\tthis.root = object;\n\t\n\t\t\tthis.matrix = object.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\n\t\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\t\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\t\n\t\tSkeletonHelper.prototype.getBoneList = function( object ) {\n\t\n\t\t\tvar boneList = [];\n\t\n\t\t\tif ( (object && object.isBone) ) {\n\t\n\t\t\t\tboneList.push( object );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\t\n\t\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn boneList;\n\t\n\t\t};\n\t\n\t\tSkeletonHelper.prototype.update = function () {\n\t\n\t\t\tvar geometry = this.geometry;\n\t\n\t\t\tvar matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );\n\t\n\t\t\tvar boneMatrix = new Matrix4();\n\t\n\t\t\tvar j = 0;\n\t\n\t\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\t\n\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\t\tj += 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction PointLightHelper( light, sphereSize ) {\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\tMesh.call( this, geometry, material );\n\t\n\t\t\tthis.matrix = this.light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\t/*\n\t\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\t\n\t\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\t\n\t\t\tvar d = light.distance;\n\t\n\t\t\tif ( d === 0.0 ) {\n\t\n\t\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t\t}\n\t\n\t\t\tthis.add( this.lightDistance );\n\t\t\t*/\n\t\n\t\t}\n\t\n\t\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\t\tPointLightHelper.prototype.constructor = PointLightHelper;\n\t\n\t\tPointLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\n\t\t};\n\t\n\t\tPointLightHelper.prototype.update = function () {\n\t\n\t\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t/*\n\t\t\tvar d = this.light.distance;\n\t\n\t\t\tif ( d === 0.0 ) {\n\t\n\t\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.lightDistance.visible = true;\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t\t}\n\t\t\t*/\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction HemisphereLightHelper( light, sphereSize ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.colors = [ new Color(), new Color() ];\n\t\n\t\t\tvar geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\t\n\t\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\t\n\t\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\t\n\t\t\t}\n\t\n\t\t\tvar material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );\n\t\n\t\t\tthis.lightSphere = new Mesh( geometry, material );\n\t\t\tthis.add( this.lightSphere );\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\t\n\t\tHemisphereLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.lightSphere.geometry.dispose();\n\t\t\tthis.lightSphere.material.dispose();\n\t\n\t\t};\n\t\n\t\tHemisphereLightHelper.prototype.update = function () {\n\t\n\t\t\tvar vector = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction GridHelper( size, divisions, color1, color2 ) {\n\t\n\t\t\tdivisions = divisions || 1;\n\t\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\t\n\t\t\tvar center = divisions / 2;\n\t\t\tvar step = ( size * 2 ) / divisions;\n\t\t\tvar vertices = [], colors = [];\n\t\n\t\t\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\t\n\t\t\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\t\t\tvertices.push( k, 0, - size, k, 0, size );\n\t\n\t\t\t\tvar color = i === center ? color1 : color2;\n\t\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\n\t\t\t}\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t}\n\t\n\t\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\t\tGridHelper.prototype.constructor = GridHelper;\n\t\n\t\tGridHelper.prototype.setColors = function () {\n\t\n\t\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\t\n\t\t\t// FaceNormalsHelper only supports THREE.Geometry\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\t\n\t\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t\t//\n\t\n\t\t\tvar nNormals = 0;\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\t\n\t\t\t\tnNormals = objGeometry.faces.length;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t\t//\n\t\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\t\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\t\n\t\tFaceNormalsHelper.prototype.update = ( function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar normalMatrix = new Matrix3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\tvar idx = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t\t.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction DirectionalLightHelper( light, size ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tif ( size === undefined ) size = 1;\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( [\n\t\t\t\t- size,   size, 0,\n\t\t\t\t  size,   size, 0,\n\t\t\t\t  size, - size, 0,\n\t\t\t\t- size, - size, 0,\n\t\t\t\t- size,   size, 0\n\t\t\t], 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { fog: false } );\n\t\n\t\t\tthis.add( new Line( geometry, material ) );\n\t\n\t\t\tgeometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\t\n\t\t\tthis.add( new Line( geometry, material ));\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\t\n\t\tDirectionalLightHelper.prototype.dispose = function () {\n\t\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\t\tlightPlane.geometry.dispose();\n\t\t\tlightPlane.material.dispose();\n\t\t\ttargetLine.geometry.dispose();\n\t\t\ttargetLine.material.dispose();\n\t\n\t\t};\n\t\n\t\tDirectionalLightHelper.prototype.update = function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar v3 = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\t\tv3.subVectors( v2, v1 );\n\t\n\t\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\t\t\tlightPlane.lookAt( v3 );\n\t\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t\ttargetLine.lookAt( v3 );\n\t\t\t\ttargetLine.scale.z = v3.length();\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t *\t- shows frustum, line of sight and up of the camera\n\t\t *\t- suitable for fast updates\n\t\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t\t */\n\t\n\t\tfunction CameraHelper( camera ) {\n\t\n\t\t\tvar geometry = new Geometry();\n\t\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\t\n\t\t\tvar pointMap = {};\n\t\n\t\t\t// colors\n\t\n\t\t\tvar hexFrustum = 0xffaa00;\n\t\t\tvar hexCone = 0xff0000;\n\t\t\tvar hexUp = 0x00aaff;\n\t\t\tvar hexTarget = 0xffffff;\n\t\t\tvar hexCross = 0x333333;\n\t\n\t\t\t// near\n\t\n\t\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\t\n\t\t\t// far\n\t\n\t\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\t\n\t\t\t// sides\n\t\n\t\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\t\n\t\t\t// cone\n\t\n\t\t\taddLine( \"p\", \"n1\", hexCone );\n\t\t\taddLine( \"p\", \"n2\", hexCone );\n\t\t\taddLine( \"p\", \"n3\", hexCone );\n\t\t\taddLine( \"p\", \"n4\", hexCone );\n\t\n\t\t\t// up\n\t\n\t\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\t\taddLine( \"u3\", \"u1\", hexUp );\n\t\n\t\t\t// target\n\t\n\t\t\taddLine( \"c\", \"t\", hexTarget );\n\t\t\taddLine( \"p\", \"c\", hexCross );\n\t\n\t\t\t// cross\n\t\n\t\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\t\n\t\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\t\n\t\t\tfunction addLine( a, b, hex ) {\n\t\n\t\t\t\taddPoint( a, hex );\n\t\t\t\taddPoint( b, hex );\n\t\n\t\t\t}\n\t\n\t\t\tfunction addPoint( id, hex ) {\n\t\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.colors.push( new Color( hex ) );\n\t\n\t\t\t\tif ( pointMap[ id ] === undefined ) {\n\t\n\t\t\t\t\tpointMap[ id ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\t\n\t\t\t}\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t\tthis.camera = camera;\n\t\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\t\n\t\t\tthis.matrix = camera.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.pointMap = pointMap;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\t\tCameraHelper.prototype.constructor = CameraHelper;\n\t\n\t\tCameraHelper.prototype.update = function () {\n\t\n\t\t\tvar geometry, pointMap;\n\t\n\t\t\tvar vector = new Vector3();\n\t\t\tvar camera = new Camera();\n\t\n\t\t\tfunction setPoint( point, x, y, z ) {\n\t\n\t\t\t\tvector.set( x, y, z ).unproject( camera );\n\t\n\t\t\t\tvar points = pointMap[ point ];\n\t\n\t\t\t\tif ( points !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tgeometry = this.geometry;\n\t\t\t\tpointMap = this.pointMap;\n\t\n\t\t\t\tvar w = 1, h = 1;\n\t\n\t\t\t\t// we need just camera projection matrix\n\t\t\t\t// world matrix must be identity\n\t\n\t\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\t\n\t\t\t\t// center / target\n\t\n\t\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\t\n\t\t\t\t// near\n\t\n\t\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\t\n\t\t\t\t// far\n\t\n\t\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\t\n\t\t\t\t// up\n\t\n\t\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\t\n\t\t\t\t// cross\n\t\n\t\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\t\n\t\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\t\n\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\t// a helper to show the world-axis-aligned bounding box for an object\n\t\n\t\tfunction BoundingBoxHelper( object, hex ) {\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.box = new Box3();\n\t\n\t\t\tMesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );\n\t\n\t\t}\n\t\n\t\tBoundingBoxHelper.prototype = Object.create( Mesh.prototype );\n\t\tBoundingBoxHelper.prototype.constructor = BoundingBoxHelper;\n\t\n\t\tBoundingBoxHelper.prototype.update = function () {\n\t\n\t\t\tthis.box.setFromObject( this.object );\n\t\n\t\t\tthis.box.getSize( this.scale );\n\t\n\t\t\tthis.box.getCenter( this.position );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BoxHelper( object, color ) {\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\n\t\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\t\tvar positions = new Float32Array( 8 * 3 );\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\t\n\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\tthis.update( object );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\t\tBoxHelper.prototype.constructor = BoxHelper;\n\t\n\t\tBoxHelper.prototype.update = ( function () {\n\t\n\t\t\tvar box = new Box3();\n\t\n\t\t\treturn function update( object ) {\n\t\n\t\t\t\tif ( (object && object.isBox3) ) {\n\t\n\t\t\t\t\tbox.copy( object );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tbox.setFromObject( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( box.isEmpty() ) return;\n\t\n\t\t\t\tvar min = box.min;\n\t\t\t\tvar max = box.max;\n\t\n\t\t\t\t/*\n\t\t\t\t  5____4\n\t\t\t\t1/___0/|\n\t\t\t\t| 6__|_7\n\t\t\t\t2/___3/\n\t\n\t\t\t\t0: max.x, max.y, max.z\n\t\t\t\t1: min.x, max.y, max.z\n\t\t\t\t2: min.x, min.y, max.z\n\t\t\t\t3: max.x, min.y, max.z\n\t\t\t\t4: max.x, max.y, min.z\n\t\t\t\t5: min.x, max.y, min.z\n\t\t\t\t6: min.x, min.y, min.z\n\t\t\t\t7: max.x, min.y, min.z\n\t\t\t\t*/\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\t\t\tvar array = position.array;\n\t\n\t\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\tthis.geometry.computeBoundingSphere();\n\t\n\t\t\t};\n\t\n\t\t} )();\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author zz85 / http://github.com/zz85\n\t\t * @author bhouston / http://clara.io\n\t\t *\n\t\t * Creates an arrow for visualizing directions\n\t\t *\n\t\t * Parameters:\n\t\t *  dir - Vector3\n\t\t *  origin - Vector3\n\t\t *  length - Number\n\t\t *  color - color in hex value\n\t\t *  headLength - Number\n\t\t *  headWidth - Number\n\t\t */\n\t\n\t\tvar lineGeometry = new BufferGeometry();\n\t\tlineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\t\n\t\tvar coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\n\t\n\t\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\t\n\t\t\t// dir is assumed to be normalized\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\t\tif ( length === undefined ) length = 1;\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tthis.position.copy( origin );\n\t\n\t\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\t\tthis.line.matrixAutoUpdate = false;\n\t\t\tthis.add( this.line );\n\t\n\t\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\t\tthis.cone.matrixAutoUpdate = false;\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.setDirection( dir );\n\t\t\tthis.setLength( length, headLength, headWidth );\n\t\n\t\t}\n\t\n\t\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\t\tArrowHelper.prototype.constructor = ArrowHelper;\n\t\n\t\tArrowHelper.prototype.setDirection = ( function () {\n\t\n\t\t\tvar axis = new Vector3();\n\t\t\tvar radians;\n\t\n\t\t\treturn function setDirection( dir ) {\n\t\n\t\t\t\t// dir is assumed to be normalized\n\t\n\t\t\t\tif ( dir.y > 0.99999 ) {\n\t\n\t\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\t\n\t\t\t\t} else if ( dir.y < - 0.99999 ) {\n\t\n\t\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\t\n\t\t\t\t\tradians = Math.acos( dir.y );\n\t\n\t\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\t\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\t\tthis.line.updateMatrix();\n\t\n\t\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\t\tthis.cone.position.y = length;\n\t\t\tthis.cone.updateMatrix();\n\t\n\t\t};\n\t\n\t\tArrowHelper.prototype.setColor = function ( color ) {\n\t\n\t\t\tthis.line.material.color.copy( color );\n\t\t\tthis.cone.material.color.copy( color );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author sroucheray / http://sroucheray.org/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AxisHelper( size ) {\n\t\n\t\t\tsize = size || 1;\n\t\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t\t0, 0, 0,  0, 0, size\n\t\t\t] );\n\t\n\t\t\tvar colors = new Float32Array( [\n\t\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t\t] );\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t}\n\t\n\t\tAxisHelper.prototype = Object.create( LineSegments.prototype );\n\t\tAxisHelper.prototype.constructor = AxisHelper;\n\t\n\t\t/**\n\t\t * @author zz85 https://github.com/zz85\n\t\t *\n\t\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t\t *\n\t\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t\t * curve.tension is used for catmullrom which defaults to 0.5\n\t\t */\n\t\n\t\tvar CatmullRomCurve3 = ( function() {\n\t\n\t\t\tvar\n\t\t\t\ttmp = new Vector3(),\n\t\t\t\tpx = new CubicPoly(),\n\t\t\t\tpy = new CubicPoly(),\n\t\t\t\tpz = new CubicPoly();\n\t\n\t\t\t/*\n\t\t\tBased on an optimized c++ solution in\n\t\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t\t - http://ideone.com/NoEbVM\n\t\n\t\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\t\twhich can be placed in CurveUtils.\n\t\t\t*/\n\t\n\t\t\tfunction CubicPoly() {}\n\t\n\t\t\t/*\n\t\t\t * Compute coefficients for a cubic polynomial\n\t\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t\t * such that\n\t\t\t *   p(0) = x0, p(1) = x1\n\t\t\t *  and\n\t\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t\t */\n\t\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\t\n\t\t\t\tthis.c0 = x0;\n\t\t\t\tthis.c1 = t0;\n\t\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\n\t\t\t};\n\t\n\t\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\t\n\t\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\t\n\t\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\t\tt1 *= dt1;\n\t\t\t\tt2 *= dt1;\n\t\n\t\t\t\t// initCubicPoly\n\t\t\t\tthis.init( x1, x2, t1, t2 );\n\t\n\t\t\t};\n\t\n\t\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\t\n\t\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\t\n\t\t\t};\n\t\n\t\t\tCubicPoly.prototype.calc = function( t ) {\n\t\n\t\t\t\tvar t2 = t * t;\n\t\t\t\tvar t3 = t2 * t;\n\t\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\t\n\t\t\t};\n\t\n\t\t\t// Subclass Three.js curve\n\t\t\treturn Curve.create(\n\t\n\t\t\t\tfunction ( p /* array of Vector3 */ ) {\n\t\n\t\t\t\t\tthis.points = p || [];\n\t\t\t\t\tthis.closed = false;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction ( t ) {\n\t\n\t\t\t\t\tvar points = this.points,\n\t\t\t\t\t\tpoint, intPoint, weight, l;\n\t\n\t\t\t\t\tl = points.length;\n\t\n\t\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\t\n\t\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\t\tweight = point - intPoint;\n\t\n\t\t\t\t\tif ( this.closed ) {\n\t\n\t\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\t\n\t\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\t\n\t\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\t\tweight = 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\t\n\t\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\t\n\t\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// extrapolate first point\n\t\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\t\tp0 = tmp;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\t\n\t\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\t\n\t\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// extrapolate last point\n\t\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\t\tp3 = tmp;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\t\n\t\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\t\n\t\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\t\n\t\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\t\n\t\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\t\n\t\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar v = new Vector3(\n\t\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\t\tpz.calc( weight )\n\t\t\t\t\t);\n\t\n\t\t\t\t\treturn v;\n\t\n\t\t\t\t}\n\t\n\t\t\t);\n\t\n\t\t} )();\n\t\n\t\t/**************************************************************\n\t\t *\tClosed Spline 3D curve\n\t\t **************************************************************/\n\t\n\t\n\t\tfunction ClosedSplineCurve3( points ) {\n\t\n\t\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\t\n\t\t\tCatmullRomCurve3.call( this, points );\n\t\t\tthis.type = 'catmullrom';\n\t\t\tthis.closed = true;\n\t\n\t\t}\n\t\n\t\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\t\n\t\t/**************************************************************\n\t\t *\tSpline 3D curve\n\t\t **************************************************************/\n\t\n\t\n\t\tvar SplineCurve3 = Curve.create(\n\t\n\t\t\tfunction ( points /* array of Vector3 */ ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar points = this.points;\n\t\t\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\t\t\tvar intPoint = Math.floor( point );\n\t\t\t\tvar weight = point - intPoint;\n\t\n\t\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\t\tvar point1 = points[ intPoint ];\n\t\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\t\t\tvar interpolate = CurveUtils.interpolate;\n\t\n\t\t\t\treturn new Vector3(\n\t\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tCubic Bezier 3D curve\n\t\t **************************************************************/\n\t\n\t\tvar CubicBezierCurve3 = Curve.create(\n\t\n\t\t\tfunction ( v0, v1, v2, v3 ) {\n\t\n\t\t\t\tthis.v0 = v0;\n\t\t\t\tthis.v1 = v1;\n\t\t\t\tthis.v2 = v2;\n\t\t\t\tthis.v3 = v3;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar b3 = ShapeUtils.b3;\n\t\n\t\t\t\treturn new Vector3(\n\t\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tQuadratic Bezier 3D curve\n\t\t **************************************************************/\n\t\n\t\tvar QuadraticBezierCurve3 = Curve.create(\n\t\n\t\t\tfunction ( v0, v1, v2 ) {\n\t\n\t\t\t\tthis.v0 = v0;\n\t\t\t\tthis.v1 = v1;\n\t\t\t\tthis.v2 = v2;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar b2 = ShapeUtils.b2;\n\t\n\t\t\t\treturn new Vector3(\n\t\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tLine3D\n\t\t **************************************************************/\n\t\n\t\tvar LineCurve3 = Curve.create(\n\t\n\t\t\tfunction ( v1, v2 ) {\n\t\n\t\t\t\tthis.v1 = v1;\n\t\t\t\tthis.v2 = v2;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tif ( t === 1 ) {\n\t\n\t\t\t\t\treturn this.v2.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\t\tvector.multiplyScalar( t );\n\t\t\t\tvector.add( this.v1 );\n\t\n\t\t\t\treturn vector;\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tArc curve\n\t\t **************************************************************/\n\t\n\t\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t}\n\t\n\t\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\t\tArcCurve.prototype.constructor = ArcCurve;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tvar SceneUtils = {\n\t\n\t\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\t\n\t\t\t\tvar group = new Group();\n\t\n\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn group;\n\t\n\t\t\t},\n\t\n\t\t\tdetach: function ( child, parent, scene ) {\n\t\n\t\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\t\tparent.remove( child );\n\t\t\t\tscene.add( child );\n\t\n\t\t\t},\n\t\n\t\t\tattach: function ( child, scene, parent ) {\n\t\n\t\t\t\tvar matrixWorldInverse = new Matrix4();\n\t\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\t\tchild.applyMatrix( matrixWorldInverse );\n\t\n\t\t\t\tscene.remove( child );\n\t\t\t\tparent.add( child );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Face4 ( a, b, c, d, normal, color, materialIndex ) {\n\t\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\t\t}\n\t\n\t\tvar LineStrip = 0;\n\t\n\t\tvar LinePieces = 1;\n\t\n\t\tfunction PointCloud ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\t\treturn new Points( geometry, material );\n\t\t}\n\t\n\t\tfunction ParticleSystem ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\t\treturn new Points( geometry, material );\n\t\t}\n\t\n\t\tfunction PointCloudMaterial ( parameters ) {\n\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\t}\n\t\n\t\tfunction ParticleBasicMaterial ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\t}\n\t\n\t\tfunction ParticleSystemMaterial ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\t}\n\t\n\t\tfunction Vertex ( x, y, z ) {\n\t\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\t\treturn new Vector3( x, y, z );\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction EdgesHelper( object, hex ) {\n\t\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t\t}\n\t\n\t\tfunction WireframeHelper( object, hex ) {\n\t\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t\t}\n\t\n\t\t//\n\t\n\t\tObject.assign( Box2.prototype, {\n\t\t\tcenter: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\t\t},\n\t\t\tempty: function () {\n\t\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\t\treturn this.isEmpty();\n\t\t\t},\n\t\t\tisIntersectionBox: function ( box ) {\n\t\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\t\t},\n\t\t\tsize: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\t\treturn this.getSize( optionalTarget );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Box3.prototype, {\n\t\t\tcenter: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\t\t},\n\t\t\tempty: function () {\n\t\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\t\treturn this.isEmpty();\n\t\t\t},\n\t\t\tisIntersectionBox: function ( box ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\t\t},\n\t\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\t\t},\n\t\t\tsize: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\t\treturn this.getSize( optionalTarget );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Line3.prototype, {\n\t\t\tcenter: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Matrix3.prototype, {\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix3( this );\n\t\t\t},\n\t\t\tmultiplyVector3Array: function ( a ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\t\treturn this.applyToVector3Array( a );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Matrix4.prototype, {\n\t\t\textractPosition: function ( m ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\t\treturn this.copyPosition( m );\n\t\t\t},\n\t\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t\t},\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\t\treturn vector.applyProjection( this );\n\t\t\t},\n\t\t\tmultiplyVector4: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix4( this );\n\t\t\t},\n\t\t\tmultiplyVector3Array: function ( a ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\t\treturn this.applyToVector3Array( a );\n\t\t\t},\n\t\t\trotateAxis: function ( v ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\t\tv.transformDirection( this );\n\t\t\t},\n\t\t\tcrossVector: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix4( this );\n\t\t\t},\n\t\t\ttranslate: function ( v ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t\t},\n\t\t\trotateX: function ( angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t\t},\n\t\t\trotateY: function ( angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t\t},\n\t\t\trotateZ: function ( angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t\t},\n\t\t\trotateByAxis: function ( axis, angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Plane.prototype, {\n\t\t\tisIntersectionLine: function ( line ) {\n\t\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\t\treturn this.intersectsLine( line );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Quaternion.prototype, {\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\t\treturn vector.applyQuaternion( this );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Ray.prototype, {\n\t\t\tisIntersectionBox: function ( box ) {\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\t\t},\n\t\t\tisIntersectionPlane: function ( plane ) {\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\t\treturn this.intersectsPlane( plane );\n\t\t\t},\n\t\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Shape.prototype, {\n\t\t\textrude: function ( options ) {\n\t\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\t\treturn new ExtrudeGeometry( this, options );\n\t\t\t},\n\t\t\tmakeGeometry: function ( options ) {\n\t\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\t\treturn new ShapeGeometry( this, options );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Vector3.prototype, {\n\t\t\tsetEulerFromRotationMatrix: function () {\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t\t},\n\t\t\tsetEulerFromQuaternion: function () {\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t\t},\n\t\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\t\treturn this.setFromMatrixPosition( m );\n\t\t\t},\n\t\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\t\treturn this.setFromMatrixScale( m );\n\t\t\t},\n\t\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( Object3D.prototype, {\n\t\t\tgetChildByName: function ( name ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\t\treturn this.getObjectByName( name );\n\t\t\t},\n\t\t\trenderDepth: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t\t},\n\t\t\ttranslate: function ( distance, axis ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( Object3D.prototype, {\n\t\t\teulerOrder: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\t\treturn this.rotation.order;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\t\tthis.rotation.order = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tuseQuaternion: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( LOD.prototype, {\n\t\t\tobjects: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\t\treturn this.levels;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\t\n\t\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\t\n\t\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\t\tthis.setFocalLength( focalLength );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Light.prototype, {\n\t\t\tonlyShadow: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraFov: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraLeft: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraRight: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraTop: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraBottom: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraNear: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraFar: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraVisible: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowBias: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\t\tthis.shadow.bias = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowDarkness: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapWidth: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapHeight: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( BufferAttribute.prototype, {\n\t\t\tlength: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\t\treturn this.array.length;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( BufferGeometry.prototype, {\n\t\t\taddIndex: function ( index ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\t\tthis.setIndex( index );\n\t\t\t},\n\t\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t\t}\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\t\tthis.addGroup( start, count );\n\t\t\t},\n\t\t\tclearDrawCalls: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\t\tthis.clearGroups();\n\t\t\t},\n\t\t\tcomputeTangents: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t\t},\n\t\t\tcomputeOffsets: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( BufferGeometry.prototype, {\n\t\t\tdrawcalls: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\t\treturn this.groups;\n\t\t\t\t}\n\t\t\t},\n\t\t\toffsets: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\t\treturn this.groups;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Material.prototype, {\n\t\t\twrapAround: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\twrapRGB: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\t\treturn new Color();\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\t\t\tmetal: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( ShaderMaterial.prototype, {\n\t\t\tderivatives: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\t\treturn this.extensions.derivatives;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tEventDispatcher.prototype = Object.assign( Object.create( {\n\t\n\t\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\t\n\t\t\tconstructor: EventDispatcher,\n\t\n\t\t\tapply: function ( target ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\t\n\t\t\t\tObject.assign( target, this );\n\t\n\t\t\t}\n\t\n\t\t} ), EventDispatcher.prototype );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Uniform.prototype, {\n\t\t\tdynamic: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tonUpdate: {\n\t\t\t\tvalue: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( WebGLRenderer.prototype, {\n\t\t\tsupportsFloatTextures: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t\t},\n\t\t\tsupportsHalfFloatTextures: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t\t},\n\t\t\tsupportsStandardDerivatives: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t\t},\n\t\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t\t},\n\t\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t\t},\n\t\t\tsupportsBlendMinMax: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t\t},\n\t\t\tsupportsVertexTextures: function () {\n\t\t\t\treturn this.capabilities.vertexTextures;\n\t\t\t},\n\t\t\tsupportsInstancedArrays: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t\t},\n\t\t\tenableScissorTest: function ( boolean ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\t\tthis.setScissorTest( boolean );\n\t\t\t},\n\t\t\tinitMaterial: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t\t},\n\t\t\taddPrePlugin: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t\t},\n\t\t\taddPostPlugin: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t\t},\n\t\t\tupdateShadowMap: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( WebGLRenderer.prototype, {\n\t\t\tshadowMapEnabled: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapType: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.shadowMap.type;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\t\tthis.shadowMap.type = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapCullFace: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( WebGLShadowMap.prototype, {\n\t\t\tcullFace: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\n\t\t\t\t},\n\t\t\t\tset: function ( cullFace ) {\n\t\t\t\t\tvar value = ( cullFace !== CullFaceBack );\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\t\tthis.renderReverseSided = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\t\t\twrapS: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\t\treturn this.texture.wrapS;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\t\tthis.texture.wrapS = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\twrapT: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\t\treturn this.texture.wrapT;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\t\tthis.texture.wrapT = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tmagFilter: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\t\treturn this.texture.magFilter;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\t\tthis.texture.magFilter = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tminFilter: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\t\treturn this.texture.minFilter;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\t\tthis.texture.minFilter = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanisotropy: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\t\treturn this.texture.anisotropy;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\toffset: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\t\treturn this.texture.offset;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\t\tthis.texture.offset = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\trepeat: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\t\treturn this.texture.repeat;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\t\tthis.texture.repeat = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tformat: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\t\treturn this.texture.format;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\t\tthis.texture.format = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\t\treturn this.texture.type;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\t\tthis.texture.type = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgenerateMipmaps: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( Audio.prototype, {\n\t\t\tload: function ( file ) {\n\t\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\t\tvar scope = this;\n\t\t\t\tvar audioLoader = new AudioLoader();\n\t\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\t\tscope.setBuffer( buffer );\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( AudioAnalyser.prototype, {\n\t\t\tgetData: function ( file ) {\n\t\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\t\treturn this.getFrequencyData();\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tvar GeometryUtils = {\n\t\n\t\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\tif ( geometry2.isMesh ) {\n\t\n\t\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\t\n\t\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\t\tgeometry2 = geometry2.geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\t\n\t\t\t},\n\t\n\t\t\tcenter: function ( geometry ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\t\treturn geometry.center();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar ImageUtils = {\n\t\n\t\t\tcrossOrigin: undefined,\n\t\n\t\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\t\n\t\t\t\tvar loader = new TextureLoader();\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\t\n\t\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\t\n\t\t\t\tvar loader = new CubeTextureLoader();\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\t\n\t\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tloadCompressedTexture: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t\t},\n\t\n\t\t\tloadCompressedTextureCube: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction Projector () {\n\t\n\t\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\t\n\t\t\tthis.projectVector = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\t\tvector.project( camera );\n\t\n\t\t\t};\n\t\n\t\t\tthis.unprojectVector = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\t\tvector.unproject( camera );\n\t\n\t\t\t};\n\t\n\t\t\tthis.pickingRay = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction CanvasRenderer () {\n\t\n\t\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\t\n\t\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tthis.clear = function () {};\n\t\t\tthis.render = function () {};\n\t\t\tthis.setClearColor = function () {};\n\t\t\tthis.setSize = function () {};\n\t\n\t\t}\n\t\n\t\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\t\texports.WebGLRenderTarget = WebGLRenderTarget;\n\t\texports.WebGLRenderer = WebGLRenderer;\n\t\texports.ShaderLib = ShaderLib;\n\t\texports.UniformsLib = UniformsLib;\n\t\texports.UniformsUtils = UniformsUtils;\n\t\texports.ShaderChunk = ShaderChunk;\n\t\texports.FogExp2 = FogExp2;\n\t\texports.Fog = Fog;\n\t\texports.Scene = Scene;\n\t\texports.LensFlare = LensFlare;\n\t\texports.Sprite = Sprite;\n\t\texports.LOD = LOD;\n\t\texports.SkinnedMesh = SkinnedMesh;\n\t\texports.Skeleton = Skeleton;\n\t\texports.Bone = Bone;\n\t\texports.Mesh = Mesh;\n\t\texports.LineSegments = LineSegments;\n\t\texports.Line = Line;\n\t\texports.Points = Points;\n\t\texports.Group = Group;\n\t\texports.VideoTexture = VideoTexture;\n\t\texports.DataTexture = DataTexture;\n\t\texports.CompressedTexture = CompressedTexture;\n\t\texports.CubeTexture = CubeTexture;\n\t\texports.CanvasTexture = CanvasTexture;\n\t\texports.DepthTexture = DepthTexture;\n\t\texports.TextureIdCount = TextureIdCount;\n\t\texports.Texture = Texture;\n\t\texports.MaterialIdCount = MaterialIdCount;\n\t\texports.CompressedTextureLoader = CompressedTextureLoader;\n\t\texports.BinaryTextureLoader = BinaryTextureLoader;\n\t\texports.DataTextureLoader = DataTextureLoader;\n\t\texports.CubeTextureLoader = CubeTextureLoader;\n\t\texports.TextureLoader = TextureLoader;\n\t\texports.ObjectLoader = ObjectLoader;\n\t\texports.MaterialLoader = MaterialLoader;\n\t\texports.BufferGeometryLoader = BufferGeometryLoader;\n\t\texports.DefaultLoadingManager = DefaultLoadingManager;\n\t\texports.LoadingManager = LoadingManager;\n\t\texports.JSONLoader = JSONLoader;\n\t\texports.ImageLoader = ImageLoader;\n\t\texports.FontLoader = FontLoader;\n\t\texports.XHRLoader = XHRLoader;\n\t\texports.Loader = Loader;\n\t\texports.Cache = Cache;\n\t\texports.AudioLoader = AudioLoader;\n\t\texports.SpotLightShadow = SpotLightShadow;\n\t\texports.SpotLight = SpotLight;\n\t\texports.PointLight = PointLight;\n\t\texports.HemisphereLight = HemisphereLight;\n\t\texports.DirectionalLightShadow = DirectionalLightShadow;\n\t\texports.DirectionalLight = DirectionalLight;\n\t\texports.AmbientLight = AmbientLight;\n\t\texports.LightShadow = LightShadow;\n\t\texports.Light = Light;\n\t\texports.StereoCamera = StereoCamera;\n\t\texports.PerspectiveCamera = PerspectiveCamera;\n\t\texports.OrthographicCamera = OrthographicCamera;\n\t\texports.CubeCamera = CubeCamera;\n\t\texports.Camera = Camera;\n\t\texports.AudioListener = AudioListener;\n\t\texports.PositionalAudio = PositionalAudio;\n\t\texports.getAudioContext = getAudioContext;\n\t\texports.AudioAnalyser = AudioAnalyser;\n\t\texports.Audio = Audio;\n\t\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\t\texports.StringKeyframeTrack = StringKeyframeTrack;\n\t\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\t\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\t\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\t\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\t\texports.PropertyMixer = PropertyMixer;\n\t\texports.PropertyBinding = PropertyBinding;\n\t\texports.KeyframeTrack = KeyframeTrack;\n\t\texports.AnimationUtils = AnimationUtils;\n\t\texports.AnimationObjectGroup = AnimationObjectGroup;\n\t\texports.AnimationMixer = AnimationMixer;\n\t\texports.AnimationClip = AnimationClip;\n\t\texports.Uniform = Uniform;\n\t\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\t\texports.BufferGeometry = BufferGeometry;\n\t\texports.GeometryIdCount = GeometryIdCount;\n\t\texports.Geometry = Geometry;\n\t\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\t\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\t\texports.InterleavedBuffer = InterleavedBuffer;\n\t\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\t\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\t\texports.Float64Attribute = Float64Attribute;\n\t\texports.Float32Attribute = Float32Attribute;\n\t\texports.Uint32Attribute = Uint32Attribute;\n\t\texports.Int32Attribute = Int32Attribute;\n\t\texports.Uint16Attribute = Uint16Attribute;\n\t\texports.Int16Attribute = Int16Attribute;\n\t\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\t\texports.Uint8Attribute = Uint8Attribute;\n\t\texports.Int8Attribute = Int8Attribute;\n\t\texports.BufferAttribute = BufferAttribute;\n\t\texports.Face3 = Face3;\n\t\texports.Object3DIdCount = Object3DIdCount;\n\t\texports.Object3D = Object3D;\n\t\texports.Raycaster = Raycaster;\n\t\texports.Layers = Layers;\n\t\texports.EventDispatcher = EventDispatcher;\n\t\texports.Clock = Clock;\n\t\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\t\texports.LinearInterpolant = LinearInterpolant;\n\t\texports.DiscreteInterpolant = DiscreteInterpolant;\n\t\texports.CubicInterpolant = CubicInterpolant;\n\t\texports.Interpolant = Interpolant;\n\t\texports.Triangle = Triangle;\n\t\texports.Spline = Spline;\n\t\texports.Math = _Math;\n\t\texports.Spherical = Spherical;\n\t\texports.Plane = Plane;\n\t\texports.Frustum = Frustum;\n\t\texports.Sphere = Sphere;\n\t\texports.Ray = Ray;\n\t\texports.Matrix4 = Matrix4;\n\t\texports.Matrix3 = Matrix3;\n\t\texports.Box3 = Box3;\n\t\texports.Box2 = Box2;\n\t\texports.Line3 = Line3;\n\t\texports.Euler = Euler;\n\t\texports.Vector4 = Vector4;\n\t\texports.Vector3 = Vector3;\n\t\texports.Vector2 = Vector2;\n\t\texports.Quaternion = Quaternion;\n\t\texports.ColorKeywords = ColorKeywords;\n\t\texports.Color = Color;\n\t\texports.MorphBlendMesh = MorphBlendMesh;\n\t\texports.ImmediateRenderObject = ImmediateRenderObject;\n\t\texports.VertexNormalsHelper = VertexNormalsHelper;\n\t\texports.SpotLightHelper = SpotLightHelper;\n\t\texports.SkeletonHelper = SkeletonHelper;\n\t\texports.PointLightHelper = PointLightHelper;\n\t\texports.HemisphereLightHelper = HemisphereLightHelper;\n\t\texports.GridHelper = GridHelper;\n\t\texports.FaceNormalsHelper = FaceNormalsHelper;\n\t\texports.DirectionalLightHelper = DirectionalLightHelper;\n\t\texports.CameraHelper = CameraHelper;\n\t\texports.BoundingBoxHelper = BoundingBoxHelper;\n\t\texports.BoxHelper = BoxHelper;\n\t\texports.ArrowHelper = ArrowHelper;\n\t\texports.AxisHelper = AxisHelper;\n\t\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\t\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\t\texports.SplineCurve3 = SplineCurve3;\n\t\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\t\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\t\texports.LineCurve3 = LineCurve3;\n\t\texports.ArcCurve = ArcCurve;\n\t\texports.EllipseCurve = EllipseCurve;\n\t\texports.SplineCurve = SplineCurve;\n\t\texports.CubicBezierCurve = CubicBezierCurve;\n\t\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\t\texports.LineCurve = LineCurve;\n\t\texports.Shape = Shape;\n\t\texports.ShapePath = ShapePath;\n\t\texports.Path = Path;\n\t\texports.Font = Font;\n\t\texports.CurvePath = CurvePath;\n\t\texports.Curve = Curve;\n\t\texports.ShapeUtils = ShapeUtils;\n\t\texports.SceneUtils = SceneUtils;\n\t\texports.CurveUtils = CurveUtils;\n\t\texports.WireframeGeometry = WireframeGeometry;\n\t\texports.ParametricGeometry = ParametricGeometry;\n\t\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\t\texports.TetrahedronGeometry = TetrahedronGeometry;\n\t\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\t\texports.OctahedronGeometry = OctahedronGeometry;\n\t\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\t\texports.IcosahedronGeometry = IcosahedronGeometry;\n\t\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\t\texports.DodecahedronGeometry = DodecahedronGeometry;\n\t\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\t\texports.PolyhedronGeometry = PolyhedronGeometry;\n\t\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\t\texports.TubeGeometry = TubeGeometry;\n\t\texports.TubeBufferGeometry = TubeBufferGeometry;\n\t\texports.TorusKnotGeometry = TorusKnotGeometry;\n\t\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\t\texports.TorusGeometry = TorusGeometry;\n\t\texports.TorusBufferGeometry = TorusBufferGeometry;\n\t\texports.TextGeometry = TextGeometry;\n\t\texports.SphereBufferGeometry = SphereBufferGeometry;\n\t\texports.SphereGeometry = SphereGeometry;\n\t\texports.RingGeometry = RingGeometry;\n\t\texports.RingBufferGeometry = RingBufferGeometry;\n\t\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\t\texports.PlaneGeometry = PlaneGeometry;\n\t\texports.LatheGeometry = LatheGeometry;\n\t\texports.LatheBufferGeometry = LatheBufferGeometry;\n\t\texports.ShapeGeometry = ShapeGeometry;\n\t\texports.ExtrudeGeometry = ExtrudeGeometry;\n\t\texports.EdgesGeometry = EdgesGeometry;\n\t\texports.ConeGeometry = ConeGeometry;\n\t\texports.ConeBufferGeometry = ConeBufferGeometry;\n\t\texports.CylinderGeometry = CylinderGeometry;\n\t\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\t\texports.CircleBufferGeometry = CircleBufferGeometry;\n\t\texports.CircleGeometry = CircleGeometry;\n\t\texports.BoxBufferGeometry = BoxBufferGeometry;\n\t\texports.BoxGeometry = BoxGeometry;\n\t\texports.ShadowMaterial = ShadowMaterial;\n\t\texports.SpriteMaterial = SpriteMaterial;\n\t\texports.RawShaderMaterial = RawShaderMaterial;\n\t\texports.ShaderMaterial = ShaderMaterial;\n\t\texports.PointsMaterial = PointsMaterial;\n\t\texports.MultiMaterial = MultiMaterial;\n\t\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\t\texports.MeshStandardMaterial = MeshStandardMaterial;\n\t\texports.MeshPhongMaterial = MeshPhongMaterial;\n\t\texports.MeshNormalMaterial = MeshNormalMaterial;\n\t\texports.MeshLambertMaterial = MeshLambertMaterial;\n\t\texports.MeshDepthMaterial = MeshDepthMaterial;\n\t\texports.MeshBasicMaterial = MeshBasicMaterial;\n\t\texports.LineDashedMaterial = LineDashedMaterial;\n\t\texports.LineBasicMaterial = LineBasicMaterial;\n\t\texports.Material = Material;\n\t\texports.REVISION = REVISION;\n\t\texports.MOUSE = MOUSE;\n\t\texports.CullFaceNone = CullFaceNone;\n\t\texports.CullFaceBack = CullFaceBack;\n\t\texports.CullFaceFront = CullFaceFront;\n\t\texports.CullFaceFrontBack = CullFaceFrontBack;\n\t\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\t\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\t\texports.BasicShadowMap = BasicShadowMap;\n\t\texports.PCFShadowMap = PCFShadowMap;\n\t\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\t\texports.FrontSide = FrontSide;\n\t\texports.BackSide = BackSide;\n\t\texports.DoubleSide = DoubleSide;\n\t\texports.FlatShading = FlatShading;\n\t\texports.SmoothShading = SmoothShading;\n\t\texports.NoColors = NoColors;\n\t\texports.FaceColors = FaceColors;\n\t\texports.VertexColors = VertexColors;\n\t\texports.NoBlending = NoBlending;\n\t\texports.NormalBlending = NormalBlending;\n\t\texports.AdditiveBlending = AdditiveBlending;\n\t\texports.SubtractiveBlending = SubtractiveBlending;\n\t\texports.MultiplyBlending = MultiplyBlending;\n\t\texports.CustomBlending = CustomBlending;\n\t\texports.BlendingMode = BlendingMode;\n\t\texports.AddEquation = AddEquation;\n\t\texports.SubtractEquation = SubtractEquation;\n\t\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\t\texports.MinEquation = MinEquation;\n\t\texports.MaxEquation = MaxEquation;\n\t\texports.ZeroFactor = ZeroFactor;\n\t\texports.OneFactor = OneFactor;\n\t\texports.SrcColorFactor = SrcColorFactor;\n\t\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\t\texports.SrcAlphaFactor = SrcAlphaFactor;\n\t\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\t\texports.DstAlphaFactor = DstAlphaFactor;\n\t\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\t\texports.DstColorFactor = DstColorFactor;\n\t\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\t\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\t\texports.NeverDepth = NeverDepth;\n\t\texports.AlwaysDepth = AlwaysDepth;\n\t\texports.LessDepth = LessDepth;\n\t\texports.LessEqualDepth = LessEqualDepth;\n\t\texports.EqualDepth = EqualDepth;\n\t\texports.GreaterEqualDepth = GreaterEqualDepth;\n\t\texports.GreaterDepth = GreaterDepth;\n\t\texports.NotEqualDepth = NotEqualDepth;\n\t\texports.MultiplyOperation = MultiplyOperation;\n\t\texports.MixOperation = MixOperation;\n\t\texports.AddOperation = AddOperation;\n\t\texports.NoToneMapping = NoToneMapping;\n\t\texports.LinearToneMapping = LinearToneMapping;\n\t\texports.ReinhardToneMapping = ReinhardToneMapping;\n\t\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\t\texports.CineonToneMapping = CineonToneMapping;\n\t\texports.UVMapping = UVMapping;\n\t\texports.CubeReflectionMapping = CubeReflectionMapping;\n\t\texports.CubeRefractionMapping = CubeRefractionMapping;\n\t\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\t\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\t\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\t\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\t\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\t\texports.TextureMapping = TextureMapping;\n\t\texports.RepeatWrapping = RepeatWrapping;\n\t\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\t\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\t\texports.TextureWrapping = TextureWrapping;\n\t\texports.NearestFilter = NearestFilter;\n\t\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\t\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\t\texports.LinearFilter = LinearFilter;\n\t\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\t\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\t\texports.TextureFilter = TextureFilter;\n\t\texports.UnsignedByteType = UnsignedByteType;\n\t\texports.ByteType = ByteType;\n\t\texports.ShortType = ShortType;\n\t\texports.UnsignedShortType = UnsignedShortType;\n\t\texports.IntType = IntType;\n\t\texports.UnsignedIntType = UnsignedIntType;\n\t\texports.FloatType = FloatType;\n\t\texports.HalfFloatType = HalfFloatType;\n\t\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\t\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\t\texports.UnsignedShort565Type = UnsignedShort565Type;\n\t\texports.UnsignedInt248Type = UnsignedInt248Type;\n\t\texports.AlphaFormat = AlphaFormat;\n\t\texports.RGBFormat = RGBFormat;\n\t\texports.RGBAFormat = RGBAFormat;\n\t\texports.LuminanceFormat = LuminanceFormat;\n\t\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\t\texports.RGBEFormat = RGBEFormat;\n\t\texports.DepthFormat = DepthFormat;\n\t\texports.DepthStencilFormat = DepthStencilFormat;\n\t\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\t\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\t\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\t\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\t\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\t\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\t\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\t\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\t\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\t\texports.LoopOnce = LoopOnce;\n\t\texports.LoopRepeat = LoopRepeat;\n\t\texports.LoopPingPong = LoopPingPong;\n\t\texports.InterpolateDiscrete = InterpolateDiscrete;\n\t\texports.InterpolateLinear = InterpolateLinear;\n\t\texports.InterpolateSmooth = InterpolateSmooth;\n\t\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\t\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\t\texports.WrapAroundEnding = WrapAroundEnding;\n\t\texports.TrianglesDrawMode = TrianglesDrawMode;\n\t\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\t\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\t\texports.LinearEncoding = LinearEncoding;\n\t\texports.sRGBEncoding = sRGBEncoding;\n\t\texports.GammaEncoding = GammaEncoding;\n\t\texports.RGBEEncoding = RGBEEncoding;\n\t\texports.LogLuvEncoding = LogLuvEncoding;\n\t\texports.RGBM7Encoding = RGBM7Encoding;\n\t\texports.RGBM16Encoding = RGBM16Encoding;\n\t\texports.RGBDEncoding = RGBDEncoding;\n\t\texports.BasicDepthPacking = BasicDepthPacking;\n\t\texports.RGBADepthPacking = RGBADepthPacking;\n\t\texports.CubeGeometry = BoxGeometry;\n\t\texports.Face4 = Face4;\n\t\texports.LineStrip = LineStrip;\n\t\texports.LinePieces = LinePieces;\n\t\texports.MeshFaceMaterial = MultiMaterial;\n\t\texports.PointCloud = PointCloud;\n\t\texports.Particle = Sprite;\n\t\texports.ParticleSystem = ParticleSystem;\n\t\texports.PointCloudMaterial = PointCloudMaterial;\n\t\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\t\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\t\texports.Vertex = Vertex;\n\t\texports.EdgesHelper = EdgesHelper;\n\t\texports.WireframeHelper = WireframeHelper;\n\t\texports.GeometryUtils = GeometryUtils;\n\t\texports.ImageUtils = ImageUtils;\n\t\texports.Projector = Projector;\n\t\texports.CanvasRenderer = CanvasRenderer;\n\t\n\t\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t\tObject.defineProperty( exports, 'AudioContext', {\n\t\t\tget: function () {\n\t\t\t\treturn exports.getAudioContext();\n\t\t\t}\n\t\t});\n\t\n\t})));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tvar Stats = function () {\n\t\n\t\tvar mode = 0;\n\t\n\t\tvar container = document.createElement('div');\n\t\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\t\tcontainer.addEventListener('click', function (event) {\n\t\n\t\t\tevent.preventDefault();\n\t\t\tshowPanel(++mode % container.children.length);\n\t\t}, false);\n\t\n\t\t//\n\t\n\t\tfunction addPanel(panel) {\n\t\n\t\t\tcontainer.appendChild(panel.dom);\n\t\t\treturn panel;\n\t\t}\n\t\n\t\tfunction showPanel(id) {\n\t\n\t\t\tfor (var i = 0; i < container.children.length; i++) {\n\t\n\t\t\t\tcontainer.children[i].style.display = i === id ? 'block' : 'none';\n\t\t\t}\n\t\n\t\t\tmode = id;\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar beginTime = (performance || Date).now(),\n\t\t    prevTime = beginTime,\n\t\t    frames = 0;\n\t\n\t\tvar fpsPanel = addPanel(new Stats.Panel('FPS', '#0ff', '#002'));\n\t\tvar msPanel = addPanel(new Stats.Panel('MS', '#0f0', '#020'));\n\t\n\t\tif (self.performance && self.performance.memory) {\n\t\n\t\t\tvar memPanel = addPanel(new Stats.Panel('MB', '#f08', '#201'));\n\t\t}\n\t\n\t\tshowPanel(0);\n\t\n\t\treturn {\n\t\n\t\t\tREVISION: 16,\n\t\n\t\t\tdom: container,\n\t\n\t\t\taddPanel: addPanel,\n\t\t\tshowPanel: showPanel,\n\t\n\t\t\tbegin: function () {\n\t\n\t\t\t\tbeginTime = (performance || Date).now();\n\t\t\t},\n\t\n\t\t\tend: function () {\n\t\n\t\t\t\tframes++;\n\t\n\t\t\t\tvar time = (performance || Date).now();\n\t\n\t\t\t\tmsPanel.update(time - beginTime, 200);\n\t\n\t\t\t\tif (time > prevTime + 1000) {\n\t\n\t\t\t\t\tfpsPanel.update(frames * 1000 / (time - prevTime), 100);\n\t\n\t\t\t\t\tprevTime = time;\n\t\t\t\t\tframes = 0;\n\t\n\t\t\t\t\tif (memPanel) {\n\t\n\t\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\t\tmemPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn time;\n\t\t\t},\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tbeginTime = this.end();\n\t\t\t},\n\t\n\t\t\t// Backwards Compatibility\n\t\n\t\t\tdomElement: container,\n\t\t\tsetMode: showPanel\n\t\n\t\t};\n\t};\n\t\n\tStats.Panel = function (name, fg, bg) {\n\t\n\t\tvar min = Infinity,\n\t\t    max = 0,\n\t\t    round = Math.round;\n\t\tvar PR = round(window.devicePixelRatio || 1);\n\t\n\t\tvar WIDTH = 80 * PR,\n\t\t    HEIGHT = 48 * PR,\n\t\t    TEXT_X = 3 * PR,\n\t\t    TEXT_Y = 2 * PR,\n\t\t    GRAPH_X = 3 * PR,\n\t\t    GRAPH_Y = 15 * PR,\n\t\t    GRAPH_WIDTH = 74 * PR,\n\t\t    GRAPH_HEIGHT = 30 * PR;\n\t\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.width = WIDTH;\n\t\tcanvas.height = HEIGHT;\n\t\tcanvas.style.cssText = 'width:80px;height:48px';\n\t\n\t\tvar context = canvas.getContext('2d');\n\t\tcontext.font = 'bold ' + 9 * PR + 'px Helvetica,Arial,sans-serif';\n\t\tcontext.textBaseline = 'top';\n\t\n\t\tcontext.fillStyle = bg;\n\t\tcontext.fillRect(0, 0, WIDTH, HEIGHT);\n\t\n\t\tcontext.fillStyle = fg;\n\t\tcontext.fillText(name, TEXT_X, TEXT_Y);\n\t\tcontext.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n\t\n\t\tcontext.fillStyle = bg;\n\t\tcontext.globalAlpha = 0.9;\n\t\tcontext.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n\t\n\t\treturn {\n\t\n\t\t\tdom: canvas,\n\t\n\t\t\tupdate: function (value, maxValue) {\n\t\n\t\t\t\tmin = Math.min(min, value);\n\t\t\t\tmax = Math.max(max, value);\n\t\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalAlpha = 1;\n\t\t\t\tcontext.fillRect(0, 0, WIDTH, GRAPH_Y);\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.fillText(round(value) + ' ' + name + ' (' + round(min) + '-' + round(max) + ')', TEXT_X, TEXT_Y);\n\t\n\t\t\t\tcontext.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);\n\t\n\t\t\t\tcontext.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);\n\t\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalAlpha = 0.9;\n\t\t\t\tcontext.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));\n\t\t\t}\n\t\n\t\t};\n\t};\n\t\n\tif (true) {\n\t\n\t\tmodule.exports = Stats;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(6)\n\tmodule.exports.color = __webpack_require__(7)\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * dat-gui JavaScript Controller Library\n\t * http://code.google.com/p/dat-gui\n\t *\n\t * Copyright 2011 Data Arts Team, Google Creative Lab\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t */\n\t\n\t/** @namespace */\n\tvar dat = module.exports = dat || {};\n\t\n\t/** @namespace */\n\tdat.gui = dat.gui || {};\n\t\n\t/** @namespace */\n\tdat.utils = dat.utils || {};\n\t\n\t/** @namespace */\n\tdat.controllers = dat.controllers || {};\n\t\n\t/** @namespace */\n\tdat.dom = dat.dom || {};\n\t\n\t/** @namespace */\n\tdat.color = dat.color || {};\n\t\n\tdat.utils.css = (function () {\n\t  return {\n\t    load: function (url, doc) {\n\t      doc = doc || document;\n\t      var link = doc.createElement('link');\n\t      link.type = 'text/css';\n\t      link.rel = 'stylesheet';\n\t      link.href = url;\n\t      doc.getElementsByTagName('head')[0].appendChild(link);\n\t    },\n\t    inject: function(css, doc) {\n\t      doc = doc || document;\n\t      var injected = document.createElement('style');\n\t      injected.type = 'text/css';\n\t      injected.innerHTML = css;\n\t      doc.getElementsByTagName('head')[0].appendChild(injected);\n\t    }\n\t  }\n\t})();\n\t\n\t\n\tdat.utils.common = (function () {\n\t  \n\t  var ARR_EACH = Array.prototype.forEach;\n\t  var ARR_SLICE = Array.prototype.slice;\n\t\n\t  /**\n\t   * Band-aid methods for things that should be a lot easier in JavaScript.\n\t   * Implementation and structure inspired by underscore.js\n\t   * http://documentcloud.github.com/underscore/\n\t   */\n\t\n\t  return { \n\t    \n\t    BREAK: {},\n\t  \n\t    extend: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (!this.isUndefined(obj[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t      \n\t    },\n\t    \n\t    defaults: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (this.isUndefined(target[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t    \n\t    },\n\t    \n\t    compose: function() {\n\t      var toCall = ARR_SLICE.call(arguments);\n\t            return function() {\n\t              var args = ARR_SLICE.call(arguments);\n\t              for (var i = toCall.length -1; i >= 0; i--) {\n\t                args = [toCall[i].apply(this, args)];\n\t              }\n\t              return args[0];\n\t            }\n\t    },\n\t    \n\t    each: function(obj, itr, scope) {\n\t\n\t      \n\t      if (ARR_EACH && obj.forEach === ARR_EACH) { \n\t        \n\t        obj.forEach(itr, scope);\n\t        \n\t      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n\t        \n\t        for (var key = 0, l = obj.length; key < l; key++)\n\t          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n\t            return;\n\t            \n\t      } else {\n\t\n\t        for (var key in obj) \n\t          if (itr.call(scope, obj[key], key) === this.BREAK)\n\t            return;\n\t            \n\t      }\n\t            \n\t    },\n\t    \n\t    defer: function(fnc) {\n\t      setTimeout(fnc, 0);\n\t    },\n\t    \n\t    toArray: function(obj) {\n\t      if (obj.toArray) return obj.toArray();\n\t      return ARR_SLICE.call(obj);\n\t    },\n\t\n\t    isUndefined: function(obj) {\n\t      return obj === undefined;\n\t    },\n\t    \n\t    isNull: function(obj) {\n\t      return obj === null;\n\t    },\n\t    \n\t    isNaN: function(obj) {\n\t      return obj !== obj;\n\t    },\n\t    \n\t    isArray: Array.isArray || function(obj) {\n\t      return obj.constructor === Array;\n\t    },\n\t    \n\t    isObject: function(obj) {\n\t      return obj === Object(obj);\n\t    },\n\t    \n\t    isNumber: function(obj) {\n\t      return obj === obj+0;\n\t    },\n\t    \n\t    isString: function(obj) {\n\t      return obj === obj+'';\n\t    },\n\t    \n\t    isBoolean: function(obj) {\n\t      return obj === false || obj === true;\n\t    },\n\t    \n\t    isFunction: function(obj) {\n\t      return Object.prototype.toString.call(obj) === '[object Function]';\n\t    }\n\t  \n\t  };\n\t    \n\t})();\n\t\n\t\n\tdat.controllers.Controller = (function (common) {\n\t\n\t  /**\n\t   * @class An \"abstract\" class that represents a given property of an object.\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var Controller = function(object, property) {\n\t\n\t    this.initialValue = object[property];\n\t\n\t    /**\n\t     * Those who extend this class will put their DOM elements in here.\n\t     * @type {DOMElement}\n\t     */\n\t    this.domElement = document.createElement('div');\n\t\n\t    /**\n\t     * The object to manipulate\n\t     * @type {Object}\n\t     */\n\t    this.object = object;\n\t\n\t    /**\n\t     * The name of the property to manipulate\n\t     * @type {String}\n\t     */\n\t    this.property = property;\n\t\n\t    /**\n\t     * The function to be called on change.\n\t     * @type {Function}\n\t     * @ignore\n\t     */\n\t    this.__onChange = undefined;\n\t\n\t    /**\n\t     * The function to be called on finishing change.\n\t     * @type {Function}\n\t     * @ignore\n\t     */\n\t    this.__onFinishChange = undefined;\n\t\n\t  };\n\t\n\t  common.extend(\n\t\n\t      Controller.prototype,\n\t\n\t      /** @lends dat.controllers.Controller.prototype */\n\t      {\n\t\n\t        /**\n\t         * Specify that a function fire every time someone changes the value with\n\t         * this Controller.\n\t         *\n\t         * @param {Function} fnc This function will be called whenever the value\n\t         * is modified via this Controller.\n\t         * @returns {dat.controllers.Controller} this\n\t         */\n\t        onChange: function(fnc) {\n\t          this.__onChange = fnc;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Specify that a function fire every time someone \"finishes\" changing\n\t         * the value wih this Controller. Useful for values that change\n\t         * incrementally like numbers or strings.\n\t         *\n\t         * @param {Function} fnc This function will be called whenever\n\t         * someone \"finishes\" changing the value via this Controller.\n\t         * @returns {dat.controllers.Controller} this\n\t         */\n\t        onFinishChange: function(fnc) {\n\t          this.__onFinishChange = fnc;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Change the value of <code>object[property]</code>\n\t         *\n\t         * @param {Object} newValue The new value of <code>object[property]</code>\n\t         */\n\t        setValue: function(newValue) {\n\t          this.object[this.property] = newValue;\n\t          if (this.__onChange) {\n\t            this.__onChange.call(this, newValue);\n\t          }\n\t          this.updateDisplay();\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Gets the value of <code>object[property]</code>\n\t         *\n\t         * @returns {Object} The current value of <code>object[property]</code>\n\t         */\n\t        getValue: function() {\n\t          return this.object[this.property];\n\t        },\n\t\n\t        /**\n\t         * Refreshes the visual display of a Controller in order to keep sync\n\t         * with the object's current value.\n\t         * @returns {dat.controllers.Controller} this\n\t         */\n\t        updateDisplay: function() {\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * @returns {Boolean} true if the value has deviated from initialValue\n\t         */\n\t        isModified: function() {\n\t          return this.initialValue !== this.getValue()\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return Controller;\n\t\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.dom.dom = (function (common) {\n\t\n\t  var EVENT_MAP = {\n\t    'HTMLEvents': ['change'],\n\t    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],\n\t    'KeyboardEvents': ['keydown']\n\t  };\n\t\n\t  var EVENT_MAP_INV = {};\n\t  common.each(EVENT_MAP, function(v, k) {\n\t    common.each(v, function(e) {\n\t      EVENT_MAP_INV[e] = k;\n\t    });\n\t  });\n\t\n\t  var CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\n\t\n\t  function cssValueToPixels(val) {\n\t\n\t    if (val === '0' || common.isUndefined(val)) return 0;\n\t\n\t    var match = val.match(CSS_VALUE_PIXELS);\n\t\n\t    if (!common.isNull(match)) {\n\t      return parseFloat(match[1]);\n\t    }\n\t\n\t    // TODO ...ems? %?\n\t\n\t    return 0;\n\t\n\t  }\n\t\n\t  /**\n\t   * @namespace\n\t   * @member dat.dom\n\t   */\n\t  var dom = {\n\t\n\t    /**\n\t     * \n\t     * @param elem\n\t     * @param selectable\n\t     */\n\t    makeSelectable: function(elem, selectable) {\n\t\n\t      if (elem === undefined || elem.style === undefined) return;\n\t\n\t      elem.onselectstart = selectable ? function() {\n\t        return false;\n\t      } : function() {\n\t      };\n\t\n\t      elem.style.MozUserSelect = selectable ? 'auto' : 'none';\n\t      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\n\t      elem.unselectable = selectable ? 'on' : 'off';\n\t\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param horizontal\n\t     * @param vertical\n\t     */\n\t    makeFullscreen: function(elem, horizontal, vertical) {\n\t\n\t      if (common.isUndefined(horizontal)) horizontal = true;\n\t      if (common.isUndefined(vertical)) vertical = true;\n\t\n\t      elem.style.position = 'absolute';\n\t\n\t      if (horizontal) {\n\t        elem.style.left = 0;\n\t        elem.style.right = 0;\n\t      }\n\t      if (vertical) {\n\t        elem.style.top = 0;\n\t        elem.style.bottom = 0;\n\t      }\n\t\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param eventType\n\t     * @param params\n\t     */\n\t    fakeEvent: function(elem, eventType, params, aux) {\n\t      params = params || {};\n\t      var className = EVENT_MAP_INV[eventType];\n\t      if (!className) {\n\t        throw new Error('Event type ' + eventType + ' not supported.');\n\t      }\n\t      var evt = document.createEvent(className);\n\t      switch (className) {\n\t        case 'MouseEvents':\n\t          var clientX = params.x || params.clientX || 0;\n\t          var clientY = params.y || params.clientY || 0;\n\t          evt.initMouseEvent(eventType, params.bubbles || false,\n\t              params.cancelable || true, window, params.clickCount || 1,\n\t              0, //screen X\n\t              0, //screen Y\n\t              clientX, //client X\n\t              clientY, //client Y\n\t              false, false, false, false, 0, null);\n\t          break;\n\t        case 'KeyboardEvents':\n\t          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz\n\t          common.defaults(params, {\n\t            cancelable: true,\n\t            ctrlKey: false,\n\t            altKey: false,\n\t            shiftKey: false,\n\t            metaKey: false,\n\t            keyCode: undefined,\n\t            charCode: undefined\n\t          });\n\t          init(eventType, params.bubbles || false,\n\t              params.cancelable, window,\n\t              params.ctrlKey, params.altKey,\n\t              params.shiftKey, params.metaKey,\n\t              params.keyCode, params.charCode);\n\t          break;\n\t        default:\n\t          evt.initEvent(eventType, params.bubbles || false,\n\t              params.cancelable || true);\n\t          break;\n\t      }\n\t      common.defaults(evt, aux);\n\t      elem.dispatchEvent(evt);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param event\n\t     * @param func\n\t     * @param bool\n\t     */\n\t    bind: function(elem, event, func, bool) {\n\t      bool = bool || false;\n\t      if (elem.addEventListener)\n\t        elem.addEventListener(event, func, bool);\n\t      else if (elem.attachEvent)\n\t        elem.attachEvent('on' + event, func);\n\t      return dom;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param event\n\t     * @param func\n\t     * @param bool\n\t     */\n\t    unbind: function(elem, event, func, bool) {\n\t      bool = bool || false;\n\t      if (elem.removeEventListener)\n\t        elem.removeEventListener(event, func, bool);\n\t      else if (elem.detachEvent)\n\t        elem.detachEvent('on' + event, func);\n\t      return dom;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param className\n\t     */\n\t    addClass: function(elem, className) {\n\t      if (elem.className === undefined) {\n\t        elem.className = className;\n\t      } else if (elem.className !== className) {\n\t        var classes = elem.className.split(/ +/);\n\t        if (classes.indexOf(className) == -1) {\n\t          classes.push(className);\n\t          elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t        }\n\t      }\n\t      return dom;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param className\n\t     */\n\t    removeClass: function(elem, className) {\n\t      if (className) {\n\t        if (elem.className === undefined) {\n\t          // elem.className = className;\n\t        } else if (elem.className === className) {\n\t          elem.removeAttribute('class');\n\t        } else {\n\t          var classes = elem.className.split(/ +/);\n\t          var index = classes.indexOf(className);\n\t          if (index != -1) {\n\t            classes.splice(index, 1);\n\t            elem.className = classes.join(' ');\n\t          }\n\t        }\n\t      } else {\n\t        elem.className = undefined;\n\t      }\n\t      return dom;\n\t    },\n\t\n\t    hasClass: function(elem, className) {\n\t      return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     */\n\t    getWidth: function(elem) {\n\t\n\t      var style = getComputedStyle(elem);\n\t\n\t      return cssValueToPixels(style['border-left-width']) +\n\t          cssValueToPixels(style['border-right-width']) +\n\t          cssValueToPixels(style['padding-left']) +\n\t          cssValueToPixels(style['padding-right']) +\n\t          cssValueToPixels(style['width']);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     */\n\t    getHeight: function(elem) {\n\t\n\t      var style = getComputedStyle(elem);\n\t\n\t      return cssValueToPixels(style['border-top-width']) +\n\t          cssValueToPixels(style['border-bottom-width']) +\n\t          cssValueToPixels(style['padding-top']) +\n\t          cssValueToPixels(style['padding-bottom']) +\n\t          cssValueToPixels(style['height']);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     */\n\t    getOffset: function(elem) {\n\t      var offset = {left: 0, top:0};\n\t      if (elem.offsetParent) {\n\t        do {\n\t          offset.left += elem.offsetLeft;\n\t          offset.top += elem.offsetTop;\n\t        } while (elem = elem.offsetParent);\n\t      }\n\t      return offset;\n\t    },\n\t\n\t    // http://stackoverflow.com/posts/2684561/revisions\n\t    /**\n\t     * \n\t     * @param elem\n\t     */\n\t    isActive: function(elem) {\n\t      return elem === document.activeElement && ( elem.type || elem.href );\n\t    }\n\t\n\t  };\n\t\n\t  return dom;\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.controllers.OptionController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a select input to alter the property of an object, using a\n\t   * list of accepted values.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Object|string[]} options A map of labels to acceptable values, or\n\t   * a list of acceptable string values.\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var OptionController = function(object, property, options) {\n\t\n\t    OptionController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t\n\t    /**\n\t     * The drop down menu\n\t     * @ignore\n\t     */\n\t    this.__select = document.createElement('select');\n\t\n\t    if (common.isArray(options)) {\n\t      var map = {};\n\t      common.each(options, function(element) {\n\t        map[element] = element;\n\t      });\n\t      options = map;\n\t    }\n\t\n\t    common.each(options, function(value, key) {\n\t\n\t      var opt = document.createElement('option');\n\t      opt.innerHTML = key;\n\t      opt.setAttribute('value', value);\n\t      _this.__select.appendChild(opt);\n\t\n\t    });\n\t\n\t    // Acknowledge original value\n\t    this.updateDisplay();\n\t\n\t    dom.bind(this.__select, 'change', function() {\n\t      var desiredValue = this.options[this.selectedIndex].value;\n\t      _this.setValue(desiredValue);\n\t    });\n\t\n\t    this.domElement.appendChild(this.__select);\n\t\n\t  };\n\t\n\t  OptionController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      OptionController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        setValue: function(v) {\n\t          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);\n\t          if (this.__onFinishChange) {\n\t            this.__onFinishChange.call(this, this.getValue());\n\t          }\n\t          return toReturn;\n\t        },\n\t\n\t        updateDisplay: function() {\n\t          this.__select.value = this.getValue();\n\t          return OptionController.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return OptionController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.NumberController = (function (Controller, common) {\n\t\n\t  /**\n\t   * @class Represents a given property of an object that is a number.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Object} [params] Optional parameters\n\t   * @param {Number} [params.min] Minimum allowed value\n\t   * @param {Number} [params.max] Maximum allowed value\n\t   * @param {Number} [params.step] Increment by which to change value\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var NumberController = function(object, property, params) {\n\t\n\t    NumberController.superclass.call(this, object, property);\n\t\n\t    params = params || {};\n\t\n\t    this.__min = params.min;\n\t    this.__max = params.max;\n\t    this.__step = params.step;\n\t\n\t    if (common.isUndefined(this.__step)) {\n\t\n\t      if (this.initialValue == 0) {\n\t        this.__impliedStep = 1; // What are we, psychics?\n\t      } else {\n\t        // Hey Doug, check this out.\n\t        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;\n\t      }\n\t\n\t    } else {\n\t\n\t      this.__impliedStep = this.__step;\n\t\n\t    }\n\t\n\t    this.__precision = numDecimals(this.__impliedStep);\n\t\n\t\n\t  };\n\t\n\t  NumberController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      NumberController.prototype,\n\t      Controller.prototype,\n\t\n\t      /** @lends dat.controllers.NumberController.prototype */\n\t      {\n\t\n\t        setValue: function(v) {\n\t\n\t          if (this.__min !== undefined && v < this.__min) {\n\t            v = this.__min;\n\t          } else if (this.__max !== undefined && v > this.__max) {\n\t            v = this.__max;\n\t          }\n\t\n\t          if (this.__step !== undefined && v % this.__step != 0) {\n\t            v = Math.round(v / this.__step) * this.__step;\n\t          }\n\t\n\t          return NumberController.superclass.prototype.setValue.call(this, v);\n\t\n\t        },\n\t\n\t        /**\n\t         * Specify a minimum value for <code>object[property]</code>.\n\t         *\n\t         * @param {Number} minValue The minimum value for\n\t         * <code>object[property]</code>\n\t         * @returns {dat.controllers.NumberController} this\n\t         */\n\t        min: function(v) {\n\t          this.__min = v;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Specify a maximum value for <code>object[property]</code>.\n\t         *\n\t         * @param {Number} maxValue The maximum value for\n\t         * <code>object[property]</code>\n\t         * @returns {dat.controllers.NumberController} this\n\t         */\n\t        max: function(v) {\n\t          this.__max = v;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Specify a step value that dat.controllers.NumberController\n\t         * increments by.\n\t         *\n\t         * @param {Number} stepValue The step value for\n\t         * dat.controllers.NumberController\n\t         * @default if minimum and maximum specified increment is 1% of the\n\t         * difference otherwise stepValue is 1\n\t         * @returns {dat.controllers.NumberController} this\n\t         */\n\t        step: function(v) {\n\t          this.__step = v;\n\t          return this;\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  function numDecimals(x) {\n\t    x = x.toString();\n\t    if (x.indexOf('.') > -1) {\n\t      return x.length - x.indexOf('.') - 1;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }\n\t\n\t  return NumberController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.NumberControllerBox = (function (NumberController, dom, common) {\n\t\n\t  /**\n\t   * @class Represents a given property of an object that is a number and\n\t   * provides an input element with which to manipulate it.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   * @extends dat.controllers.NumberController\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Object} [params] Optional parameters\n\t   * @param {Number} [params.min] Minimum allowed value\n\t   * @param {Number} [params.max] Maximum allowed value\n\t   * @param {Number} [params.step] Increment by which to change value\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var NumberControllerBox = function(object, property, params) {\n\t\n\t    this.__truncationSuspended = false;\n\t\n\t    NumberControllerBox.superclass.call(this, object, property, params);\n\t\n\t    var _this = this;\n\t\n\t    /**\n\t     * {Number} Previous mouse y position\n\t     * @ignore\n\t     */\n\t    var prev_y;\n\t\n\t    this.__input = document.createElement('input');\n\t    this.__input.setAttribute('type', 'text');\n\t\n\t    // Makes it so manually specified values are not truncated.\n\t\n\t    dom.bind(this.__input, 'change', onChange);\n\t    dom.bind(this.__input, 'blur', onBlur);\n\t    dom.bind(this.__input, 'mousedown', onMouseDown);\n\t    dom.bind(this.__input, 'keydown', function(e) {\n\t\n\t      // When pressing entire, you can be as precise as you want.\n\t      if (e.keyCode === 13) {\n\t        _this.__truncationSuspended = true;\n\t        this.blur();\n\t        _this.__truncationSuspended = false;\n\t      }\n\t\n\t    });\n\t\n\t    function onChange() {\n\t      var attempted = parseFloat(_this.__input.value);\n\t      if (!common.isNaN(attempted)) _this.setValue(attempted);\n\t    }\n\t\n\t    function onBlur() {\n\t      onChange();\n\t      if (_this.__onFinishChange) {\n\t        _this.__onFinishChange.call(_this, _this.getValue());\n\t      }\n\t    }\n\t\n\t    function onMouseDown(e) {\n\t      dom.bind(window, 'mousemove', onMouseDrag);\n\t      dom.bind(window, 'mouseup', onMouseUp);\n\t      prev_y = e.clientY;\n\t    }\n\t\n\t    function onMouseDrag(e) {\n\t\n\t      var diff = prev_y - e.clientY;\n\t      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\n\t\n\t      prev_y = e.clientY;\n\t\n\t    }\n\t\n\t    function onMouseUp() {\n\t      dom.unbind(window, 'mousemove', onMouseDrag);\n\t      dom.unbind(window, 'mouseup', onMouseUp);\n\t    }\n\t\n\t    this.updateDisplay();\n\t\n\t    this.domElement.appendChild(this.__input);\n\t\n\t  };\n\t\n\t  NumberControllerBox.superclass = NumberController;\n\t\n\t  common.extend(\n\t\n\t      NumberControllerBox.prototype,\n\t      NumberController.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t\n\t          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\n\t          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  function roundToDecimal(value, decimals) {\n\t    var tenTo = Math.pow(10, decimals);\n\t    return Math.round(value * tenTo) / tenTo;\n\t  }\n\t\n\t  return NumberControllerBox;\n\t\n\t})(dat.controllers.NumberController,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {\n\t\n\t  /**\n\t   * @class Represents a given property of an object that is a number, contains\n\t   * a minimum and maximum, and provides a slider element with which to\n\t   * manipulate it. It should be noted that the slider element is made up of\n\t   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5\n\t   * <code>&lt;slider&gt;</code> element.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   * @extends dat.controllers.NumberController\n\t   * \n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Number} minValue Minimum allowed value\n\t   * @param {Number} maxValue Maximum allowed value\n\t   * @param {Number} stepValue Increment by which to change value\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var NumberControllerSlider = function(object, property, min, max, step) {\n\t\n\t    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });\n\t\n\t    var _this = this;\n\t\n\t    this.__background = document.createElement('div');\n\t    this.__foreground = document.createElement('div');\n\t    \n\t\n\t\n\t    dom.bind(this.__background, 'mousedown', onMouseDown);\n\t    \n\t    dom.addClass(this.__background, 'slider');\n\t    dom.addClass(this.__foreground, 'slider-fg');\n\t\n\t    function onMouseDown(e) {\n\t\n\t      dom.bind(window, 'mousemove', onMouseDrag);\n\t      dom.bind(window, 'mouseup', onMouseUp);\n\t\n\t      onMouseDrag(e);\n\t    }\n\t\n\t    function onMouseDrag(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      var offset = dom.getOffset(_this.__background);\n\t      var width = dom.getWidth(_this.__background);\n\t      \n\t      _this.setValue(\n\t        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)\n\t      );\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function onMouseUp() {\n\t      dom.unbind(window, 'mousemove', onMouseDrag);\n\t      dom.unbind(window, 'mouseup', onMouseUp);\n\t      if (_this.__onFinishChange) {\n\t        _this.__onFinishChange.call(_this, _this.getValue());\n\t      }\n\t    }\n\t\n\t    this.updateDisplay();\n\t\n\t    this.__background.appendChild(this.__foreground);\n\t    this.domElement.appendChild(this.__background);\n\t\n\t  };\n\t\n\t  NumberControllerSlider.superclass = NumberController;\n\t\n\t  /**\n\t   * Injects default stylesheet for slider elements.\n\t   */\n\t  NumberControllerSlider.useDefaultStyles = function() {\n\t    css.inject(styleSheet);\n\t  };\n\t\n\t  common.extend(\n\t\n\t      NumberControllerSlider.prototype,\n\t      NumberController.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);\n\t          this.__foreground.style.width = pct*100+'%';\n\t          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t\n\t\n\t  );\n\t\n\t  function map(v, i1, i2, o1, o2) {\n\t    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\n\t  }\n\t\n\t  return NumberControllerSlider;\n\t  \n\t})(dat.controllers.NumberController,\n\tdat.dom.dom,\n\tdat.utils.css,\n\tdat.utils.common,\n\t\".slider {\\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\\n  height: 1em;\\n  border-radius: 1em;\\n  background-color: #eee;\\n  padding: 0 0.5em;\\n  overflow: hidden;\\n}\\n\\n.slider-fg {\\n  padding: 1px 0 2px 0;\\n  background-color: #aaa;\\n  height: 1em;\\n  margin-left: -0.5em;\\n  padding-right: 0.5em;\\n  border-radius: 1em 0 0 1em;\\n}\\n\\n.slider-fg:after {\\n  display: inline-block;\\n  border-radius: 1em;\\n  background-color: #fff;\\n  border:  1px solid #aaa;\\n  content: '';\\n  float: right;\\n  margin-right: -1em;\\n  margin-top: -1px;\\n  height: 0.9em;\\n  width: 0.9em;\\n}\");\n\t\n\t\n\tdat.controllers.FunctionController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a GUI interface to fire a specified method, a property of an object.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var FunctionController = function(object, property, text) {\n\t\n\t    FunctionController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t\n\t    this.__button = document.createElement('div');\n\t    this.__button.innerHTML = text === undefined ? 'Fire' : text;\n\t    dom.bind(this.__button, 'click', function(e) {\n\t      e.preventDefault();\n\t      _this.fire();\n\t      return false;\n\t    });\n\t\n\t    dom.addClass(this.__button, 'button');\n\t\n\t    this.domElement.appendChild(this.__button);\n\t\n\t\n\t  };\n\t\n\t  FunctionController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      FunctionController.prototype,\n\t      Controller.prototype,\n\t      {\n\t        \n\t        fire: function() {\n\t          if (this.__onChange) {\n\t            this.__onChange.call(this);\n\t          }\n\t          if (this.__onFinishChange) {\n\t            this.__onFinishChange.call(this, this.getValue());\n\t          }\n\t          this.getValue().call(this.object);\n\t        }\n\t      }\n\t\n\t  );\n\t\n\t  return FunctionController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.BooleanController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a checkbox input to alter the boolean property of an object.\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var BooleanController = function(object, property) {\n\t\n\t    BooleanController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t    this.__prev = this.getValue();\n\t\n\t    this.__checkbox = document.createElement('input');\n\t    this.__checkbox.setAttribute('type', 'checkbox');\n\t\n\t\n\t    dom.bind(this.__checkbox, 'change', onChange, false);\n\t\n\t    this.domElement.appendChild(this.__checkbox);\n\t\n\t    // Match original value\n\t    this.updateDisplay();\n\t\n\t    function onChange() {\n\t      _this.setValue(!_this.__prev);\n\t    }\n\t\n\t  };\n\t\n\t  BooleanController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      BooleanController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        setValue: function(v) {\n\t          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);\n\t          if (this.__onFinishChange) {\n\t            this.__onFinishChange.call(this, this.getValue());\n\t          }\n\t          this.__prev = this.getValue();\n\t          return toReturn;\n\t        },\n\t\n\t        updateDisplay: function() {\n\t          \n\t          if (this.getValue() === true) {\n\t            this.__checkbox.setAttribute('checked', 'checked');\n\t            this.__checkbox.checked = true;    \n\t          } else {\n\t              this.__checkbox.checked = false;\n\t          }\n\t\n\t          return BooleanController.superclass.prototype.updateDisplay.call(this);\n\t\n\t        }\n\t\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return BooleanController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.color.toString = (function (common) {\n\t\n\t  return function(color) {\n\t\n\t    if (color.a == 1 || common.isUndefined(color.a)) {\n\t\n\t      var s = color.hex.toString(16);\n\t      while (s.length < 6) {\n\t        s = '0' + s;\n\t      }\n\t\n\t      return '#' + s;\n\t\n\t    } else {\n\t\n\t      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\t\n\t    }\n\t\n\t  }\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.color.interpret = (function (toString, common) {\n\t\n\t  var result, toReturn;\n\t\n\t  var interpret = function() {\n\t\n\t    toReturn = false;\n\t\n\t    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\t\n\t    common.each(INTERPRETATIONS, function(family) {\n\t\n\t      if (family.litmus(original)) {\n\t\n\t        common.each(family.conversions, function(conversion, conversionName) {\n\t\n\t          result = conversion.read(original);\n\t\n\t          if (toReturn === false && result !== false) {\n\t            toReturn = result;\n\t            result.conversionName = conversionName;\n\t            result.conversion = conversion;\n\t            return common.BREAK;\n\t\n\t          }\n\t\n\t        });\n\t\n\t        return common.BREAK;\n\t\n\t      }\n\t\n\t    });\n\t\n\t    return toReturn;\n\t\n\t  };\n\t\n\t  var INTERPRETATIONS = [\n\t\n\t    // Strings\n\t    {\n\t\n\t      litmus: common.isString,\n\t\n\t      conversions: {\n\t\n\t        THREE_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt(\n\t                  '0x' +\n\t                      test[1].toString() + test[1].toString() +\n\t                      test[2].toString() + test[2].toString() +\n\t                      test[3].toString() + test[3].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        SIX_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9]{6})$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt('0x' + test[1].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGB: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGBA: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3]),\n\t              a: parseFloat(test[4])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Numbers\n\t    {\n\t\n\t      litmus: common.isNumber,\n\t\n\t      conversions: {\n\t\n\t        HEX: {\n\t          read: function(original) {\n\t            return {\n\t              space: 'HEX',\n\t              hex: original,\n\t              conversionName: 'HEX'\n\t            }\n\t          },\n\t\n\t          write: function(color) {\n\t            return color.hex;\n\t          }\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Arrays\n\t    {\n\t\n\t      litmus: common.isArray,\n\t\n\t      conversions: {\n\t\n\t        RGB_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 3) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b];\n\t          }\n\t\n\t        },\n\t\n\t        RGBA_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 4) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2],\n\t              a: original[3]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b, color.a];\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Objects\n\t    {\n\t\n\t      litmus: common.isObject,\n\t\n\t      conversions: {\n\t\n\t        RGBA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        RGB_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b\n\t            }\n\t          }\n\t        },\n\t\n\t        HSVA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        HSV_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v\n\t            }\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t\n\t\n\t  ];\n\t\n\t  return interpret;\n\t\n\t\n\t})(dat.color.toString,\n\tdat.utils.common);\n\t\n\t\n\tdat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {\n\t\n\t  css.inject(styleSheet);\n\t\n\t  /** Outer-most className for GUI's */\n\t  var CSS_NAMESPACE = 'dg';\n\t\n\t  var HIDE_KEY_CODE = 72;\n\t\n\t  /** The only value shared between the JS and SCSS. Use caution. */\n\t  var CLOSE_BUTTON_HEIGHT = 20;\n\t\n\t  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';\n\t\n\t  var SUPPORTS_LOCAL_STORAGE = (function() {\n\t    try {\n\t      return 'localStorage' in window && window['localStorage'] !== null;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  })();\n\t\n\t  var SAVE_DIALOGUE;\n\t\n\t  /** Have we yet to create an autoPlace GUI? */\n\t  var auto_place_virgin = true;\n\t\n\t  /** Fixed position div that auto place GUI's go inside */\n\t  var auto_place_container;\n\t\n\t  /** Are we hiding the GUI's ? */\n\t  var hide = false;\n\t\n\t  /** GUI's which should be hidden */\n\t  var hideable_guis = [];\n\t\n\t  /**\n\t   * A lightweight controller library for JavaScript. It allows you to easily\n\t   * manipulate variables and fire functions on the fly.\n\t   * @class\n\t   *\n\t   * @member dat.gui\n\t   *\n\t   * @param {Object} [params]\n\t   * @param {String} [params.name] The name of this GUI.\n\t   * @param {Object} [params.load] JSON object representing the saved state of\n\t   * this GUI.\n\t   * @param {Boolean} [params.auto=true]\n\t   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.\n\t   * @param {Boolean} [params.closed] If true, starts closed\n\t   */\n\t  var GUI = function(params) {\n\t\n\t    var _this = this;\n\t\n\t    /**\n\t     * Outermost DOM Element\n\t     * @type DOMElement\n\t     */\n\t    this.domElement = document.createElement('div');\n\t    this.__ul = document.createElement('ul');\n\t    this.domElement.appendChild(this.__ul);\n\t\n\t    dom.addClass(this.domElement, CSS_NAMESPACE);\n\t\n\t    /**\n\t     * Nested GUI's by name\n\t     * @ignore\n\t     */\n\t    this.__folders = {};\n\t\n\t    this.__controllers = [];\n\t\n\t    /**\n\t     * List of objects I'm remembering for save, only used in top level GUI\n\t     * @ignore\n\t     */\n\t    this.__rememberedObjects = [];\n\t\n\t    /**\n\t     * Maps the index of remembered objects to a map of controllers, only used\n\t     * in top level GUI.\n\t     *\n\t     * @private\n\t     * @ignore\n\t     *\n\t     * @example\n\t     * [\n\t     *  {\n\t     *    propertyName: Controller,\n\t     *    anotherPropertyName: Controller\n\t     *  },\n\t     *  {\n\t     *    propertyName: Controller\n\t     *  }\n\t     * ]\n\t     */\n\t    this.__rememberedObjectIndecesToControllers = [];\n\t\n\t    this.__listening = [];\n\t\n\t    params = params || {};\n\t\n\t    // Default parameters\n\t    params = common.defaults(params, {\n\t      autoPlace: true,\n\t      width: GUI.DEFAULT_WIDTH\n\t    });\n\t\n\t    params = common.defaults(params, {\n\t      resizable: params.autoPlace,\n\t      hideable: params.autoPlace\n\t    });\n\t\n\t\n\t    if (!common.isUndefined(params.load)) {\n\t\n\t      // Explicit preset\n\t      if (params.preset) params.load.preset = params.preset;\n\t\n\t    } else {\n\t\n\t      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\n\t\n\t    }\n\t\n\t    if (common.isUndefined(params.parent) && params.hideable) {\n\t      hideable_guis.push(this);\n\t    }\n\t\n\t    // Only root level GUI's are resizable.\n\t    params.resizable = common.isUndefined(params.parent) && params.resizable;\n\t\n\t\n\t    if (params.autoPlace && common.isUndefined(params.scrollable)) {\n\t      params.scrollable = true;\n\t    }\n\t//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;\n\t\n\t    // Not part of params because I don't want people passing this in via\n\t    // constructor. Should be a 'remembered' value.\n\t    var use_local_storage =\n\t        SUPPORTS_LOCAL_STORAGE &&\n\t            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\n\t\n\t    Object.defineProperties(this,\n\t\n\t        /** @lends dat.gui.GUI.prototype */\n\t        {\n\t\n\t          /**\n\t           * The parent <code>GUI</code>\n\t           * @type dat.gui.GUI\n\t           */\n\t          parent: {\n\t            get: function() {\n\t              return params.parent;\n\t            }\n\t          },\n\t\n\t          scrollable: {\n\t            get: function() {\n\t              return params.scrollable;\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Handles <code>GUI</code>'s element placement for you\n\t           * @type Boolean\n\t           */\n\t          autoPlace: {\n\t            get: function() {\n\t              return params.autoPlace;\n\t            }\n\t          },\n\t\n\t          /**\n\t           * The identifier for a set of saved values\n\t           * @type String\n\t           */\n\t          preset: {\n\t\n\t            get: function() {\n\t              if (_this.parent) {\n\t                return _this.getRoot().preset;\n\t              } else {\n\t                return params.load.preset;\n\t              }\n\t            },\n\t\n\t            set: function(v) {\n\t              if (_this.parent) {\n\t                _this.getRoot().preset = v;\n\t              } else {\n\t                params.load.preset = v;\n\t              }\n\t              setPresetSelectIndex(this);\n\t              _this.revert();\n\t            }\n\t\n\t          },\n\t\n\t          /**\n\t           * The width of <code>GUI</code> element\n\t           * @type Number\n\t           */\n\t          width: {\n\t            get: function() {\n\t              return params.width;\n\t            },\n\t            set: function(v) {\n\t              params.width = v;\n\t              setWidth(_this, v);\n\t            }\n\t          },\n\t\n\t          /**\n\t           * The name of <code>GUI</code>. Used for folders. i.e\n\t           * a folder's name\n\t           * @type String\n\t           */\n\t          name: {\n\t            get: function() {\n\t              return params.name;\n\t            },\n\t            set: function(v) {\n\t              // TODO Check for collisions among sibling folders\n\t              params.name = v;\n\t              if (title_row_name) {\n\t                title_row_name.innerHTML = params.name;\n\t              }\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Whether the <code>GUI</code> is collapsed or not\n\t           * @type Boolean\n\t           */\n\t          closed: {\n\t            get: function() {\n\t              return params.closed;\n\t            },\n\t            set: function(v) {\n\t              params.closed = v;\n\t              if (params.closed) {\n\t                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\n\t              } else {\n\t                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\n\t              }\n\t              // For browsers that aren't going to respect the CSS transition,\n\t              // Lets just check our height against the window height right off\n\t              // the bat.\n\t              this.onResize();\n\t\n\t              if (_this.__closeButton) {\n\t                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\n\t              }\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Contains all presets\n\t           * @type Object\n\t           */\n\t          load: {\n\t            get: function() {\n\t              return params.load;\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Determines whether or not to use <a href=\"https://developer.mozilla.org/en/DOM/Storage#localStorage\">localStorage</a> as the means for\n\t           * <code>remember</code>ing\n\t           * @type Boolean\n\t           */\n\t          useLocalStorage: {\n\t\n\t            get: function() {\n\t              return use_local_storage;\n\t            },\n\t            set: function(bool) {\n\t              if (SUPPORTS_LOCAL_STORAGE) {\n\t                use_local_storage = bool;\n\t                if (bool) {\n\t                  dom.bind(window, 'unload', saveToLocalStorage);\n\t                } else {\n\t                  dom.unbind(window, 'unload', saveToLocalStorage);\n\t                }\n\t                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\n\t              }\n\t            }\n\t\n\t          }\n\t\n\t        });\n\t\n\t    // Are we a root level GUI?\n\t    if (common.isUndefined(params.parent)) {\n\t\n\t      params.closed = false;\n\t\n\t      dom.addClass(this.domElement, GUI.CLASS_MAIN);\n\t      dom.makeSelectable(this.domElement, false);\n\t\n\t      // Are we supposed to be loading locally?\n\t      if (SUPPORTS_LOCAL_STORAGE) {\n\t\n\t        if (use_local_storage) {\n\t\n\t          _this.useLocalStorage = true;\n\t\n\t          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\n\t\n\t          if (saved_gui) {\n\t            params.load = JSON.parse(saved_gui);\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t      this.__closeButton = document.createElement('div');\n\t      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\n\t      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\n\t      this.domElement.appendChild(this.__closeButton);\n\t\n\t      dom.bind(this.__closeButton, 'click', function() {\n\t\n\t        _this.closed = !_this.closed;\n\t\n\t\n\t      });\n\t\n\t\n\t      // Oh, you're a nested GUI!\n\t    } else {\n\t\n\t      if (params.closed === undefined) {\n\t        params.closed = true;\n\t      }\n\t\n\t      var title_row_name = document.createTextNode(params.name);\n\t      dom.addClass(title_row_name, 'controller-name');\n\t\n\t      var title_row = addRow(_this, title_row_name);\n\t\n\t      var on_click_title = function(e) {\n\t        e.preventDefault();\n\t        _this.closed = !_this.closed;\n\t        return false;\n\t      };\n\t\n\t      dom.addClass(this.__ul, GUI.CLASS_CLOSED);\n\t\n\t      dom.addClass(title_row, 'title');\n\t      dom.bind(title_row, 'click', on_click_title);\n\t\n\t      if (!params.closed) {\n\t        this.closed = false;\n\t      }\n\t\n\t    }\n\t\n\t    if (params.autoPlace) {\n\t\n\t      if (common.isUndefined(params.parent)) {\n\t\n\t        if (auto_place_virgin) {\n\t          auto_place_container = document.createElement('div');\n\t          dom.addClass(auto_place_container, CSS_NAMESPACE);\n\t          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);\n\t          document.body.appendChild(auto_place_container);\n\t          auto_place_virgin = false;\n\t        }\n\t\n\t        // Put it in the dom for you.\n\t        auto_place_container.appendChild(this.domElement);\n\t\n\t        // Apply the auto styles\n\t        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\n\t\n\t      }\n\t\n\t\n\t      // Make it not elastic.\n\t      if (!this.parent) setWidth(_this, params.width);\n\t\n\t    }\n\t\n\t    dom.bind(window, 'resize', function() { _this.onResize() });\n\t    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });\n\t    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });\n\t    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });\n\t    this.onResize();\n\t\n\t\n\t    if (params.resizable) {\n\t      addResizeHandle(this);\n\t    }\n\t\n\t    function saveToLocalStorage() {\n\t      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\n\t    }\n\t\n\t    var root = _this.getRoot();\n\t    function resetWidth() {\n\t        var root = _this.getRoot();\n\t        root.width += 1;\n\t        common.defer(function() {\n\t          root.width -= 1;\n\t        });\n\t      }\n\t\n\t      if (!params.parent) {\n\t        resetWidth();\n\t      }\n\t\n\t  };\n\t\n\t  GUI.toggleHide = function() {\n\t\n\t    hide = !hide;\n\t    common.each(hideable_guis, function(gui) {\n\t      gui.domElement.style.zIndex = hide ? -999 : 999;\n\t      gui.domElement.style.opacity = hide ? 0 : 1;\n\t    });\n\t  };\n\t\n\t  GUI.CLASS_AUTO_PLACE = 'a';\n\t  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\n\t  GUI.CLASS_MAIN = 'main';\n\t  GUI.CLASS_CONTROLLER_ROW = 'cr';\n\t  GUI.CLASS_TOO_TALL = 'taller-than-window';\n\t  GUI.CLASS_CLOSED = 'closed';\n\t  GUI.CLASS_CLOSE_BUTTON = 'close-button';\n\t  GUI.CLASS_DRAG = 'drag';\n\t\n\t  GUI.DEFAULT_WIDTH = 245;\n\t  GUI.TEXT_CLOSED = 'Close Controls';\n\t  GUI.TEXT_OPEN = 'Open Controls';\n\t\n\t  dom.bind(window, 'keydown', function(e) {\n\t\n\t    if (document.activeElement.type !== 'text' &&\n\t        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {\n\t      GUI.toggleHide();\n\t    }\n\t\n\t  }, false);\n\t\n\t  common.extend(\n\t\n\t      GUI.prototype,\n\t\n\t      /** @lends dat.gui.GUI */\n\t      {\n\t\n\t        /**\n\t         * @param object\n\t         * @param property\n\t         * @returns {dat.controllers.Controller} The new controller that was added.\n\t         * @instance\n\t         */\n\t        add: function(object, property) {\n\t\n\t          return add(\n\t              this,\n\t              object,\n\t              property,\n\t              {\n\t                factoryArgs: Array.prototype.slice.call(arguments, 2)\n\t              }\n\t          );\n\t\n\t        },\n\t\n\t        /**\n\t         * @param object\n\t         * @param property\n\t         * @returns {dat.controllers.ColorController} The new controller that was added.\n\t         * @instance\n\t         */\n\t        addColor: function(object, property) {\n\t\n\t          return add(\n\t              this,\n\t              object,\n\t              property,\n\t              {\n\t                color: true\n\t              }\n\t          );\n\t\n\t        },\n\t\n\t        /**\n\t         * @param controller\n\t         * @instance\n\t         */\n\t        remove: function(controller) {\n\t\n\t          // TODO listening?\n\t          this.__ul.removeChild(controller.__li);\n\t          this.__controllers.slice(this.__controllers.indexOf(controller), 1);\n\t          var _this = this;\n\t          common.defer(function() {\n\t            _this.onResize();\n\t          });\n\t\n\t        },\n\t\n\t        destroy: function() {\n\t\n\t          if (this.autoPlace) {\n\t            auto_place_container.removeChild(this.domElement);\n\t          }\n\t\n\t        },\n\t\n\t        /**\n\t         * @param name\n\t         * @returns {dat.gui.GUI} The new folder.\n\t         * @throws {Error} if this GUI already has a folder by the specified\n\t         * name\n\t         * @instance\n\t         */\n\t        addFolder: function(name) {\n\t\n\t          // We have to prevent collisions on names in order to have a key\n\t          // by which to remember saved values\n\t          if (this.__folders[name] !== undefined) {\n\t            throw new Error('You already have a folder in this GUI by the' +\n\t                ' name \"' + name + '\"');\n\t          }\n\t\n\t          var new_gui_params = { name: name, parent: this };\n\t\n\t          // We need to pass down the autoPlace trait so that we can\n\t          // attach event listeners to open/close folder actions to\n\t          // ensure that a scrollbar appears if the window is too short.\n\t          new_gui_params.autoPlace = this.autoPlace;\n\t\n\t          // Do we have saved appearance data for this folder?\n\t\n\t          if (this.load && // Anything loaded?\n\t              this.load.folders && // Was my parent a dead-end?\n\t              this.load.folders[name]) { // Did daddy remember me?\n\t\n\t            // Start me closed if I was closed\n\t            new_gui_params.closed = this.load.folders[name].closed;\n\t\n\t            // Pass down the loaded data\n\t            new_gui_params.load = this.load.folders[name];\n\t\n\t          }\n\t\n\t          var gui = new GUI(new_gui_params);\n\t          this.__folders[name] = gui;\n\t\n\t          var li = addRow(this, gui.domElement);\n\t          dom.addClass(li, 'folder');\n\t          return gui;\n\t\n\t        },\n\t\n\t        open: function() {\n\t          this.closed = false;\n\t        },\n\t\n\t        close: function() {\n\t          this.closed = true;\n\t        },\n\t\n\t        onResize: function() {\n\t\n\t          var root = this.getRoot();\n\t\n\t          if (root.scrollable) {\n\t\n\t            var top = dom.getOffset(root.__ul).top;\n\t            var h = 0;\n\t\n\t            common.each(root.__ul.childNodes, function(node) {\n\t              if (! (root.autoPlace && node === root.__save_row))\n\t                h += dom.getHeight(node);\n\t            });\n\t\n\t            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\n\t              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\n\t              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\n\t            } else {\n\t              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\n\t              root.__ul.style.height = 'auto';\n\t            }\n\t\n\t          }\n\t\n\t          if (root.__resize_handle) {\n\t            common.defer(function() {\n\t              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\n\t            });\n\t          }\n\t\n\t          if (root.__closeButton) {\n\t            root.__closeButton.style.width = root.width + 'px';\n\t          }\n\t\n\t        },\n\t\n\t        /**\n\t         * Mark objects for saving. The order of these objects cannot change as\n\t         * the GUI grows. When remembering new objects, append them to the end\n\t         * of the list.\n\t         *\n\t         * @param {Object...} objects\n\t         * @throws {Error} if not called on a top level GUI.\n\t         * @instance\n\t         */\n\t        remember: function() {\n\t\n\t          if (common.isUndefined(SAVE_DIALOGUE)) {\n\t            SAVE_DIALOGUE = new CenteredDiv();\n\t            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;\n\t          }\n\t\n\t          if (this.parent) {\n\t            throw new Error(\"You can only call remember on a top level GUI.\");\n\t          }\n\t\n\t          var _this = this;\n\t\n\t          common.each(Array.prototype.slice.call(arguments), function(object) {\n\t            if (_this.__rememberedObjects.length == 0) {\n\t              addSaveMenu(_this);\n\t            }\n\t            if (_this.__rememberedObjects.indexOf(object) == -1) {\n\t              _this.__rememberedObjects.push(object);\n\t            }\n\t          });\n\t\n\t          if (this.autoPlace) {\n\t            // Set save row width\n\t            setWidth(this, this.width);\n\t          }\n\t\n\t        },\n\t\n\t        /**\n\t         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.\n\t         * @instance\n\t         */\n\t        getRoot: function() {\n\t          var gui = this;\n\t          while (gui.parent) {\n\t            gui = gui.parent;\n\t          }\n\t          return gui;\n\t        },\n\t\n\t        /**\n\t         * @returns {Object} a JSON object representing the current state of\n\t         * this GUI as well as its remembered properties.\n\t         * @instance\n\t         */\n\t        getSaveObject: function() {\n\t\n\t          var toReturn = this.load;\n\t\n\t          toReturn.closed = this.closed;\n\t\n\t          // Am I remembering any values?\n\t          if (this.__rememberedObjects.length > 0) {\n\t\n\t            toReturn.preset = this.preset;\n\t\n\t            if (!toReturn.remembered) {\n\t              toReturn.remembered = {};\n\t            }\n\t\n\t            toReturn.remembered[this.preset] = getCurrentPreset(this);\n\t\n\t          }\n\t\n\t          toReturn.folders = {};\n\t          common.each(this.__folders, function(element, key) {\n\t            toReturn.folders[key] = element.getSaveObject();\n\t          });\n\t\n\t          return toReturn;\n\t\n\t        },\n\t\n\t        save: function() {\n\t\n\t          if (!this.load.remembered) {\n\t            this.load.remembered = {};\n\t          }\n\t\n\t          this.load.remembered[this.preset] = getCurrentPreset(this);\n\t          markPresetModified(this, false);\n\t\n\t        },\n\t\n\t        saveAs: function(presetName) {\n\t\n\t          if (!this.load.remembered) {\n\t\n\t            // Retain default values upon first save\n\t            this.load.remembered = {};\n\t            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\n\t\n\t          }\n\t\n\t          this.load.remembered[presetName] = getCurrentPreset(this);\n\t          this.preset = presetName;\n\t          addPresetOption(this, presetName, true);\n\t\n\t        },\n\t\n\t        revert: function(gui) {\n\t\n\t          common.each(this.__controllers, function(controller) {\n\t            // Make revert work on Default.\n\t            if (!this.getRoot().load.remembered) {\n\t              controller.setValue(controller.initialValue);\n\t            } else {\n\t              recallSavedValue(gui || this.getRoot(), controller);\n\t            }\n\t          }, this);\n\t\n\t          common.each(this.__folders, function(folder) {\n\t            folder.revert(folder);\n\t          });\n\t\n\t          if (!gui) {\n\t            markPresetModified(this.getRoot(), false);\n\t          }\n\t\n\t\n\t        },\n\t\n\t        listen: function(controller) {\n\t\n\t          var init = this.__listening.length == 0;\n\t          this.__listening.push(controller);\n\t          if (init) updateDisplays(this.__listening);\n\t\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  function add(gui, object, property, params) {\n\t\n\t    if (object[property] === undefined) {\n\t      throw new Error(\"Object \" + object + \" has no property \\\"\" + property + \"\\\"\");\n\t    }\n\t\n\t    var controller;\n\t\n\t    if (params.color) {\n\t\n\t      controller = new ColorController(object, property);\n\t\n\t    } else {\n\t\n\t      var factoryArgs = [object,property].concat(params.factoryArgs);\n\t      controller = controllerFactory.apply(gui, factoryArgs);\n\t\n\t    }\n\t\n\t    if (params.before instanceof Controller) {\n\t      params.before = params.before.__li;\n\t    }\n\t\n\t    recallSavedValue(gui, controller);\n\t\n\t    dom.addClass(controller.domElement, 'c');\n\t\n\t    var name = document.createElement('span');\n\t    dom.addClass(name, 'property-name');\n\t    name.innerHTML = controller.property;\n\t\n\t    var container = document.createElement('div');\n\t    container.appendChild(name);\n\t    container.appendChild(controller.domElement);\n\t\n\t    var li = addRow(gui, container, params.before);\n\t\n\t    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\n\t    dom.addClass(li, typeof controller.getValue());\n\t\n\t    augmentController(gui, li, controller);\n\t\n\t    gui.__controllers.push(controller);\n\t\n\t    return controller;\n\t\n\t  }\n\t\n\t  /**\n\t   * Add a row to the end of the GUI or before another row.\n\t   *\n\t   * @param gui\n\t   * @param [dom] If specified, inserts the dom content in the new row\n\t   * @param [liBefore] If specified, places the new row before another row\n\t   */\n\t  function addRow(gui, dom, liBefore) {\n\t    var li = document.createElement('li');\n\t    if (dom) li.appendChild(dom);\n\t    if (liBefore) {\n\t      gui.__ul.insertBefore(li, params.before);\n\t    } else {\n\t      gui.__ul.appendChild(li);\n\t    }\n\t    gui.onResize();\n\t    return li;\n\t  }\n\t\n\t  function augmentController(gui, li, controller) {\n\t\n\t    controller.__li = li;\n\t    controller.__gui = gui;\n\t\n\t    common.extend(controller, {\n\t\n\t      options: function(options) {\n\t\n\t        if (arguments.length > 1) {\n\t          controller.remove();\n\t\n\t          return add(\n\t              gui,\n\t              controller.object,\n\t              controller.property,\n\t              {\n\t                before: controller.__li.nextElementSibling,\n\t                factoryArgs: [common.toArray(arguments)]\n\t              }\n\t          );\n\t\n\t        }\n\t\n\t        if (common.isArray(options) || common.isObject(options)) {\n\t          controller.remove();\n\t\n\t          return add(\n\t              gui,\n\t              controller.object,\n\t              controller.property,\n\t              {\n\t                before: controller.__li.nextElementSibling,\n\t                factoryArgs: [options]\n\t              }\n\t          );\n\t\n\t        }\n\t\n\t      },\n\t\n\t      name: function(v) {\n\t        controller.__li.firstElementChild.firstElementChild.innerHTML = v;\n\t        return controller;\n\t      },\n\t\n\t      listen: function() {\n\t        controller.__gui.listen(controller);\n\t        return controller;\n\t      },\n\t\n\t      remove: function() {\n\t        controller.__gui.remove(controller);\n\t        return controller;\n\t      }\n\t\n\t    });\n\t\n\t    // All sliders should be accompanied by a box.\n\t    if (controller instanceof NumberControllerSlider) {\n\t\n\t      var box = new NumberControllerBox(controller.object, controller.property,\n\t          { min: controller.__min, max: controller.__max, step: controller.__step });\n\t\n\t      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {\n\t        var pc = controller[method];\n\t        var pb = box[method];\n\t        controller[method] = box[method] = function() {\n\t          var args = Array.prototype.slice.call(arguments);\n\t          pc.apply(controller, args);\n\t          return pb.apply(box, args);\n\t        }\n\t      });\n\t\n\t      dom.addClass(li, 'has-slider');\n\t      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\n\t\n\t    }\n\t    else if (controller instanceof NumberControllerBox) {\n\t\n\t      var r = function(returned) {\n\t\n\t        // Have we defined both boundaries?\n\t        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {\n\t\n\t          // Well, then lets just replace this with a slider.\n\t          controller.remove();\n\t          return add(\n\t              gui,\n\t              controller.object,\n\t              controller.property,\n\t              {\n\t                before: controller.__li.nextElementSibling,\n\t                factoryArgs: [controller.__min, controller.__max, controller.__step]\n\t              });\n\t\n\t        }\n\t\n\t        return returned;\n\t\n\t      };\n\t\n\t      controller.min = common.compose(r, controller.min);\n\t      controller.max = common.compose(r, controller.max);\n\t\n\t    }\n\t    else if (controller instanceof BooleanController) {\n\t\n\t      dom.bind(li, 'click', function() {\n\t        dom.fakeEvent(controller.__checkbox, 'click');\n\t      });\n\t\n\t      dom.bind(controller.__checkbox, 'click', function(e) {\n\t        e.stopPropagation(); // Prevents double-toggle\n\t      })\n\t\n\t    }\n\t    else if (controller instanceof FunctionController) {\n\t\n\t      dom.bind(li, 'click', function() {\n\t        dom.fakeEvent(controller.__button, 'click');\n\t      });\n\t\n\t      dom.bind(li, 'mouseover', function() {\n\t        dom.addClass(controller.__button, 'hover');\n\t      });\n\t\n\t      dom.bind(li, 'mouseout', function() {\n\t        dom.removeClass(controller.__button, 'hover');\n\t      });\n\t\n\t    }\n\t    else if (controller instanceof ColorController) {\n\t\n\t      dom.addClass(li, 'color');\n\t      controller.updateDisplay = common.compose(function(r) {\n\t        li.style.borderLeftColor = controller.__color.toString();\n\t        return r;\n\t      }, controller.updateDisplay);\n\t\n\t      controller.updateDisplay();\n\t\n\t    }\n\t\n\t    controller.setValue = common.compose(function(r) {\n\t      if (gui.getRoot().__preset_select && controller.isModified()) {\n\t        markPresetModified(gui.getRoot(), true);\n\t      }\n\t      return r;\n\t    }, controller.setValue);\n\t\n\t  }\n\t\n\t  function recallSavedValue(gui, controller) {\n\t\n\t    // Find the topmost GUI, that's where remembered objects live.\n\t    var root = gui.getRoot();\n\t\n\t    // Does the object we're controlling match anything we've been told to\n\t    // remember?\n\t    var matched_index = root.__rememberedObjects.indexOf(controller.object);\n\t\n\t    // Why yes, it does!\n\t    if (matched_index != -1) {\n\t\n\t      // Let me fetch a map of controllers for thcommon.isObject.\n\t      var controller_map =\n\t          root.__rememberedObjectIndecesToControllers[matched_index];\n\t\n\t      // Ohp, I believe this is the first controller we've created for this\n\t      // object. Lets make the map fresh.\n\t      if (controller_map === undefined) {\n\t        controller_map = {};\n\t        root.__rememberedObjectIndecesToControllers[matched_index] =\n\t            controller_map;\n\t      }\n\t\n\t      // Keep track of this controller\n\t      controller_map[controller.property] = controller;\n\t\n\t      // Okay, now have we saved any values for this controller?\n\t      if (root.load && root.load.remembered) {\n\t\n\t        var preset_map = root.load.remembered;\n\t\n\t        // Which preset are we trying to load?\n\t        var preset;\n\t\n\t        if (preset_map[gui.preset]) {\n\t\n\t          preset = preset_map[gui.preset];\n\t\n\t        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {\n\t\n\t          // Uhh, you can have the default instead?\n\t          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];\n\t\n\t        } else {\n\t\n\t          // Nada.\n\t\n\t          return;\n\t\n\t        }\n\t\n\t\n\t        // Did the loaded object remember thcommon.isObject?\n\t        if (preset[matched_index] &&\n\t\n\t          // Did we remember this particular property?\n\t            preset[matched_index][controller.property] !== undefined) {\n\t\n\t          // We did remember something for this guy ...\n\t          var value = preset[matched_index][controller.property];\n\t\n\t          // And that's what it is.\n\t          controller.initialValue = value;\n\t          controller.setValue(value);\n\t\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function getLocalStorageHash(gui, key) {\n\t    // TODO how does this deal with multiple GUI's?\n\t    return document.location.href + '.' + key;\n\t\n\t  }\n\t\n\t  function addSaveMenu(gui) {\n\t\n\t    var div = gui.__save_row = document.createElement('li');\n\t\n\t    dom.addClass(gui.domElement, 'has-save');\n\t\n\t    gui.__ul.insertBefore(div, gui.__ul.firstChild);\n\t\n\t    dom.addClass(div, 'save-row');\n\t\n\t    var gears = document.createElement('span');\n\t    gears.innerHTML = '&nbsp;';\n\t    dom.addClass(gears, 'button gears');\n\t\n\t    // TODO replace with FunctionController\n\t    var button = document.createElement('span');\n\t    button.innerHTML = 'Save';\n\t    dom.addClass(button, 'button');\n\t    dom.addClass(button, 'save');\n\t\n\t    var button2 = document.createElement('span');\n\t    button2.innerHTML = 'New';\n\t    dom.addClass(button2, 'button');\n\t    dom.addClass(button2, 'save-as');\n\t\n\t    var button3 = document.createElement('span');\n\t    button3.innerHTML = 'Revert';\n\t    dom.addClass(button3, 'button');\n\t    dom.addClass(button3, 'revert');\n\t\n\t    var select = gui.__preset_select = document.createElement('select');\n\t\n\t    if (gui.load && gui.load.remembered) {\n\t\n\t      common.each(gui.load.remembered, function(value, key) {\n\t        addPresetOption(gui, key, key == gui.preset);\n\t      });\n\t\n\t    } else {\n\t      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\n\t    }\n\t\n\t    dom.bind(select, 'change', function() {\n\t\n\t\n\t      for (var index = 0; index < gui.__preset_select.length; index++) {\n\t        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\n\t      }\n\t\n\t      gui.preset = this.value;\n\t\n\t    });\n\t\n\t    div.appendChild(select);\n\t    div.appendChild(gears);\n\t    div.appendChild(button);\n\t    div.appendChild(button2);\n\t    div.appendChild(button3);\n\t\n\t    if (SUPPORTS_LOCAL_STORAGE) {\n\t\n\t      var saveLocally = document.getElementById('dg-save-locally');\n\t      var explain = document.getElementById('dg-local-explain');\n\t\n\t      saveLocally.style.display = 'block';\n\t\n\t      var localStorageCheckBox = document.getElementById('dg-local-storage');\n\t\n\t      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\n\t        localStorageCheckBox.setAttribute('checked', 'checked');\n\t      }\n\t\n\t      function showHideExplain() {\n\t        explain.style.display = gui.useLocalStorage ? 'block' : 'none';\n\t      }\n\t\n\t      showHideExplain();\n\t\n\t      // TODO: Use a boolean controller, fool!\n\t      dom.bind(localStorageCheckBox, 'change', function() {\n\t        gui.useLocalStorage = !gui.useLocalStorage;\n\t        showHideExplain();\n\t      });\n\t\n\t    }\n\t\n\t    var newConstructorTextArea = document.getElementById('dg-new-constructor');\n\t\n\t    dom.bind(newConstructorTextArea, 'keydown', function(e) {\n\t      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {\n\t        SAVE_DIALOGUE.hide();\n\t      }\n\t    });\n\t\n\t    dom.bind(gears, 'click', function() {\n\t      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\n\t      SAVE_DIALOGUE.show();\n\t      newConstructorTextArea.focus();\n\t      newConstructorTextArea.select();\n\t    });\n\t\n\t    dom.bind(button, 'click', function() {\n\t      gui.save();\n\t    });\n\t\n\t    dom.bind(button2, 'click', function() {\n\t      var presetName = prompt('Enter a new preset name.');\n\t      if (presetName) gui.saveAs(presetName);\n\t    });\n\t\n\t    dom.bind(button3, 'click', function() {\n\t      gui.revert();\n\t    });\n\t\n\t//    div.appendChild(button2);\n\t\n\t  }\n\t\n\t  function addResizeHandle(gui) {\n\t\n\t    gui.__resize_handle = document.createElement('div');\n\t\n\t    common.extend(gui.__resize_handle.style, {\n\t\n\t      width: '6px',\n\t      marginLeft: '-3px',\n\t      height: '200px',\n\t      cursor: 'ew-resize',\n\t      position: 'absolute'\n\t//      border: '1px solid blue'\n\t\n\t    });\n\t\n\t    var pmouseX;\n\t\n\t    dom.bind(gui.__resize_handle, 'mousedown', dragStart);\n\t    dom.bind(gui.__closeButton, 'mousedown', dragStart);\n\t\n\t    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\n\t\n\t    function dragStart(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      pmouseX = e.clientX;\n\t\n\t      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\n\t      dom.bind(window, 'mousemove', drag);\n\t      dom.bind(window, 'mouseup', dragStop);\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function drag(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      gui.width += pmouseX - e.clientX;\n\t      gui.onResize();\n\t      pmouseX = e.clientX;\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function dragStop() {\n\t\n\t      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\n\t      dom.unbind(window, 'mousemove', drag);\n\t      dom.unbind(window, 'mouseup', dragStop);\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function setWidth(gui, w) {\n\t    gui.domElement.style.width = w + 'px';\n\t    // Auto placed save-rows are position fixed, so we have to\n\t    // set the width manually if we want it to bleed to the edge\n\t    if (gui.__save_row && gui.autoPlace) {\n\t      gui.__save_row.style.width = w + 'px';\n\t    }if (gui.__closeButton) {\n\t      gui.__closeButton.style.width = w + 'px';\n\t    }\n\t  }\n\t\n\t  function getCurrentPreset(gui, useInitialValues) {\n\t\n\t    var toReturn = {};\n\t\n\t    // For each object I'm remembering\n\t    common.each(gui.__rememberedObjects, function(val, index) {\n\t\n\t      var saved_values = {};\n\t\n\t      // The controllers I've made for thcommon.isObject by property\n\t      var controller_map =\n\t          gui.__rememberedObjectIndecesToControllers[index];\n\t\n\t      // Remember each value for each property\n\t      common.each(controller_map, function(controller, property) {\n\t        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();\n\t      });\n\t\n\t      // Save the values for thcommon.isObject\n\t      toReturn[index] = saved_values;\n\t\n\t    });\n\t\n\t    return toReturn;\n\t\n\t  }\n\t\n\t  function addPresetOption(gui, name, setSelected) {\n\t    var opt = document.createElement('option');\n\t    opt.innerHTML = name;\n\t    opt.value = name;\n\t    gui.__preset_select.appendChild(opt);\n\t    if (setSelected) {\n\t      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\n\t    }\n\t  }\n\t\n\t  function setPresetSelectIndex(gui) {\n\t    for (var index = 0; index < gui.__preset_select.length; index++) {\n\t      if (gui.__preset_select[index].value == gui.preset) {\n\t        gui.__preset_select.selectedIndex = index;\n\t      }\n\t    }\n\t  }\n\t\n\t  function markPresetModified(gui, modified) {\n\t    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\n\t//    console.log('mark', modified, opt);\n\t    if (modified) {\n\t      opt.innerHTML = opt.value + \"*\";\n\t    } else {\n\t      opt.innerHTML = opt.value;\n\t    }\n\t  }\n\t\n\t  function updateDisplays(controllerArray) {\n\t\n\t\n\t    if (controllerArray.length != 0) {\n\t\n\t      requestAnimationFrame(function() {\n\t        updateDisplays(controllerArray);\n\t      });\n\t\n\t    }\n\t\n\t    common.each(controllerArray, function(c) {\n\t      c.updateDisplay();\n\t    });\n\t\n\t  }\n\t\n\t  return GUI;\n\t\n\t})(dat.utils.css,\n\t\"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n      \\n    </div>\\n    \\n  </div>\\n\\n</div>\",\n\t\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\",\n\tdat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {\n\t\n\t      return function(object, property) {\n\t\n\t        var initialValue = object[property];\n\t\n\t        // Providing options?\n\t        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {\n\t          return new OptionController(object, property, arguments[2]);\n\t        }\n\t\n\t        // Providing a map?\n\t\n\t        if (common.isNumber(initialValue)) {\n\t\n\t          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {\n\t\n\t            // Has min and max.\n\t            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\n\t\n\t          } else {\n\t\n\t            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\n\t\n\t          }\n\t\n\t        }\n\t\n\t        if (common.isString(initialValue)) {\n\t          return new StringController(object, property);\n\t        }\n\t\n\t        if (common.isFunction(initialValue)) {\n\t          return new FunctionController(object, property, '');\n\t        }\n\t\n\t        if (common.isBoolean(initialValue)) {\n\t          return new BooleanController(object, property);\n\t        }\n\t\n\t      }\n\t\n\t    })(dat.controllers.OptionController,\n\tdat.controllers.NumberControllerBox,\n\tdat.controllers.NumberControllerSlider,\n\tdat.controllers.StringController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a text input to alter the string property of an object.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var StringController = function(object, property) {\n\t\n\t    StringController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t\n\t    this.__input = document.createElement('input');\n\t    this.__input.setAttribute('type', 'text');\n\t\n\t    dom.bind(this.__input, 'keyup', onChange);\n\t    dom.bind(this.__input, 'change', onChange);\n\t    dom.bind(this.__input, 'blur', onBlur);\n\t    dom.bind(this.__input, 'keydown', function(e) {\n\t      if (e.keyCode === 13) {\n\t        this.blur();\n\t      }\n\t    });\n\t    \n\t\n\t    function onChange() {\n\t      _this.setValue(_this.__input.value);\n\t    }\n\t\n\t    function onBlur() {\n\t      if (_this.__onFinishChange) {\n\t        _this.__onFinishChange.call(_this, _this.getValue());\n\t      }\n\t    }\n\t\n\t    this.updateDisplay();\n\t\n\t    this.domElement.appendChild(this.__input);\n\t\n\t  };\n\t\n\t  StringController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      StringController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t          // Stops the caret from moving on account of:\n\t          // keyup -> setValue -> updateDisplay\n\t          if (!dom.isActive(this.__input)) {\n\t            this.__input.value = this.getValue();\n\t          }\n\t          return StringController.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return StringController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common),\n\tdat.controllers.FunctionController,\n\tdat.controllers.BooleanController,\n\tdat.utils.common),\n\tdat.controllers.Controller,\n\tdat.controllers.BooleanController,\n\tdat.controllers.FunctionController,\n\tdat.controllers.NumberControllerBox,\n\tdat.controllers.NumberControllerSlider,\n\tdat.controllers.OptionController,\n\tdat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {\n\t\n\t  var ColorController = function(object, property) {\n\t\n\t    ColorController.superclass.call(this, object, property);\n\t\n\t    this.__color = new Color(this.getValue());\n\t    this.__temp = new Color(0);\n\t\n\t    var _this = this;\n\t\n\t    this.domElement = document.createElement('div');\n\t\n\t    dom.makeSelectable(this.domElement, false);\n\t\n\t    this.__selector = document.createElement('div');\n\t    this.__selector.className = 'selector';\n\t\n\t    this.__saturation_field = document.createElement('div');\n\t    this.__saturation_field.className = 'saturation-field';\n\t\n\t    this.__field_knob = document.createElement('div');\n\t    this.__field_knob.className = 'field-knob';\n\t    this.__field_knob_border = '2px solid ';\n\t\n\t    this.__hue_knob = document.createElement('div');\n\t    this.__hue_knob.className = 'hue-knob';\n\t\n\t    this.__hue_field = document.createElement('div');\n\t    this.__hue_field.className = 'hue-field';\n\t\n\t    this.__input = document.createElement('input');\n\t    this.__input.type = 'text';\n\t    this.__input_textShadow = '0 1px 1px ';\n\t\n\t    dom.bind(this.__input, 'keydown', function(e) {\n\t      if (e.keyCode === 13) { // on enter\n\t        onBlur.call(this);\n\t      }\n\t    });\n\t\n\t    dom.bind(this.__input, 'blur', onBlur);\n\t\n\t    dom.bind(this.__selector, 'mousedown', function(e) {\n\t\n\t      dom\n\t        .addClass(this, 'drag')\n\t        .bind(window, 'mouseup', function(e) {\n\t          dom.removeClass(_this.__selector, 'drag');\n\t        });\n\t\n\t    });\n\t\n\t    var value_field = document.createElement('div');\n\t\n\t    common.extend(this.__selector.style, {\n\t      width: '122px',\n\t      height: '102px',\n\t      padding: '3px',\n\t      backgroundColor: '#222',\n\t      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\n\t    });\n\t\n\t    common.extend(this.__field_knob.style, {\n\t      position: 'absolute',\n\t      width: '12px',\n\t      height: '12px',\n\t      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),\n\t      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\n\t      borderRadius: '12px',\n\t      zIndex: 1\n\t    });\n\t    \n\t    common.extend(this.__hue_knob.style, {\n\t      position: 'absolute',\n\t      width: '15px',\n\t      height: '2px',\n\t      borderRight: '4px solid #fff',\n\t      zIndex: 1\n\t    });\n\t\n\t    common.extend(this.__saturation_field.style, {\n\t      width: '100px',\n\t      height: '100px',\n\t      border: '1px solid #555',\n\t      marginRight: '3px',\n\t      display: 'inline-block',\n\t      cursor: 'pointer'\n\t    });\n\t\n\t    common.extend(value_field.style, {\n\t      width: '100%',\n\t      height: '100%',\n\t      background: 'none'\n\t    });\n\t    \n\t    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');\n\t\n\t    common.extend(this.__hue_field.style, {\n\t      width: '15px',\n\t      height: '100px',\n\t      display: 'inline-block',\n\t      border: '1px solid #555',\n\t      cursor: 'ns-resize'\n\t    });\n\t\n\t    hueGradient(this.__hue_field);\n\t\n\t    common.extend(this.__input.style, {\n\t      outline: 'none',\n\t//      width: '120px',\n\t      textAlign: 'center',\n\t//      padding: '4px',\n\t//      marginBottom: '6px',\n\t      color: '#fff',\n\t      border: 0,\n\t      fontWeight: 'bold',\n\t      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'\n\t    });\n\t\n\t    dom.bind(this.__saturation_field, 'mousedown', fieldDown);\n\t    dom.bind(this.__field_knob, 'mousedown', fieldDown);\n\t\n\t    dom.bind(this.__hue_field, 'mousedown', function(e) {\n\t      setH(e);\n\t      dom.bind(window, 'mousemove', setH);\n\t      dom.bind(window, 'mouseup', unbindH);\n\t    });\n\t\n\t    function fieldDown(e) {\n\t      setSV(e);\n\t      // document.body.style.cursor = 'none';\n\t      dom.bind(window, 'mousemove', setSV);\n\t      dom.bind(window, 'mouseup', unbindSV);\n\t    }\n\t\n\t    function unbindSV() {\n\t      dom.unbind(window, 'mousemove', setSV);\n\t      dom.unbind(window, 'mouseup', unbindSV);\n\t      // document.body.style.cursor = 'default';\n\t    }\n\t\n\t    function onBlur() {\n\t      var i = interpret(this.value);\n\t      if (i !== false) {\n\t        _this.__color.__state = i;\n\t        _this.setValue(_this.__color.toOriginal());\n\t      } else {\n\t        this.value = _this.__color.toString();\n\t      }\n\t    }\n\t\n\t    function unbindH() {\n\t      dom.unbind(window, 'mousemove', setH);\n\t      dom.unbind(window, 'mouseup', unbindH);\n\t    }\n\t\n\t    this.__saturation_field.appendChild(value_field);\n\t    this.__selector.appendChild(this.__field_knob);\n\t    this.__selector.appendChild(this.__saturation_field);\n\t    this.__selector.appendChild(this.__hue_field);\n\t    this.__hue_field.appendChild(this.__hue_knob);\n\t\n\t    this.domElement.appendChild(this.__input);\n\t    this.domElement.appendChild(this.__selector);\n\t\n\t    this.updateDisplay();\n\t\n\t    function setSV(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      var w = dom.getWidth(_this.__saturation_field);\n\t      var o = dom.getOffset(_this.__saturation_field);\n\t      var s = (e.clientX - o.left + document.body.scrollLeft) / w;\n\t      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;\n\t\n\t      if (v > 1) v = 1;\n\t      else if (v < 0) v = 0;\n\t\n\t      if (s > 1) s = 1;\n\t      else if (s < 0) s = 0;\n\t\n\t      _this.__color.v = v;\n\t      _this.__color.s = s;\n\t\n\t      _this.setValue(_this.__color.toOriginal());\n\t\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function setH(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      var s = dom.getHeight(_this.__hue_field);\n\t      var o = dom.getOffset(_this.__hue_field);\n\t      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;\n\t\n\t      if (h > 1) h = 1;\n\t      else if (h < 0) h = 0;\n\t\n\t      _this.__color.h = h * 360;\n\t\n\t      _this.setValue(_this.__color.toOriginal());\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t  };\n\t\n\t  ColorController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      ColorController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t\n\t          var i = interpret(this.getValue());\n\t\n\t          if (i !== false) {\n\t\n\t            var mismatch = false;\n\t\n\t            // Check for mismatch on the interpreted value.\n\t\n\t            common.each(Color.COMPONENTS, function(component) {\n\t              if (!common.isUndefined(i[component]) &&\n\t                  !common.isUndefined(this.__color.__state[component]) &&\n\t                  i[component] !== this.__color.__state[component]) {\n\t                mismatch = true;\n\t                return {}; // break\n\t              }\n\t            }, this);\n\t\n\t            // If nothing diverges, we keep our previous values\n\t            // for statefulness, otherwise we recalculate fresh\n\t            if (mismatch) {\n\t              common.extend(this.__color.__state, i);\n\t            }\n\t\n\t          }\n\t\n\t          common.extend(this.__temp.__state, this.__color.__state);\n\t\n\t          this.__temp.a = 1;\n\t\n\t          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;\n\t          var _flip = 255 - flip;\n\t\n\t          common.extend(this.__field_knob.style, {\n\t            marginLeft: 100 * this.__color.s - 7 + 'px',\n\t            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\n\t            backgroundColor: this.__temp.toString(),\n\t            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'\n\t          });\n\t\n\t          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'\n\t\n\t          this.__temp.s = 1;\n\t          this.__temp.v = 1;\n\t\n\t          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());\n\t\n\t          common.extend(this.__input.style, {\n\t            backgroundColor: this.__input.value = this.__color.toString(),\n\t            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',\n\t            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'\n\t          });\n\t\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t  \n\t  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];\n\t  \n\t  function linearGradient(elem, x, a, b) {\n\t    elem.style.background = '';\n\t    common.each(vendors, function(vendor) {\n\t      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';\n\t    });\n\t  }\n\t  \n\t  function hueGradient(elem) {\n\t    elem.style.background = '';\n\t    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'\n\t    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t  }\n\t\n\t\n\t  return ColorController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.color.Color = (function (interpret, math, toString, common) {\n\t\n\t  var Color = function() {\n\t\n\t    this.__state = interpret.apply(this, arguments);\n\t\n\t    if (this.__state === false) {\n\t      throw 'Failed to interpret color arguments';\n\t    }\n\t\n\t    this.__state.a = this.__state.a || 1;\n\t\n\t\n\t  };\n\t\n\t  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\t\n\t  common.extend(Color.prototype, {\n\t\n\t    toString: function() {\n\t      return toString(this);\n\t    },\n\t\n\t    toOriginal: function() {\n\t      return this.__state.conversion.write(this);\n\t    }\n\t\n\t  });\n\t\n\t  defineRGBComponent(Color.prototype, 'r', 2);\n\t  defineRGBComponent(Color.prototype, 'g', 1);\n\t  defineRGBComponent(Color.prototype, 'b', 0);\n\t\n\t  defineHSVComponent(Color.prototype, 'h');\n\t  defineHSVComponent(Color.prototype, 's');\n\t  defineHSVComponent(Color.prototype, 'v');\n\t\n\t  Object.defineProperty(Color.prototype, 'a', {\n\t\n\t    get: function() {\n\t      return this.__state.a;\n\t    },\n\t\n\t    set: function(v) {\n\t      this.__state.a = v;\n\t    }\n\t\n\t  });\n\t\n\t  Object.defineProperty(Color.prototype, 'hex', {\n\t\n\t    get: function() {\n\t\n\t      if (!this.__state.space !== 'HEX') {\n\t        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n\t      }\n\t\n\t      return this.__state.hex;\n\t\n\t    },\n\t\n\t    set: function(v) {\n\t\n\t      this.__state.space = 'HEX';\n\t      this.__state.hex = v;\n\t\n\t    }\n\t\n\t  });\n\t\n\t  function defineRGBComponent(target, component, componentHexIndex) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'RGB') {\n\t          return this.__state[component];\n\t        }\n\t\n\t        recalculateRGB(this, component, componentHexIndex);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'RGB') {\n\t          recalculateRGB(this, component, componentHexIndex);\n\t          this.__state.space = 'RGB';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function defineHSVComponent(target, component) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'HSV')\n\t          return this.__state[component];\n\t\n\t        recalculateHSV(this);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'HSV') {\n\t          recalculateHSV(this);\n\t          this.__state.space = 'HSV';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function recalculateRGB(color, component, componentHexIndex) {\n\t\n\t    if (color.__state.space === 'HEX') {\n\t\n\t      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\t\n\t    } else if (color.__state.space === 'HSV') {\n\t\n\t      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\t\n\t    } else {\n\t\n\t      throw 'Corrupted color state';\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function recalculateHSV(color) {\n\t\n\t    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\t\n\t    common.extend(color.__state,\n\t        {\n\t          s: result.s,\n\t          v: result.v\n\t        }\n\t    );\n\t\n\t    if (!common.isNaN(result.h)) {\n\t      color.__state.h = result.h;\n\t    } else if (common.isUndefined(color.__state.h)) {\n\t      color.__state.h = 0;\n\t    }\n\t\n\t  }\n\t\n\t  return Color;\n\t\n\t})(dat.color.interpret,\n\tdat.color.math = (function () {\n\t\n\t  var tmpComponent;\n\t\n\t  return {\n\t\n\t    hsv_to_rgb: function(h, s, v) {\n\t\n\t      var hi = Math.floor(h / 60) % 6;\n\t\n\t      var f = h / 60 - Math.floor(h / 60);\n\t      var p = v * (1.0 - s);\n\t      var q = v * (1.0 - (f * s));\n\t      var t = v * (1.0 - ((1.0 - f) * s));\n\t      var c = [\n\t        [v, t, p],\n\t        [q, v, p],\n\t        [p, v, t],\n\t        [p, q, v],\n\t        [t, p, v],\n\t        [v, p, q]\n\t      ][hi];\n\t\n\t      return {\n\t        r: c[0] * 255,\n\t        g: c[1] * 255,\n\t        b: c[2] * 255\n\t      };\n\t\n\t    },\n\t\n\t    rgb_to_hsv: function(r, g, b) {\n\t\n\t      var min = Math.min(r, g, b),\n\t          max = Math.max(r, g, b),\n\t          delta = max - min,\n\t          h, s;\n\t\n\t      if (max != 0) {\n\t        s = delta / max;\n\t      } else {\n\t        return {\n\t          h: NaN,\n\t          s: 0,\n\t          v: 0\n\t        };\n\t      }\n\t\n\t      if (r == max) {\n\t        h = (g - b) / delta;\n\t      } else if (g == max) {\n\t        h = 2 + (b - r) / delta;\n\t      } else {\n\t        h = 4 + (r - g) / delta;\n\t      }\n\t      h /= 6;\n\t      if (h < 0) {\n\t        h += 1;\n\t      }\n\t\n\t      return {\n\t        h: h * 360,\n\t        s: s,\n\t        v: max / 255\n\t      };\n\t    },\n\t\n\t    rgb_to_hex: function(r, g, b) {\n\t      var hex = this.hex_with_component(0, 2, r);\n\t      hex = this.hex_with_component(hex, 1, g);\n\t      hex = this.hex_with_component(hex, 0, b);\n\t      return hex;\n\t    },\n\t\n\t    component_from_hex: function(hex, componentIndex) {\n\t      return (hex >> (componentIndex * 8)) & 0xFF;\n\t    },\n\t\n\t    hex_with_component: function(hex, componentIndex, value) {\n\t      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n\t    }\n\t\n\t  }\n\t\n\t})(),\n\tdat.color.toString,\n\tdat.utils.common),\n\tdat.color.interpret,\n\tdat.utils.common),\n\tdat.utils.requestAnimationFrame = (function () {\n\t\n\t  /**\n\t   * requirejs version of Paul Irish's RequestAnimationFrame\n\t   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t   */\n\t\n\t  return window.webkitRequestAnimationFrame ||\n\t      window.mozRequestAnimationFrame ||\n\t      window.oRequestAnimationFrame ||\n\t      window.msRequestAnimationFrame ||\n\t      function(callback, element) {\n\t\n\t        window.setTimeout(callback, 1000 / 60);\n\t\n\t      };\n\t})(),\n\tdat.dom.CenteredDiv = (function (dom, common) {\n\t\n\t\n\t  var CenteredDiv = function() {\n\t\n\t    this.backgroundElement = document.createElement('div');\n\t    common.extend(this.backgroundElement.style, {\n\t      backgroundColor: 'rgba(0,0,0,0.8)',\n\t      top: 0,\n\t      left: 0,\n\t      display: 'none',\n\t      zIndex: '1000',\n\t      opacity: 0,\n\t      WebkitTransition: 'opacity 0.2s linear'\n\t    });\n\t\n\t    dom.makeFullscreen(this.backgroundElement);\n\t    this.backgroundElement.style.position = 'fixed';\n\t\n\t    this.domElement = document.createElement('div');\n\t    common.extend(this.domElement.style, {\n\t      position: 'fixed',\n\t      display: 'none',\n\t      zIndex: '1001',\n\t      opacity: 0,\n\t      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'\n\t    });\n\t\n\t\n\t    document.body.appendChild(this.backgroundElement);\n\t    document.body.appendChild(this.domElement);\n\t\n\t    var _this = this;\n\t    dom.bind(this.backgroundElement, 'click', function() {\n\t      _this.hide();\n\t    });\n\t\n\t\n\t  };\n\t\n\t  CenteredDiv.prototype.show = function() {\n\t\n\t    var _this = this;\n\t    \n\t\n\t\n\t    this.backgroundElement.style.display = 'block';\n\t\n\t    this.domElement.style.display = 'block';\n\t    this.domElement.style.opacity = 0;\n\t//    this.domElement.style.top = '52%';\n\t    this.domElement.style.webkitTransform = 'scale(1.1)';\n\t\n\t    this.layout();\n\t\n\t    common.defer(function() {\n\t      _this.backgroundElement.style.opacity = 1;\n\t      _this.domElement.style.opacity = 1;\n\t      _this.domElement.style.webkitTransform = 'scale(1)';\n\t    });\n\t\n\t  };\n\t\n\t  CenteredDiv.prototype.hide = function() {\n\t\n\t    var _this = this;\n\t\n\t    var hide = function() {\n\t\n\t      _this.domElement.style.display = 'none';\n\t      _this.backgroundElement.style.display = 'none';\n\t\n\t      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\n\t      dom.unbind(_this.domElement, 'transitionend', hide);\n\t      dom.unbind(_this.domElement, 'oTransitionEnd', hide);\n\t\n\t    };\n\t\n\t    dom.bind(this.domElement, 'webkitTransitionEnd', hide);\n\t    dom.bind(this.domElement, 'transitionend', hide);\n\t    dom.bind(this.domElement, 'oTransitionEnd', hide);\n\t\n\t    this.backgroundElement.style.opacity = 0;\n\t//    this.domElement.style.top = '48%';\n\t    this.domElement.style.opacity = 0;\n\t    this.domElement.style.webkitTransform = 'scale(1.1)';\n\t\n\t  };\n\t\n\t  CenteredDiv.prototype.layout = function() {\n\t    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';\n\t    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';\n\t  };\n\t  \n\t  function lockScroll(e) {\n\t    console.log(e);\n\t  }\n\t\n\t  return CenteredDiv;\n\t\n\t})(dat.dom.dom,\n\tdat.utils.common),\n\tdat.dom.dom,\n\tdat.utils.common);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * dat-gui JavaScript Controller Library\n\t * http://code.google.com/p/dat-gui\n\t *\n\t * Copyright 2011 Data Arts Team, Google Creative Lab\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t */\n\t\n\t/** @namespace */\n\tvar dat = module.exports = dat || {};\n\t\n\t/** @namespace */\n\tdat.color = dat.color || {};\n\t\n\t/** @namespace */\n\tdat.utils = dat.utils || {};\n\t\n\tdat.utils.common = (function () {\n\t  \n\t  var ARR_EACH = Array.prototype.forEach;\n\t  var ARR_SLICE = Array.prototype.slice;\n\t\n\t  /**\n\t   * Band-aid methods for things that should be a lot easier in JavaScript.\n\t   * Implementation and structure inspired by underscore.js\n\t   * http://documentcloud.github.com/underscore/\n\t   */\n\t\n\t  return { \n\t    \n\t    BREAK: {},\n\t  \n\t    extend: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (!this.isUndefined(obj[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t      \n\t    },\n\t    \n\t    defaults: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (this.isUndefined(target[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t    \n\t    },\n\t    \n\t    compose: function() {\n\t      var toCall = ARR_SLICE.call(arguments);\n\t            return function() {\n\t              var args = ARR_SLICE.call(arguments);\n\t              for (var i = toCall.length -1; i >= 0; i--) {\n\t                args = [toCall[i].apply(this, args)];\n\t              }\n\t              return args[0];\n\t            }\n\t    },\n\t    \n\t    each: function(obj, itr, scope) {\n\t\n\t      \n\t      if (ARR_EACH && obj.forEach === ARR_EACH) { \n\t        \n\t        obj.forEach(itr, scope);\n\t        \n\t      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n\t        \n\t        for (var key = 0, l = obj.length; key < l; key++)\n\t          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n\t            return;\n\t            \n\t      } else {\n\t\n\t        for (var key in obj) \n\t          if (itr.call(scope, obj[key], key) === this.BREAK)\n\t            return;\n\t            \n\t      }\n\t            \n\t    },\n\t    \n\t    defer: function(fnc) {\n\t      setTimeout(fnc, 0);\n\t    },\n\t    \n\t    toArray: function(obj) {\n\t      if (obj.toArray) return obj.toArray();\n\t      return ARR_SLICE.call(obj);\n\t    },\n\t\n\t    isUndefined: function(obj) {\n\t      return obj === undefined;\n\t    },\n\t    \n\t    isNull: function(obj) {\n\t      return obj === null;\n\t    },\n\t    \n\t    isNaN: function(obj) {\n\t      return obj !== obj;\n\t    },\n\t    \n\t    isArray: Array.isArray || function(obj) {\n\t      return obj.constructor === Array;\n\t    },\n\t    \n\t    isObject: function(obj) {\n\t      return obj === Object(obj);\n\t    },\n\t    \n\t    isNumber: function(obj) {\n\t      return obj === obj+0;\n\t    },\n\t    \n\t    isString: function(obj) {\n\t      return obj === obj+'';\n\t    },\n\t    \n\t    isBoolean: function(obj) {\n\t      return obj === false || obj === true;\n\t    },\n\t    \n\t    isFunction: function(obj) {\n\t      return Object.prototype.toString.call(obj) === '[object Function]';\n\t    }\n\t  \n\t  };\n\t    \n\t})();\n\t\n\t\n\tdat.color.toString = (function (common) {\n\t\n\t  return function(color) {\n\t\n\t    if (color.a == 1 || common.isUndefined(color.a)) {\n\t\n\t      var s = color.hex.toString(16);\n\t      while (s.length < 6) {\n\t        s = '0' + s;\n\t      }\n\t\n\t      return '#' + s;\n\t\n\t    } else {\n\t\n\t      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\t\n\t    }\n\t\n\t  }\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.Color = dat.color.Color = (function (interpret, math, toString, common) {\n\t\n\t  var Color = function() {\n\t\n\t    this.__state = interpret.apply(this, arguments);\n\t\n\t    if (this.__state === false) {\n\t      throw 'Failed to interpret color arguments';\n\t    }\n\t\n\t    this.__state.a = this.__state.a || 1;\n\t\n\t\n\t  };\n\t\n\t  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\t\n\t  common.extend(Color.prototype, {\n\t\n\t    toString: function() {\n\t      return toString(this);\n\t    },\n\t\n\t    toOriginal: function() {\n\t      return this.__state.conversion.write(this);\n\t    }\n\t\n\t  });\n\t\n\t  defineRGBComponent(Color.prototype, 'r', 2);\n\t  defineRGBComponent(Color.prototype, 'g', 1);\n\t  defineRGBComponent(Color.prototype, 'b', 0);\n\t\n\t  defineHSVComponent(Color.prototype, 'h');\n\t  defineHSVComponent(Color.prototype, 's');\n\t  defineHSVComponent(Color.prototype, 'v');\n\t\n\t  Object.defineProperty(Color.prototype, 'a', {\n\t\n\t    get: function() {\n\t      return this.__state.a;\n\t    },\n\t\n\t    set: function(v) {\n\t      this.__state.a = v;\n\t    }\n\t\n\t  });\n\t\n\t  Object.defineProperty(Color.prototype, 'hex', {\n\t\n\t    get: function() {\n\t\n\t      if (!this.__state.space !== 'HEX') {\n\t        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n\t      }\n\t\n\t      return this.__state.hex;\n\t\n\t    },\n\t\n\t    set: function(v) {\n\t\n\t      this.__state.space = 'HEX';\n\t      this.__state.hex = v;\n\t\n\t    }\n\t\n\t  });\n\t\n\t  function defineRGBComponent(target, component, componentHexIndex) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'RGB') {\n\t          return this.__state[component];\n\t        }\n\t\n\t        recalculateRGB(this, component, componentHexIndex);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'RGB') {\n\t          recalculateRGB(this, component, componentHexIndex);\n\t          this.__state.space = 'RGB';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function defineHSVComponent(target, component) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'HSV')\n\t          return this.__state[component];\n\t\n\t        recalculateHSV(this);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'HSV') {\n\t          recalculateHSV(this);\n\t          this.__state.space = 'HSV';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function recalculateRGB(color, component, componentHexIndex) {\n\t\n\t    if (color.__state.space === 'HEX') {\n\t\n\t      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\t\n\t    } else if (color.__state.space === 'HSV') {\n\t\n\t      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\t\n\t    } else {\n\t\n\t      throw 'Corrupted color state';\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function recalculateHSV(color) {\n\t\n\t    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\t\n\t    common.extend(color.__state,\n\t        {\n\t          s: result.s,\n\t          v: result.v\n\t        }\n\t    );\n\t\n\t    if (!common.isNaN(result.h)) {\n\t      color.__state.h = result.h;\n\t    } else if (common.isUndefined(color.__state.h)) {\n\t      color.__state.h = 0;\n\t    }\n\t\n\t  }\n\t\n\t  return Color;\n\t\n\t})(dat.color.interpret = (function (toString, common) {\n\t\n\t  var result, toReturn;\n\t\n\t  var interpret = function() {\n\t\n\t    toReturn = false;\n\t\n\t    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\t\n\t    common.each(INTERPRETATIONS, function(family) {\n\t\n\t      if (family.litmus(original)) {\n\t\n\t        common.each(family.conversions, function(conversion, conversionName) {\n\t\n\t          result = conversion.read(original);\n\t\n\t          if (toReturn === false && result !== false) {\n\t            toReturn = result;\n\t            result.conversionName = conversionName;\n\t            result.conversion = conversion;\n\t            return common.BREAK;\n\t\n\t          }\n\t\n\t        });\n\t\n\t        return common.BREAK;\n\t\n\t      }\n\t\n\t    });\n\t\n\t    return toReturn;\n\t\n\t  };\n\t\n\t  var INTERPRETATIONS = [\n\t\n\t    // Strings\n\t    {\n\t\n\t      litmus: common.isString,\n\t\n\t      conversions: {\n\t\n\t        THREE_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt(\n\t                  '0x' +\n\t                      test[1].toString() + test[1].toString() +\n\t                      test[2].toString() + test[2].toString() +\n\t                      test[3].toString() + test[3].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        SIX_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9]{6})$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt('0x' + test[1].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGB: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGBA: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3]),\n\t              a: parseFloat(test[4])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Numbers\n\t    {\n\t\n\t      litmus: common.isNumber,\n\t\n\t      conversions: {\n\t\n\t        HEX: {\n\t          read: function(original) {\n\t            return {\n\t              space: 'HEX',\n\t              hex: original,\n\t              conversionName: 'HEX'\n\t            }\n\t          },\n\t\n\t          write: function(color) {\n\t            return color.hex;\n\t          }\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Arrays\n\t    {\n\t\n\t      litmus: common.isArray,\n\t\n\t      conversions: {\n\t\n\t        RGB_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 3) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b];\n\t          }\n\t\n\t        },\n\t\n\t        RGBA_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 4) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2],\n\t              a: original[3]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b, color.a];\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Objects\n\t    {\n\t\n\t      litmus: common.isObject,\n\t\n\t      conversions: {\n\t\n\t        RGBA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        RGB_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b\n\t            }\n\t          }\n\t        },\n\t\n\t        HSVA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        HSV_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v\n\t            }\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t\n\t\n\t  ];\n\t\n\t  return interpret;\n\t\n\t\n\t})(dat.color.toString,\n\tdat.utils.common),\n\tdat.color.math = (function () {\n\t\n\t  var tmpComponent;\n\t\n\t  return {\n\t\n\t    hsv_to_rgb: function(h, s, v) {\n\t\n\t      var hi = Math.floor(h / 60) % 6;\n\t\n\t      var f = h / 60 - Math.floor(h / 60);\n\t      var p = v * (1.0 - s);\n\t      var q = v * (1.0 - (f * s));\n\t      var t = v * (1.0 - ((1.0 - f) * s));\n\t      var c = [\n\t        [v, t, p],\n\t        [q, v, p],\n\t        [p, v, t],\n\t        [p, q, v],\n\t        [t, p, v],\n\t        [v, p, q]\n\t      ][hi];\n\t\n\t      return {\n\t        r: c[0] * 255,\n\t        g: c[1] * 255,\n\t        b: c[2] * 255\n\t      };\n\t\n\t    },\n\t\n\t    rgb_to_hsv: function(r, g, b) {\n\t\n\t      var min = Math.min(r, g, b),\n\t          max = Math.max(r, g, b),\n\t          delta = max - min,\n\t          h, s;\n\t\n\t      if (max != 0) {\n\t        s = delta / max;\n\t      } else {\n\t        return {\n\t          h: NaN,\n\t          s: 0,\n\t          v: 0\n\t        };\n\t      }\n\t\n\t      if (r == max) {\n\t        h = (g - b) / delta;\n\t      } else if (g == max) {\n\t        h = 2 + (b - r) / delta;\n\t      } else {\n\t        h = 4 + (r - g) / delta;\n\t      }\n\t      h /= 6;\n\t      if (h < 0) {\n\t        h += 1;\n\t      }\n\t\n\t      return {\n\t        h: h * 360,\n\t        s: s,\n\t        v: max / 255\n\t      };\n\t    },\n\t\n\t    rgb_to_hex: function(r, g, b) {\n\t      var hex = this.hex_with_component(0, 2, r);\n\t      hex = this.hex_with_component(hex, 1, g);\n\t      hex = this.hex_with_component(hex, 0, b);\n\t      return hex;\n\t    },\n\t\n\t    component_from_hex: function(hex, componentIndex) {\n\t      return (hex >> (componentIndex * 8)) & 0xFF;\n\t    },\n\t\n\t    hex_with_component: function(hex, componentIndex, value) {\n\t      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n\t    }\n\t\n\t  }\n\t\n\t})(),\n\tdat.color.toString,\n\tdat.utils.common);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.THREE = __webpack_require__(3);\n\t\n\t(function () {\n\t  /**\n\t   * Cubeクラス\n\t   */\n\t  var Cube = window.Cube || {};\n\t\n\t  window.Cube = function () {\n\t    //Cubeクラスをイニシャライズ\n\t    p.init();\n\t  };\n\t\n\t  var p, s;\n\t\n\t  s = window.Cube;\n\t  p = s.prototype;\n\t\n\t  /**\n\t   * Cubeクラスイニシャライズ\n\t   **/\n\t  p.init = function () {\n\t    var self = this;\n\t\n\t    //cubeGeometry\n\t    self.cubeGeometry = new THREE.BoxGeometry(4, 4, 4);\n\t\n\t    //cubeMaterial\n\t    self.cubeMaterial = new THREE.MeshLambertMaterial({\n\t      color: 0xff0000, wireframe: false\n\t    });\n\t\n\t    //cube\n\t    self.CubeObject = new THREE.Mesh(self.cubeGeometry, self.cubeMaterial);\n\t    self.CubeObject.castShadow = true;\n\t    //CubeObjectを回転\n\t    self.CubeObject.position.x = -4;\n\t    self.CubeObject.position.y = 3;\n\t    self.CubeObject.position.z = 0;\n\t\n\t    //オブジェクトとしてCubeObject返す\n\t    return self.CubeObject;\n\t  };\n\t})();\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7c9e4fa24d023465f2db","var cats = require('./main.js');\n\n// console.log(cats);\n\n\n// WEBPACK FOOTER //\n// ./src/js/app.js","window.THREE = require('three');\nvar Stats = require('./libs/stats.js');\nvar dat　= require('dat-gui');\n\nrequire('./object/Cube.js');\n\n(function() {\n\n  var sample = window.sample || {};\n  window.sample = sample;\n\n  //初期化実行\n  $(function() {\n    new sample.MainDisplay();\n  });\n\n})();\n\n//Cubeをインスタンス化\nvar CubeObject = new Cube();\n\n\n\n(function(){\n  var sample = window.sample || {};\n  window.sample = sample;\n\n  /**\n   * メインクラス\n   */\n  sample.MainDisplay = function () {\n    //イニシャライズ\n    p.init();\n  };\n\n  var p, s;\n\n  s = sample.MainDisplay;\n  p = s.prototype;\n\n  var renderScene;\n\n  /**\n   * イニシャライズ\n   */\n  p.init = function () {\n    var self = this;\n\n    this.$window = $(window);\n    this.$MainDisplay = $('#WebGL-output');\n\n    //WebGL renderer\n    this.renderer = new THREE.WebGLRenderer();\n    if (!this.renderer) {\n      alert('Three.jsの初期化に失敗しました。');\n    }\n    this.renderer.setClearColor(new THREE.Color(0xEEEEEE));\n    this.renderer.setSize( window.innerWidth, window.innerHeight );\n    this.renderer.shadowMap.enabled = true;\n\n    // 高解像度対応\n    var pixelRatio = Math.min(window.devicePixelRatio || 1, 2);\n    this.renderer.setPixelRatio(pixelRatio);\n\n    //scene\n    this.scene = new THREE.Scene();\n\n    //camera\n    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n    this.camera.position.x = -30;\n    this.camera.position.y = 40;\n    this.camera.position.z = 30;\n    this.camera.lookAt(this.scene.position);\n\n    // window resize\n    this.$window.on('resize', function(e) {\n      self.onResize();\n    });\n\n    // resizeイベントを発火してキャンバスサイズをリサイズ\n    this.$window.trigger('resize');\n\n    //axes\n    // var axes = new THREE.AxisHelper(20);\n    // this.scene.add(axes);\n\n    //planeGeometry\n    var planeGeometry = new THREE.PlaneGeometry(60,20);\n\n    //planeMaterial\n    var planeMaterial = new THREE.MeshLambertMaterial({\n      color: 0xffffff\n    });\n\n    //plane\n    var plane = new THREE.Mesh(planeGeometry, planeMaterial);\n    plane.receiveShadow = true;\n    //planeを回転\n    plane.rotation.x = -0.5 * Math.PI;\n    plane.position.x = 15;\n    plane.position.y = 0;\n    plane.position.z = 0;\n    this.scene.add(plane);\n\n    //Cubeをシーンに追加\n    this.scene.add(CubeObject.init());\n\n    //sphereGeometry\n    // var sphereGeometry = new THREE.SphereGeometry(4, 20,20);\n    //\n    // //sphereMaterial\n    // var sphereMaterial = new THREE.MeshLambertMaterial({\n    //   color: 0x7777ff, wireframe: false\n    // });\n    //\n    // //sphere\n    // var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);\n    // sphere.castShadow = true;\n    // //sphereを回転\n    // sphere.position.x = 20;\n    // sphere.position.y = 4;\n    // sphere.position.z = 2;\n    // this.scene.add(sphere);\n\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    spotLight.position.set(-20, 30, -5);\n    spotLight.castShadow = true;\n    this.scene.add(spotLight);\n\n    document.getElementById(\"WebGL-output\").appendChild(this.renderer.domElement);\n\n\n    var stats = initStats();\n    renderScene = function () {\n      stats.update();\n      // rotate the cube around its axes\n      // CubeObject.init().rotation.x += 0.02;\n      // CubeObject.init().rotation.y += 0.02;\n      // CubeObject.init().rotation.z += 0.02;\n\n      // bounce the sphere up and down\n      // step += 0.04;\n      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\n      // render using requestAnimationFrame\n      this.updateAnimation();\n    }.bind(this);\n\n    // call the render function\n    var step = 0;\n    renderScene();\n\n\n    /**\n     * dat.gui\n     * dat.guiのコントローラーを定義\n     */\n    var controls = new function () {\n      this.rotationSpeed = 0.001;\n      this.bouncingSpeed = 0.001;\n    };\n\n    var gui = new dat.GUI();\n    gui.add(controls, 'rotationSpeed', 0, 0.1);\n    gui.add(controls, 'bouncingSpeed', 0, 0.1);\n\n    var render =  function() {\n      stats.update();\n      // rotate the cube around its axes\n      // cube.rotation.x += controls.rotationSpeed;\n      // cube.rotation.y += controls.rotationSpeed;\n      // cube.rotation.z += controls.rotationSpeed;\n\n      // bounce the sphere up and down\n      // step += controls.bouncingSpeed;\n      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\n      requestAnimationFrame(render);\n      this.renderer.render(this.scene, this.camera);\n    }.bind(this);\n    render();\n\n  };\n\n  //Stats表示設定\n  function initStats() {\n\n    var stats = new Stats();\n\n    stats.setMode(0); // 0: fps, 1: ms\n\n    // Align top-left\n    stats.domElement.style.position = 'absolute';\n    stats.domElement.style.left = '0px';\n    stats.domElement.style.top = '0px';\n\n    document.getElementById(\"Stats-output\").appendChild(stats.domElement);\n\n    return stats;\n  }\n\n  /**\n   * アニメーション開始\n   */\n  // p.start = function () {\n  //   var self = this;\n  //\n  //   var enterFrameHandler = function() {\n  //     requestAnimationFrame(enterFrameHandler);\n  //     self.update();\n  //   };\n  //\n  //   enterFrameHandler();\n  // };\n\n  /**\n   * アニメーションループ内で実行される\n   */\n  p.updateAnimation = function() {\n    requestAnimationFrame(renderScene);\n    this.renderer.render(this.scene, this.camera);\n  };\n\n\n  /**\n   * リサイズ処理\n   * @param {jQuery.Event} e - jQueryのイベントオブジェクト\n   */\n  p.onResize = function () {\n\n    this.width = this.$window.width();\n    this.height = this.$window.height();\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n\n    this.renderer.setSize(this.width, this.height);\n  };\n\n\n\n  // p.createDatGUIBox = function () {\n\n  // };\n\n})();\n\n\n// WEBPACK FOOTER //\n// ./src/js/main.js","/*!\n * jQuery JavaScript Library v3.1.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-09-22T22:30Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.1.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\tresolve.call( undefined, value );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.call( undefined, value );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\tscale = scale || \".5\";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\nfunction manipulationTarget( elem, content ) {\n\tif ( jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn elem.getElementsByTagName( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\"position:relative;display:block;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"top:1%;width:50%\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.marginRight = \"50%\";\n\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\"padding:0;margin-top:1px;position:absolute\";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE <=9 only\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === \"width\" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar val,\n\t\tvalueIsBorderBox = true,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Support: IE <=11 only\n\t// Running getBoundingClientRect on a disconnected node\n\t// in IE throws an error.\n\tif ( elem.getClientRects().length ) {\n\t\tval = elem.getBoundingClientRect()[ name ];\n\t}\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction raf() {\n\tif ( timerId ) {\n\t\twindow.requestAnimationFrame( raf );\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off or if document is hidden\n\tif ( jQuery.fx.off || document.hidden ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = window.requestAnimationFrame ?\n\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tif ( window.cancelAnimationFrame ) {\n\t\twindow.cancelAnimationFrame( timerId );\n\t} else {\n\t\twindow.clearInterval( timerId );\n\t}\n\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === \"string\" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar docElem, win, rect, doc,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\t// Make sure element is not hidden (display: none)\n\t\tif ( rect.width || rect.height ) {\n\t\t\tdoc = elem.ownerDocument;\n\t\t\twin = getWindow( doc );\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\treturn {\n\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\treturn rect;\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\njQuery.parseJSON = JSON.parse;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t} );\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\n\nreturn jQuery;\n} );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jquery/dist/jquery.js\n// module id = 2\n// module chunks = 0","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.THREE = global.THREE || {})));\n}(this, (function (exports) { 'use strict';\n\n\t// Polyfills\n\n\tif ( Number.EPSILON === undefined ) {\n\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n\t}\n\n\t//\n\n\tif ( Math.sign === undefined ) {\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\t\tMath.sign = function ( x ) {\n\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t\t};\n\n\t}\n\n\tif ( Function.prototype.name === undefined ) {\n\n\t\t// Missing in IE9-11.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\t\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tif ( Object.assign === undefined ) {\n\n\t\t// Missing in IE.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t\t( function () {\n\n\t\t\tObject.assign = function ( target ) {\n\n\t\t\t\t'use strict';\n\n\t\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t\t}\n\n\t\t\t\tvar output = Object( target );\n\n\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\n\t\t\t};\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\n\tfunction EventDispatcher() {}\n\n\tObject.assign( EventDispatcher.prototype, {\n\n\t\taddEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\t\tlisteners[ type ] = [];\n\n\t\t\t}\n\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\t\tlisteners[ type ].push( listener );\n\n\t\t\t}\n\n\t\t},\n\n\t\thasEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return false;\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdispatchEvent: function ( event ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tevent.target = this;\n\n\t\t\t\tvar array = [], i = 0;\n\t\t\t\tvar length = listenerArray.length;\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tvar REVISION = '82';\n\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\tvar CullFaceNone = 0;\n\tvar CullFaceBack = 1;\n\tvar CullFaceFront = 2;\n\tvar CullFaceFrontBack = 3;\n\tvar FrontFaceDirectionCW = 0;\n\tvar FrontFaceDirectionCCW = 1;\n\tvar BasicShadowMap = 0;\n\tvar PCFShadowMap = 1;\n\tvar PCFSoftShadowMap = 2;\n\tvar FrontSide = 0;\n\tvar BackSide = 1;\n\tvar DoubleSide = 2;\n\tvar FlatShading = 1;\n\tvar SmoothShading = 2;\n\tvar NoColors = 0;\n\tvar FaceColors = 1;\n\tvar VertexColors = 2;\n\tvar NoBlending = 0;\n\tvar NormalBlending = 1;\n\tvar AdditiveBlending = 2;\n\tvar SubtractiveBlending = 3;\n\tvar MultiplyBlending = 4;\n\tvar CustomBlending = 5;\n\tvar BlendingMode = {\n\t\tNoBlending: NoBlending,\n\t\tNormalBlending: NormalBlending,\n\t\tAdditiveBlending: AdditiveBlending,\n\t\tSubtractiveBlending: SubtractiveBlending,\n\t\tMultiplyBlending: MultiplyBlending,\n\t\tCustomBlending: CustomBlending\n\t};\n\tvar AddEquation = 100;\n\tvar SubtractEquation = 101;\n\tvar ReverseSubtractEquation = 102;\n\tvar MinEquation = 103;\n\tvar MaxEquation = 104;\n\tvar ZeroFactor = 200;\n\tvar OneFactor = 201;\n\tvar SrcColorFactor = 202;\n\tvar OneMinusSrcColorFactor = 203;\n\tvar SrcAlphaFactor = 204;\n\tvar OneMinusSrcAlphaFactor = 205;\n\tvar DstAlphaFactor = 206;\n\tvar OneMinusDstAlphaFactor = 207;\n\tvar DstColorFactor = 208;\n\tvar OneMinusDstColorFactor = 209;\n\tvar SrcAlphaSaturateFactor = 210;\n\tvar NeverDepth = 0;\n\tvar AlwaysDepth = 1;\n\tvar LessDepth = 2;\n\tvar LessEqualDepth = 3;\n\tvar EqualDepth = 4;\n\tvar GreaterEqualDepth = 5;\n\tvar GreaterDepth = 6;\n\tvar NotEqualDepth = 7;\n\tvar MultiplyOperation = 0;\n\tvar MixOperation = 1;\n\tvar AddOperation = 2;\n\tvar NoToneMapping = 0;\n\tvar LinearToneMapping = 1;\n\tvar ReinhardToneMapping = 2;\n\tvar Uncharted2ToneMapping = 3;\n\tvar CineonToneMapping = 4;\n\tvar UVMapping = 300;\n\tvar CubeReflectionMapping = 301;\n\tvar CubeRefractionMapping = 302;\n\tvar EquirectangularReflectionMapping = 303;\n\tvar EquirectangularRefractionMapping = 304;\n\tvar SphericalReflectionMapping = 305;\n\tvar CubeUVReflectionMapping = 306;\n\tvar CubeUVRefractionMapping = 307;\n\tvar TextureMapping = {\n\t\tUVMapping: UVMapping,\n\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t};\n\tvar RepeatWrapping = 1000;\n\tvar ClampToEdgeWrapping = 1001;\n\tvar MirroredRepeatWrapping = 1002;\n\tvar TextureWrapping = {\n\t\tRepeatWrapping: RepeatWrapping,\n\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t};\n\tvar NearestFilter = 1003;\n\tvar NearestMipMapNearestFilter = 1004;\n\tvar NearestMipMapLinearFilter = 1005;\n\tvar LinearFilter = 1006;\n\tvar LinearMipMapNearestFilter = 1007;\n\tvar LinearMipMapLinearFilter = 1008;\n\tvar TextureFilter = {\n\t\tNearestFilter: NearestFilter,\n\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\tLinearFilter: LinearFilter,\n\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t};\n\tvar UnsignedByteType = 1009;\n\tvar ByteType = 1010;\n\tvar ShortType = 1011;\n\tvar UnsignedShortType = 1012;\n\tvar IntType = 1013;\n\tvar UnsignedIntType = 1014;\n\tvar FloatType = 1015;\n\tvar HalfFloatType = 1016;\n\tvar UnsignedShort4444Type = 1017;\n\tvar UnsignedShort5551Type = 1018;\n\tvar UnsignedShort565Type = 1019;\n\tvar UnsignedInt248Type = 1020;\n\tvar AlphaFormat = 1021;\n\tvar RGBFormat = 1022;\n\tvar RGBAFormat = 1023;\n\tvar LuminanceFormat = 1024;\n\tvar LuminanceAlphaFormat = 1025;\n\tvar RGBEFormat = RGBAFormat;\n\tvar DepthFormat = 1026;\n\tvar DepthStencilFormat = 1027;\n\tvar RGB_S3TC_DXT1_Format = 2001;\n\tvar RGBA_S3TC_DXT1_Format = 2002;\n\tvar RGBA_S3TC_DXT3_Format = 2003;\n\tvar RGBA_S3TC_DXT5_Format = 2004;\n\tvar RGB_PVRTC_4BPPV1_Format = 2100;\n\tvar RGB_PVRTC_2BPPV1_Format = 2101;\n\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\n\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\n\tvar RGB_ETC1_Format = 2151;\n\tvar LoopOnce = 2200;\n\tvar LoopRepeat = 2201;\n\tvar LoopPingPong = 2202;\n\tvar InterpolateDiscrete = 2300;\n\tvar InterpolateLinear = 2301;\n\tvar InterpolateSmooth = 2302;\n\tvar ZeroCurvatureEnding = 2400;\n\tvar ZeroSlopeEnding = 2401;\n\tvar WrapAroundEnding = 2402;\n\tvar TrianglesDrawMode = 0;\n\tvar TriangleStripDrawMode = 1;\n\tvar TriangleFanDrawMode = 2;\n\tvar LinearEncoding = 3000;\n\tvar sRGBEncoding = 3001;\n\tvar GammaEncoding = 3007;\n\tvar RGBEEncoding = 3002;\n\tvar LogLuvEncoding = 3003;\n\tvar RGBM7Encoding = 3004;\n\tvar RGBM16Encoding = 3005;\n\tvar RGBDEncoding = 3006;\n\tvar BasicDepthPacking = 3200;\n\tvar RGBADepthPacking = 3201;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar _Math = {\n\n\t\tDEG2RAD: Math.PI / 180,\n\t\tRAD2DEG: 180 / Math.PI,\n\n\t\tgenerateUUID: function () {\n\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\tvar uuid = new Array( 36 );\n\t\t\tvar rnd = 0, r;\n\n\t\t\treturn function generateUUID() {\n\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn uuid.join( '' );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclamp: function ( value, min, max ) {\n\n\t\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t\t},\n\n\t\t// compute euclidian modulo of m % n\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\t\teuclideanModulo: function ( n, m ) {\n\n\t\t\treturn ( ( n % m ) + m ) % m;\n\n\t\t},\n\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t\t},\n\n\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\t\tlerp: function ( x, y, t ) {\n\n\t\t\treturn ( 1 - t ) * x + t * y;\n\n\t\t},\n\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\t\tsmoothstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * ( 3 - 2 * x );\n\n\t\t},\n\n\t\tsmootherstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t\t},\n\n\t\trandom16: function () {\n\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\treturn Math.random();\n\n\t\t},\n\n\t\t// Random integer from <low, high> interval\n\n\t\trandInt: function ( low, high ) {\n\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t\t},\n\n\t\t// Random float from <low, high> interval\n\n\t\trandFloat: function ( low, high ) {\n\n\t\t\treturn low + Math.random() * ( high - low );\n\n\t\t},\n\n\t\t// Random float from <-range/2, range/2> interval\n\n\t\trandFloatSpread: function ( range ) {\n\n\t\t\treturn range * ( 0.5 - Math.random() );\n\n\t\t},\n\n\t\tdegToRad: function ( degrees ) {\n\n\t\t\treturn degrees * _Math.DEG2RAD;\n\n\t\t},\n\n\t\tradToDeg: function ( radians ) {\n\n\t\t\treturn radians * _Math.RAD2DEG;\n\n\t\t},\n\n\t\tisPowerOfTwo: function ( value ) {\n\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t\t},\n\n\t\tnearestPowerOfTwo: function ( value ) {\n\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t\t},\n\n\t\tnextPowerOfTwo: function ( value ) {\n\n\t\t\tvalue --;\n\t\t\tvalue |= value >> 1;\n\t\t\tvalue |= value >> 2;\n\t\t\tvalue |= value >> 4;\n\t\t\tvalue |= value >> 8;\n\t\t\tvalue |= value >> 16;\n\t\t\tvalue ++;\n\n\t\t\treturn value;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author egraether / http://egraether.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tfunction Vector2( x, y ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\n\t}\n\n\tVector2.prototype = {\n\n\t\tconstructor: Vector2,\n\n\t\tisVector2: true,\n\n\t\tget width() {\n\n\t\t\treturn this.x;\n\n\t\t},\n\n\t\tset width( value ) {\n\n\t\t\tthis.x = value;\n\n\t\t},\n\n\t\tget height() {\n\n\t\t\treturn this.y;\n\n\t\t},\n\n\t\tset height( value ) {\n\n\t\t\tthis.y = value;\n\n\t\t},\n\n\t\t//\n\n\t\tset: function ( x, y ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v ) {\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector2();\n\t\t\t\t\tmax = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t\t},\n\n\t\tlengthManhattan: function() {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tangle: function () {\n\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\t\treturn angle;\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateAround: function ( center, angle ) {\n\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\t\tvar x = this.x - center.x;\n\t\t\tvar y = this.y - center.y;\n\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t */\n\n\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\tObject.defineProperty( this, 'id', { value: TextureIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.sourceFile = '';\n\n\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding !== undefined ? encoding :  LinearEncoding;\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t}\n\n\tTexture.DEFAULT_IMAGE = undefined;\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\n\tTexture.prototype = {\n\n\t\tconstructor: Texture,\n\n\t\tisTexture: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\t\tthis.mapping = source.mapping;\n\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\n\t\t\tthis.anisotropy = source.anisotropy;\n\n\t\t\tthis.format = source.format;\n\t\t\tthis.type = source.type;\n\n\t\t\tthis.offset.copy( source.offset );\n\t\t\tthis.repeat.copy( source.repeat );\n\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t\t}\n\n\t\t\tfunction getDataURL( image ) {\n\n\t\t\t\tvar canvas;\n\n\t\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\t\tcanvas = image;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\n\t\t\t\tmapping: this.mapping,\n\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\n\t\t\t\tflipY: this.flipY\n\t\t\t};\n\n\t\t\tif ( this.image !== undefined ) {\n\n\t\t\t\t// TODO: Move to THREE.Image\n\n\t\t\t\tvar image = this.image;\n\n\t\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\n\t\t\t\t}\n\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\toutput.image = image.uuid;\n\n\t\t\t}\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t},\n\n\t\ttransformUv: function ( uv ) {\n\n\t\t\tif ( this.mapping !== UVMapping )  return;\n\n\t\t\tuv.multiply( this.repeat );\n\t\t\tuv.add( this.offset );\n\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.flipY ) {\n\n\t\t\t\tuv.y = 1 - uv.y;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tObject.assign( Texture.prototype, EventDispatcher.prototype );\n\n\tvar count = 0;\n\tfunction TextureIdCount() { return count++; }\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector4( x, y, z, w ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\tthis.w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tVector4.prototype = {\n\n\t\tconstructor: Vector4,\n\n\t\tisVector4: true,\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( w ) {\n\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tcase 3: return this.w;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\t\t\tthis.w *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t\t// q is assumed to be normalized\n\n\t\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\t\tif ( s < 0.0001 ) {\n\n\t\t\t\t this.x = 1;\n\t\t\t\t this.y = 0;\n\t\t\t\t this.z = 0;\n\n\t\t\t} else {\n\n\t\t\t\t this.x = q.x / s;\n\t\t\t\t this.y = q.y / s;\n\t\t\t\t this.z = q.z / s;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\t\tte = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t\t}\n\n\t\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\t\tangle = Math.PI;\n\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.set( x, y, z, angle );\n\n\t\t\t\treturn this; // return 180 deg rotation\n\n\t\t\t}\n\n\t\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\tthis.w = Math.min( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\tthis.w = Math.max( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\tmax = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\t\tthis.w = Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\t\tthis.w = Math.ceil( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\t\tthis.w = Math.round( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\t\tthis.w = - this.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\t\tthis.w = array[ offset + 3 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\tarray[ offset + 3 ] = this.w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author szimek / https://github.com/szimek/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Marius Kintel / https://github.com/kintel\n\t */\n\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\tfunction WebGLRenderTarget( width, height, options ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\toptions = options || {};\n\n\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\n\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n\t}\n\n\tObject.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {\n\n\t\tisWebGLRenderTarget: true,\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\tthis.scissor.set( 0, 0, width, height );\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\n\t\t\tthis.viewport.copy( source.viewport );\n\n\t\t\tthis.texture = source.texture.clone();\n\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com\n\t */\n\n\tfunction WebGLRenderTargetCube( width, height, options ) {\n\n\t\tWebGLRenderTarget.call( this, width, height, options );\n\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\tthis.activeMipMapLevel = 0;\n\n\t}\n\n\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\n\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Quaternion( x, y, z, w ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tQuaternion.prototype = {\n\n\t\tconstructor: Quaternion,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget w () {\n\n\t\t\treturn this._w;\n\n\t\t},\n\n\t\tset w ( value ) {\n\n\t\t\tthis._w = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t\t},\n\n\t\tcopy: function ( quaternion ) {\n\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromEuler: function ( euler, update ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\t\tvar order = euler.order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t}\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos( halfAngle );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\ts;\n\n\t\t\tif ( trace > 0 ) {\n\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t\t} else if ( m22 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t\t} else {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromUnitVectors: function () {\n\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\t\tvar v1, r;\n\n\t\t\tvar EPS = 0.000001;\n\n\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\t\tif ( r < EPS ) {\n\n\t\t\t\t\tr = 0;\n\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t\t}\n\n\t\t\t\tthis._x = v1.x;\n\t\t\t\tthis._y = v1.y;\n\t\t\t\tthis._z = v1.z;\n\t\t\t\tthis._w = r;\n\n\t\t\t\treturn this.normalize();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tinverse: function () {\n\n\t\t\treturn this.conjugate().normalize();\n\n\t\t},\n\n\t\tconjugate: function () {\n\n\t\t\tthis._x *= - 1;\n\t\t\tthis._y *= - 1;\n\t\t\tthis._z *= - 1;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tvar l = this.length();\n\n\t\t\tif ( l === 0 ) {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\n\t\t\t} else {\n\n\t\t\t\tl = 1 / l;\n\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( q, p ) {\n\n\t\t\tif ( p !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyQuaternions( this, q );\n\n\t\t},\n\n\t\tpremultiply: function ( q ) {\n\n\t\t\treturn this.multiplyQuaternions( q, this );\n\n\t\t},\n\n\t\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tslerp: function ( qb, t ) {\n\n\t\t\tif ( t === 0 ) return this;\n\t\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\t\tthis._w = - qb._w;\n\t\t\t\tthis._x = - qb._x;\n\t\t\t\tthis._y = - qb._y;\n\t\t\t\tthis._z = - qb._z;\n\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t\t} else {\n\n\t\t\t\tthis.copy( qb );\n\n\t\t\t}\n\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( quaternion ) {\n\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis._x = array[ offset ];\n\t\t\tthis._y = array[ offset + 1 ];\n\t\t\tthis._z = array[ offset + 2 ];\n\t\t\tthis._w = array[ offset + 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\tObject.assign( Quaternion, {\n\n\t\tslerp: function( qa, qb, qm, t ) {\n\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t\t},\n\n\t\tslerpFlat: function(\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\t\tvar s = 1 - t,\n\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t\t}\n\n\t\t\t\tvar tDir = t * dir;\n\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdst[ dstOffset ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author *kile / http://kile.stravaganza.org/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector3( x, y, z ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\n\t}\n\n\tVector3.prototype = {\n\n\t\tconstructor: Vector3,\n\n\t\tisVector3: true,\n\n\t\tset: function ( x, y, z ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyEuler: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyEuler( euler ) {\n\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyAxisAngle: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix3: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyProjection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 projection matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyQuaternion: function ( q ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t\t// calculate quat * vector\n\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t\t// calculate result * inverse quat\n\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function project( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tunproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function unproject( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttransformDirection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\t\treturn this.normalize();\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector3();\n\t\t\t\t\tmax = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tcross: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\treturn this.crossVectors( v, w );\n\n\t\t\t}\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\tthis.z = x * v.y - y * v.x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossVectors: function ( a, b ) {\n\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tprojectOnVector: function ( vector ) {\n\n\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\n\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\n\t\t},\n\n\t\tprojectOnPlane: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\t\treturn this.sub( v1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\treflect: function () {\n\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\n\t\t\tvar v1;\n\n\t\t\treturn function reflect( normal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tangleTo: function ( v ) {\n\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t\t// clamp, to handle numerical problems\n\n\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t\t},\n\n\t\tsetFromSpherical: function( s ) {\n\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixPosition: function ( m ) {\n\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t\t},\n\n\t\tsetFromMatrixScale: function ( m ) {\n\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\t\tif ( typeof m === 'number' ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\tvar temp = m;\n\t\t\t\tm = index;\n\t\t\t\tindex = temp;\n\n\t\t\t}\n\n\t\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author jordi_ros / http://plattsoft.com\n\t * @author D1plo1d / http://github.com/D1plo1d\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author timknip / http://www.floorplanner.com/\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Matrix4() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix4.prototype = {\n\n\t\tconstructor: Matrix4,\n\n\t\tisMatrix4: true,\n\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new Matrix4().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tthis.elements.set( m.elements );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyPosition: function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\tte[ 14 ] = me[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\tthis.set(\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t0,       0,       0,       1\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractRotation: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function extractRotation( m ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeRotationFromEuler: function ( euler ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\tte[ 8 ] = d;\n\n\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\tte[ 9 ] = - b * c;\n\n\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\tte[ 8 ] = a * d;\n\n\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b;\n\n\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\tte[ 6 ] = b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\t\tte[ 2 ] = - d;\n\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\t\tte[ 1 ] = f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b * e;\n\n\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - f;\n\t\t\t\tte[ 8 ] = d * e;\n\n\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t\t}\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\tte[ 4 ] = xy - wz;\n\t\t\tte[ 8 ] = xz + wy;\n\n\t\t\tte[ 1 ] = xy + wz;\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\tte[ 9 ] = yz - wx;\n\n\t\t\tte[ 2 ] = xz - wy;\n\t\t\tte[ 6 ] = yz + wx;\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlookAt: function () {\n\n\t\t\tvar x, y, z;\n\n\t\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\t\tif ( x === undefined ) {\n\n\t\t\t\t\tx = new Vector3();\n\t\t\t\t\ty = new Vector3();\n\t\t\t\t\tz = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z = 1;\n\n\t\t\t\t}\n\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\ty.crossVectors( z, x );\n\n\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiply: function ( m, n ) {\n\n\t\t\tif ( n !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyMatrices( this, m );\n\n\t\t},\n\n\t\tpremultiply: function ( m ) {\n\n\t\t\treturn this.multiplyMatrices( m, this );\n\n\t\t},\n\n\t\tmultiplyMatrices: function ( a, b ) {\n\n\t\t\tvar ae = a.elements;\n\t\t\tvar be = b.elements;\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyToArray: function ( a, b, r ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tthis.multiplyMatrices( a, b );\n\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t\t//TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\treturn (\n\t\t\t\tn41 * (\n\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t) +\n\t\t\t\tn42 * (\n\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t) +\n\t\t\t\tn43 * (\n\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t) +\n\t\t\t\tn44 * (\n\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t)\n\n\t\t\t);\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar tmp;\n\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetPosition: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function getPosition() {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetPosition: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 12 ] = v.x;\n\t\t\tte[ 13 ] = v.y;\n\t\t\tte[ 14 ] = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tvar te = this.elements,\n\t\t\t\tme = m.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tscale: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetMaxScaleOnAxis: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t\t},\n\n\t\tmakeTranslation: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationX: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0,  0, 0,\n\t\t\t\t0, c, - s, 0,\n\t\t\t\t0, s,  c, 0,\n\t\t\t\t0, 0,  0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationY: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t- s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationZ: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\tc, - s, 0, 0,\n\t\t\t\ts,  c, 0, 0,\n\t\t\t\t0,  0, 1, 0,\n\t\t\t\t0,  0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\t\tvar c = Math.cos( angle );\n\t\t\tvar s = Math.sin( angle );\n\t\t\tvar t = 1 - c;\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\tvar tx = t * x, ty = t * y;\n\n\t\t\tthis.set(\n\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\t return this;\n\n\t\t},\n\n\t\tmakeScale: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\tx, 0, 0, 0,\n\t\t\t\t0, y, 0, 0,\n\t\t\t\t0, 0, z, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompose: function ( position, quaternion, scale ) {\n\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\tthis.scale( scale );\n\t\t\tthis.setPosition( position );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdecompose: function () {\n\n\t\t\tvar vector, matrix;\n\n\t\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tvector = new Vector3();\n\t\t\t\t\tmatrix = new Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\tvar det = this.determinant();\n\t\t\t\tif ( det < 0 ) {\n\n\t\t\t\t\tsx = - sx;\n\n\t\t\t\t}\n\n\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\tposition.z = te[ 14 ];\n\n\t\t\t\t// scale the rotation part\n\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\tvar invSZ = 1 / sz;\n\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\t\tscale.x = sx;\n\t\t\t\tscale.y = sy;\n\t\t\t\tscale.z = sz;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = 2 * near / ( right - left );\n\t\t\tvar y = 2 * near / ( top - bottom );\n\n\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\t\tvar ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );\n\t\t\tvar ymin = - ymax;\n\t\t\tvar xmin = ymin * aspect;\n\t\t\tvar xmax = ymax * aspect;\n\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t\t},\n\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar w = 1.0 / ( right - left );\n\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\tvar p = 1.0 / ( far - near );\n\n\t\t\tvar x = ( right + left ) * w;\n\t\t\tvar y = ( top + bottom ) * h;\n\t\t\tvar z = ( far + near ) * p;\n\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( matrix ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = matrix.elements;\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tCubeTexture.prototype = Object.create( Texture.prototype );\n\tCubeTexture.prototype.constructor = CubeTexture;\n\n\tCubeTexture.prototype.isCubeTexture = true;\n\n\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\n\t\tget: function () {\n\n\t\t\treturn this.image;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.image = value;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t *\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [renderer] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (renderer factorizations):\n\t *\n\t * .upload( gl, seq, values, renderer )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (renderer factorizations):\n\t *\n\t * .setValue( gl, name, value )\n\t *\n\t * \t\tsets uniform with  name 'name' to 'value'\n\t *\n\t * .set( gl, obj, prop )\n\t *\n\t * \t\tsets uniform from object and property with same name than uniform\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\n\tvar emptyTexture = new Texture();\n\tvar emptyCubeTexture = new CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tfunction UniformContainer() {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\tvar arrayCacheF32 = [];\n\tvar arrayCacheI32 = [];\n\n\t// Flattening for arrays of vectors and matrices\n\n\tfunction flatten( array, nBlocks, blockSize ) {\n\n\t\tvar firstElem = array[ 0 ];\n\n\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t// unoptimized: ! isNaN( firstElem )\n\t\t// see http://jacksondunstan.com/articles/983\n\n\t\tvar n = nBlocks * blockSize,\n\t\t\tr = arrayCacheF32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Float32Array( n );\n\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t}\n\n\t\tif ( nBlocks !== 0 ) {\n\n\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\toffset += blockSize;\n\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n\t// Texture unit allocation\n\n\tfunction allocTexUnits( renderer, n ) {\n\n\t\tvar r = arrayCacheI32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Int32Array( n );\n\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\treturn r;\n\n\t}\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t// Single scalar\n\n\tfunction setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }\n\tfunction setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }\n\n\t// Single float vector (from flat array or THREE.VectorN)\n\n\tfunction setValue2fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t}\n\n\tfunction setValue3fv( gl, v ) {\n\n\t\tif ( v.x !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\telse if ( v.r !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\telse\n\t\t\tgl.uniform3fv( this.addr, v );\n\n\t}\n\n\tfunction setValue4fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t}\n\n\t// Single matrix (from flat array or MatrixN)\n\n\tfunction setValue2fm( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue3fm( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue4fm( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t}\n\n\t// Single texture (2D / Cube)\n\n\tfunction setValueT1( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t}\n\n\tfunction setValueT6( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t}\n\n\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\tfunction setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }\n\tfunction setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }\n\tfunction setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }\n\n\t// Helper to pick the right setter for the singular case\n\n\tfunction getSingularSetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// Array of scalars\n\n\tfunction setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }\n\tfunction setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }\n\n\t// Array of vectors (flat or from THREE classes)\n\n\tfunction setValueV2a( gl, v ) {\n\n\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t}\n\n\tfunction setValueV3a( gl, v ) {\n\n\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t}\n\n\tfunction setValueV4a( gl, v ) {\n\n\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t}\n\n\t// Array of matrices (flat or from THREE clases)\n\n\tfunction setValueM2a( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t}\n\n\tfunction setValueM3a( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t}\n\n\tfunction setValueM4a( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t}\n\n\t// Array of textures (2D / Cube)\n\n\tfunction setValueT1a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\tfunction setValueT6a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\tfunction getPureArraySetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// --- Uniform Classes ---\n\n\tfunction SingleUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction StructuredUniform( id ) {\n\n\t\tthis.id = id;\n\n\t\tUniformContainer.call( this ); // mix-in\n\n\t}\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n\t// extracts\n\t// \t- the identifier (member name or array index)\n\t//  - followed by an optional right bracket (found when array index)\n\t//  - followed by an optional left bracket or dot (type of subscript)\n\t//\n\t// Note: These portions can be read in a non-overlapping fashion and\n\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t// in the uniform names.\n\n\tfunction addUniform( container, uniformObject ) {\n\n\t\tcontainer.seq.push( uniformObject );\n\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t}\n\n\tfunction parseUniform( activeInfo, addr, container ) {\n\n\t\tvar path = activeInfo.name,\n\t\t\tpathLength = path.length;\n\n\t\t// reset RegExp object, because of the early exit of a previous run\n\t\tRePathPart.lastIndex = 0;\n\n\t\tfor (; ;) {\n\n\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\tid = match[ 1 ],\n\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\tif ( subscript === undefined ||\n\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\tvar map = container.map,\n\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t}\n\n\t\t\t\tcontainer = next;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Root Container\n\n\tfunction WebGLUniforms( gl, program, renderer ) {\n\n\t\tUniformContainer.call( this );\n\n\t\tthis.renderer = renderer;\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\tpath = info.name,\n\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\t/**\n\t * Uniform Utilities\n\t */\n\n\tvar UniformsUtils = {\n\n\t\tmerge: function ( uniforms ) {\n\n\t\t\tvar merged = {};\n\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn merged;\n\n\t\t},\n\n\t\tclone: function ( uniforms_src ) {\n\n\t\t\tvar uniforms_dst = {};\n\n\t\t\tfor ( var u in uniforms_src ) {\n\n\t\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uniforms_dst;\n\n\t\t}\n\n\t};\n\n\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\n\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\n\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n\tvar bsdfs = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\n\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\n\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\n\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\n\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n\tvar defaultnormal_vertex = \"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\n\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\n\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\t#else\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\t#endif\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\n\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\\t\\t\\tdirectLight.color = pointLight.color;\\n\\t\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\t#include <normal_flip>\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\t#include <normal_flip>\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\n\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\n\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t \\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\t\\t\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n\tvar logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\n\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\n\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\n\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar normal_flip = \"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\n\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n\tvar project_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\n\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n\tvar tonemapping_pars_fragment = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\n\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\n\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\n\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\n\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar distanceRGBA_frag = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n\tvar distanceRGBA_vert = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\n\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\n\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight;\\n\\treflectedLight.directDiffuse = vec3( 0.0 );\\n\\treflectedLight.directSpecular = vec3( 0.0 );\\n\\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n}\\n\";\n\n\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar normal_frag = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n\tvar normal_vert = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvNormal = normalize( normalMatrix * normal );\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar shadow_frag = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n\tvar shadow_vert = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar ShaderChunk = {\n\t\talphamap_fragment: alphamap_fragment,\n\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\talphatest_fragment: alphatest_fragment,\n\t\taomap_fragment: aomap_fragment,\n\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\tbegin_vertex: begin_vertex,\n\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\tbsdfs: bsdfs,\n\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\tcolor_fragment: color_fragment,\n\t\tcolor_pars_fragment: color_pars_fragment,\n\t\tcolor_pars_vertex: color_pars_vertex,\n\t\tcolor_vertex: color_vertex,\n\t\tcommon: common,\n\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\temissivemap_fragment: emissivemap_fragment,\n\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\tencodings_fragment: encodings_fragment,\n\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\tenvmap_fragment: envmap_fragment,\n\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\tenvmap_vertex: envmap_vertex,\n\t\tfog_fragment: fog_fragment,\n\t\tfog_pars_fragment: fog_pars_fragment,\n\t\tlightmap_fragment: lightmap_fragment,\n\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\tlights_pars: lights_pars,\n\t\tlights_phong_fragment: lights_phong_fragment,\n\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\tlights_physical_fragment: lights_physical_fragment,\n\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\tlights_template: lights_template,\n\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\tmap_fragment: map_fragment,\n\t\tmap_pars_fragment: map_pars_fragment,\n\t\tmap_particle_fragment: map_particle_fragment,\n\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\tnormal_flip: normal_flip,\n\t\tnormal_fragment: normal_fragment,\n\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\tpacking: packing,\n\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\tproject_vertex: project_vertex,\n\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\tshadowmap_vertex: shadowmap_vertex,\n\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\tskinbase_vertex: skinbase_vertex,\n\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\tskinning_vertex: skinning_vertex,\n\t\tskinnormal_vertex: skinnormal_vertex,\n\t\tspecularmap_fragment: specularmap_fragment,\n\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\ttonemapping_fragment: tonemapping_fragment,\n\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\tuv_pars_fragment: uv_pars_fragment,\n\t\tuv_pars_vertex: uv_pars_vertex,\n\t\tuv_vertex: uv_vertex,\n\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\tuv2_vertex: uv2_vertex,\n\t\tworldpos_vertex: worldpos_vertex,\n\n\t\tcube_frag: cube_frag,\n\t\tcube_vert: cube_vert,\n\t\tdepth_frag: depth_frag,\n\t\tdepth_vert: depth_vert,\n\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\tequirect_frag: equirect_frag,\n\t\tequirect_vert: equirect_vert,\n\t\tlinedashed_frag: linedashed_frag,\n\t\tlinedashed_vert: linedashed_vert,\n\t\tmeshbasic_frag: meshbasic_frag,\n\t\tmeshbasic_vert: meshbasic_vert,\n\t\tmeshlambert_frag: meshlambert_frag,\n\t\tmeshlambert_vert: meshlambert_vert,\n\t\tmeshphong_frag: meshphong_frag,\n\t\tmeshphong_vert: meshphong_vert,\n\t\tmeshphysical_frag: meshphysical_frag,\n\t\tmeshphysical_vert: meshphysical_vert,\n\t\tnormal_frag: normal_frag,\n\t\tnormal_vert: normal_vert,\n\t\tpoints_frag: points_frag,\n\t\tpoints_vert: points_vert,\n\t\tshadow_frag: shadow_frag,\n\t\tshadow_vert: shadow_vert\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Color( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\n\t\t}\n\n\t\treturn this.setRGB( r, g, b );\n\n\t}\n\n\tColor.prototype = {\n\n\t\tconstructor: Color,\n\n\t\tisColor: true,\n\n\t\tr: 1, g: 1, b: 1,\n\n\t\tset: function ( value ) {\n\n\t\t\tif ( (value && value.isColor) ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHex: function ( hex ) {\n\n\t\t\thex = Math.floor( hex );\n\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetRGB: function ( r, g, b ) {\n\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHSL: function () {\n\n\t\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\n\t\t\t\tif ( s === 0 ) {\n\n\t\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetStyle: function ( style ) {\n\n\t\t\tfunction handleAlpha( string ) {\n\n\t\t\t\tif ( string === undefined ) return;\n\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar m;\n\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t\t// rgb / hsl\n\n\t\t\t\tvar color;\n\t\t\t\tvar name = m[ 1 ];\n\t\t\t\tvar components = m[ 2 ];\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t\t// hex color\n\n\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\tvar size = hex.length;\n\n\t\t\t\tif ( size === 3 ) {\n\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( style && style.length > 0 ) {\n\n\t\t\t\t// color keywords\n\t\t\t\tvar hex = ColorKeywords[ style ];\n\n\t\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t\t// red\n\t\t\t\t\tthis.setHex( hex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// unknown color\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t\t},\n\n\t\tcopy: function ( color ) {\n\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertGammaToLinear: function () {\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tthis.r = r * r;\n\t\t\tthis.g = g * g;\n\t\t\tthis.b = b * b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertLinearToGamma: function () {\n\n\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\tthis.b = Math.sqrt( this.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetHex: function () {\n\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t\t},\n\n\t\tgetHexString: function () {\n\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t\t},\n\n\t\tgetHSL: function ( optionalTarget ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tvar max = Math.max( r, g, b );\n\t\t\tvar min = Math.min( r, g, b );\n\n\t\t\tvar hue, saturation;\n\t\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\t\tif ( min === max ) {\n\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\n\t\t\t} else {\n\n\t\t\t\tvar delta = max - min;\n\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\t\tswitch ( max ) {\n\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\n\t\t\t}\n\n\t\t\thsl.h = hue;\n\t\t\thsl.s = saturation;\n\t\t\thsl.l = lightness;\n\n\t\t\treturn hsl;\n\n\t\t},\n\n\t\tgetStyle: function () {\n\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t\t},\n\n\t\toffsetHSL: function ( h, s, l ) {\n\n\t\t\tvar hsl = this.getHSL();\n\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( color ) {\n\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddColors: function ( color1, color2 ) {\n\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function( color ) {\n\n\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( color ) {\n\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerp: function ( color, alpha ) {\n\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( c ) {\n\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.r = array[ offset ];\n\t\t\tthis.g = array[ offset + 1 ];\n\t\t\tthis.b = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.r;\n\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\tarray[ offset + 2 ] = this.b;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\treturn this.getHex();\n\n\t\t}\n\n\t};\n\n\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\n\tvar UniformsLib = {\n\n\t\tcommon: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },\n\n\t\t\tspecularMap: { value: null },\n\t\t\talphaMap: { value: null },\n\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\treflectivity: { value: 1.0 },\n\t\t\trefractionRatio: { value: 0.98 }\n\n\t\t},\n\n\t\taomap: {\n\n\t\t\taoMap: { value: null },\n\t\t\taoMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\tlightmap: {\n\n\t\t\tlightMap: { value: null },\n\t\t\tlightMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\temissivemap: {\n\n\t\t\temissiveMap: { value: null }\n\n\t\t},\n\n\t\tbumpmap: {\n\n\t\t\tbumpMap: { value: null },\n\t\t\tbumpScale: { value: 1 }\n\n\t\t},\n\n\t\tnormalmap: {\n\n\t\t\tnormalMap: { value: null },\n\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t\t},\n\n\t\tdisplacementmap: {\n\n\t\t\tdisplacementMap: { value: null },\n\t\t\tdisplacementScale: { value: 1 },\n\t\t\tdisplacementBias: { value: 0 }\n\n\t\t},\n\n\t\troughnessmap: {\n\n\t\t\troughnessMap: { value: null }\n\n\t\t},\n\n\t\tmetalnessmap: {\n\n\t\t\tmetalnessMap: { value: null }\n\n\t\t},\n\n\t\tfog: {\n\n\t\t\tfogDensity: { value: 0.00025 },\n\t\t\tfogNear: { value: 1 },\n\t\t\tfogFar: { value: 2000 },\n\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t\t},\n\n\t\tlights: {\n\n\t\t\tambientLightColor: { value: [] },\n\n\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tcolor: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\t\tspotLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdirection: {},\n\t\t\t\tdistance: {},\n\t\t\t\tconeCos: {},\n\t\t\t\tpenumbraCos: {},\n\t\t\t\tdecay: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tspotShadowMap: { value: [] },\n\t\t\tspotShadowMatrix: { value: [] },\n\n\t\t\tpointLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdecay: {},\n\t\t\t\tdistance: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tpointShadowMap: { value: [] },\n\t\t\tpointShadowMatrix: { value: [] },\n\n\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tskyColor: {},\n\t\t\t\tgroundColor: {}\n\t\t\t} }\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\t\t\tsize: { value: 1.0 },\n\t\t\tscale: { value: 1.0 },\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t */\n\n\tvar ShaderLib = {\n\n\t\tbasic: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t\t},\n\n\t\tlambert: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t\t},\n\n\t\tphong: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\tspecular : { value: new Color( 0x111111 ) },\n\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t\t},\n\n\t\tstandard: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\tmetalness: { value: 0 },\n\t\t\t\t\tenvMapIntensity : { value: 1 }, // temporary\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.points,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\tfragmentShader: ShaderChunk.points_frag\n\n\t\t},\n\n\t\tdashed: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.fog,\n\n\t\t\t\t{\n\t\t\t\t\tscale    : { value: 1 },\n\t\t\t\t\tdashSize : { value: 1 },\n\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t\t},\n\n\t\tdepth: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.displacementmap\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t\t},\n\n\t\tnormal: {\n\n\t\t\tuniforms: {\n\n\t\t\t\topacity : { value: 1.0 }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tcube: {\n\n\t\t\tuniforms: {\n\t\t\t\ttCube: { value: null },\n\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tequirect: {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t\ttFlip: { value: - 1 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t\t},\n\n\t\tdistanceRGBA: {\n\n\t\t\tuniforms: {\n\n\t\t\t\tlightPos: { value: new Vector3() }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t\t}\n\n\t};\n\n\tShaderLib.physical = {\n\n\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\tShaderLib.standard.uniforms,\n\n\t\t\t{\n\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Box2( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\n\t}\n\n\tBox2.prototype = {\n\n\t\tconstructor: Box2,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlarePlugin( renderer, flares ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar shader, program, attributes, uniforms;\n\n\t\tvar tempTexture, occlusionTexture;\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t- 1,  1,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\t// buffers\n\n\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\telementBuffer    = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\t// textures\n\n\t\t\ttempTexture      = gl.createTexture();\n\t\t\tocclusionTexture = gl.createTexture();\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tshader = {\n\n\t\t\t\tvertexShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" ),\n\n\t\t\t\tfragmentShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t// pink square\n\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t\t// restore\n\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t\t// flare\n\n\t\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" )\n\n\t\t\t};\n\n\t\t\tprogram = createProgram( shader );\n\n\t\t\tattributes = {\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t};\n\n\t\t}\n\n\t\t/*\n\t\t * Render lens flares\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t *         reads these back and calculates occlusion.\n\t\t */\n\n\t\tthis.render = function ( scene, camera, viewport ) {\n\n\t\t\tif ( flares.length === 0 ) return;\n\n\t\t\tvar tempPosition = new Vector3();\n\n\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\t\tvar size = 16 / viewport.w,\n\t\t\t\tscale = new Vector2( size * invAspect, size );\n\n\t\t\tvar screenPosition = new Vector3( 1, 1, 0 ),\n\t\t\t\tscreenPositionPixels = new Vector2( 1, 1 );\n\n\t\t\tvar validArea = new Box2();\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t// setup gl and common used attribs/uniforms\n\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.setDepthWrite( false );\n\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t\t// calc object screen position\n\n\t\t\t\tvar flare = flares[ i ];\n\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t\t// setup arrays for gl programs\n\n\t\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t\t// screen cull\n\n\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// render pink quad\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// restore graphics\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// update object positions\n\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// render flares\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\tstate.setDepthWrite( true );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram( shader ) {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\t\tgl.compileShader( fragmentShader );\n\t\t\tgl.compileShader( vertexShader );\n\n\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\tgl.attachShader( program, vertexShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpritePlugin( renderer, sprites ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar program, attributes, uniforms;\n\n\t\tvar texture;\n\n\t\t// decompose matrixWorld\n\n\t\tvar spritePosition = new Vector3();\n\t\tvar spriteRotation = new Quaternion();\n\t\tvar spriteScale = new Vector3();\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\telementBuffer = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\tprogram = createProgram();\n\n\t\t\tattributes = {\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t};\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = 8;\n\t\t\tcanvas.height = 8;\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.fillStyle = 'white';\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\t\ttexture = new Texture( canvas );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( sprites.length === 0 ) return;\n\n\t\t\t// setup gl\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.BLEND );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\t\tvar oldFogType = 0;\n\t\t\tvar sceneFogType = 0;\n\t\t\tvar fog = scene.fog;\n\n\t\t\tif ( fog ) {\n\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\t\tif ( (fog && fog.isFog) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\toldFogType = 1;\n\t\t\t\t\tsceneFogType = 1;\n\n\t\t\t\t} else if ( (fog && fog.isFogExp2) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\toldFogType = 2;\n\t\t\t\t\tsceneFogType = 2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\toldFogType = 0;\n\t\t\t\tsceneFogType = 0;\n\n\t\t\t}\n\n\n\t\t\t// update positions and sort\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t\t}\n\n\t\t\tsprites.sort( painterSortStable );\n\n\t\t\t// render all sprites\n\n\t\t\tvar scale = [];\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\tvar material = sprite.material;\n\n\t\t\t\tif ( material.visible === false ) continue;\n\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\t\tvar fogType = 0;\n\n\t\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\t\tfogType = sceneFogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\toldFogType = fogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram() {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform float rotation;',\n\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t\t'attribute vec2 position;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform vec3 color;',\n\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t'uniform float opacity;',\n\n\t\t\t\t'uniform int fogType;',\n\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t'uniform float fogNear;',\n\t\t\t\t'uniform float fogFar;',\n\t\t\t\t'uniform float alphaTest;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t\t'}',\n\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.compileShader( vertexShader );\n\t\t\tgl.compileShader( fragmentShader );\n\n\t\t\tgl.attachShader( program, vertexShader );\n\t\t\tgl.attachShader( program, fragmentShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn b.id - a.id;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Material() {\n\n\t\tObject.defineProperty( this, 'id', { value: MaterialIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.alphaTest = 0;\n\t\tthis.premultipliedAlpha = false;\n\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\t\tthis.visible = true;\n\n\t\tthis._needsUpdate = true;\n\n\t}\n\n\tMaterial.prototype = {\n\n\t\tconstructor: Material,\n\n\t\tisMaterial: true,\n\n\t\tget needsUpdate() {\n\n\t\t\treturn this._needsUpdate;\n\n\t\t},\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.update();\n\t\t\tthis._needsUpdate = value;\n\n\t\t},\n\n\t\tsetValues: function ( values ) {\n\n\t\t\tif ( values === undefined ) return;\n\n\t\t\tfor ( var key in values ) {\n\n\t\t\t\tvar newValue = values[ key ];\n\n\t\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar currentValue = this[ key ];\n\n\t\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( (currentValue && currentValue.isColor) ) {\n\n\t\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t\t} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar isRoot = meta === undefined;\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Material serialization\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( (this.color && this.color.isColor) ) data.color = this.color.getHex();\n\n\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\t\tif ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();\n\t\t\tif ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\t\tif ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\tif ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.bumpMap && this.bumpMap.isTexture) ) {\n\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t\t}\n\t\t\tif ( (this.normalMap && this.normalMap.isTexture) ) {\n\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t\t}\n\t\t\tif ( (this.displacementMap && this.displacementMap.isTexture) ) {\n\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t\t}\n\t\t\tif ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.envMap && this.envMap.isTexture) ) {\n\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t\t}\n\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\tif ( this.shading !== SmoothShading ) data.shading = this.shading;\n\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\tdata.depthTest = this.depthTest;\n\t\t\tdata.depthWrite = this.depthWrite;\n\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\t\tdata.skinning = this.skinning;\n\t\t\tdata.morphTargets = this.morphTargets;\n\n\t\t\t// TODO: Copied from Object3D.toJSON\n\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.lights = source.lights;\n\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.shading = source.shading;\n\t\t\tthis.vertexColors = source.vertexColors;\n\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\n\t\t\tthis.colorWrite = source.colorWrite;\n\n\t\t\tthis.precision = source.precision;\n\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\t\tthis.alphaTest = source.alphaTest;\n\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\t\tthis.overdraw = source.overdraw;\n\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\tthis.clipIntersection = source.clipIntersection;\n\n\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\tdstPlanes = null;\n\n\t\t\tif ( srcPlanes !== null ) {\n\n\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array( n );\n\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t\tthis.clippingPlanes = dstPlanes;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t};\n\n\tObject.assign( Material.prototype, EventDispatcher.prototype );\n\n\tvar count$1 = 0;\n\tfunction MaterialIdCount() { return count$1++; }\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  defines: { \"label\" : \"value\" },\n\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *  fragmentShader: <string>,\n\t *  vertexShader: <string>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  lights: <bool>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction ShaderMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\tthis.morphTargets = false; // set to use morph targets\n\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv2': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tShaderMaterial.prototype = Object.create( Material.prototype );\n\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\n\tShaderMaterial.prototype.isShaderMaterial = true;\n\n\tShaderMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\n\t\tthis.defines = source.defines;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.skinning = source.skinning;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.extensions = source.extensions;\n\n\t\treturn this;\n\n\t};\n\n\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\n\t\tdata.uniforms = this.uniforms;\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / https://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshDepthMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\n\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Box3( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\n\t}\n\n\tBox3.prototype = {\n\n\t\tconstructor: Box3,\n\n\t\tisBox3: true,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromArray: function ( array ) {\n\n\t\t\tvar minX = + Infinity;\n\t\t\tvar minY = + Infinity;\n\t\t\tvar minZ = + Infinity;\n\n\t\t\tvar maxX = - Infinity;\n\t\t\tvar maxY = - Infinity;\n\t\t\tvar maxZ = - Infinity;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar x = array[ i ];\n\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\tvar z = array[ i + 2 ];\n\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t\t}\n\n\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromObject: function () {\n\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromObject( object ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\t\tthis.makeEmpty();\n\n\t\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\t\t\tvar array, offset, stride;\n\n\t\t\t\t\t\t\t\tif ( (attribute && attribute.isInterleavedBufferAttribute) ) {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\t\tstride = 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\n\t\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsSphere: ( function () {\n\n\t\t\tvar closestPoint;\n\n\t\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new Vector3();\n\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\t\tvar min, max;\n\n\t\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t\t} else {\n\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t\t}\n\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetBoundingSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Sphere();\n\n\t\t\t\tthis.getCenter( result.center );\n\n\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar points = [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t];\n\n\t\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\t\tthis.setFromPoints( points );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Sphere( center, radius ) {\n\n\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n\t}\n\n\tSphere.prototype = {\n\n\t\tconstructor: Sphere,\n\n\t\tset: function ( center, radius ) {\n\n\t\t\tthis.center.copy( center );\n\t\t\tthis.radius = radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function () {\n\n\t\t\tvar box = new Box3();\n\n\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\t\tvar center = this.center;\n\n\t\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\n\t\t\t\t}\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( sphere ) {\n\n\t\t\tthis.center.copy( sphere.center );\n\t\t\tthis.radius = sphere.radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tempty: function () {\n\n\t\t\treturn ( this.radius <= 0 );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsSphere( this );\n\n\t\t},\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t// the center of the sphere to the plane.\n\t\t\t//\n\t\t\t// distance = q * n - d\n\t\t\t//\n\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t// then there is no intersection.\n\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.copy( point );\n\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\t\tvar box = optionalTarget || new Box3();\n\n\t\t\tbox.set( this.center, this.center );\n\t\t\tbox.expandByScalar( this.radius );\n\n\t\t\treturn box;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.center.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( sphere ) {\n\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t * @author tschw\n\t */\n\n\tfunction Matrix3() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix3.prototype = {\n\n\t\tconstructor: Matrix3,\n\n\t\tisMatrix3: true,\n\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix4: function( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t\t},\n\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\t\tif ( (matrix && matrix.isMatrix4) ) {\n\n\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t\t}\n\n\t\t\tvar me = matrix.elements,\n\t\t\t\tte = this.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar tmp, m = this.elements;\n\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t\t},\n\n\t\ttransposeIntoArray: function ( r ) {\n\n\t\t\tvar m = this.elements;\n\n\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\tr[ 8 ] = m[ 8 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 9; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Plane( normal, constant ) {\n\n\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n\t}\n\n\tPlane.prototype = {\n\n\t\tconstructor: Plane,\n\n\t\tset: function ( normal, constant ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponents: function ( x, y, z, w ) {\n\n\t\t\tthis.normal.set( x, y, z );\n\t\t\tthis.constant = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCoplanarPoints: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( plane ) {\n\n\t\t\tthis.normal.copy( plane.normal );\n\t\t\tthis.constant = plane.constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\tthis.constant *= inverseNormalLength;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.constant *= - 1;\n\t\t\tthis.normal.negate();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) + this.constant;\n\n\t\t},\n\n\t\tdistanceToSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t\t},\n\n\t\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t\t},\n\n\t\torthoPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t\t},\n\n\t\tintersectLine: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tvar direction = line.delta( v1 );\n\n\t\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsLine: function ( line ) {\n\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsPlane( this );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn sphere.intersectsPlane( this );\n\n\t\t},\n\n\t\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar m1 = new Matrix3();\n\n\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t\t// transform normal based on theory here:\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( plane ) {\n\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tthis.planes = [\n\n\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\n\t\t];\n\n\t}\n\n\tFrustum.prototype = {\n\n\t\tconstructor: Frustum,\n\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\tplanes[ 5 ].copy( p5 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( frustum ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix: function ( m ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar me = m.elements;\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tintersectsObject: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsObject( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSprite: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar center = sphere.center;\n\t\t\tvar negRadius = - sphere.radius;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsBox: function () {\n\n\t\t\tvar p1 = new Vector3(),\n\t\t\t\tp2 = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\tvar planes = this.planes;\n\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t}(),\n\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {\n\n\t\tvar _gl = _renderer.context,\n\t\t_state = _renderer.state,\n\t\t_frustum = new Frustum(),\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_lightShadows = _lights.shadows,\n\n\t\t_shadowMapSize = new Vector2(),\n\t\t_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\n\t\t_lookTarget = new Vector3(),\n\t\t_lightPositionWorld = new Vector3(),\n\n\t\t_renderList = [],\n\n\t\t_MorphingFlag = 1,\n\t\t_SkinningFlag = 2,\n\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t\t_materialCache = {};\n\n\t\tvar cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tvar cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t\tvar cube2DViewPorts = [\n\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t];\n\n\t\t// init\n\n\t\tvar depthMaterialTemplate = new MeshDepthMaterial();\n\t\tdepthMaterialTemplate.depthPacking = RGBADepthPacking;\n\t\tdepthMaterialTemplate.clipping = true;\n\n\t\tvar distanceShader = ShaderLib[ \"distanceRGBA\" ];\n\t\tvar distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );\n\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\t\tvar distanceMaterial = new ShaderMaterial( {\n\t\t\t\tdefines: {\n\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t},\n\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning,\n\t\t\t\tclipping: true\n\t\t\t} );\n\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tthis.enabled = false;\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis.type = PCFShadowMap;\n\n\t\tthis.renderReverseSided = true;\n\t\tthis.renderSingleSided = true;\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t\t// Set GL state for depth map.\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t_state.disable( _gl.BLEND );\n\t\t\t_state.setDepthTest( true );\n\t\t\t_state.setScissorTest( false );\n\n\t\t\t// render depth map\n\n\t\t\tvar faceCount, isPointLight;\n\n\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\n\t\t\t\tif ( (light && light.isPointLight) ) {\n\n\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\tisPointLight = true;\n\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t// following orientation:\n\t\t\t\t\t//\n\t\t\t\t\t//  xzXZ\n\t\t\t\t\t//   y Y\n\t\t\t\t\t//\n\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t// z - Negative z direction\n\n\t\t\t\t\t// positive X\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative X\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Z\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative Z\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Y\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t// negative Y\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\tisPointLight = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tif ( (shadow && shadow.isSpotLightShadow) ) {\n\n\t\t\t\t\tshadow.update( light );\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t_renderer.clear();\n\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t// run a single pass if not\n\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t\t// compute shadow matrix\n\n\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t);\n\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t\t_renderList.length = 0;\n\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t\t// render shadow map\n\t\t\t\t\t// render regular objects\n\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( (material && material.isMultiMaterial) ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Restore GL state.\n\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\t\tscope.needsUpdate = false;\n\n\t\t};\n\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tvar result = null;\n\n\t\t\tvar materialVariants = _depthMaterials;\n\t\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t\t}\n\n\t\t\tif ( ! customMaterial ) {\n\n\t\t\t\tvar useMorphing = false;\n\n\t\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\n\t\t\t\tvar variantIndex = 0;\n\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t\t} else {\n\n\t\t\t\tresult = customMaterial;\n\n\t\t\t}\n\n\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\n\t\t\tvar side = material.side;\n\n\t\t\tif ( scope.renderSingleSided && side == DoubleSide ) {\n\n\t\t\t\tside = FrontSide;\n\n\t\t\t}\n\n\t\t\tif ( scope.renderReverseSided ) {\n\n\t\t\t\tif ( side === FrontSide ) side = BackSide;\n\t\t\t\telse if ( side === BackSide ) side = FrontSide;\n\n\t\t\t}\n\n\t\t\tresult.side = side;\n\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\n\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Ray( origin, direction ) {\n\n\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\n\t}\n\n\tRay.prototype = {\n\n\t\tconstructor: Ray,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\tthis.origin.copy( origin );\n\t\t\tthis.direction.copy( direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( ray ) {\n\n\t\t\tthis.origin.copy( ray.origin );\n\t\t\tthis.direction.copy( ray.direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t\t},\n\n\t\tlookAt: function ( v ) {\n\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trecast: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function recast( t ) {\n\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\tresult.subVectors( point, this.origin );\n\t\t\tvar directionDistance = result.dot( this.direction );\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn result.copy( this.origin );\n\n\t\t\t}\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t\t},\n\n\t\tdistanceSqToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t\t// point behind the ray\n\n\t\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t\t}\n\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\t\treturn v1.distanceToSquared( point );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceSqToSegment: function () {\n\n\t\t\tvar segCenter = new Vector3();\n\t\t\tvar segDir = new Vector3();\n\t\t\tvar diff = new Vector3();\n\n\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t// defined by v0 and v1\n\t\t\t\t// It can also set two optional targets :\n\t\t\t\t// - The closest point on the ray\n\t\t\t\t// - The closest point on the segment\n\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\t\tif ( det > 0 ) {\n\n\t\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\textDet = segExtent * det;\n\n\t\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t\t}\n\n\t\t\t\treturn sqrDist;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\tvar t0 = tca - thc;\n\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\tvar t1 = tca + thc;\n\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t\t},\n\n\t\tdistanceToPlane: function ( plane ) {\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\t\treturn 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t\t// Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t :  null;\n\n\t\t},\n\n\t\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\t\tvar t = this.distanceToPlane( plane );\n\n\t\t\tif ( t === null ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn this.at( t, optionalTarget );\n\n\t\t},\n\n\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// check if the ray lies on the plane first\n\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\t\tif ( distToPoint === 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tintersectBox: function ( box, optionalTarget ) {\n\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\t\tvar origin = this.origin;\n\n\t\t\tif ( invdirx >= 0 ) {\n\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t\t} else {\n\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t\t}\n\n\t\t\tif ( invdiry >= 0 ) {\n\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t\t} else {\n\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\t\tif ( invdirz >= 0 ) {\n\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t\t} else {\n\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t\t//return point closest to the ray (positive side)\n\n\t\t\tif ( tmax < 0 ) return null;\n\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t\t},\n\n\t\tintersectsBox: ( function () {\n\n\t\t\tvar v = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectTriangle: function () {\n\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\tvar diff = new Vector3();\n\t\t\tvar edge1 = new Vector3();\n\t\t\tvar edge2 = new Vector3();\n\t\t\tvar normal = new Vector3();\n\n\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\tvar sign;\n\n\t\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\tsign = 1;\n\n\t\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\t\tsign = - 1;\n\t\t\t\t\tDdN = - DdN;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t\t// b1 < 0, no intersection\n\t\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t\t// b2 < 0, no intersection\n\t\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t\t// t < 0, no intersection\n\t\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Ray intersects triangle.\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix4: function ( matrix4 ) {\n\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\tthis.direction.sub( this.origin );\n\t\t\tthis.direction.normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( ray ) {\n\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Euler( x, y, z, order ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._order = order || Euler.DefaultOrder;\n\n\t}\n\n\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\n\tEuler.DefaultOrder = 'XYZ';\n\n\tEuler.prototype = {\n\n\t\tconstructor: Euler,\n\n\t\tisEuler: true,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget order () {\n\n\t\t\treturn this._order;\n\n\t\t},\n\n\t\tset order ( value ) {\n\n\t\t\tthis._order = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, order ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t\t},\n\n\t\tcopy: function ( euler ) {\n\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\t\tvar clamp = _Math.clamp;\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements;\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\torder = order || this._order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t\t}\n\n\t\t\tthis._order = order;\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromQuaternion: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromVector3: function ( v, order ) {\n\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t\t},\n\n\t\treorder: function () {\n\n\t\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t\tvar q = new Quaternion();\n\n\t\t\treturn function reorder( newOrder ) {\n\n\t\t\t\tq.setFromEuler( this );\n\n\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( euler ) {\n\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t\t},\n\n\t\tfromArray: function ( array ) {\n\n\t\t\tthis._x = array[ 0 ];\n\t\t\tthis._y = array[ 1 ];\n\t\t\tthis._z = array[ 2 ];\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._order;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoVector3: function ( optionalResult ) {\n\n\t\t\tif ( optionalResult ) {\n\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t\t} else {\n\n\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t\t}\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Layers() {\n\n\t\tthis.mask = 1;\n\n\t}\n\n\tLayers.prototype = {\n\n\t\tconstructor: Layers,\n\n\t\tset: function ( channel ) {\n\n\t\t\tthis.mask = 1 << channel;\n\n\t\t},\n\n\t\tenable: function ( channel ) {\n\n\t\t\tthis.mask |= 1 << channel;\n\n\t\t},\n\n\t\ttoggle: function ( channel ) {\n\n\t\t\tthis.mask ^= 1 << channel;\n\n\t\t},\n\n\t\tdisable: function ( channel ) {\n\n\t\t\tthis.mask &= ~ ( 1 << channel );\n\n\t\t},\n\n\t\ttest: function ( layers ) {\n\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author elephantatwork / www.elephantatwork.ch\n\t */\n\n\tfunction Object3D() {\n\n\t\tObject.defineProperty( this, 'id', { value: Object3DIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DefaultUp.clone();\n\n\t\tvar position = new Vector3();\n\t\tvar rotation = new Euler();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation.onChange( onRotationChange );\n\t\tquaternion.onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.userData = {};\n\n\t\tthis.onBeforeRender = function(){}; \n\t\tthis.onAfterRender = function(){};\n\n\t}\n\n\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\tObject3D.DefaultMatrixAutoUpdate = true;\n\n\tObject.assign( Object3D.prototype, EventDispatcher.prototype, {\n\n\t\tisObject3D: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t\t},\n\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t\t},\n\n\t\tsetRotationFromEuler: function ( euler ) {\n\n\t\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t\t},\n\n\t\tsetRotationFromMatrix: function ( m ) {\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t\t},\n\n\t\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t\t// assumes q is normalized\n\n\t\t\tthis.quaternion.copy( q );\n\n\t\t},\n\n\t\trotateOnAxis: function () {\n\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar q1 = new Quaternion();\n\n\t\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateOnAxis: function () {\n\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function translateX( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function translateY( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function translateZ( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlocalToWorld: function ( vector ) {\n\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t\t},\n\n\t\tworldToLocal: function () {\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function worldToLocal( vector ) {\n\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tadd: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( object === this ) {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( (object && object.isObject3D) ) {\n\n\t\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\t\tobject.parent.remove( object );\n\n\t\t\t\t}\n\n\t\t\t\tobject.parent = this;\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\t\tthis.children.push( object );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tremove: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar index = this.children.indexOf( object );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tobject.parent = null;\n\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetObjectById: function ( id ) {\n\n\t\t\treturn this.getObjectByProperty( 'id', id );\n\n\t\t},\n\n\t\tgetObjectByName: function ( name ) {\n\n\t\t\treturn this.getObjectByProperty( 'name', name );\n\n\t\t},\n\n\t\tgetObjectByProperty: function ( name, value ) {\n\n\t\t\tif ( this[ name ] === value ) return this;\n\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\t\tif ( object !== undefined ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t},\n\n\t\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t\t},\n\n\t\tgetWorldQuaternion: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar scale = new Vector3();\n\n\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Quaternion();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldRotation: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Euler();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldScale: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldDirection: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\traycast: function () {},\n\n\t\ttraverse: function ( callback ) {\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverse( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseVisible: function ( callback ) {\n\n\t\t\tif ( this.visible === false ) return;\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseAncestors: function ( callback ) {\n\n\t\t\tvar parent = this.parent;\n\n\t\t\tif ( parent !== null ) {\n\n\t\t\t\tcallback( parent );\n\n\t\t\t\tparent.traverseAncestors( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrix: function () {\n\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t\t},\n\n\t\tupdateMatrixWorld: function ( force ) {\n\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t\tforce = true;\n\n\t\t\t}\n\n\t\t\t// update children\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\t// meta is '' when called from JSON.stringify\n\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\t\tvar output = {};\n\n\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// standard Object3D serialization\n\n\t\t\tvar object = {};\n\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\n\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\tif ( this.visible === false ) object.visible = false;\n\n\t\t\tobject.matrix = this.matrix.toArray();\n\n\t\t\t//\n\n\t\t\tif ( this.geometry !== undefined ) {\n\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t\t}\n\n\t\t\tif ( this.material !== undefined ) {\n\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = this.material.uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( this.children.length > 0 ) {\n\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t\t}\n\n\t\t\toutput.object = object;\n\n\t\t\treturn output;\n\n\t\t\t// extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function ( recursive ) {\n\n\t\t\treturn new this.constructor().copy( this, recursive );\n\n\t\t},\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tif ( recursive === undefined ) recursive = true;\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.up.copy( source.up );\n\n\t\t\tthis.position.copy( source.position );\n\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\tthis.scale.copy( source.scale );\n\n\t\t\tthis.matrix.copy( source.matrix );\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\t\tthis.visible = source.visible;\n\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\tthis.add( child.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\tvar count$2 = 0;\n\tfunction Object3DIdCount() { return count$2++; }\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Line3( start, end ) {\n\n\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\n\t}\n\n\tLine3.prototype = {\n\n\t\tconstructor: Line3,\n\n\t\tset: function ( start, end ) {\n\n\t\t\tthis.start.copy( start );\n\t\t\tthis.end.copy( end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( line ) {\n\n\t\t\tthis.start.copy( line.start );\n\t\t\tthis.end.copy( line.end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tdelta: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.subVectors( this.end, this.start );\n\n\t\t},\n\n\t\tdistanceSq: function () {\n\n\t\t\treturn this.start.distanceToSquared( this.end );\n\n\t\t},\n\n\t\tdistance: function () {\n\n\t\t\treturn this.start.distanceTo( this.end );\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tclosestPointToPointParameter: function () {\n\n\t\t\tvar startP = new Vector3();\n\t\t\tvar startEnd = new Vector3();\n\n\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\t\tif ( clampToLine ) {\n\n\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t\treturn t;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\tthis.end.applyMatrix4( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( line ) {\n\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Triangle( a, b, c ) {\n\n\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n\t}\n\n\tTriangle.normal = function () {\n\n\t\tvar v0 = new Vector3();\n\n\t\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.subVectors( c, b );\n\t\t\tv0.subVectors( a, b );\n\t\t\tresult.cross( v0 );\n\n\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t\t}\n\n\t\t\treturn result.set( 0, 0, 0 );\n\n\t\t};\n\n\t}();\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tTriangle.barycoordFromPoint = function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\t\tv0.subVectors( c, a );\n\t\t\tv1.subVectors( b, a );\n\t\t\tv2.subVectors( point, a );\n\n\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\tvar dot12 = v1.dot( v2 );\n\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t// collinear or singular triangle\n\t\t\tif ( denom === 0 ) {\n\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t\t}\n\n\t\t\tvar invDenom = 1 / denom;\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t\t// barycentric coordinates must always sum to 1\n\t\t\treturn result.set( 1 - u - v, v, u );\n\n\t\t};\n\n\t}();\n\n\tTriangle.containsPoint = function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function containsPoint( point, a, b, c ) {\n\n\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t\t};\n\n\t}();\n\n\tTriangle.prototype = {\n\n\t\tconstructor: Triangle,\n\n\t\tset: function ( a, b, c ) {\n\n\t\t\tthis.a.copy( a );\n\t\t\tthis.b.copy( b );\n\t\t\tthis.c.copy( c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\tthis.c.copy( points[ i2 ] );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( triangle ) {\n\n\t\t\tthis.a.copy( triangle.a );\n\t\t\tthis.b.copy( triangle.b );\n\t\t\tthis.c.copy( triangle.c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tarea: function () {\n\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function area() {\n\n\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmidpoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t\t},\n\n\t\tnormal: function ( optionalTarget ) {\n\n\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tplane: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Plane();\n\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t\t},\n\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t\t},\n\n\t\tclosestPointToPoint: function () {\n\n\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\t\tif ( plane === undefined ) {\n\n\t\t\t\t\tplane = new Plane();\n\t\t\t\t\tedgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\t\t\tprojectedPoint = new Vector3();\n\t\t\t\t\tclosestPoint = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tvar minDistance = Infinity;\n\n\t\t\t\t// project the point onto the plane of the triangle\n\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t\t// check if the projection lies within the triangle\n\n\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t\t// if so, this is the closest point\n\n\t\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( triangle ) {\n\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.normal = (normal && normal.isVector3) ? normal : new Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\t\tthis.color = (color && color.isColor) ? color : new Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\t}\n\n\tFace3.prototype = {\n\n\t\tconstructor: Face3,\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.a = source.a;\n\t\t\tthis.b = source.b;\n\t\t\tthis.c = source.c;\n\n\t\t\tthis.normal.copy( source.normal );\n\t\t\tthis.color.copy( source.color );\n\n\t\t\tthis.materialIndex = source.materialIndex;\n\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  shading: THREE.SmoothShading,\n\t *  depthTest: <bool>,\n\t *  depthWrite: <bool>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>\n\t * }\n\t */\n\n\tfunction MeshBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\n\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferAttribute( array, itemSize, normalized ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized === true;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tBufferAttribute.prototype = {\n\n\t\tconstructor: BufferAttribute,\n\n\t\tisBufferAttribute: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.itemSize = source.itemSize;\n\t\t\tthis.count = source.count;\n\t\t\tthis.normalized = source.normalized;\n\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyArray: function ( array ) {\n\n\t\t\tthis.array.set( array );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyColorsArray: function ( colors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\tvar color = colors[ i ];\n\n\t\t\t\tif ( color === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\tcolor = new Color();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyIndicesArray: function ( indices ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tvar index = indices[ i ];\n\n\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector2sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector3sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector4sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize ];\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\t\tthis.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Int8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n\t}\n\n\tfunction Int16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int16Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint16Array( array ), itemSize );\n\n\t}\n\n\tfunction Int32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int32Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float64Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float64Array( array ), itemSize );\n\n\t}\n\n\t// Deprecated\n\n\tfunction DynamicBufferAttribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Geometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Geometry';\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\tthis.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = false;\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.lineDistancesNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( Geometry.prototype, EventDispatcher.prototype, {\n\n\t\tisGeometry: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\tthis.verticesNeedUpdate = true;\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfromBufferGeometry: function ( geometry ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tvar positions = attributes.position.array;\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\t\tvar tempNormals = [];\n\t\t\tvar tempUVs = [];\n\t\t\tvar tempUVs2 = [];\n\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\t\tscope.faces.push( face );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t\tvar center = this.boundingSphere.center;\n\t\t\tvar radius = this.boundingSphere.radius;\n\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\t\tvar matrix = new Matrix4();\n\t\t\tmatrix.set(\n\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\tthis.applyMatrix( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tvar face = this.faces[ f ];\n\n\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tface.normal.copy( cb );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\t\tvar v, vl, f, fl, face, vertices;\n\n\t\t\tvertices = new Array( this.vertices.length );\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ] = new Vector3();\n\n\t\t\t}\n\n\t\t\tif ( areaWeighted ) {\n\n\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\t\tvar vA, vB, vC;\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.computeFaceNormals();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ].normalize();\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeFlatVertexNormals: function () {\n\n\t\t\tvar f, fl, face;\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeMorphNormals: function () {\n\n\t\t\tvar i, il, f, fl, face;\n\n\t\t\t// save original normals\n\t\t\t// - create temp variables on first access\n\t\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\t\tvar tmpGeo = new Geometry();\n\t\t\ttmpGeo.faces = this.faces;\n\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\t// create on first access\n\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t\t// set vertices to morph target\n\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t\t// compute morph normals\n\n\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t\t// store morph normals\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore original normals\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeTangents: function () {\n\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t\t},\n\n\t\tcomputeLineDistances: function () {\n\n\t\t\tvar d = 0;\n\t\t\tvar vertices = this.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tif ( i > 0 ) {\n\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\t\tif ( (geometry && geometry.isGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\t\tif ( matrix !== undefined ) {\n\n\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\t\tvertices1.push( vertexCopy );\n\n\t\t\t}\n\n\t\t\t// colors\n\n\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\t\tfaces1.push( faceCopy );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\t\tif ( uv === undefined ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tuvs1.push( uvCopy );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmergeMesh: function ( mesh ) {\n\n\t\t\tif ( (mesh && mesh.isMesh) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t\t},\n\n\t\t/*\n\t\t * Checks for duplicate vertices with hashmap.\n\t\t * Duplicated vertices are removed\n\t\t * and faces' vertices are updated.\n\t\t */\n\n\t\tmergeVertices: function () {\n\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\tvar unique = [], changes = [];\n\n\t\t\tvar v, key;\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\tvar i, il, face;\n\t\t\tvar indices, j, jl;\n\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tv = this.vertices[ i ];\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t// have to remove them from the geometry.\n\t\t\tvar faceIndicesToRemove = [];\n\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tface = this.faces[ i ];\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\n\t\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t\tvar dupIndex = - 1;\n\n\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Use unique set of vertices\n\n\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\tthis.vertices = unique;\n\t\t\treturn diff;\n\n\t\t},\n\n\t\tsortFacesByMaterialIndex: function () {\n\n\t\t\tvar faces = this.faces;\n\t\t\tvar length = faces.length;\n\n\t\t\t// tag faces\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tfaces[ i ]._id = i;\n\n\t\t\t}\n\n\t\t\t// sort faces\n\n\t\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t}\n\n\t\t\tfaces.sort( materialIndexSort );\n\n\t\t\t// sort uvs\n\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\t\tvar newUvs1, newUvs2;\n\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tvar id = faces[ i ]._id;\n\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t\t}\n\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Geometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t\tvar faces = [];\n\t\t\tvar normals = [];\n\t\t\tvar normalsHash = {};\n\t\t\tvar colors = [];\n\t\t\tvar colorsHash = {};\n\t\t\tvar uvs = [];\n\t\t\tvar uvsHash = {};\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tvar hasMaterial = true;\n\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\t\tvar faceType = 0;\n\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\t\tfaces.push( faceType );\n\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\tfaces.push( face.materialIndex );\n\n\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t\t}\n\n\t\t\tfunction getNormalIndex( normal ) {\n\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getColorIndex( color ) {\n\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\tcolors.push( color.getHex() );\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getUvIndex( uv ) {\n\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tdata.data = {};\n\n\t\t\tdata.data.vertices = vertices;\n\t\t\tdata.data.normals = normals;\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\tdata.data.faces = faces;\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new Geometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.vertices = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\t\tthis.colors = [];\n\n\t\t\tvar vertices = source.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar colors = source.colors;\n\n\t\t\tfor ( var i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar faces = source.faces;\n\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tvar count$3 = 0;\n\tfunction GeometryIdCount() { return count$3++; }\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'DirectGeometry';\n\n\t\tthis.indices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( DirectGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tcomputeBoundingBox: Geometry.prototype.computeBoundingBox,\n\t\tcomputeBoundingSphere: Geometry.prototype.computeBoundingSphere,\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeGroups: function ( geometry ) {\n\n\t\t\tvar group;\n\t\t\tvar groups = [];\n\t\t\tvar materialIndex;\n\n\t\t\tvar faces = geometry.faces;\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// materials\n\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup = {\n\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( group !== undefined ) {\n\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\tgroups.push( group );\n\n\t\t\t}\n\n\t\t\tthis.groups = groups;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t\t// morphs\n\n\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\t\tvar morphTargetsPosition;\n\n\t\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\t\tmorphTargetsPosition = [];\n\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t\t}\n\n\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\t\tvar morphTargetsNormal;\n\n\t\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\t\tmorphTargetsNormal = [];\n\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\tvar skinWeights = geometry.skinWeights;\n\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t\t//\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar normal = face.normal;\n\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t\t}\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = face.color;\n\n\t\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// morphs\n\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t\t}\n\n\t\t\t\t// skins\n\n\t\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeGroups( geometry );\n\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t}\n\n\tObject.assign( BufferGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tisBufferGeometry: true,\n\n\t\tgetIndex: function () {\n\n\t\t\treturn this.index;\n\n\t\t},\n\n\t\tsetIndex: function ( index ) {\n\n\t\t\tthis.index = index;\n\n\t\t},\n\n\t\taddAttribute: function ( name, attribute ) {\n\n\t\t\tif ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( name === 'index' ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\tthis.setIndex( attribute );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.attributes[ name ] = attribute;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetAttribute: function ( name ) {\n\n\t\t\treturn this.attributes[ name ];\n\n\t\t},\n\n\t\tremoveAttribute: function ( name ) {\n\n\t\t\tdelete this.attributes[ name ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddGroup: function ( start, count, materialIndex ) {\n\n\t\t\tthis.groups.push( {\n\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t\t} );\n\n\t\t},\n\n\t\tclearGroups: function () {\n\n\t\t\tthis.groups = [];\n\n\t\t},\n\n\t\tsetDrawRange: function ( start, count ) {\n\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\n\t\t},\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar position = this.attributes.position;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tvar normal = this.attributes.normal;\n\n\t\t\tif ( normal !== undefined ) {\n\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\tnormal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isPoints) || (object && object.isLine) ) {\n\n\t\t\t\tvar positions = new Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\tvar colors = new Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\t\tvar lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( (object && object.isMesh) ) {\n\n\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateFromObject: function ( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isMesh) ) {\n\n\t\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\t\tdirect = undefined;\n\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( direct === undefined ) {\n\n\t\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t\tgeometry = direct;\n\n\t\t\t}\n\n\t\t\tvar attribute;\n\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.normal;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.color;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.uv;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\tthis.groups = geometry.groups;\n\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t\t},\n\n\t\tfromDirectGeometry: function ( geometry ) {\n\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t\t}\n\n\t\t\t// groups\n\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\t// morphs\n\n\t\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\t\tvar array = [];\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\t\tvar attribute = new Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t\t}\n\n\t\t\t// skinning\n\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\t\tvar skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\t\tvar skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position.array;\n\n\t\t\tif ( positions !== undefined ) {\n\n\t\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t\t} else {\n\n\t\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t\t}\n\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tvar box = new Box3();\n\t\t\tvar vector = new Vector3();\n\n\t\t\treturn function computeBoundingSphere() {\n\n\t\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t\t}\n\n\t\t\t\tvar positions = this.attributes.position;\n\n\t\t\t\tif ( positions ) {\n\n\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\tbox.getCenter( center );\n\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\t// backwards compatibility\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tvar index = this.index;\n\t\t\tvar attributes = this.attributes;\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( attributes.position ) {\n\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset existing normals to zero\n\n\t\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\tvar vA, vB, vC,\n\n\t\t\t\tpA = new Vector3(),\n\t\t\t\tpB = new Vector3(),\n\t\t\t\tpC = new Vector3(),\n\n\t\t\t\tcb = new Vector3(),\n\t\t\t\tab = new Vector3();\n\n\t\t\t\t// indexed elements\n\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.normalizeNormals();\n\n\t\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmerge: function ( geometry, offset ) {\n\n\t\t\tif ( (geometry && geometry.isBufferGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalizeNormals: function () {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\n\t\t\tvar x, y, z, n;\n\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\t\tx = normals[ i ];\n\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\tz = normals[ i + 2 ];\n\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\t\tnormals[ i ] *= n;\n\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoNonIndexed: function () {\n\n\t\t\tif ( this.index === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar geometry2 = new BufferGeometry();\n\n\t\t\tvar indices = this.index.array;\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\n\t\t\t}\n\n\t\t\treturn geometry2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard BufferGeometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tdata.data = { attributes: {} };\n\n\t\t\tvar index = this.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: array\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = this.boundingSphere;\n\n\t\t\tif ( boundingSphere !== null ) {\n\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new BufferGeometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tvar index = source.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.setIndex( index.clone() );\n\n\t\t\t}\n\n\t\t\tvar attributes = source.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t\t}\n\n\t\t\tvar groups = source.groups;\n\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tBufferGeometry.MaxIndex = 65535;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author jonobr1 / http://jonobr1.com/\n\t */\n\n\tfunction Mesh( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t\tthis.drawMode = TrianglesDrawMode;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Mesh,\n\n\t\tisMesh: true,\n\n\t\tsetDrawMode: function ( value ) {\n\n\t\t\tthis.drawMode = value;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.drawMode = source.drawMode;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateMorphTargets: function () {\n\n\t\t\tvar morphTargets = this.geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ morphTargets[ m ].name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\tvar vA = new Vector3();\n\t\t\tvar vB = new Vector3();\n\t\t\tvar vC = new Vector3();\n\n\t\t\tvar tempA = new Vector3();\n\t\t\tvar tempB = new Vector3();\n\t\t\tvar tempC = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tvar barycoord = new Vector3();\n\n\t\t\tvar intersectionPoint = new Vector3();\n\t\t\tvar intersectionPointWorld = new Vector3();\n\n\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\t\treturn uv1.clone();\n\n\t\t\t}\n\n\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\t\tvar intersect;\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersect === null ) return null;\n\n\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\t\treturn {\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\tobject: object\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t\t}\n\n\t\t\t\treturn intersection;\n\n\t\t\t}\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar material = this.material;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\tif ( material === undefined ) return;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\t// Check boundingBox before continuing\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t\t}\n\n\t\t\t\tvar uvs, intersection;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar a, b, c;\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\tvar isFaceMaterial = (material && material.isMultiMaterial);\n\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'BoxBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tvar scope = this;\n\n\t\t// segments\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\t\tvar numberOfVertices = 0;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// build each side of the box geometry\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount( w, h, d ) {\n\n\t\t\tvar vertices = 0;\n\n\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\t\treturn vertices;\n\n\t\t}\n\n\t\tfunction calculateIndexCount( w, h, d ) {\n\n\t\t\tvar index = 0;\n\n\t\t\t// calculate the amount of squares for each side\n\t\t\tindex += w * h * 2; // xy\n\t\t\tindex += w * d * 2; // xz\n\t\t\tindex += d * h * 2; // zy\n\n\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t\t}\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\tvar segmentHeight = height / gridY;\n\n\t\t\tvar widthHalf = width / 2;\n\t\t\tvar heightHalf = height / 2;\n\t\t\tvar depthHalf = depth / 2;\n\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\n\t\t\tvar vertexCounter = 0;\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// uvs\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PlaneBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tvar width_half = width / 2;\n\t\tvar height_half = height / 2;\n\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar segment_width = width / gridX;\n\t\tvar segment_height = height / gridY;\n\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\t\tvar offset = 0;\n\t\tvar offset2 = 0;\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segment_height - height_half;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\t\tvertices[ offset ] = x;\n\t\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\toffset += 3;\n\t\t\t\toffset2 += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\toffset = 0;\n\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices[ offset ] = a;\n\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\t\toffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction Camera() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\t\tthis.projectionMatrix = new Matrix4();\n\n\t}\n\n\tCamera.prototype = Object.create( Object3D.prototype );\n\tCamera.prototype.constructor = Camera;\n\n\tCamera.prototype.isCamera = true;\n\n\tCamera.prototype.getWorldDirection = function () {\n\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.lookAt = function () {\n\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.clone = function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t};\n\n\tCamera.prototype.copy = function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author greggman / http://games.greggman.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author tschw\n\t */\n\n\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near !== undefined ? near : 0.1;\n\t\tthis.far = far !== undefined ? far : 2000;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: PerspectiveCamera,\n\n\t\tisPerspectiveCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\t\tsetFocalLength: function ( focalLength ) {\n\n\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\t\tgetFocalLength: function () {\n\n\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t\t},\n\n\t\tgetEffectiveFOV: function () {\n\n\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t\t},\n\n\t\tgetFilmWidth: function () {\n\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t\t},\n\n\t\tgetFilmHeight: function () {\n\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t\t},\n\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *   +---+---+---+\n\t\t *   | A | B | C |\n\t\t *   +---+---+---+\n\t\t *   | D | E | F |\n\t\t *   +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *   var w = 1920;\n\t\t *   var h = 1080;\n\t\t *   var fullWidth = w * 3;\n\t\t *   var fullHeight = h * 2;\n\t\t *\n\t\t *   --A--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *   --B--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *   --C--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *   --D--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *   --E--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *   --F--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar near = this.near,\n\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\theight = 2 * top,\n\t\t\t\twidth = this.aspect * height,\n\t\t\t\tleft = - 0.5 * width,\n\t\t\t\tview = this.view;\n\n\t\t\tif ( view !== null ) {\n\n\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\n\t\t\t}\n\n\t\t\tvar skew = this.filmOffset;\n\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\n\t\t\tdata.object.aspect = this.aspect;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author arose / http://github.com/arose\n\t */\n\n\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: OrthographicCamera,\n\n\t\tisOrthographicCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\t\tvar left = cx - dx;\n\t\t\tvar right = cx + dx;\n\t\t\tvar top = cy + dy;\n\t\t\tvar bottom = cy - dy;\n\n\t\t\tif ( this.view !== null ) {\n\n\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t\t}\n\n\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tvar type, size;\n\n\t\tfunction setIndex( index ) {\n\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t\tsize = 4;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\tsize = 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawElements( mode, count, type, start * size );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry, start, count ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tsetMode: setMode,\n\t\t\tsetIndex: setIndex,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar position = geometry.attributes.position;\n\n\t\t\tvar count = 0;\n\n\t\t\tif ( (position && position.isInterleavedBufferAttribute) ) {\n\n\t\t\t\tcount = position.data.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t} else {\n\n\t\t\t\tcount = position.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t}\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\t\t\tsetMode: setMode,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLLights() {\n\n\t\tvar lights = {};\n\n\t\treturn {\n\n\t\t\tget: function ( light ) {\n\n\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\t\treturn lights[ light.id ];\n\n\t\t\t\t}\n\n\t\t\t\tvar uniforms;\n\n\t\t\t\tswitch ( light.type ) {\n\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\t\treturn uniforms;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\tfunction WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material.isRawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\t\t\t'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( ! material.isShaderMaterial ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLPrograms( renderer, capabilities ) {\n\n\t\tvar programs = [];\n\n\t\tvar shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points'\n\t\t};\n\n\t\tvar parameterNames = [\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\"\n\t\t];\n\n\n\t\tfunction allocateBones( object ) {\n\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\t\treturn 1024;\n\n\t\t\t} else {\n\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//    (up to 54 should be safe)\n\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\t\tif ( object !== undefined && (object && object.isSkinnedMesh) ) {\n\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn maxBones;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\t\tvar encoding;\n\n\t\t\tif ( ! map ) {\n\n\t\t\t\tencoding = LinearEncoding;\n\n\t\t\t} else if ( (map && map.isTexture) ) {\n\n\t\t\t\tencoding = map.encoding;\n\n\t\t\t} else if ( (map && map.isWebGLRenderTarget) ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\tencoding = map.texture.encoding;\n\n\t\t\t}\n\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\t\tencoding = GammaEncoding;\n\n\t\t\t}\n\n\t\t\treturn encoding;\n\n\t\t}\n\n\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {\n\n\t\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\n\t\t\tvar maxBones = allocateBones( object );\n\t\t\tvar precision = renderer.getPrecision();\n\n\t\t\tif ( material.precision !== null ) {\n\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\t\tvar parameters = {\n\n\t\t\t\tshaderID: shaderID,\n\n\t\t\t\tprecision: precision,\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\tmap: !! material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\t\tcombine: material.combine,\n\n\t\t\t\tvertexColors: material.vertexColors,\n\n\t\t\t\tfog: !! fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp: (fog && fog.isFogExp2),\n\n\t\t\t\tflatShading: material.shading === FlatShading,\n\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\t\tskinning: material.skinning,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\tnumClipIntersection: nClipIntersection,\n\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\tflipSided: material.side === BackSide,\n\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t\t};\n\n\t\t\treturn parameters;\n\n\t\t};\n\n\t\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\t\tvar array = [];\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tarray.push( parameters.shaderID );\n\n\t\t\t} else {\n\n\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\tarray.push( material.vertexShader );\n\n\t\t\t}\n\n\t\t\tif ( material.defines !== undefined ) {\n\n\t\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\t\tarray.push( name );\n\t\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t\t}\n\n\t\t\treturn array.join();\n\n\t\t};\n\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\t\tvar program;\n\n\t\t\t// Check if code has been already compiled\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\t\tvar programInfo = programs[ p ];\n\n\t\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t++ program.usedTimes;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tprogram = new WebGLProgram( renderer, code, material, parameters );\n\t\t\t\tprograms.push( program );\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t};\n\n\t\tthis.releaseProgram = function( program ) {\n\n\t\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t\t// Remove from unordered set\n\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\tprograms.pop();\n\n\t\t\t\t// Free WebGL resources\n\t\t\t\tprogram.destroy();\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tthis.programs = programs;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLGeometries( gl, properties, info ) {\n\n\t\tvar geometries = {};\n\n\t\tfunction onGeometryDispose( event ) {\n\n\t\t\tvar geometry = event.target;\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t\t}\n\n\t\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\t\tdelete geometries[ geometry.id ];\n\n\t\t\t// TODO\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe ) {\n\n\t\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( geometry );\n\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( buffergeometry );\n\n\t\t\t//\n\n\t\t\tinfo.memory.geometries --;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction deleteAttribute( attribute ) {\n\n\t\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\t\tif ( buffer !== undefined ) {\n\n\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction deleteAttributes( attributes ) {\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tproperties.delete( attribute.data );\n\n\t\t\t} else {\n\n\t\t\t\tproperties.delete( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\t\t\treturn geometries[ geometry.id ];\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\t\t\tvar buffergeometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tbuffergeometry = geometry;\n\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t\t\t}\n\n\t\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\t\t\tinfo.memory.geometries ++;\n\n\t\t\t\treturn buffergeometry;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLObjects( gl, properties, info ) {\n\n\t\tvar geometries = new WebGLGeometries( gl, properties, info );\n\n\t\t//\n\n\t\tfunction update( object ) {\n\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\t\tvar geometry = geometries.get( object );\n\n\t\t\tif ( object.geometry.isGeometry ) {\n\n\t\t\t\tgeometry.updateFromObject( object );\n\n\t\t\t}\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var name in morphAttributes ) {\n\n\t\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\t\tvar data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\t\tvar attributeProperties = properties.get( data );\n\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tif ( data.dynamic === false ) {\n\n\t\t\t\tgl.bufferData( bufferType, data.array, gl.STATIC_DRAW );\n\n\t\t\t} else if ( data.updateRange.count === - 1 ) {\n\n\t\t\t\t// Not using update ranges\n\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t\t}\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction getWireframeAttribute( geometry ) {\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\t\treturn property.wireframe;\n\n\t\t\t}\n\n\t\t\tvar indices = [];\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\t\tvar position = attributes.position;\n\n\t\t\t// console.time( 'wireframe' );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar edges = {};\n\t\t\t\tvar array = index.array;\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar array = attributes.position.array;\n\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\tvar c = i + 2;\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// console.timeEnd( 'wireframe' );\n\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar attribute = new BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\tproperty.wireframe = attribute;\n\n\t\t\treturn attribute;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tgetAttributeBuffer: getAttributeBuffer,\n\t\t\tgetWireframeAttribute: getWireframeAttribute,\n\n\t\t\tupdate: update\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\t\tvar _infoMemory = info.memory;\n\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t\t//\n\n\t\tfunction clampToMaxSize( image, maxSize ) {\n\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t// premultiplied alpha.\n\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\n\t\t}\n\n\t\tfunction makePowerOfTwo( image ) {\n\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = _Math.nearestPowerOfTwo( image.width );\n\t\t\t\tcanvas.height = _Math.nearestPowerOfTwo( image.height );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Fallback filters for non-power-of-2 textures\n\n\t\tfunction filterFallback( f ) {\n\n\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\n\t\t\t\treturn _gl.NEAREST;\n\n\t\t\t}\n\n\t\t\treturn _gl.LINEAR;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction onTextureDispose( event ) {\n\n\t\t\tvar texture = event.target;\n\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\t\tdeallocateTexture( texture );\n\n\t\t\t_infoMemory.textures --;\n\n\n\t\t}\n\n\t\tfunction onRenderTargetDispose( event ) {\n\n\t\t\tvar renderTarget = event.target;\n\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t\t_infoMemory.textures --;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction deallocateTexture( texture ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t\t} else {\n\n\t\t\t\t// 2D texture\n\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\t// remove all webgl properties\n\t\t\tproperties.delete( texture );\n\n\t\t}\n\n\t\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\tif ( ! renderTarget ) return;\n\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t\t}\n\n\t\t\tproperties.delete( renderTarget.texture );\n\t\t\tproperties.delete( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\n\n\t\tfunction setTexture2D( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tvar image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureCube( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image.length === 6 ) {\n\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\t\tvar isCompressed = (texture && texture.isCompressedTexture);\n\t\t\t\t\tvar isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);\n\n\t\t\t\t\tvar cubeImage = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension ) {\n\n\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\t\timage = makePowerOfTwo( image );\n\n\t\t\t}\n\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\tif ( (texture && texture.isDepthTexture) ) {\n\n\t\t\t\t// populate depth texture with dummy data\n\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\t}\n\n\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\n\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\n\t\t\t\t}\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t} else if ( (texture && texture.isDataTexture) ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( (texture && texture.isCompressedTexture) ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\t// Render targets\n\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else {\n\n\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t}\n\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {\n\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t\t}\n\n\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\n\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error('Unknown depthTexture format')\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup GL resources for a non-texture depth buffer\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Set up GL resources for the render target\n\t\tfunction setupRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t\t// Setup framebuffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t\t// Setup color buffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t// Setup depth and stencil buffers\n\n\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\t\tvar texture = renderTarget.texture;\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\ttexture.minFilter !== NearestFilter &&\n\t\t\t\t\ttexture.minFilter !== LinearFilter ) {\n\n\t\t\t\tvar target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\tstate.bindTexture( target, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n\t}\n\n\t/**\n\t * @author fordacious / fordacious.github.io\n\t */\n\n\tfunction WebGLProperties() {\n\n\t\tvar properties = {};\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar uuid = object.uuid;\n\t\t\t\tvar map = properties[ uuid ];\n\n\t\t\t\tif ( map === undefined ) {\n\n\t\t\t\t\tmap = {};\n\t\t\t\t\tproperties[ uuid ] = map;\n\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\n\t\t\t},\n\n\t\t\tdelete: function ( object ) {\n\n\t\t\t\tdelete properties[ object.uuid ];\n\n\t\t\t},\n\n\t\t\tclear: function () {\n\n\t\t\t\tproperties = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLState( gl, extensions, paramThreeToGL ) {\n\n\t\tfunction ColorBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar color = new Vector4();\n\t\t\tvar currentColorMask = null;\n\t\t\tvar currentColorClear = new Vector4();\n\n\t\t\treturn {\n\n\t\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( r, g, b, a ) {\n\n\t\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\tcurrentColorClear.set( 0, 0, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction DepthBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentDepthMask = null;\n\t\t\tvar currentDepthFunc = null;\n\t\t\tvar currentDepthClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction StencilBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentStencilMask = null;\n\t\t\tvar currentStencilFunc = null;\n\t\t\tvar currentStencilRef = null;\n\t\t\tvar currentStencilFuncMask = null;\n\t\t\tvar currentStencilFail  = null;\n\t\t\tvar currentStencilZFail = null;\n\t\t\tvar currentStencilZPass = null;\n\t\t\tvar currentStencilClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tvar colorBuffer = new ColorBuffer();\n\t\tvar depthBuffer = new DepthBuffer();\n\t\tvar stencilBuffer = new StencilBuffer();\n\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\t\tvar capabilities = {};\n\n\t\tvar compressedTextureFormats = null;\n\n\t\tvar currentBlending = null;\n\t\tvar currentBlendEquation = null;\n\t\tvar currentBlendSrc = null;\n\t\tvar currentBlendDst = null;\n\t\tvar currentBlendEquationAlpha = null;\n\t\tvar currentBlendSrcAlpha = null;\n\t\tvar currentBlendDstAlpha = null;\n\t\tvar currentPremultipledAlpha = false;\n\n\t\tvar currentFlipSided = null;\n\t\tvar currentCullFace = null;\n\n\t\tvar currentLineWidth = null;\n\n\t\tvar currentPolygonOffsetFactor = null;\n\t\tvar currentPolygonOffsetUnits = null;\n\n\t\tvar currentScissorTest = null;\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\t\tvar currentTextureSlot = null;\n\t\tvar currentBoundTextures = {};\n\n\t\tvar currentScissor = new Vector4();\n\t\tvar currentViewport = new Vector4();\n\n\t\tfunction createTexture( type, target, count ) {\n\n\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\tvar texture = gl.createTexture();\n\n\t\t\tgl.bindTexture( type, texture );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tvar emptyTextures = {};\n\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t\t//\n\n\t\tfunction init() {\n\n\t\t\tclearColor( 0, 0, 0, 1 );\n\t\t\tclearDepth( 1 );\n\t\t\tclearStencil( 0 );\n\n\t\t\tenable( gl.DEPTH_TEST );\n\t\t\tsetDepthFunc( LessEqualDepth );\n\n\t\t\tsetFlipSided( false );\n\t\t\tsetCullFace( CullFaceBack );\n\t\t\tenable( gl.CULL_FACE );\n\n\t\t\tenable( gl.BLEND );\n\t\t\tsetBlending( NormalBlending );\n\n\t\t}\n\n\t\tfunction initAttributes() {\n\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tnewAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttribute( attribute ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disableUnusedAttributes() {\n\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\t\tgl.enable( id );\n\t\t\t\tcapabilities[ id ] = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\t\tgl.disable( id );\n\t\t\t\tcapabilities[ id ] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getCompressedTextureFormats() {\n\n\t\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\t\tcompressedTextureFormats = [];\n\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn compressedTextureFormats;\n\n\t\t}\n\n\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\t\tif ( blending !== NoBlending ) {\n\n\t\t\t\tenable( gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.BLEND );\n\n\t\t\t}\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( blending === AdditiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === SubtractiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === MultiplyBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blending === CustomBlending ) {\n\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t\t}\n\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction setColorWrite( colorWrite ) {\n\n\t\t\tcolorBuffer.setMask( colorWrite );\n\n\t\t}\n\n\t\tfunction setDepthTest( depthTest ) {\n\n\t\t\tdepthBuffer.setTest( depthTest );\n\n\t\t}\n\n\t\tfunction setDepthWrite( depthWrite ) {\n\n\t\t\tdepthBuffer.setMask( depthWrite );\n\n\t\t}\n\n\t\tfunction setDepthFunc( depthFunc ) {\n\n\t\t\tdepthBuffer.setFunc( depthFunc );\n\n\t\t}\n\n\t\tfunction setStencilTest( stencilTest ) {\n\n\t\t\tstencilBuffer.setTest( stencilTest );\n\n\t\t}\n\n\t\tfunction setStencilWrite( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( stencilWrite );\n\n\t\t}\n\n\t\tfunction setStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\tstencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t}\n\n\t\tfunction setStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\tstencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction setFlipSided( flipSided ) {\n\n\t\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\t\tif ( flipSided ) {\n\n\t\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFlipSided = flipSided;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setCullFace( cullFace ) {\n\n\t\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\t\tenable( gl.CULL_FACE );\n\n\t\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\tcurrentCullFace = cullFace;\n\n\t\t}\n\n\t\tfunction setLineWidth( width ) {\n\n\t\t\tif ( width !== currentLineWidth ) {\n\n\t\t\t\tgl.lineWidth( width );\n\n\t\t\t\tcurrentLineWidth = width;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\t\tif ( polygonOffset ) {\n\n\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getScissorTest() {\n\n\t\t\treturn currentScissorTest;\n\n\t\t}\n\n\t\tfunction setScissorTest( scissorTest ) {\n\n\t\t\tcurrentScissorTest = scissorTest;\n\n\t\t\tif ( scissorTest ) {\n\n\t\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// texture\n\n\t\tfunction activeTexture( webglSlot ) {\n\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\tactiveTexture();\n\n\t\t\t}\n\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\t\tif ( boundTexture === undefined ) {\n\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t\t}\n\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction compressedTexImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction texImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction clearColor( r, g, b, a ) {\n\n\t\t\tcolorBuffer.setClear( r, g, b, a );\n\n\t\t}\n\n\t\tfunction clearDepth( depth ) {\n\n\t\t\tdepthBuffer.setClear( depth );\n\n\t\t}\n\n\t\tfunction clearStencil( stencil ) {\n\n\t\t\tstencilBuffer.setClear( stencil );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction scissor( scissor ) {\n\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\tcurrentScissor.copy( scissor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction viewport( viewport ) {\n\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\tcurrentViewport.copy( viewport );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction reset() {\n\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcapabilities = {};\n\n\t\t\tcompressedTextureFormats = null;\n\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\n\t\t\tcurrentBlending = null;\n\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\n\t\t\tcolorBuffer.reset();\n\t\t\tdepthBuffer.reset();\n\t\t\tstencilBuffer.reset();\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tbuffers: {\n\t\t\t\tcolor: colorBuffer,\n\t\t\t\tdepth: depthBuffer,\n\t\t\t\tstencil: stencilBuffer\n\t\t\t},\n\n\t\t\tinit: init,\n\t\t\tinitAttributes: initAttributes,\n\t\t\tenableAttribute: enableAttribute,\n\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\tenable: enable,\n\t\t\tdisable: disable,\n\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\n\t\t\tsetBlending: setBlending,\n\n\t\t\tsetColorWrite: setColorWrite,\n\t\t\tsetDepthTest: setDepthTest,\n\t\t\tsetDepthWrite: setDepthWrite,\n\t\t\tsetDepthFunc: setDepthFunc,\n\t\t\tsetStencilTest: setStencilTest,\n\t\t\tsetStencilWrite: setStencilWrite,\n\t\t\tsetStencilFunc: setStencilFunc,\n\t\t\tsetStencilOp: setStencilOp,\n\n\t\t\tsetFlipSided: setFlipSided,\n\t\t\tsetCullFace: setCullFace,\n\n\t\t\tsetLineWidth: setLineWidth,\n\t\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\t\tgetScissorTest: getScissorTest,\n\t\t\tsetScissorTest: setScissorTest,\n\n\t\t\tactiveTexture: activeTexture,\n\t\t\tbindTexture: bindTexture,\n\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\ttexImage2D: texImage2D,\n\n\t\t\tclearColor: clearColor,\n\t\t\tclearDepth: clearDepth,\n\t\t\tclearStencil: clearStencil,\n\n\t\t\tscissor: scissor,\n\t\t\tviewport: viewport,\n\n\t\t\treset: reset\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\t\tvar maxAnisotropy;\n\n\t\tfunction getMaxAnisotropy() {\n\n\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t\t} else {\n\n\t\t\t\tmaxAnisotropy = 0;\n\n\t\t\t}\n\n\t\t\treturn maxAnisotropy;\n\n\t\t}\n\n\t\tfunction getMaxPrecision( precision ) {\n\n\t\t\tif ( precision === 'highp' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'highp';\n\n\t\t\t\t}\n\n\t\t\t\tprecision = 'mediump';\n\n\t\t\t}\n\n\t\t\tif ( precision === 'mediump' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'mediump';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn 'lowp';\n\n\t\t}\n\n\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tvar maxPrecision = getMaxPrecision( precision );\n\n\t\tif ( maxPrecision !== precision ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\tprecision = maxPrecision;\n\n\t\t}\n\n\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\t\treturn {\n\n\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\t\tprecision: precision,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tmaxTextures: maxTextures,\n\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\t\tmaxAttributes: maxAttributes,\n\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\tmaxVaryings: maxVaryings,\n\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\t\tvertexTextures: vertexTextures,\n\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\tfloatVertexTextures: floatVertexTextures\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLExtensions( gl ) {\n\n\t\tvar extensions = {};\n\n\t\treturn {\n\n\t\t\tget: function ( name ) {\n\n\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\t\t\treturn extensions[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tvar extension;\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\textension = gl.getExtension( name );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\textensions[ name ] = extension;\n\n\t\t\t\treturn extension;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction WebGLClipping() {\n\n\t\tvar scope = this,\n\n\t\t\tglobalState = null,\n\t\t\tnumGlobalPlanes = 0,\n\t\t\tlocalClippingEnabled = false,\n\t\t\trenderingShadows = false,\n\n\t\t\tplane = new Plane(),\n\t\t\tviewNormalMatrix = new Matrix3(),\n\n\t\t\tuniform = { value: null, needsUpdate: false };\n\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\tthis.numIntersection = 0;\n\n\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\t\tvar enabled =\n\t\t\t\tplanes.length !== 0 ||\n\t\t\t\tenableLocalClipping ||\n\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\tlocalClippingEnabled;\n\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\tnumGlobalPlanes = planes.length;\n\n\t\t\treturn enabled;\n\n\t\t};\n\n\t\tthis.beginShadows = function() {\n\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes( null );\n\n\t\t};\n\n\t\tthis.endShadows = function() {\n\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\n\t\t};\n\n\t\tthis.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t// there's no local clipping\n\n\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t// there's no global clipping\n\n\t\t\t\t\tprojectPlanes( null );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\tthis.numPlanes += nGlobal;\n\n\t\t\t}\n\n\n\t\t};\n\n\t\tfunction resetGlobalState() {\n\n\t\t\tif ( uniform.value !== globalState ) {\n\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\tscope.numIntersection = 0;\n\n\t\t}\n\n\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\tdstArray = null;\n\n\t\t\tif ( nPlanes !== 0 ) {\n\n\t\t\t\tdstArray = uniform.value;\n\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\t\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t * @author tschw\n\t */\n\n\tfunction WebGLRenderer( parameters ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\n\t\tparameters = parameters || {};\n\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\t\tvar lights = [];\n\n\t\tvar opaqueObjects = [];\n\t\tvar opaqueObjectsLastIndex = - 1;\n\t\tvar transparentObjects = [];\n\t\tvar transparentObjectsLastIndex = - 1;\n\n\t\tvar morphInfluences = new Float32Array( 8 );\n\n\t\tvar sprites = [];\n\t\tvar lensFlares = [];\n\n\t\t// public properties\n\n\t\tthis.domElement = _canvas;\n\t\tthis.context = null;\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\tthis.gammaInput = false;\n\t\tthis.gammaOutput = false;\n\n\t\t// physical lights\n\n\t\tthis.physicallyCorrectLights = false;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = LinearToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\t\tthis.toneMappingWhitePoint = 1.0;\n\n\t\t// morphs\n\n\t\tthis.maxMorphTargets = 8;\n\t\tthis.maxMorphNormals = 4;\n\n\t\t// internal properties\n\n\t\tvar _this = this,\n\n\t\t// internal state cache\n\n\t\t_currentProgram = null,\n\t\t_currentRenderTarget = null,\n\t\t_currentFramebuffer = null,\n\t\t_currentMaterialId = - 1,\n\t\t_currentGeometryProgram = '',\n\t\t_currentCamera = null,\n\n\t\t_currentScissor = new Vector4(),\n\t\t_currentScissorTest = null,\n\n\t\t_currentViewport = new Vector4(),\n\n\t\t//\n\n\t\t_usedTextureUnits = 0,\n\n\t\t//\n\n\t\t_clearColor = new Color( 0x000000 ),\n\t\t_clearAlpha = 0,\n\n\t\t_width = _canvas.width,\n\t\t_height = _canvas.height,\n\n\t\t_pixelRatio = 1,\n\n\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t_scissorTest = false,\n\n\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\n\t\t// frustum\n\n\t\t_frustum = new Frustum(),\n\n\t\t// clipping\n\n\t\t_clipping = new WebGLClipping(),\n\t\t_clippingEnabled = false,\n\t\t_localClippingEnabled = false,\n\n\t\t_sphere = new Sphere(),\n\n\t\t// camera matrices cache\n\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_vector3 = new Vector3(),\n\n\t\t// light arrays cache\n\n\t\t_lights = {\n\n\t\t\thash: '',\n\n\t\t\tambient: [ 0, 0, 0 ],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\tpoint: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: [],\n\n\t\t\tshadows: []\n\n\t\t},\n\n\t\t// info\n\n\t\t_infoRender = {\n\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\n\t\t};\n\n\t\tthis.info = {\n\n\t\t\trender: _infoRender,\n\t\t\tmemory: {\n\n\t\t\t\tgeometries: 0,\n\t\t\t\ttextures: 0\n\n\t\t\t},\n\t\t\tprograms: null\n\n\t\t};\n\n\n\t\t// initialize\n\n\t\tvar _gl;\n\n\t\ttry {\n\n\t\t\tvar attributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t};\n\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t\t}\n\n\t\tvar extensions = new WebGLExtensions( _gl );\n\n\t\textensions.get( 'WEBGL_depth_texture' );\n\t\textensions.get( 'OES_texture_float' );\n\t\textensions.get( 'OES_texture_float_linear' );\n\t\textensions.get( 'OES_texture_half_float' );\n\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\textensions.get( 'OES_standard_derivatives' );\n\t\textensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\tBufferGeometry.MaxIndex = 4294967296;\n\n\t\t}\n\n\t\tvar capabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\tvar state = new WebGLState( _gl, extensions, paramThreeToGL );\n\t\tvar properties = new WebGLProperties();\n\t\tvar textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\tvar objects = new WebGLObjects( _gl, properties, this.info );\n\t\tvar programCache = new WebGLPrograms( this, capabilities );\n\t\tvar lightCache = new WebGLLights();\n\n\t\tthis.info.programs = programCache.programs;\n\n\t\tvar bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\tvar indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t\t//\n\n\t\tvar backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\tvar backgroundCamera2 = new PerspectiveCamera();\n\t\tvar backgroundPlaneMesh = new Mesh(\n\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t);\n\t\tvar backgroundBoxShader = ShaderLib[ 'cube' ];\n\t\tvar backgroundBoxMesh = new Mesh(\n\t\t\tnew BoxBufferGeometry( 5, 5, 5 ),\n\t\t\tnew ShaderMaterial( {\n\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tfog: false\n\t\t\t} )\n\t\t);\n\n\t\t//\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\tfunction glClearColor( r, g, b, a ) {\n\n\t\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t}\n\n\t\t\tstate.clearColor( r, g, b, a );\n\n\t\t}\n\n\t\tfunction setDefaultGLState() {\n\n\t\t\tstate.init();\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t}\n\n\t\tfunction resetGLState() {\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\n\t\t\tstate.reset();\n\n\t\t}\n\n\t\tsetDefaultGLState();\n\n\t\tthis.context = _gl;\n\t\tthis.capabilities = capabilities;\n\t\tthis.extensions = extensions;\n\t\tthis.properties = properties;\n\t\tthis.state = state;\n\n\t\t// shadow map\n\n\t\tvar shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );\n\n\t\tthis.shadowMap = shadowMap;\n\n\n\t\t// Plugins\n\n\t\tvar spritePlugin = new SpritePlugin( this, sprites );\n\t\tvar lensFlarePlugin = new LensFlarePlugin( this, lensFlares );\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t\t};\n\n\t\tthis.getMaxAnisotropy = function () {\n\n\t\t\treturn capabilities.getMaxAnisotropy();\n\n\t\t};\n\n\t\tthis.getPrecision = function () {\n\n\t\t\treturn capabilities.precision;\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t\t};\n\n\t\tthis.getSize = function () {\n\n\t\t\treturn {\n\t\t\t\twidth: _width,\n\t\t\t\theight: _height\n\t\t\t};\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t_canvas.height = height * _pixelRatio;\n\n\t\t\tif ( updateStyle !== false ) {\n\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function () {\n\n\t\t\treturn _clearColor;\n\n\t\t};\n\n\t\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t\t_clearColor.set( color );\n\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn _clearAlpha;\n\n\t\t};\n\n\t\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t\t_clearAlpha = alpha;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.clear = function ( color, depth, stencil ) {\n\n\t\t\tvar bits = 0;\n\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\tthis.clear( color, depth, stencil );\n\n\t\t};\n\n\t\t// Reset\n\n\t\tthis.resetGLState = resetGLState;\n\n\t\tthis.dispose = function() {\n\n\t\t\ttransparentObjects = [];\n\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\topaqueObjects = [];\n\t\t\topaqueObjectsLastIndex = -1;\n\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tresetGLState();\n\t\t\tsetDefaultGLState();\n\n\t\t\tproperties.clear();\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tvar material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\tproperties.delete( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReference( material ) {\n\n\t\t\tvar programInfo = properties.get( material ).program;\n\n\t\t\tmaterial.program = undefined;\n\n\t\t\tif ( programInfo !== undefined ) {\n\n\t\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar buffers = properties.get( object );\n\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( object.hasPositions ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasNormals ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t     ! material.isMeshStandardMaterial &&\n\t\t\t\t       material.shading === FlatShading ) {\n\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\t\tobject.count = 0;\n\n\t\t};\n\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\t\tsetMaterial( material );\n\n\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\tvar updateBuffers = false;\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\t\tvar activeInfluences = [];\n\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t\t}\n\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t\t}\n\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {\n\n\t\t\t\t\tmorphInfluences[ i ] = 0.0;\n\n\t\t\t\t}\n\n\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar position = geometry.attributes.position;\n\t\t\tvar rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\tvar renderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( index );\n\n\t\t\t} else {\n\n\t\t\t\trenderer = bufferRenderer;\n\n\t\t\t}\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar dataCount = 0;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdataCount = index.count;\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\tdataCount = position.count;\n\n\t\t\t}\n\n\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t\tif ( drawCount === 0 ) return;\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t}\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t\tvar programAttributes = program.getAttributes();\n\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\t\tfor ( var name in programAttributes ) {\n\n\t\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\t\tconsole.warn( \"Unsupported data buffer format: Float64Array\" );\n\n\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t}\n\n\t\t// Sorting\n\n\t\tfunction absNumericalSort( a, b ) {\n\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\n\t\t\t\treturn a.material.program.id - b.material.program.id;\n\n\t\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\t\treturn a.material.id - b.material.id;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn a.z - b.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction reversePainterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// reset caching for this frame\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\tlights.length = 0;\n\n\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\ttransparentObjectsLastIndex = - 1;\n\n\t\t\tsprites.length = 0;\n\t\t\tlensFlares.length = 0;\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\t\tprojectObject( scene, camera );\n\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\t\tsetupShadows( lights );\n\n\t\t\tshadowMap.render( scene, camera );\n\n\t\t\tsetupLights( lights, camera );\n\n\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t\t//\n\n\t\t\t_infoRender.calls = 0;\n\t\t\t_infoRender.vertices = 0;\n\t\t\t_infoRender.faces = 0;\n\t\t\t_infoRender.points = 0;\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\trenderTarget = null;\n\n\t\t\t}\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t\t//\n\n\t\t\tvar background = scene.background;\n\n\t\t\tif ( background === null ) {\n\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t\t} else if ( background && background.isColor ) {\n\n\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\t\t\tforceClear = true;\n\n\t\t\t}\n\n\t\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t\t}\n\n\t\t\tif ( background && background.isCubeTexture ) {\n\n\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t\tobjects.update( backgroundBoxMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t\t} else if ( background && background.isTexture ) {\n\n\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t\tobjects.update( backgroundPlaneMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.overrideMaterial ) {\n\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\t\trenderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\trenderObjects( transparentObjects, scene, camera, overrideMaterial );\n\n\t\t\t} else {\n\n\t\t\t\t// opaque pass (front-to-back order)\n\n\t\t\t\tstate.setBlending( NoBlending );\n\t\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\t\t// transparent pass (back-to-front order)\n\n\t\t\t\trenderObjects( transparentObjects, scene, camera );\n\n\t\t\t}\n\n\t\t\t// custom render plugins (post pass)\n\n\t\t\tspritePlugin.render( scene, camera );\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t\t}\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.setDepthTest( true );\n\t\t\tstate.setDepthWrite( true );\n\t\t\tstate.setColorWrite( true );\n\n\t\t\t// _gl.finish();\n\n\t\t};\n\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\t\tvar array, index;\n\n\t\t\t// allocate the next position in the appropriate array\n\n\t\t\tif ( material.transparent ) {\n\n\t\t\t\tarray = transparentObjects;\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t\t} else {\n\n\t\t\t\tarray = opaqueObjects;\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t\t}\n\n\t\t\t// recycle existing render item or grow the array\n\n\t\t\tvar renderItem = array[ index ];\n\n\t\t\tif ( renderItem !== undefined ) {\n\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\trenderItem.group = group;\n\n\t\t\t} else {\n\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\n\t\t\t\t// assert( index === array.length );\n\t\t\t\tarray.push( renderItem );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Duplicated code (Frustum)\n\n\t\tfunction isObjectViewable( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSpriteViewable( sprite ) {\n\n\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSphereViewable( sphere ) {\n\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\t\tif ( numPlanes === 0 ) return true;\n\n\t\t\tvar planes = _this.clippingPlanes,\n\n\t\t\t\tcenter = sphere.center,\n\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\ti = 0;\n\n\t\t\tdo {\n\n\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t\t} while ( ++ i !== numPlanes );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isLight ) {\n\n\t\t\t\t\tlights.push( object );\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isLensFlare ) {\n\n\t\t\t\t\tlensFlares.push( object );\n\n\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\t\tif ( material.isMultiMaterial ) {\n\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\t\tvar object = renderItem.object;\n\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\tvar group = renderItem.group;\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tsetMaterial( material );\n\n\t\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\n\t\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\n\t\t\t\t}\n\n\t\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction initMaterial( material, fog, object ) {\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\t\tvar program = materialProperties.program;\n\t\t\tvar programChange = true;\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t} else if ( program.code !== code ) {\n\n\t\t\t\t// changed glsl or parameters\n\t\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t\t// same glsl and uniform list\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// only rebuild uniform list\n\t\t\t\tprogramChange = false;\n\n\t\t\t}\n\n\t\t\tif ( programChange ) {\n\n\t\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\t\tmaterialProperties.program = program;\n\t\t\t\tmaterial.program = program;\n\n\t\t\t}\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t     ! material.isRawShaderMaterial ||\n\t\t\t       material.clipping === true ) {\n\n\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t\t}\n\n\t\t\tmaterialProperties.fog = fog;\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t\t}\n\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\tuniformsList =\n\t\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\t}\n\n\t\tfunction setMaterial( material ) {\n\n\t\t\tmaterial.side === DoubleSide\n\t\t\t\t? state.disable( _gl.CULL_FACE )\n\t\t\t\t: state.enable( _gl.CULL_FACE );\n\n\t\t\tstate.setFlipSided( material.side === BackSide );\n\n\t\t\tmaterial.transparent === true\n\t\t\t\t? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t: state.setBlending( NoBlending );\n\n\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t}\n\n\t\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t\t_usedTextureUnits = 0;\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tif ( _clippingEnabled ) {\n\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate === false ) {\n\n\t\t\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes || \n\t \t\t\t\t  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate ) {\n\n\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\tmaterial.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\tvar refreshProgram = false;\n\t\t\tvar refreshMaterial = false;\n\t\t\tvar refreshLights = false;\n\n\t\t\tvar program = materialProperties.program,\n\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t_currentProgram = program.id;\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t\t// load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.envMap ) {\n\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isShaderMaterial ||\n\t\t\t\t     material.skinning ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\t}\n\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t\t}\n\n\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// not sure why, but otherwise weird things happen\n\n\t\t\tif ( material.skinning ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tvar skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tif ( material.lights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isMeshDepthMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh single material specific uniforms\n\n\t\t\t\tif ( material.isLineBasicMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isLineDashedMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t\t}\n\n\t\t\t\tWebGLUniforms.upload(\n\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t\t}\n\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// Uniforms (refresh uniforms objects)\n\n\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t\tif ( material.emissive ) {\n\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t\t}\n\n\t\t\tuniforms.map.value = material.map;\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\tif ( material.aoMap ) {\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\t// uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. normal map\n\t\t\t// 4. bump map\n\t\t\t// 5. alpha map\n\t\t\t// 6. emissive map\n\n\t\t\tvar uvScaleMap;\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\tuvScaleMap = material.map;\n\n\t\t\t} else if ( material.specularMap ) {\n\n\t\t\t\tuvScaleMap = material.specularMap;\n\n\t\t\t} else if ( material.displacementMap ) {\n\n\t\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t\t} else if ( material.normalMap ) {\n\n\t\t\t\tuvScaleMap = material.normalMap;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t\t} else if ( material.roughnessMap ) {\n\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t\t} else if ( material.metalnessMap ) {\n\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t\t} else if ( material.alphaMap ) {\n\n\t\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t\t} else if ( material.emissiveMap ) {\n\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t\t// backwards compatibility\n\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t\t}\n\n\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t\tuniforms.envMap.value = material.envMap;\n\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t}\n\n\t\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t}\n\n\t\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\n\t\t}\n\n\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\tuniforms.scale.value = _height * 0.5;\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tvar offset = material.map.offset;\n\t\t\t\tvar repeat = material.map.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\n\t\t\tuniforms.fogColor.value = fog.color;\n\n\t\t\tif ( fog.isFog ) {\n\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\t\tuniforms.specular.value = material.specular;\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\n\t\t\tif ( material.roughnessMap ) {\n\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.metalnessMap ) {\n\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t\tif ( material.envMap ) {\n\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\n\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\t// Lighting\n\n\t\tfunction setupShadows( lights ) {\n\n\t\t\tvar lightShadowsLength = 0;\n\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.shadows.length = lightShadowsLength;\n\n\t\t}\n\n\t\tfunction setupLights( lights, camera ) {\n\n\t\t\tvar l, ll, light,\n\t\t\tr = 0, g = 0, b = 0,\n\t\t\tcolor,\n\t\t\tintensity,\n\t\t\tdistance,\n\t\t\tshadowMap,\n\n\t\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\t\tdirectionalLength = 0,\n\t\t\tpointLength = 0,\n\t\t\tspotLength = 0,\n\t\t\themiLength = 0;\n\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\t\tlight = lights[ l ];\n\n\t\t\t\tcolor = light.color;\n\t\t\t\tintensity = light.intensity;\n\t\t\t\tdistance = light.distance;\n\n\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\n\t\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t_lights.ambient[ 2 ] = b;\n\n\t\t\t_lights.directional.length = directionalLength;\n\t\t\t_lights.spot.length = spotLength;\n\t\t\t_lights.point.length = pointLength;\n\t\t\t_lights.hemi.length = hemiLength;\n\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t\t}\n\n\t\t// GL state setting\n\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\t\tstate.setCullFace( cullFace );\n\t\t\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\n\n\t\t};\n\n\t\t// Textures\n\n\t\tfunction allocTextureUnit() {\n\n\t\t\tvar textureUnit = _usedTextureUnits;\n\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t\t}\n\n\t\t\t_usedTextureUnits += 1;\n\n\t\t\treturn textureUnit;\n\n\t\t}\n\n\t\tthis.allocTextureUnit = allocTextureUnit;\n\n\t\t// this.setTexture2D = setTexture2D;\n\t\tthis.setTexture2D = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTexture = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTexture( texture, slot ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTextureCube = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t// TODO: unify these code paths\n\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.getCurrentRenderTarget = function() {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t}\n\n\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\tvar framebuffer;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t\t}\n\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = null;\n\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t\t}\n\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tstate.viewport( _currentViewport );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\t\tif ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tvar restore = false;\n\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t\trestore = true;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\tvar textureType = texture.type;\n\n\t\t\t\t\tif ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Map three.js constants to WebGL constants\n\n\t\tfunction paramThreeToGL( p ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( p === RepeatWrapping ) return _gl.REPEAT;\n\t\t\tif ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\tif ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\t\tif ( p === NearestFilter ) return _gl.NEAREST;\n\t\t\tif ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\tif ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\t\tif ( p === LinearFilter ) return _gl.LINEAR;\n\t\t\tif ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\tif ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\t\tif ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\tif ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\t\tif ( p === ByteType ) return _gl.BYTE;\n\t\t\tif ( p === ShortType ) return _gl.SHORT;\n\t\t\tif ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\tif ( p === IntType ) return _gl.INT;\n\t\t\tif ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\tif ( p === FloatType ) return _gl.FLOAT;\n\n\t\t\tif ( p === HalfFloatType ) {\n\n\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\n\t\t\t}\n\n\t\t\tif ( p === AlphaFormat ) return _gl.ALPHA;\n\t\t\tif ( p === RGBFormat ) return _gl.RGB;\n\t\t\tif ( p === RGBAFormat ) return _gl.RGBA;\n\t\t\tif ( p === LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\tif ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\tif ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\t\tif ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;\n\n\t\t\tif ( p === AddEquation ) return _gl.FUNC_ADD;\n\t\t\tif ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\tif ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\t\tif ( p === ZeroFactor ) return _gl.ZERO;\n\t\t\tif ( p === OneFactor ) return _gl.ONE;\n\t\t\tif ( p === SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\tif ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\tif ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\tif ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\tif ( p === DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\tif ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\t\tif ( p === DstColorFactor ) return _gl.DST_COLOR;\n\t\t\tif ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\tif ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\t p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t\t}\n\n\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\n\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction FogExp2 ( color, density ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n\t}\n\n\tFogExp2.prototype.isFogExp2 = true;\n\n\tFogExp2.prototype.clone = function () {\n\n\t\treturn new FogExp2( this.color.getHex(), this.density );\n\n\t};\n\n\tFogExp2.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Fog ( color, near, far ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\n\t}\n\n\tFog.prototype.isFog = true;\n\n\tFog.prototype.clone = function () {\n\n\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\n\t};\n\n\tFog.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Scene () {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.fog = null;\n\t\tthis.overrideMaterial = null;\n\n\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t}\n\n\tScene.prototype = Object.create( Object3D.prototype );\n\n\tScene.prototype.constructor = Scene;\n\n\tScene.prototype.copy = function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t};\n\n\tScene.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlare( texture, size, distance, blending, color ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.lensFlares = [];\n\n\t\tthis.positionScreen = new Vector3();\n\t\tthis.customUpdateCallback = undefined;\n\n\t\tif ( texture !== undefined ) {\n\n\t\t\tthis.add( texture, size, distance, blending, color );\n\n\t\t}\n\n\t}\n\n\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LensFlare,\n\n\t\tisLensFlare: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\t\tif ( size === undefined ) size = - 1;\n\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\tif ( color === undefined ) color = new Color( 0xffffff );\n\t\t\tif ( blending === undefined ) blending = NormalBlending;\n\n\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\t\tthis.lensFlares.push( {\n\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\tcolor: color,\t\t// color\n\t\t\t\tblending: blending\t// blending\n\t\t\t} );\n\n\t\t},\n\n\t\t/*\n\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t */\n\n\t\tupdateLensFlares: function () {\n\n\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\tvar flare;\n\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *\tuvOffset: new THREE.Vector2(),\n\t *\tuvScale: new THREE.Vector2()\n\t * }\n\t */\n\n\tfunction SpriteMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\t\tthis.map = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\n\tSpriteMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.map = source.map;\n\n\t\tthis.rotation = source.rotation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Sprite( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Sprite';\n\n\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\t}\n\n\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Sprite,\n\n\t\tisSprite: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\tpoint: this.position,\n\t\t\t\t\tface: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LOD() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t}\n\t\t} );\n\n\t}\n\n\n\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LOD,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source, false );\n\n\t\t\tvar levels = source.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddLevel: function ( object, distance ) {\n\n\t\t\tif ( distance === undefined ) distance = 0;\n\n\t\t\tdistance = Math.abs( distance );\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\t\tthis.add( object );\n\n\t\t},\n\n\t\tgetObjectForDistance: function ( distance ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tupdate: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar levels = this.levels;\n\n\t\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.levels = [];\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.generateMipmaps  = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n\tDataTexture.prototype = Object.create( Texture.prototype );\n\tDataTexture.prototype.constructor = DataTexture;\n\n\tDataTexture.prototype.isDataTexture = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author michael guerrero / http://realitymeltdown.com\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Skeleton( bones, boneInverses, useVertexTexture ) {\n\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\t\tthis.identityMatrix = new Matrix4();\n\n\t\t// copy the bone array\n\n\t\tbones = bones || [];\n\n\t\tthis.bones = bones.slice( 0 );\n\n\t\t// create a bone texture or an array of floats\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\tsize = _Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\tsize = Math.max( size, 4 );\n\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t\t}\n\n\t\t// use the supplied bone inverses or calculate the inverses\n\n\t\tif ( boneInverses === undefined ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tObject.assign( Skeleton.prototype, {\n\n\t\tcalculateInverses: function () {\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tvar inverse = new Matrix4();\n\n\t\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boneInverses.push( inverse );\n\n\t\t\t}\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tvar bone;\n\n\t\t\t// recover the bind-time world matrices\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// compute the local matrices, positions, rotations and scales\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: ( function () {\n\n\t\t\tvar offsetMatrix = new Matrix4();\n\n\t\t\treturn function update() {\n\n\t\t\t\t// flatten bone matrices to array\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tclone: function () {\n\n\t\t\treturn new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Bone( skin ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Bone';\n\n\t\tthis.skin = skin;\n\n\t}\n\n\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Bone,\n\n\t\tisBone: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.skin = source.skin;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkinnedMesh( geometry, material, useVertexTexture ) {\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = \"attached\";\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\t// init bones\n\n\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t// convenience) for THREE.SkinnedMesh to do this.\n\n\t\tvar bones = [];\n\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\t\tvar bone, gbone;\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tbone = new Bone( this );\n\t\t\t\tbones.push( bone );\n\n\t\t\t\tbone.name = gbone.name;\n\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t\t}\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.normalizeSkinWeights();\n\n\t\tthis.updateMatrixWorld( true );\n\t\tthis.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n\t}\n\n\n\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\t\tconstructor: SkinnedMesh,\n\n\t\tisSkinnedMesh: true,\n\n\t\tbind: function( skeleton, bindMatrix ) {\n\n\t\t\tthis.skeleton = skeleton;\n\n\t\t\tif ( bindMatrix === undefined ) {\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t\t}\n\n\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tthis.skeleton.pose();\n\n\t\t},\n\n\t\tnormalizeSkinWeights: function () {\n\n\t\t\tif ( (this.geometry && this.geometry.isGeometry) ) {\n\n\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {\n\n\t\t\t\tvar vec = new Vector4();\n\n\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrixWorld: function( force ) {\n\n\t\t\tMesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function() {\n\n\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *  linecap: \"round\",\n\t *  linejoin: \"round\"\n\t * }\n\t */\n\n\tfunction LineBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\n\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n\tLineBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Line( geometry, material, mode ) {\n\n\t\tif ( mode === 1 ) {\n\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\treturn new LineSegments( geometry, material );\n\n\t\t}\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Line,\n\n\t\tisLine: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\tvar precisionSq = precision * precision;\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar vStart = new Vector3();\n\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\tvar interRay = new Vector3();\n\t\t\t\tvar step = (this && this.isLineSegments) ? 2 : 1;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LineSegments( geometry, material ) {\n\n\t\tLine.call( this, geometry, material );\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\t\tconstructor: LineSegments,\n\n\t\tisLineSegments: true\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  size: <float>,\n\t *  sizeAttenuation: <bool>\n\t * }\n\t */\n\n\tfunction PointsMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tPointsMaterial.prototype = Object.create( Material.prototype );\n\tPointsMaterial.prototype.constructor = PointsMaterial;\n\n\tPointsMaterial.prototype.isPointsMaterial = true;\n\n\tPointsMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Points( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Points,\n\n\t\tisPoints: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar object = this;\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\tvar position = new Vector3();\n\n\t\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Group() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Group';\n\n\t}\n\n\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Group\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.generateMipmaps = false;\n\n\t\tvar scope = this;\n\n\t\tfunction update() {\n\n\t\t\trequestAnimationFrame( update );\n\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\t\tscope.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdate();\n\n\t}\n\n\tVideoTexture.prototype = Object.create( Texture.prototype );\n\tVideoTexture.prototype.constructor = VideoTexture;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\tCompressedTexture.prototype.constructor = CompressedTexture;\n\n\tCompressedTexture.prototype.isCompressedTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\tCanvasTexture.prototype.constructor = CanvasTexture;\n\n\t/**\n\t * @author Matt DesLauriers / @mattdesl\n\t * @author atix / arthursilber.de\n\t */\n\n\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )\n\n\t\t}\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.type = type !== undefined ? type : UnsignedShortType;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps\t= false;\n\n\t}\n\n\tDepthTexture.prototype = Object.create( Texture.prototype );\n\tDepthTexture.prototype.constructor = DepthTexture;\n\tDepthTexture.prototype.isDepthTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WireframeGeometry( geometry ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar numEdges = 0;\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// Indexed BufferGeometry\n\n\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\tvar groups = geometry.groups;\n\t\t\t\tvar numEdges = 0;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\tvar numTris = numEdges / 3;\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'ParametricBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// generate vertices and uvs\n\n\t\tvar vertices = [];\n\t\tvar uvs = [];\n\n\t\tvar i, j, p;\n\t\tvar u, v;\n\n\t\tvar sliceCount = slices + 1;\n\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\t\tv = i / stacks;\n\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tu = j / slices;\n\n\t\t\t\tp = func( u, v );\n\t\t\t\tvertices.push( p.x, p.y, p.z );\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tvar indices = [];\n\t\tvar a, b, c, d;\n\n\t\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\t\ta = i * sliceCount + j;\n\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t}\n\n\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n\t/**\n\t * @author zz85 / https://github.com/zz85\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricGeometry( func, slices, stacks ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\n\t\t// default buffer data\n\n\t\tvar vertexBuffer = [];\n\t\tvar uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tappplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );\n\t\tthis.normalizeNormals();\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tvar cols = Math.pow( 2, detail );\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tvar v = [];\n\n\t\t\tvar i, j;\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( i = 0 ; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tvar rows = cols - i;\n\n\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( i = 0; i < cols ; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction appplyRadius( radius ) {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tvar stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\tvar centroid = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tvar azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth  ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] =  uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\n\t\tvar vertices = [\n\t\t\t1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction TetrahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction OctahedronBufferGeometry( radius,detail ) {\n\n\t\tvar vertices = [\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction OctahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tvar vertices = [\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction IcosahedronGeometry( radius, detail ) {\n\n\t \tGeometry.call( this );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tvar r = 1 / t;\n\n\t\tvar vertices = [\n\n\t\t\t// (±1, ±1, ±1)\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t r, - t,  0,     r,  t,  0,\n\n\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t- t,  0,  r,     t,  0,  r\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n\t/**\n\t * @author Abe Pazos / https://hamoid.com\n\t */\n\n\tfunction DodecahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\n\t/**\n\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t *\n\t */\n\n\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TubeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\ttubularSegments = tubularSegments || 64;\n\t\tradius = radius || 1;\n\t\tradialSegments = radialSegments || 8;\n\t\tclosed = closed || false;\n\n\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar i, j;\n\n\t\t// buffer\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\t\tvar indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tvar P = path.getPointAt( i / tubularSegments );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tvar N = frames.normals[ i ];\n\t\t\tvar B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tvar sin =   Math.sin( v );\n\t\t\t\tvar cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t * @author WestLangley / https://github.com/WestLangley\n\t * @author zz85 / https://github.com/zz85\n\t * @author miningold / https://github.com/miningold\n\t * @author jonobr1 / https://github.com/jonobr1\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t */\n\n\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\n\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = bufferGeometry.tangents;\n\t\tthis.normals = bufferGeometry.normals;\n\t\tthis.binormals = bufferGeometry.binormals;\n\n\t\t// create geometry\n\n\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\tTubeGeometry.prototype.constructor = TubeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t */\n\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\tp = p || 2;\n\t\tq = q || 3;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar i, j, index = 0, indexOffset = 0;\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar P1 = new Vector3();\n\t\tvar P2 = new Vector3();\n\n\t\tvar B = new Vector3();\n\t\tvar T = new Vector3();\n\t\tvar N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tvar cu = Math.cos( u );\n\t\t\tvar su = Math.sin( u );\n\t\t\tvar quOverP = q / p * u;\n\t\t\tvar cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t */\n\n\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\tarc = arc || Math.PI * 2;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\n\t\t// helper variables\n\t\tvar center = new Vector3();\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t\t// uv\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t\t// update offsets\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offset\n\t\t\t\tindexBufferOffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t */\n\n\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n\t}\n\n\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusGeometry.prototype.constructor = TorusGeometry;\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar ShapeUtils = {\n\n\t\t// calculate area of the contour polygon\n\n\t\tarea: function ( contour ) {\n\n\t\t\tvar n = contour.length;\n\t\t\tvar a = 0.0;\n\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t\t}\n\n\t\t\treturn a * 0.5;\n\n\t\t},\n\n\t\ttriangulate: ( function () {\n\n\t\t\t/**\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t * See original code and more information here:\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t *\n\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t * www.actionsnippet.com\n\t\t\t *\n\t\t\t * ported to javascript by Joshua Koo\n\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t *\n\t\t\t */\n\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\t\tvar p;\n\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\tvar cx, cy, px, py;\n\n\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\t\tif ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;\n\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// takes in an contour array and returns\n\n\t\t\treturn function triangulate( contour, indices ) {\n\n\t\t\t\tvar n = contour.length;\n\n\t\t\t\tif ( n < 3 ) return null;\n\n\t\t\t\tvar result = [],\n\t\t\t\t\tverts = [],\n\t\t\t\t\tvertIndices = [];\n\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\t\tvar u, v, w;\n\n\t\t\t\tif ( ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t\t}\n\n\t\t\t\tvar nv = n;\n\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnv --;\n\n\t\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t} )(),\n\n\t\ttriangulateShape: function ( contour, holes ) {\n\n\t\t\tfunction removeDupEndPts(points) {\n\n\t\t\t\tvar l = points.length;\n\n\t\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\t\tpoints.pop();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tremoveDupEndPts( contour );\n\t\t\tholes.forEach( removeDupEndPts );\n\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\n\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t\t// return real intersection point\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t// both segments are points\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t\t// The order of legs is important\n\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t\t// angle != 180 deg.\n\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\tvar hole;\n\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar indepHoles = [];\n\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tindepHoles.push( h );\n\n\t\t\t\t}\n\n\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\t\tcounter --;\n\t\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t\t}\n\n\n\t\t\tvar i, il, f, face,\n\t\t\t\tkey, index,\n\t\t\t\tallPointsMap = {};\n\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\t\tvar allpoints = contour.concat();\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t\t}\n\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t\t// prepare all points map\n\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\n\t\t\t\t}\n\n\t\t\t\tallPointsMap[ key ] = i;\n\n\t\t\t}\n\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\t\tvar triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t\t// check all face vertices against all points map\n\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\t\tface = triangles[ i ];\n\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangles.concat();\n\n\t\t},\n\n\t\tisClockWise: function ( pts ) {\n\n\t\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t\t},\n\n\t\t// Bezier Curves formulas obtained from\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t\t// Quad Bezier Functions\n\n\t\tb2: ( function () {\n\n\t\t\tfunction b2p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p1( t, p ) {\n\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p2( t, p ) {\n\n\t\t\t\treturn t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\t// Cubic Bezier Functions\n\n\t\tb3: ( function () {\n\n\t\t\tfunction b3p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p1( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * k * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p2( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * t * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p3( t, p ) {\n\n\t\t\t\treturn t * t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *  curveSegments: <int>, // number of points on the curves\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *  amount: <int>, // Depth to extrude the shape\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t *  bevelSegments: <int>, // number of bevel layers\n\t *\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t *\n\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ExtrudeGeometry( shapes, options ) {\n\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\t\tshapes = [];\n\t\t\treturn;\n\n\t\t}\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t\t// can't really use automatic vertex normals\n\t\t// as then front and back sides get smoothed too\n\t\t// should do separate smoothing just for sides\n\n\t\t//this.computeVertexNormals();\n\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n\t}\n\n\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\n\tExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tvar sl = shapes.length;\n\n\t\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\t\tvar shape = shapes[ s ];\n\t\t\tthis.addShape( shape, options );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\t\tvar extrudePath = options.extrudePath;\n\t\tvar extrudePts, extrudeByPath = false;\n\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\n\t\tvar splineTube, binormal, normal, position2;\n\t\tif ( extrudePath ) {\n\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t// SETUP TNB variables\n\n\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\tbinormal = new Vector3();\n\t\t\tnormal = new Vector3();\n\t\t\tposition2 = new Vector3();\n\n\t\t}\n\n\t\t// Safeguards if bevels are not enabled\n\n\t\tif ( ! bevelEnabled ) {\n\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\n\t\t}\n\n\t\t// Variables initialization\n\n\t\tvar ahole, h, hl; // looping of holes\n\t\tvar scope = this;\n\n\t\tvar shapesOffset = this.vertices.length;\n\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t\t}\n\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t/* Vertices */\n\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tvertices = vertices.concat( ahole );\n\n\t\t}\n\n\n\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t}\n\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\n\n\t\t// Find directions for point movement\n\n\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t// not collinear\n\n\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\treturn\tnew Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tnew Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t}\n\n\n\t\tvar contourMovements = [];\n\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t}\n\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\toneHoleMovements = [];\n\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t}\n\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t}\n\n\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbs = bevelSize;\n\n\t\t// Back facing vertices\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\n\t\tvar s;\n\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Add bevel segments planes\n\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos ( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Faces */\n\n\t\t// Top and bottom faces\n\n\t\tbuildLidFaces();\n\n\t\t// Sides faces\n\n\t\tbuildSideFaces();\n\n\n\t\t/////  Internal functions\n\n\t\tfunction buildLidFaces() {\n\n\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Create faces for the z-sides of the shape\n\n\t\tfunction buildSideFaces() {\n\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\n\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction v( x, y, z ) {\n\n\t\t\tscope.vertices.push( new Vector3( x, y, z ) );\n\n\t\t}\n\n\t\tfunction f3( a, b, c ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, c, null, null, 0 ) );\n\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t\t}\n\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\t\t\td += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, d, null, null, 1 ) );\n\t\t\tscope.faces.push( new Face3( b, c, d, null, null, 1 ) );\n\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.WorldUVGenerator = {\n\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a.x, a.y ),\n\t\t\t\tnew Vector2( b.x, b.y ),\n\t\t\t\tnew Vector2( c.x, c.y )\n\t\t\t];\n\n\t\t},\n\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\t\t\tvar d = vertices[ indexD ];\n\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.x, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.x, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.x, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.x, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.y, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.y, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.y, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.y, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *  font: <THREE.Font>, // font\n\t *\n\t *  size: <float>, // size of the text\n\t *  height: <float>, // thickness to extrude text\n\t *  curveSegments: <int>, // number of points on the curves\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t *  bevelSize: <float> // how far from text outline is bevel\n\t * }\n\t */\n\n\tfunction TextGeometry( text, parameters ) {\n\n\t\tparameters = parameters || {};\n\n\t\tvar font = parameters.font;\n\n\t\tif ( (font && font.isFont) === false ) {\n\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new Geometry();\n\n\t\t}\n\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t\t// translate parameters to ExtrudeGeometry API\n\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t\t// defaults\n\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\tExtrudeGeometry.call( this, shapes, parameters );\n\n\t\tthis.type = 'TextGeometry';\n\n\t}\n\n\tTextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );\n\tTextGeometry.prototype.constructor = TextGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * based on THREE.SphereGeometry\n\t */\n\n\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'SphereBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\t\tvar thetaEnd = thetaStart + thetaLength;\n\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\t\tvar positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\tvar index = 0, vertices = [], normal = new Vector3();\n\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar verticesRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\t\tvar u = x / widthSegments;\n\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\tverticesRow.push( index );\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvertices.push( verticesRow );\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', positions );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n\t}\n\n\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\tSphereGeometry.prototype.constructor = SphereGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'RingBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tinnerRadius = innerRadius || 20;\n\t\touterRadius = outerRadius || 50;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// some helper variables\n\t\tvar index = 0, indexOffset = 0, segment;\n\t\tvar radius = innerRadius;\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\t// values are generate from the inside of the ring to the outside\n\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex++;\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = segment;\n\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\tvar d = segment + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t}\n\n\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n\t/**\n\t * @author Kaleb Murphy\n\t */\n\n\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n\t}\n\n\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\tRingGeometry.prototype.constructor = RingGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n\t}\n\n\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t // points - to create a closed torus, one must use a set of points\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t // segments - the number of circumference segments to create\n\t // phiStart - the starting radian\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t //    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'LatheBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments ) || 12;\n\t\tphiStart = phiStart || 0;\n\t\tphiLength = phiLength || Math.PI * 2;\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\tvar indexCount = segments * points.length * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar index = 0, indexOffset = 0, base;\n\t\tvar inverseSegments = 1.0 / segments;\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar i, j;\n\n\t\t// generate vertices and uvs\n\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tvar sin = Math.sin( phi );\n\t\t\tvar cos = Math.cos( phi );\n\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tbase = j + i * points.length;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = base;\n\t\t\t\tvar b = base + points.length;\n\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\tvar d = base + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\tif( phiLength === Math.PI * 2 ) {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\t\t\tvar n1 = new Vector3();\n\t\t\tvar n2 = new Vector3();\n\t\t\tvar n = new Vector3();\n\n\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\tbase = segments * points.length * 3;\n\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\t// average normals\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\t// assign the new values to both normals\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t\t} // next row\n\n\t\t}\n\n\t}\n\n\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n\t/**\n\t * @author astrodud / http://astrodud.isgreat.org/\n\t * @author zz85 / https://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t */\n\n\t// points - to create a closed torus, one must use a set of points\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t// segments - the number of circumference segments to create\n\t// phiStart - the starting radian\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t//    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\tLatheGeometry.prototype.constructor = LatheGeometry;\n\n\t/**\n\t * @author jonobr1 / http://jonobr1.com\n\t *\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t * ExtrudeGeometry.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t *\n\t *\tmaterial: <int> // material index for front and back faces\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ShapeGeometry( shapes, options ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t}\n\n\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\n\t/**\n\t * Add an array of shapes to THREE.ShapeGeometry.\n\t */\n\tShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tthis.addShape( shapes[ i ], options );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t */\n\tShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tif ( options === undefined ) options = {};\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar material = options.material;\n\t\tvar uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t\t//\n\n\t\tvar i, l, hole;\n\n\t\tvar shapesOffset = this.vertices.length;\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\t\thole = holes[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false;\n\n\t\t}\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t// Vertices\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\t\t\tvertices = vertices.concat( hole );\n\n\t\t}\n\n\t\t//\n\n\t\tvar vert, vlen = vertices.length;\n\t\tvar face, flen = faces.length;\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = vertices[ i ];\n\n\t\t\tthis.vertices.push( new Vector3( vert.x, vert.y, 0 ) );\n\n\t\t}\n\n\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\t\tthis.faces.push( new Face3( a, b, c, null, null, material ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tvar geometry2;\n\n\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tgeometry2 = new Geometry();\n\t\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tgeometry2 = geometry.clone();\n\n\t\t}\n\n\t\tgeometry2.mergeVertices();\n\t\tgeometry2.computeFaceNormals();\n\n\t\tvar vertices = geometry2.vertices;\n\t\tvar faces = geometry2.faces;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t\t} else {\n\n\t\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = [];\n\n\t\tfor ( var key in hash ) {\n\n\t\t\tvar h = hash[ key ];\n\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );\n\n\t}\n\n\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CylinderBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tvar scope = this;\n\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\theight = height !== undefined ? height : 100;\n\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t\t// used to calculate buffer length\n\n\t\tvar nbCap = 0;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t\t}\n\n\t\tvar vertexCount = calculateVertexCount();\n\t\tvar indexCount = calculateIndexCount();\n\n\t\t// buffers\n\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\n\t\tvar index = 0,\n\t\t    indexOffset = 0,\n\t\t    indexArray = [],\n\t\t    halfHeight = height / 2;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount() {\n\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction calculateIndexCount() {\n\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction generateTorso() {\n\n\t\t\tvar x, y;\n\t\t\tvar normal = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tvar indexRow = [];\n\n\t\t\t\tvar v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\tindexRow.push( index );\n\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\t\tvar uv = new Vector2();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// save the index of the first center vertex\n\t\t\tcenterIndexStart = index;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = 0.5;\n\t\t\t\tuv.y = 0.5;\n\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tcenterIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t}\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\tConeGeometry.prototype.constructor = ConeGeometry;\n\n\t/**\n\t * @author: abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CircleBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tvar vertices = segments + 2;\n\n\t\tvar positions = new Float32Array( vertices * 3 );\n\t\tvar normals = new Float32Array( vertices * 3 );\n\t\tvar uvs = new Float32Array( vertices * 2 );\n\n\t\t// center data is already zero, but need to set a few extras\n\t\tnormals[ 2 ] = 1.0;\n\t\tuvs[ 0 ] = 0.5;\n\t\tuvs[ 1 ] = 0.5;\n\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n\t/**\n\t * @author hughes\n\t */\n\n\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n\t}\n\n\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\tCircleGeometry.prototype.constructor = CircleGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t */\n\n\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\tBoxGeometry.prototype.constructor = BoxGeometry;\n\n\n\n\tvar Geometries = Object.freeze({\n\t\tWireframeGeometry: WireframeGeometry,\n\t\tParametricGeometry: ParametricGeometry,\n\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\tOctahedronGeometry: OctahedronGeometry,\n\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\tTubeGeometry: TubeGeometry,\n\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\tTorusGeometry: TorusGeometry,\n\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\tTextGeometry: TextGeometry,\n\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\tSphereGeometry: SphereGeometry,\n\t\tRingGeometry: RingGeometry,\n\t\tRingBufferGeometry: RingBufferGeometry,\n\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\tPlaneGeometry: PlaneGeometry,\n\t\tLatheGeometry: LatheGeometry,\n\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\tShapeGeometry: ShapeGeometry,\n\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\tEdgesGeometry: EdgesGeometry,\n\t\tConeGeometry: ConeGeometry,\n\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\tCylinderGeometry: CylinderGeometry,\n\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\tCircleGeometry: CircleGeometry,\n\t\tBoxBufferGeometry: BoxBufferGeometry,\n\t\tBoxGeometry: BoxGeometry\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ShadowMaterial() {\n\n\t\tShaderMaterial.call( this, {\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib[ \"lights\" ],\n\t\t\t\t{\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t}\n\t\t\t] ),\n\t\t\tvertexShader: ShaderChunk[ 'shadow_vert' ],\n\t\t\tfragmentShader: ShaderChunk[ 'shadow_frag' ]\n\t\t} );\n\n\t\tthis.lights = true;\n\t\tthis.transparent = true;\n\n\t\tObject.defineProperties( this, {\n\t\t\topacity: {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\n\tShadowMaterial.prototype.isShadowMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction RawShaderMaterial( parameters ) {\n\n\t\tShaderMaterial.call( this, parameters );\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\n\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MultiMaterial( materials ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.type = 'MultiMaterial';\n\n\t\tthis.materials = materials instanceof Array ? materials : [];\n\n\t\tthis.visible = true;\n\n\t}\n\n\tMultiMaterial.prototype = {\n\n\t\tconstructor: MultiMaterial,\n\n\t\tisMultiMaterial: true,\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.2,\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\ttype: this.type,\n\t\t\t\tmaterials: []\n\t\t\t};\n\n\t\t\tvar materials = this.materials;\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\tdelete material.metadata;\n\n\t\t\t\toutput.materials.push( material );\n\n\t\t\t}\n\n\t\t\toutput.visible = this.visible;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\tvar material = new this.constructor();\n\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tmaterial.visible = this.visible;\n\n\t\t\treturn material;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  roughness: <float>,\n\t *  metalness: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *  envMapIntensity: <float>\n\t *\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshStandardMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 0.5;\n\t\tthis.metalness = 0.5;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\n\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  reflectivity: <float>\n\t * }\n\t */\n\n\tfunction MeshPhysicalMaterial( parameters ) {\n\n\t\tMeshStandardMaterial.call( this );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\tthis.clearCoat = 0.0;\n\t\tthis.clearCoatRoughness = 0.0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\n\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.reflectivity = source.reflectivity;\n\n\t\tthis.clearCoat = source.clearCoat;\n\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  specular: <hex>,\n\t *  shininess: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshPhongMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\n\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * parameters = {\n\t *  opacity: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshNormalMaterial( parameters ) {\n\n\t\tMaterial.call( this, parameters );\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\n\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshLambertMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\n\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *\n\t *  scale: <float>,\n\t *  dashSize: <float>,\n\t *  gapSize: <float>\n\t * }\n\t */\n\n\tfunction LineDashedMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineDashedMaterial.prototype = Object.create( Material.prototype );\n\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\n\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n\tLineDashedMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t};\n\n\n\n\tvar Materials = Object.freeze({\n\t\tShadowMaterial: ShadowMaterial,\n\t\tSpriteMaterial: SpriteMaterial,\n\t\tRawShaderMaterial: RawShaderMaterial,\n\t\tShaderMaterial: ShaderMaterial,\n\t\tPointsMaterial: PointsMaterial,\n\t\tMultiMaterial: MultiMaterial,\n\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\tLineDashedMaterial: LineDashedMaterial,\n\t\tLineBasicMaterial: LineBasicMaterial,\n\t\tMaterial: Material\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar Cache = {\n\n\t\tenabled: false,\n\n\t\tfiles: {},\n\n\t\tadd: function ( key, file ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\t\tthis.files[ key ] = file;\n\n\t\t},\n\n\t\tget: function ( key ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\t\treturn this.files[ key ];\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete this.files[ key ];\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.files = {};\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tvar DefaultLoadingManager = new LoadingManager();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction XHRLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( XHRLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( url === undefined ) url = '';\n\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\t\tvar scope = this;\n\n\t\t\tvar cached = Cache.get( url );\n\n\t\t\tif ( cached !== undefined ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t\treturn cached;\n\n\t\t\t}\n\n\t\t\t// Check for data: URI\n\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\n\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\tif ( dataUriRegexResult ) {\n\n\t\t\t\tvar mimeType = dataUriRegexResult[1];\n\t\t\t\tvar isBase64 = !!dataUriRegexResult[2];\n\t\t\t\tvar data = dataUriRegexResult[3];\n\n\t\t\t\tdata = window.decodeURIComponent(data);\n\n\t\t\t\tif( isBase64 ) {\n\t\t\t\t\tdata = window.atob(data);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar response;\n\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\t \tresponse = new ArrayBuffer( data.length );\n\t\t\t\t\t\t\tvar view = new Uint8Array( response );\n\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\t\tresponse = new Blob( [ response ], { \"type\" : mimeType } );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\trequest.open( 'GET', url, true );\n\n\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\tvar response = event.target.response;\n\n\t\t\t\t\tCache.add( url, response );\n\n\t\t\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( onProgress !== undefined ) {\n\n\t\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\t\t\tonProgress( event );\n\n\t\t\t\t\t}, false );\n\n\t\t\t\t}\n\n\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );\n\n\t\t\t\trequest.send( null );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn request;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetResponseType: function ( value ) {\n\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t */\n\n\tfunction CompressedTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( CompressedTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar images = [];\n\n\t\t\tvar texture = new CompressedTexture();\n\t\t\ttexture.image = images;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\n\t\t\t\t\tloaded += 1;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\tvar loaded = 0;\n\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\t\tloadTexture( i );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Nikos M. / https://github.com/foo123/\n\t *\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t */\n\n\tvar DataTextureLoader = BinaryTextureLoader;\n\tfunction BinaryTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( BinaryTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texture = new DataTexture();\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\t\tif ( ! texData ) return;\n\n\t\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\t\ttexture.image = texData.image;\n\n\t\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\t\ttexture.format = texData.format;\n\n\t\t\t\t}\n\t\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\t\ttexture.type = texData.type;\n\n\t\t\t\t}\n\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t}, onProgress, onError );\n\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ImageLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( ImageLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\timage.onload = function () {\n\n\t\t\t\timage.onload = null;\n\n\t\t\t\tURL.revokeObjectURL( image.src );\n\n\t\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t};\n\t\t\timage.onerror = onError;\n\n\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\timage.src = url;\n\n\t\t\t} else {\n\n\t\t\t\tvar loader = new XHRLoader();\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn image;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( CubeTextureLoader.prototype, {\n\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new CubeTexture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\t\tloaded ++;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, undefined, onError );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction TextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( TextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new Texture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( image ) {\n\n\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\ttexture.image = image;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\t\tonLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Light( color, intensity ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\t\tthis.receiveShadow = undefined;\n\n\t}\n\n\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Light,\n\n\t\tisLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.intensity = source.intensity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\n\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\n\t\tLight.call( this, skyColor, intensity );\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.castShadow = undefined;\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: HemisphereLight,\n\n\t\tisHemisphereLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.groundColor.copy( source.groundColor );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LightShadow( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.radius = 1;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.matrix = new Matrix4();\n\n\t}\n\n\tObject.assign( LightShadow.prototype, {\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.camera = source.camera.clone();\n\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\n\t\t\tthis.mapSize.copy( source.mapSize );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar object = {};\n\n\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\tdelete object.camera.matrix;\n\n\t\t\treturn object;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SpotLightShadow() {\n\n\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t}\n\n\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: SpotLightShadow,\n\n\t\tisSpotLightShadow: true,\n\n\t\tupdate: function ( light ) {\n\n\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tvar far = light.distance || 500;\n\n\t\t\tvar camera = this.camera;\n\n\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: SpotLight,\n\n\t\tisSpotLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\n\tfunction PointLight( color, intensity, distance, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'PointLight';\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t}\n\n\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: PointLight,\n\n\t\tisPointLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectionalLightShadow( light ) {\n\n\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t}\n\n\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: DirectionalLightShadow\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DirectionalLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: DirectionalLight,\n\n\t\tisDirectionalLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AmbientLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'AmbientLight';\n\n\t\tthis.castShadow = undefined;\n\n\t}\n\n\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: AmbientLight,\n\n\t\tisAmbientLight: true,\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tvar AnimationUtils = {\n\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function( array, from, to ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t\t}\n\n\t\t\treturn array.slice( from, to );\n\n\t\t},\n\n\t\t// converts an array to a specific type\n\t\tconvertArray: function( array, type, forceClone ) {\n\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\t\treturn new type( array ); // create typed array\n\n\t\t\t}\n\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t\t},\n\n\t\tisTypedArray: function( object ) {\n\n\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t! ( object instanceof DataView );\n\n\t\t},\n\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function( times ) {\n\n\t\t\tfunction compareTime( i, j ) {\n\n\t\t\t\treturn times[ i ] - times[ j ];\n\n\t\t\t}\n\n\t\t\tvar n = times.length;\n\t\t\tvar result = new Array( n );\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\t\tresult.sort( compareTime );\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function( values, stride, order ) {\n\n\t\t\tvar nValues = values.length;\n\t\t\tvar result = new values.constructor( nValues );\n\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t}\n\n\t\t\tif ( key === undefined ) return; // no data\n\n\t\t\tvar value = key[ valuePropertyName ];\n\t\t\tif ( value === undefined ) return; // no data\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t// ...assume THREE.Math-ish\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t * @author tschw\n\t */\n\n\tfunction Interpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t}\n\n\tInterpolant.prototype = {\n\n\t\tconstructor: Interpolant,\n\n\t\tevaluate: function( t ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\ti1 = this._cachedIndex,\n\n\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\tvalidate_interval: {\n\n\t\t\t\tseek: {\n\n\t\t\t\t\tvar right;\n\n\t\t\t\t\tlinear_scan: {\n\t//- See http://jsperf.com/comparison-to-undefined/3\n\t//- slower code:\n\t//-\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t//- slower code:\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t\t} // linear scan\n\n\t\t\t\t\t// binary search\n\n\t\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t\t// check boundary cases, again\n\n\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // seek\n\n\t\t\t\tthis._cachedIndex = i1;\n\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t\t} // validate_interval\n\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t\t},\n\n\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t// Note: The indirection allows central control of many interpolants.\n\n\t\t// --- Protected interface\n\n\t\tDefaultSettings_: {},\n\n\t\tgetSettings_: function() {\n\n\t\t\treturn this.settings || this.DefaultSettings_;\n\n\t\t},\n\n\t\tcopySampleValue_: function( index ) {\n\n\t\t\t// copies a sample value to the result buffer\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = index * stride;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// Template methods for derived classes:\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t// implementations shall return this.resultBuffer\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\t// empty\n\n\t\t}\n\n\t};\n\n\tObject.assign( Interpolant.prototype, {\n\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_,\n\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_\n\n\t} );\n\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction CubicInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = -0;\n\t\tthis._offsetPrev = -0;\n\t\tthis._weightNext = -0;\n\t\tthis._offsetNext = -0;\n\n\t}\n\n\tCubicInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: CubicInterpolant,\n\n\t\tDefaultSettings_: {\n\n\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\tiPrev = i1 - 2,\n\t\t\t\tiNext = i1 + 1,\n\n\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\ttNext = pp[ iNext ];\n\n\t\t\tif ( tPrev === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tNext === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\tstride = this.valueSize;\n\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\n\t\t},\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tpp = p * p,\n\t\t\t\tppp = pp * p;\n\n\t\t\t// evaluate polynomials\n\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t\t// combine data linearly\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction LinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: LinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset1 = i1 * stride,\n\t\t\t\toffset0 = offset1 - stride,\n\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tweight0 = 1 - weight1;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction DiscreteInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tDiscreteInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: DiscreteInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t}\n\n\t} );\n\n\tvar KeyframeTrackPrototype;\n\n\tKeyframeTrackPrototype = {\n\n\t\tTimeBufferType: Float32Array,\n\t\tValueBufferType: Float32Array,\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\t\treturn new DiscreteInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new LinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\t\treturn new CubicInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tsetInterpolation: function( interpolation ) {\n\n\t\t\tvar factoryMethod;\n\n\t\t\tswitch ( interpolation ) {\n\n\t\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateLinear:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateSmooth:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( factoryMethod === undefined ) {\n\n\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( message );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.createInterpolant = factoryMethod;\n\n\t\t},\n\n\t\tgetInterpolation: function() {\n\n\t\t\tswitch ( this.createInterpolant ) {\n\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\t\treturn InterpolateLinear;\n\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\t\treturn InterpolateSmooth;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetValueSize: function() {\n\n\t\t\treturn this.values.length / this.times.length;\n\n\t\t},\n\n\t\t// move all keyframes either forwards or backwards in time\n\t\tshift: function( timeOffset ) {\n\n\t\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\tscale: function( timeScale ) {\n\n\t\t\tif( timeScale !== 1.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\ttrim: function( startTime, endTime ) {\n\n\t\t\tvar times = this.times,\n\t\t\t\tnKeys = times.length,\n\t\t\t\tfrom = 0,\n\t\t\t\tto = nKeys - 1;\n\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t\t++ to; // inclusive -> exclusive bound\n\n\t\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\tthis.values = AnimationUtils.\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\tvalidate: function() {\n\n\t\t\tvar valid = true;\n\n\t\t\tvar valueSize = this.getValueSize();\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\n\t\t\t\tnKeys = times.length;\n\n\t\t\tif( nKeys === 0 ) {\n\n\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar prevTime = null;\n\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\t\tvar currTime = times[ i ];\n\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tprevTime = currTime;\n\n\t\t\t}\n\n\t\t\tif ( values !== undefined ) {\n\n\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn valid;\n\n\t\t},\n\n\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\toptimize: function() {\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\t\t\tstride = this.getValueSize(),\n\n\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\t\twriteIndex = 1,\n\t\t\t\tlastIndex = times.length - 1;\n\n\t\t\tfor( var i = 1; i < lastIndex; ++ i ) {\n\n\t\t\t\tvar keep = false;\n\n\t\t\t\tvar time = times[ i ];\n\t\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else keep = true;\n\n\t\t\t\t}\n\n\t\t\t\t// in-place compaction\n\n\t\t\t\tif ( keep ) {\n\n\t\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j )\n\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t++ writeIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// flush last keyframe (compaction looks ahead)\n\n\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )\n\n\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t\tif ( writeIndex !== times.length ) {\n\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\tfunction KeyframeTrackConstructor( name, times, values, interpolation ) {\n\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\t\tif( times === undefined || times.length === 0 ) {\n\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t\t}\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t\tthis.validate();\n\t\tthis.optimize();\n\n\t}\n\n\t/**\n\t *\n\t * A Track of vectored keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tVectorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: VectorKeyframeTrack,\n\n\t\tValueTypeName: 'vector'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction QuaternionLinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tQuaternionLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: QuaternionLinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset = i1 * stride,\n\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\t\tQuaternion.slerpFlat( result, 0,\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of quaternion keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tQuaternionKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: QuaternionKeyframeTrack,\n\n\t\tValueTypeName: 'quaternion',\n\n\t\t// ValueBufferType is inherited\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new QuaternionLinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of numeric keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tNumberKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: NumberKeyframeTrack,\n\n\t\tValueTypeName: 'number',\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t *\n\t * A Track that interpolates Strings\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tStringKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: StringKeyframeTrack,\n\n\t\tValueTypeName: 'string',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of Boolean keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction BooleanKeyframeTrack( name, times, values ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values );\n\n\t}\n\n\tBooleanKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: BooleanKeyframeTrack,\n\n\t\tValueTypeName: 'bool',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t\t// Note: Actually this track could have a optimized / compressed\n\t\t// representation of a single value and a custom interpolant that\n\t\t// computes \"firstValue ^ isOdd( index )\".\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of keyframe values that represent color.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tColorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: ColorKeyframeTrack,\n\n\t\tValueTypeName: 'color'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\n\t\t// Note: Very basic implementation and nothing special yet.\n\t\t// However, this is the place for color space parameterization.\n\n\t} );\n\n\t/**\n\t *\n\t * A timed sequence of keyframes for a specific property.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.apply( this, arguments );\n\n\t}\n\n\tKeyframeTrack.prototype = KeyframeTrackPrototype;\n\tKeyframeTrackPrototype.constructor = KeyframeTrack;\n\n\t// Static methods:\n\n\tObject.assign( KeyframeTrack, {\n\n\t\t// Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\n\t\tparse: function( json ) {\n\n\t\t\tif( json.type === undefined ) {\n\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t\t}\n\n\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\t\tif ( json.times === undefined ) {\n\n\t\t\t\tvar times = [], values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\t\tjson.times = times;\n\t\t\t\tjson.values = values;\n\n\t\t\t}\n\n\t\t\t// derived classes can define a static parse method\n\t\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\t\treturn trackType.parse( json );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\treturn new trackType(\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function( track ) {\n\n\t\t\tvar trackType = track.constructor;\n\n\t\t\tvar json;\n\n\t\t\t// derived classes can define a static toJSON method\n\t\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\t\tjson = trackType.toJSON( track );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t\t};\n\n\t\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\t\treturn json;\n\n\t\t},\n\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\t\tcase \"scalar\":\n\t\t\t\tcase \"double\":\n\t\t\t\tcase \"float\":\n\t\t\t\tcase \"number\":\n\t\t\t\tcase \"integer\":\n\n\t\t\t\t\treturn NumberKeyframeTrack;\n\n\t\t\t\tcase \"vector\":\n\t\t\t\tcase \"vector2\":\n\t\t\t\tcase \"vector3\":\n\t\t\t\tcase \"vector4\":\n\n\t\t\t\t\treturn VectorKeyframeTrack;\n\n\t\t\t\tcase \"color\":\n\n\t\t\t\t\treturn ColorKeyframeTrack;\n\n\t\t\t\tcase \"quaternion\":\n\n\t\t\t\t\treturn QuaternionKeyframeTrack;\n\n\t\t\t\tcase \"bool\":\n\t\t\t\tcase \"boolean\":\n\n\t\t\t\t\treturn BooleanKeyframeTrack;\n\n\t\t\t\tcase \"string\":\n\n\t\t\t\t\treturn StringKeyframeTrack;\n\n\t\t\t}\n\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Reusable set of Tracks that represent an animation.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tfunction AnimationClip( name, duration, tracks ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t\tthis.optimize();\n\n\t}\n\n\tAnimationClip.prototype = {\n\n\t\tconstructor: AnimationClip,\n\n\t\tresetDuration: function() {\n\n\t\t\tvar tracks = this.tracks,\n\t\t\t\tduration = 0;\n\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\t\tvar track = this.tracks[ i ];\n\n\t\t\t\tduration = Math.max(\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.duration = duration;\n\n\t\t},\n\n\t\ttrim: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\toptimize: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].optimize();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t// Static methods:\n\n\tObject.assign( AnimationClip, {\n\n\t\tparse: function( json ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\n\t\t},\n\n\n\t\ttoJSON: function( clip ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tclipTracks = clip.tracks;\n\n\t\t\tvar json = {\n\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks\n\n\t\t\t};\n\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn json;\n\n\t\t},\n\n\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\ttimes.push(\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttracks.push(\n\t\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, -1, tracks );\n\n\t\t},\n\n\t\tfindByName: function( objectOrClipArray, name ) {\n\n\t\t\tvar clipArray = objectOrClipArray;\n\n\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\t\treturn clipArray[ i ];\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\t\tvar animationToMorphTargets = {};\n\n\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t\t// sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar clips = [];\n\n\t\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t\t}\n\n\t\t\treturn clips;\n\n\t\t},\n\n\t\t// parse the animation.hierarchy format\n\t\tparseAnimation: function( animation, bones ) {\n\n\t\t\tif ( ! animation ) {\n\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tAnimationUtils.flattenJSON(\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar clipName = animation.name || 'default';\n\t\t\t// automatic length determination in AnimationClip.\n\t\t\tvar duration = animation.length || -1;\n\t\t\tvar fps = animation.fps || 30;\n\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t\t// skip empty tracks\n\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\n\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tracks.length === 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MaterialLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.textures = {};\n\n\t}\n\n\tObject.assign( MaterialLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTextures: function ( value ) {\n\n\t\t\tthis.textures = value;\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar textures = this.textures;\n\n\t\t\tfunction getTexture( name ) {\n\n\t\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn textures[ name ];\n\n\t\t\t}\n\n\t\t\tvar material = new Materials[ json.type ]();\n\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\n\t\t\t// for PointsMaterial\n\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t\t// maps\n\n\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\n\t\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\t\tvar normalScale = json.normalScale;\n\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t\t}\n\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\n\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t\t// MultiMaterial\n\n\t\t\tif ( json.materials !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometryLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( BufferGeometryLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar geometry = new BufferGeometry();\n\n\t\t\tvar index = json.data.index;\n\n\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t'Float64Array': Float64Array\n\t\t\t};\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tvar attributes = json.data.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t\t}\n\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\t\tif ( groups !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\t\tvar center = new Vector3();\n\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Loader() {\n\n\t\tthis.onLoadStart = function () {};\n\t\tthis.onLoadProgress = function () {};\n\t\tthis.onLoadComplete = function () {};\n\n\t}\n\n\tLoader.prototype = {\n\n\t\tconstructor: Loader,\n\n\t\tcrossOrigin: undefined,\n\n\t\textractUrlBase: function ( url ) {\n\n\t\t\tvar parts = url.split( '/' );\n\n\t\t\tif ( parts.length === 1 ) return './';\n\n\t\t\tparts.pop();\n\n\t\t\treturn parts.join( '/' ) + '/';\n\n\t\t},\n\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tcreateMaterial: ( function () {\n\n\t\t\tvar color, textureLoader, materialLoader;\n\n\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\t\tif ( color === undefined ) color = new Color();\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new TextureLoader();\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new MaterialLoader();\n\n\t\t\t\t// convert from old material format\n\n\t\t\t\tvar textures = {};\n\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\n\t\t\t\t\tvar texture;\n\n\t\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar uuid = _Math.generateUUID();\n\n\t\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\t\treturn uuid;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar json = {\n\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t};\n\n\t\t\t\tfor ( var name in m ) {\n\n\t\t\t\t\tvar value = m[ name ];\n\n\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\t\treturn materialLoader.parse( json );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\tLoader.Handlers = {\n\n\t\thandlers: [],\n\n\t\tadd: function ( regex, loader ) {\n\n\t\t\tthis.handlers.push( regex, loader );\n\n\t\t},\n\n\t\tget: function ( file ) {\n\n\t\t\tvar handlers = this.handlers;\n\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction JSONLoader( manager ) {\n\n\t\tif ( typeof manager === 'boolean' ) {\n\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\n\t\t}\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.withCredentials = false;\n\n\t}\n\n\tObject.assign( JSONLoader.prototype, {\n\n\t\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\n\t\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\t\tvar type = metadata.type;\n\n\t\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tparse: function ( json, texturePath ) {\n\n\t\t\tvar geometry = new Geometry(),\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\t\tparseModel( scale );\n\n\t\t\tparseSkin();\n\t\t\tparseMorphing( scale );\n\t\t\tparseAnimations();\n\n\t\t\tgeometry.computeFaceNormals();\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tfunction parseModel( scale ) {\n\n\t\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t\t}\n\n\t\t\t\tvar i, j, fi,\n\n\t\t\t\toffset, zLength,\n\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\t\ttype,\n\t\t\t\tisQuad,\n\t\t\t\thasMaterial,\n\t\t\t\thasFaceVertexUv,\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\t\tuvLayer, uv, u, v,\n\n\t\t\t\tfaces = json.faces,\n\t\t\t\tvertices = json.vertices,\n\t\t\t\tnormals = json.normals,\n\t\t\t\tcolors = json.colors,\n\n\t\t\t\tnUvLayers = 0;\n\n\t\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t\t// disregard empty arrays\n\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\tvertex = new Vector3();\n\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseSkin() {\n\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.bones = json.bones;\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseMorphing( scale ) {\n\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAnimations() {\n\n\t\t\t\tvar outputAnimations = [];\n\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\n\t\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\t\tanimations.push( json.animation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t\t}\n\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t\t}\n\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\t\treturn { geometry: geometry };\n\n\t\t\t} else {\n\n\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ObjectLoader ( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.texturePath = '';\n\n\t}\n\n\tObject.assign( ObjectLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( this.texturePath === '' ) {\n\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\n\t\t},\n\n\t\tparse: function ( json, onLoad ) {\n\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t} );\n\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\t\tif ( json.animations ) {\n\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t\t}\n\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t},\n\n\t\tparseGeometries: function ( json ) {\n\n\t\t\tvar geometries = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar geometry;\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometries;\n\n\t\t},\n\n\t\tparseMaterials: function ( json, textures ) {\n\n\t\t\tvar materials = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\tloader.setTextures( textures );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t},\n\n\t\tparseAnimations: function ( json ) {\n\n\t\t\tvar animations = [];\n\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\n\t\t\t\tanimations.push( clip );\n\n\t\t\t}\n\n\t\t\treturn animations;\n\n\t\t},\n\n\t\tparseImages: function ( json, onLoad ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar images = {};\n\n\t\t\tfunction loadImage( url ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\treturn loader.load( url, function () {\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, undefined, function () {\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\t\tvar manager = new LoadingManager( onLoad );\n\n\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn images;\n\n\t\t},\n\n\t\tparseTextures: function ( json, images ) {\n\n\t\t\tfunction parseConstant( value, type ) {\n\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\t\treturn type[ value ];\n\n\t\t\t}\n\n\t\t\tvar textures = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );\n\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn textures;\n\n\t\t},\n\n\t\tparseObject: function () {\n\n\t\t\tvar matrix = new Matrix4();\n\n\t\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\t\tvar object;\n\n\t\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn geometries[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn materials[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'Scene':\n\n\t\t\t\t\t\tobject = new Scene();\n\n\t\t\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LOD':\n\n\t\t\t\t\t\tobject = new LOD();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Line':\n\n\t\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LineSegments':\n\n\t\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Group':\n\n\t\t\t\t\t\tobject = new Group();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tobject = new Object3D();\n\n\t\t\t\t}\n\n\t\t\t\tobject.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\t\tif ( data.shadow ) {\n\n\t\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\t\tvar levels = data.levels;\n\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t};\n\n\t\t}()\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Extensible curve object\n\t *\n\t * Some common of Curve methods\n\t * .getPoint(t), getTangent(t)\n\t * .getPointAt(u), getTangentAt(u)\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following classes subclasses THREE.Curve:\n\t *\n\t * -- 2d classes --\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.SplineCurve\n\t * THREE.ArcCurve\n\t * THREE.EllipseCurve\n\t *\n\t * -- 3d classes --\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.SplineCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tAbstract Curve base class\n\t **************************************************************/\n\n\tfunction Curve() {}\n\n\tCurve.prototype = {\n\n\t\tconstructor: Curve,\n\n\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\n\t\tgetPointAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getPoint( t );\n\n\t\t},\n\n\t\t// Get sequence of points using getPoint( t )\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get sequence of points using getPointAt( u )\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get total curve arc length\n\n\t\tgetLength: function () {\n\n\t\t\tvar lengths = this.getLengths();\n\t\t\treturn lengths[ lengths.length - 1 ];\n\n\t\t},\n\n\t\t// Get list of cumulative segment lengths\n\n\t\tgetLengths: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\t\tif ( this.cacheArcLengths\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\treturn this.cacheArcLengths;\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tvar cache = [];\n\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\tvar p, sum = 0;\n\n\t\t\tcache.push( 0 );\n\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\tcache.push( sum );\n\t\t\t\tlast = current;\n\n\t\t\t}\n\n\t\t\tthis.cacheArcLengths = cache;\n\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t\t},\n\n\t\tupdateArcLengths: function() {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\t\tgetUtoTmapping: function ( u, distance ) {\n\n\t\t\tvar arcLengths = this.getLengths();\n\n\t\t\tvar i = 0, il = arcLengths.length;\n\n\t\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\t\tif ( distance ) {\n\n\t\t\t\ttargetArcLength = distance;\n\n\t\t\t} else {\n\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t\t}\n\n\t\t\t//var time = Date.now();\n\n\t\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\t\tvar low = 0, high = il - 1, comparison;\n\n\t\t\twhile ( low <= high ) {\n\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\t\tlow = i + 1;\n\n\t\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\t\thigh = i - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// DONE\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ti = high;\n\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\treturn t;\n\n\t\t\t}\n\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t\t// determine where we are between the 'before' and 'after' points\n\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t\t// add that fractional amount to t\n\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\t\treturn t;\n\n\t\t},\n\n\t\t// Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\n\t\tgetTangent: function( t ) {\n\n\t\t\tvar delta = 0.0001;\n\t\t\tvar t1 = t - delta;\n\t\t\tvar t2 = t + delta;\n\n\t\t\t// Capping in case of danger\n\n\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\tvar pt2 = this.getPoint( t2 );\n\n\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\treturn vec.normalize();\n\n\t\t},\n\n\t\tgetTangentAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getTangent( t );\n\n\t\t},\n\n\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\t\tvar normal = new Vector3();\n\n\t\t\tvar tangents = [];\n\t\t\tvar normals = [];\n\t\t\tvar binormals = [];\n\n\t\t\tvar vec = new Vector3();\n\t\t\tvar mat = new Matrix4();\n\n\t\t\tvar i, u, theta;\n\n\t\t\t// compute the tangent vectors for each segment on the curve\n\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\t\tu = i / segments;\n\n\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\ttangents[ i ].normalize();\n\n\t\t\t}\n\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the minimum tangent xyz component\n\n\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\tvar min = Number.MAX_VALUE;\n\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\n\t\t\tif ( tx <= min ) {\n\n\t\t\t\tmin = tx;\n\t\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( ty <= min ) {\n\n\t\t\t\tmin = ty;\n\t\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t\t}\n\n\t\t\tif ( tz <= min ) {\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t\t}\n\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\t\tvec.normalize();\n\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t\t}\n\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\t\tif ( closed === true ) {\n\n\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\ttheta /= segments;\n\n\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\t\ttheta = - theta;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t\t// twist a little...\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttangents: tangents,\n\t\t\t\tnormals: normals,\n\t\t\t\tbinormals: binormals\n\t\t\t};\n\n\t\t}\n\n\t};\n\n\t// TODO: Transformation for Curves?\n\n\t/**************************************************************\n\t *\t3D Curves\n\t **************************************************************/\n\n\t// A Factory method for creating new curve subclasses\n\n\tCurve.create = function ( constructor, getPointFunc ) {\n\n\t\tconstructor.prototype = Object.create( Curve.prototype );\n\t\tconstructor.prototype.constructor = constructor;\n\t\tconstructor.prototype.getPoint = getPointFunc;\n\n\t\treturn constructor;\n\n\t};\n\n\t/**************************************************************\n\t *\tLine\n\t **************************************************************/\n\n\tfunction LineCurve( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tLineCurve.prototype = Object.create( Curve.prototype );\n\tLineCurve.prototype.constructor = LineCurve;\n\n\tLineCurve.prototype.isLineCurve = true;\n\n\tLineCurve.prototype.getPoint = function ( t ) {\n\n\t\tif ( t === 1 ) {\n\n\t\t\treturn this.v2.clone();\n\n\t\t}\n\n\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\treturn point;\n\n\t};\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\n\tLineCurve.prototype.getPointAt = function ( u ) {\n\n\t\treturn this.getPoint( u );\n\n\t};\n\n\tLineCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\t\treturn tangent.normalize();\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *  curves, but retains the api of a curve\n\t **************************************************************/\n\n\tfunction CurvePath() {\n\n\t\tthis.curves = [];\n\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\t\tconstructor: CurvePath,\n\n\t\tadd: function ( curve ) {\n\n\t\t\tthis.curves.push( curve );\n\n\t\t},\n\n\t\tclosePath: function () {\n\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tvar d = t * this.getLength();\n\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\tvar i = 0;\n\n\t\t\t// To think about boundaries points.\n\n\t\t\twhile ( i < curveLengths.length ) {\n\n\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t\t},\n\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\t\tgetLength: function () {\n\n\t\t\tvar lens = this.getCurveLengths();\n\t\t\treturn lens[ lens.length - 1 ];\n\n\t\t},\n\n\t\t// cacheLengths must be recalculated.\n\t\tupdateArcLengths: function () {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\t\tgetCurveLengths: function () {\n\n\t\t\t// We use cache values if curves and cache array are same length\n\n\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\t\treturn this.cacheLengths;\n\n\t\t\t}\n\n\t\t\t// Get length of sub-curve\n\t\t\t// Push sums into cached array\n\n\t\t\tvar lengths = [], sums = 0;\n\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\tlengths.push( sums );\n\n\t\t\t}\n\n\t\t\tthis.cacheLengths = lengths;\n\n\t\t\treturn lengths;\n\n\t\t},\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 40;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tdivisions = divisions || 12;\n\n\t\t\tvar points = [], last;\n\n\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\t\tvar curve = curves[ i ];\n\t\t\t\tvar resolution = (curve && curve.isEllipseCurve) ? divisions * 2\n\t\t\t\t\t: (curve && curve.isLineCurve) ? 1\n\t\t\t\t\t: (curve && curve.isSplineCurve) ? divisions * curve.points.length\n\t\t\t\t\t: divisions;\n\n\t\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\n\t\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\tpoints.push( point );\n\t\t\t\t\tlast = point;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t/**************************************************************\n\t\t *\tCreate Geometries Helpers\n\t\t **************************************************************/\n\n\t\t/// Generate geometry from path points (for Line or Points objects)\n\n\t\tcreatePointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\t// Generate geometry from equidistant sampling along the path\n\n\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\tcreateGeometry: function ( points ) {\n\n\t\t\tvar geometry = new Geometry();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**************************************************************\n\t *\tEllipse curve\n\t **************************************************************/\n\n\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation || 0;\n\n\t}\n\n\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\tEllipseCurve.prototype.constructor = EllipseCurve;\n\n\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\tEllipseCurve.prototype.getPoint = function( t ) {\n\n\t\tvar twoPi = Math.PI * 2;\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\tvar sin = Math.sin( this.aRotation );\n\n\t\t\tvar tx = x - this.aX;\n\t\t\tvar ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn new Vector2( x, y );\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar CurveUtils = {\n\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t\t},\n\n\t\t// Puay Bing, thanks for helping with this derivative!\n\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t3 * t * t * p3;\n\n\t\t},\n\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\t// To check if my formulas are correct\n\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\n\t\t\treturn h00 + h10 + h01 + h11;\n\n\t\t},\n\n\t\t// Catmull-Rom\n\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t};\n\n\t/**************************************************************\n\t *\tSpline curve\n\t **************************************************************/\n\n\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\n\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t}\n\n\tSplineCurve.prototype = Object.create( Curve.prototype );\n\tSplineCurve.prototype.constructor = SplineCurve;\n\n\tSplineCurve.prototype.isSplineCurve = true;\n\n\tSplineCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\treturn new Vector2(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t);\n\n\t};\n\n\t/**************************************************************\n\t *\tCubic Bezier curve\n\t **************************************************************/\n\n\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\n\tCubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b3 = ShapeUtils.b3;\n\n\t\treturn new Vector2(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t);\n\n\t};\n\n\tCubicBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentCubicBezier = CurveUtils.tangentCubicBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t).normalize();\n\n\t};\n\n\t/**************************************************************\n\t *\tQuadratic Bezier curve\n\t **************************************************************/\n\n\n\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\n\n\tQuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b2 = ShapeUtils.b2;\n\n\t\treturn new Vector2(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t);\n\n\t};\n\n\n\tQuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t).normalize();\n\n\t};\n\n\tvar PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n\t\tfromPoints: function ( vectors ) {\n\n\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmoveTo: function ( x, y ) {\n\n\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\t},\n\n\t\tlineTo: function ( x, y ) {\n\n\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( x, y );\n\n\t\t},\n\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\t\tvar curve = new SplineCurve( npts );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\t},\n\n\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t},\n\n\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\tthis.currentPoint.copy( lastPoint );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Defines a 2d shape plane using paths.\n\t **/\n\n\t// STEP 1 Create a path.\n\t// STEP 2 Turn path into shape.\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t// STEP 3a - Extract points from each shape, turn to vertices\n\t// STEP 3b - Triangulate each shape, add faces.\n\n\tfunction Shape() {\n\n\t\tPath.apply( this, arguments );\n\n\t\tthis.holes = [];\n\n\t}\n\n\tShape.prototype = Object.assign( Object.create( PathPrototype ), {\n\n\t\tconstructor: Shape,\n\n\t\tgetPointsHoles: function ( divisions ) {\n\n\t\t\tvar holesPts = [];\n\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t\t}\n\n\t\t\treturn holesPts;\n\n\t\t},\n\n\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\t\textractAllPoints: function ( divisions ) {\n\n\t\t\treturn {\n\n\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t\t};\n\n\t\t},\n\n\t\textractPoints: function ( divisions ) {\n\n\t\t\treturn this.extractAllPoints( divisions );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Creates free form 2d path using series of points, lines or curves.\n\t *\n\t **/\n\n\tfunction Path( points ) {\n\n\t\tCurvePath.call( this );\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.fromPoints( points );\n\n\t\t}\n\n\t}\n\n\tPath.prototype = PathPrototype;\n\tPathPrototype.constructor = Path;\n\n\n\t// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\tfunction ShapePath() {\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\t}\n\n\tShapePath.prototype = {\n\t\tmoveTo: function ( x, y ) {\n\t\t\tthis.currentPath = new Path();\n\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\tthis.currentPath.moveTo( x, y );\n\t\t},\n\t\tlineTo: function ( x, y ) {\n\t\t\tthis.currentPath.lineTo( x, y );\n\t\t},\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\t},\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\t},\n\t\tsplineThru: function ( pts ) {\n\t\t\tthis.currentPath.splineThru( pts );\n\t\t},\n\n\t\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\t\tvar shapes = [];\n\n\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t\t}\n\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\tvar inside = false;\n\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn\tinside;\n\n\t\t\t}\n\n\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\n\t\t\tvar subPaths = this.subPaths;\n\t\t\tif ( subPaths.length === 0 ) return [];\n\n\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\t\tif ( subPaths.length === 1 ) {\n\n\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\ttmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\t\tvar betterShapeHoles = [];\n\t\t\tvar newShapes = [];\n\t\t\tvar newShapeHoles = [];\n\t\t\tvar mainIdx = 0;\n\t\t\tvar tmpPoints;\n\n\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\t\tif ( solid ) {\n\n\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t\t//console.log('cw', i);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t\t//console.log('ccw', i);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tif ( newShapes.length > 1 ) {\n\n\t\t\t\tvar ambiguous = false;\n\t\t\t\tvar toChange = [];\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar tmpHoles;\n\n\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Font( data ) {\n\n\t\tthis.data = data;\n\n\t}\n\n\tObject.assign( Font.prototype, {\n\n\t\tisFont: true,\n\n\t\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\t\tfunction createPaths( text ) {\n\n\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\tvar offset = 0;\n\n\t\t\t\tvar paths = [];\n\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\toffset += ret.offset;\n\n\t\t\t\t\tpaths.push( ret.path );\n\n\t\t\t\t}\n\n\t\t\t\treturn paths;\n\n\t\t\t}\n\n\t\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\t\tif ( ! glyph ) return;\n\n\t\t\t\tvar path = new ShapePath();\n\n\t\t\t\tvar pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\t\tif ( glyph.o ) {\n\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( size === undefined ) size = 100;\n\t\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\t\tvar data = this.data;\n\n\t\t\tvar paths = createPaths( text );\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction FontLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( FontLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json;\n\n\t\t\t\ttry {\n\n\t\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar font = scope.parse( json );\n\n\t\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\treturn new Font( json );\n\n\t\t}\n\n\t} );\n\n\tvar context;\n\n\tfunction getAudioContext() {\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn context;\n\n\t}\n\n\t/**\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction AudioLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( AudioLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar context = getAudioContext();\n\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction StereoCamera() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t}\n\n\tObject.assign( StereoCamera.prototype, {\n\n\t\tupdate: ( function () {\n\n\t\t\tvar instance, focus, fov, aspect, near, far, zoom;\n\n\t\t\tvar eyeRight = new Matrix4();\n\t\t\tvar eyeLeft = new Matrix4();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom;\n\n\t\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t\tinstance = this;\n\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\tnear = camera.near;\n\t\t\t\t\tfar = camera.far;\n\t\t\t\t\tzoom = camera.zoom;\n\n\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\tvar eyeSep = this.eyeSep / 2;\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t\t// translate xOffset\n\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t\t// for left eye\n\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t\t// for right eye\n\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * Camera for rendering cube maps\n\t *\t- renders scene into axis-aligned cube\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CubeCamera( near, far, cubeResolution ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tvar fov = 90, aspect = 1;\n\n\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\n\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\n\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\n\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\n\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\n\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\n\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\n\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\t\tvar renderTarget = this.renderTarget;\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t};\n\n\t}\n\n\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\tCubeCamera.prototype.constructor = CubeCamera;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioListener() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = getAudioContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t}\n\n\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: AudioListener,\n\n\t\tgetInput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tremoveFilter: function ( ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\tthis.filter = null;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.filter;\n\n\t\t},\n\n\t\tsetFilter: function ( value ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t\t} else {\n\n\t\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t\t}\n\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect( this.filter );\n\t\t\tthis.filter.connect( this.context.destination );\n\n\t\t},\n\n\t\tgetMasterVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\t\tsetMasterVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3();\n\n\t\t\tvar orientation = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tvar listener = this.context.listener;\n\t\t\t\tvar up = this.up;\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction Audio( listener ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.context = listener.context;\n\t\tthis.source = this.context.createBufferSource();\n\t\tthis.source.onended = this.onEnded.bind( this );\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.startTime = 0;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis.filters = [];\n\n\t}\n\n\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Audio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tsetNodeSource: function ( audioNode ) {\n\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetBuffer: function ( audioBuffer ) {\n\n\t\t\tthis.source.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\n\t\t\tif ( this.autoplay ) this.play();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tplay: function () {\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar source = this.context.createBufferSource();\n\n\t\t\tsource.buffer = this.source.buffer;\n\t\t\tsource.loop = this.source.loop;\n\t\t\tsource.onended = this.source.onended;\n\t\t\tsource.start( 0, this.startTime );\n\t\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\t\tthis.isPlaying = true;\n\n\t\t\tthis.source = source;\n\n\t\t\treturn this.connect();\n\n\t\t},\n\n\t\tpause: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = this.context.currentTime;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = 0;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdisconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilters: function () {\n\n\t\t\treturn this.filters;\n\n\t\t},\n\n\t\tsetFilters: function ( value ) {\n\n\t\t\tif ( ! value ) value = [];\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value;\n\t\t\t\tthis.connect();\n\n\t\t\t} else {\n\n\t\t\t\tthis.filters = value;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.getFilters()[ 0 ];\n\n\t\t},\n\n\t\tsetFilter: function ( filter ) {\n\n\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t\t},\n\n\t\tsetPlaybackRate: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.playbackRate = value;\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetPlaybackRate: function () {\n\n\t\t\treturn this.playbackRate;\n\n\t\t},\n\n\t\tonEnded: function () {\n\n\t\t\tthis.isPlaying = false;\n\n\t\t},\n\n\t\tgetLoop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn this.source.loop;\n\n\t\t},\n\n\t\tsetLoop: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.loop = value;\n\n\t\t},\n\n\t\tgetVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\n\t\tsetVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PositionalAudio( listener ) {\n\n\t\tAudio.call( this, listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\n\t\tconstructor: PositionalAudio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.panner;\n\n\t\t},\n\n\t\tgetRefDistance: function () {\n\n\t\t\treturn this.panner.refDistance;\n\n\t\t},\n\n\t\tsetRefDistance: function ( value ) {\n\n\t\t\tthis.panner.refDistance = value;\n\n\t\t},\n\n\t\tgetRolloffFactor: function () {\n\n\t\t\treturn this.panner.rolloffFactor;\n\n\t\t},\n\n\t\tsetRolloffFactor: function ( value ) {\n\n\t\t\tthis.panner.rolloffFactor = value;\n\n\t\t},\n\n\t\tgetDistanceModel: function () {\n\n\t\t\treturn this.panner.distanceModel;\n\n\t\t},\n\n\t\tsetDistanceModel: function ( value ) {\n\n\t\t\tthis.panner.distanceModel = value;\n\n\t\t},\n\n\t\tgetMaxDistance: function () {\n\n\t\t\treturn this.panner.maxDistance;\n\n\t\t},\n\n\t\tsetMaxDistance: function ( value ) {\n\n\t\t\tthis.panner.maxDistance = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioAnalyser( audio, fftSize ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\tObject.assign( AudioAnalyser.prototype, {\n\n\t\tgetFrequencyData: function () {\n\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\t\treturn this.data;\n\n\t\t},\n\n\t\tgetAverageFrequency: function () {\n\n\t\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tvalue += data[ i ];\n\n\t\t\t}\n\n\t\t\treturn value / data.length;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Buffered scene graph property that allows weighted accumulation.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tvar bufferType = Float64Array,\n\t\t\tmixFunction;\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t\t}\n\n\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\n\t\tthis._mixBufferRegion = mixFunction;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\tPropertyMixer.prototype = {\n\n\t\tconstructor: PropertyMixer,\n\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\taccumulate: function( accuIndex, weight ) {\n\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\t\tif ( currentWeight === 0 ) {\n\n\t\t\t\t// accuN := incoming * weight\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcurrentWeight = weight;\n\n\t\t\t} else {\n\n\t\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = currentWeight;\n\n\t\t},\n\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\tapply: function( accuIndex ) {\n\n\t\t\tvar stride = this.valueSize,\n\t\t\t\tbuffer = this.buffer,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tweight = this.cumulativeWeight,\n\n\t\t\t\tbinding = this.binding;\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t\tif ( weight < 1 ) {\n\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t\t}\n\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remember the state of the bound property and copy it to both accus\n\t\tsaveOriginalState: function() {\n\n\t\t\tvar binding = this.binding;\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toriginalValueOffset = stride * 3;\n\n\t\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t},\n\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\trestoreOriginalState: function() {\n\n\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t\t},\n\n\n\t\t// mix functions\n\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tif ( t >= 0.5 ) {\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tQuaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t\t},\n\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tvar s = 1 - t;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tvar j = dstOffset + i;\n\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * A reference to a real property in the scene graph.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode(\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\t\tthis.rootNode = rootNode;\n\n\t}\n\n\tPropertyBinding.prototype = {\n\n\t\tconstructor: PropertyBinding,\n\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.getValue( targetArray, offset );\n\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t// prototype version of these methods with one that represents\n\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t// become no-ops.\n\n\t\t},\n\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.setValue( sourceArray, offset );\n\n\t\t},\n\n\t\t// create getter / setter pair for a property in the scene graph\n\t\tbind: function() {\n\n\t\t\tvar targetObject = this.node,\n\t\t\t\tparsedPath = this.parsedPath,\n\n\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\ttargetObject = PropertyBinding.findNode(\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\t\tthis.node = targetObject;\n\n\t\t\t}\n\n\t\t\t// set fail state so we can just 'return' on error\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable;\n\n\t \t\t// ensure there is a value node\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( objectName ) {\n\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\tswitch ( objectName ) {\n\n\t\t\t\t\tcase 'materials':\n\n\t\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bones':\n\n\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// resolve property\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\t\tif ( nodeProperty === undefined ) {\n\n\t\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// determine versioning scheme\n\t\t\tvar versioning = this.Versioning.None;\n\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t}\n\n\t\t\t// determine how the property gets bound\n\t\t\tvar bindingType = this.BindingType.Direct;\n\n\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else {\n\n\t\t\t\tthis.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\t// select getter / setter\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tthis.node = null;\n\n\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\n\t\t}\n\n\t};\n\n\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t\t// these are used to \"bind\" a nonexistent property\n\t\t_getValue_unavailable: function() {},\n\t\t_setValue_unavailable: function() {},\n\n\t\t// initial state of these methods that calls 'bind'\n\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n\t\tBindingType: {\n\t\t\tDirect: 0,\n\t\t\tEntireArray: 1,\n\t\t\tArrayElement: 2,\n\t\t\tHasFromToArray: 3\n\t\t},\n\n\t\tVersioning: {\n\t\t\tNone: 0,\n\t\t\tNeedsUpdate: 1,\n\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t},\n\n\t\tGetterByBindingType: [\n\n\t\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\t\tvar source = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t\t}\n\n\t\t],\n\n\t\tSetterByBindingTypeAndVersioning: [\n\n\t\t\t[\n\t\t\t\t// Direct\n\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// EntireArray\n\n\t\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// ArrayElement\n\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// HasToFromArray\n\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t]\n\n\t\t]\n\n\t} );\n\n\tPropertyBinding.Composite =\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t};\n\n\tPropertyBinding.Composite.prototype = {\n\n\t\tconstructor: PropertyBinding.Composite,\n\n\t\tgetValue: function( array, offset ) {\n\n\t\t\tthis.bind(); // bind all binding\n\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t\t// and only call .getValue on the first\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t\t},\n\n\t\tsetValue: function( array, offset ) {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t\t}\n\n\t\t},\n\n\t\tbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].bind();\n\n\t\t\t}\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].unbind();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.create = function( root, path, parsedPath ) {\n\n\t\tif ( ! ( (root && root.isAnimationObjectGroup) ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.parseTrackName = function( trackName ) {\n\n\t\t// matches strings in the form of:\n\t\t//    nodeName.property\n\t\t//    nodeName.property[accessor]\n\t\t//    nodeName.material.property[accessor]\n\t\t//    uuid.property[accessor]\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t//    parentName/nodeName.property\n\t\t//    parentName/parentName/nodeName.property[index]\n\t\t//    .bone[Armature.DEF_cog].position\n\t\t//    scene:helium_balloon_model:helium_balloon_model.position\n\t\t// created and tested via https://regex101.com/#javascript\n\n\t\tvar re = /^((?:\\w+[\\/:])*)(\\w+)?(?:\\.(\\w+)(?:\\[(.+)\\])?)?\\.(\\w+)(?:\\[(.+)\\])?$/;\n\t\tvar matches = re.exec( trackName );\n\n\t\tif ( ! matches ) {\n\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t\t}\n\n\t\tvar results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ], \t// allowed to be null, specified root node.\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ],\n\t\t\tpropertyIndex: matches[ 6 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t};\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t};\n\n\tPropertyBinding.findNode = function( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\t\treturn bone;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\t\tif ( bone ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t * \t-\tInstead pass this object as 'root'.\n\t *\n\t * \t-\tYou can also add and remove objects later when the mixer\n\t * \t\tis running.\n\t *\n\t * Note:\n\t *\n\t *  \tObjects of this class appear as one object to the mixer,\n\t *  \tso cache control of the individual objects must be done\n\t *  \ton the group.\n\t *\n\t * Limitation:\n\t *\n\t * \t- \tThe animated properties must be compatible among the\n\t * \t\tall objects in the group.\n\t *\n\t *  -\tA single property can either be controlled through a\n\t *  \ttarget group or directly, but not both.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction AnimationObjectGroup( var_args ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tvar indices = {};\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t},\n\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t\t};\n\n\t}\n\n\tAnimationObjectGroup.prototype = {\n\n\t\tconstructor: AnimationObjectGroup,\n\n\t\tisAnimationObjectGroup: true,\n\n\t\tadd: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tpaths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index === undefined ) {\n\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\tnew PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\t\tbinding = new PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t\t} // else the object is already where we want it to be\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\tremove: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// remove & forget\n\t\tuncache: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // cached or active\n\n\t\t\t\t} // if object is known\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tobjects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\t\tindex = bindings.length;\n\n\t\t\tindicesByPath[ path ] = index;\n\n\t\t\tpaths.push( path );\n\t\t\tparsedPaths.push( parsedPath );\n\t\t\tbindings.push( bindingsForPath );\n\n\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\tnew PropertyBinding( object, path, parsedPath );\n\n\t\t\t}\n\n\t\t\treturn bindingsForPath;\n\n\t\t},\n\n\t\tunsubscribe_: function( path ) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\tbindings.pop();\n\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\tparsedPaths.pop();\n\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\tpaths.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t * objects.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t *\n\t */\n\n\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\n\t\tvar tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tvar interpolantSettings = {\n\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = -1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n\t}\n\n\tAnimationAction.prototype = {\n\n\t\tconstructor: AnimationAction,\n\n\t\t// State & Scheduling\n\n\t\tplay: function() {\n\n\t\t\tthis._mixer._activateAction( this );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function() {\n\n\t\t\tthis._mixer._deactivateAction( this );\n\n\t\t\treturn this.reset();\n\n\t\t},\n\n\t\treset: function() {\n\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\n\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\tthis._startTime = null;\t// forget scheduling\n\n\t\t\treturn this.stopFading().stopWarping();\n\n\t\t},\n\n\t\tisRunning: function() {\n\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\t// return true when play has been called\n\t\tisScheduled: function() {\n\n\t\t\treturn this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\tstartAt: function( time ) {\n\n\t\t\tthis._startTime = time;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetLoop: function( mode, repetitions ) {\n\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Weight\n\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\t\tsetEffectiveWeight: function( weight ) {\n\n\t\t\tthis.weight = weight;\n\n\t\t\t// note: same logic as when updated at runtime\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\t\treturn this.stopFading();\n\n\t\t},\n\n\t\t// return the weight considering fading and .enabled\n\t\tgetEffectiveWeight: function() {\n\n\t\t\treturn this._effectiveWeight;\n\n\t\t},\n\n\t\tfadeIn: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t\t},\n\n\t\tfadeOut: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t\t},\n\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\tthis.fadeIn( duration );\n\n\t\t\tif( warp ) {\n\n\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t\t},\n\n\t\tstopFading: function() {\n\n\t\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\t\tif ( weightInterpolant !== null ) {\n\n\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Time Scale Control\n\n\t\t// set the weight stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\t\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\t// return the time scale considering warping and .paused\n\t\tgetEffectiveTimeScale: function() {\n\n\t\t\treturn this._effectiveTimeScale;\n\n\t\t},\n\n\t\tsetDuration: function( duration ) {\n\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\tsyncWith: function( action ) {\n\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\thalt: function( duration ) {\n\n\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t\t},\n\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now;\n\t\t\ttimes[ 1 ] = now + duration;\n\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstopWarping: function() {\n\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Object Accessors\n\n\t\tgetMixer: function() {\n\n\t\t\treturn this._mixer;\n\n\t\t},\n\n\t\tgetClip: function() {\n\n\t\t\treturn this._clip;\n\n\t\t},\n\n\t\tgetRoot: function() {\n\n\t\t\treturn this._localRoot || this._mixer._root;\n\n\t\t},\n\n\t\t// Interna\n\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t// called by the mixer\n\n\t\t\tvar startTime = this._startTime;\n\n\t\t\tif ( startTime !== null ) {\n\n\t\t\t\t// check for scheduled start of action\n\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t\t}\n\n\t\t\t\t// start\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t\t// apply time scale and advance time\n\n\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\n\t\t\tvar weight = this._updateWeight( time );\n\n\t\t\tif ( weight > 0 ) {\n\n\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_updateWeight: function( time ) {\n\n\t\t\tvar weight = 0;\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\tweight = this.weight;\n\t\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\n\t\t},\n\n\t\t_updateTimeScale: function( time ) {\n\n\t\t\tvar timeScale = 0;\n\n\t\t\tif ( ! this.paused ) {\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\n\t\t},\n\n\t\t_updateTime: function( deltaTime ) {\n\n\t\t\tvar time = this.time + deltaTime;\n\n\t\t\tif ( deltaTime === 0 ) return time;\n\n\t\t\tvar duration = this._clip.duration,\n\n\t\t\t\tloop = this.loop,\n\t\t\t\tloopCount = this._loopCount;\n\n\t\t\tif ( loop === LoopOnce ) {\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t\t}\n\n\t\t\t\thandle_stop: {\n\n\t\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\t\ttime = duration;\n\n\t\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\t\ttime = 0;\n\n\t\t\t\t\t} else break handle_stop;\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t// wrap around\n\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\n\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\t\tthis.time = time;\n\t\t\t\t\treturn duration - time;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.time = time;\n\t\t\treturn time;\n\n\t\t},\n\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\t\tvar settings = this._interpolantSettings;\n\n\t\t\tif ( pingPong ) {\n\n\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\n\t\t\t} else {\n\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\t\tif ( atStart ) {\n\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t\tif ( atEnd ) {\n\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Player for AnimationClips.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction AnimationMixer( root ) {\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\tObject.assign( AnimationMixer.prototype, EventDispatcher.prototype, {\n\n\t\t// return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\t\tclipAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\tprototypeAction = null;\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\tvar existingAction =\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\t\treturn existingAction;\n\n\t\t\t\t}\n\n\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\tif ( clipObject === null )\n\t\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t\t}\n\n\t\t\t// clip must be known when specified via string\n\t\t\tif ( clipObject === null ) return null;\n\n\t\t\t// allocate all resources required to run it\n\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n\t\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t\t// and make the action known to the memory manager\n\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\t\treturn newAction;\n\n\t\t},\n\n\t\t// get an existing action\n\t\texistingAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// deactivates all previously scheduled actions\n\t\tstopAllAction: function() {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tactions[ i ].reset();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].useCount = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// advance the time and update apply the animation\n\t\tupdate: function( deltaTime ) {\n\n\t\t\tdeltaTime *= this.timeScale;\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\n\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t\t// run active actions\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tvar action = actions[ i ];\n\n\t\t\t\tif ( action.enabled ) {\n\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update scene graph\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// return this mixer's root target object\n\t\tgetRoot: function() {\n\n\t\t\treturn this._root;\n\n\t\t},\n\n\t\t// free all resources specific to a particular clip\n\t\tuncacheClip: function( clip ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t\t}\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t// free all resources specific to a particular root target object\n\t\tuncacheRoot: function( root ) {\n\n\t\t\tvar rootUuid = root.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip;\n\n\t\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( action !== undefined ) {\n\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingByName !== undefined ) {\n\n\t\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remove a targeted clip from the cache\n\t\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\t\tif ( action !== null ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// Implementation details:\n\n\tObject.assign( AnimationMixer.prototype, {\n\n\t\t_bindAction: function( action, prototypeAction ) {\n\n\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\trootUuid = root.uuid,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingsByName === undefined ) {\n\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t}\n\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t\t}\n\n\t\t},\n\n\t\t_activateAction: function( action ) {\n\n\t\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t\t}\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// increment reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._lendAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t_deactivateAction: function( action ) {\n\n\t\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._takeBackAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Memory manager\n\n\t\t_initMemoryManager: function() {\n\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\tthis._nActiveActions = 0;\n\n\t\t\tthis._actionsByClip = {};\n\t\t\t// inside:\n\t\t\t// {\n\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t// }\n\n\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\tthis._nActiveControlInterpolants = 0;\n\n\t\t\tvar scope = this;\n\n\t\t\tthis.stats = {\n\n\t\t\t\tactions: {\n\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t},\n\n\t\t// Memory management for AnimationAction objects\n\n\t\t_isActiveAction: function( action ) {\n\n\t\t\tvar index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\n\t\t},\n\n\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip === undefined ) {\n\n\t\t\t\tactionsForClip = {\n\n\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\tactionByRoot: {}\n\n\t\t\t\t};\n\n\t\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t\t} else {\n\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push( action );\n\n\t\t\t}\n\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push( action );\n\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t\t},\n\n\t\t_removeInactiveAction: function( action ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\tcacheIndex = action._cacheIndex;\n\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\tactions.pop();\n\n\t\t\taction._cacheIndex = null;\n\n\n\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\t\tlastKnownAction =\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\n\t\t\taction._byClipCacheIndex = null;\n\n\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\t\tdelete actionByRoot[ rootUuid ];\n\n\t\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t},\n\n\t\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendAction: function( action ) {\n\n\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t// [  active actions >| inactive actions ]\n\t\t\t//                 s        a\n\t\t\t//                  <-swap->\n\t\t\t//                 a        s\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[ lastActiveIndex ] = action;\n\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t\t},\n\n\t\t_takeBackAction: function( action ) {\n\n\t\t\t// [  active actions  | inactive actions ]\n\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t//        a        s\n\t\t\t//         <-swap->\n\t\t\t//        s        a\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[ firstInactiveIndex ] = action;\n\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t\t},\n\n\t\t// Memory management for PropertyMixer objects\n\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( bindingByName === undefined ) {\n\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t\t}\n\n\t\t\tbindingByName[ trackName ] = binding;\n\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push( binding );\n\n\t\t},\n\n\t\t_removeInactiveBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tpropBinding = binding.binding,\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\ttrackName = propBinding.path,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\n\t\t\tdelete bindingByName[ trackName ];\n\n\t\t\tremove_empty_map: {\n\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t\t},\n\n\t\t_takeBackBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t\t},\n\n\n\t\t// Memory management of Interpolants for weight and time scale\n\n\t\t_lendControlInterpolant: function() {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\t\tif ( interpolant === undefined ) {\n\n\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t\t}\n\n\t\t\treturn interpolant;\n\n\t\t},\n\n\t\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t\t},\n\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Uniform( value ) {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferGeometry() {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.maxInstancedCount = undefined;\n\n\t}\n\n\tInstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tInstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;\n\n\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\n\tInstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t};\n\n\tInstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized === true;\n\n\t}\n\n\n\tInterleavedBufferAttribute.prototype = {\n\n\t\tconstructor: InterleavedBufferAttribute,\n\n\t\tisInterleavedBufferAttribute: true,\n\n\t\tget count() {\n\n\t\t\treturn this.data.count;\n\n\t\t},\n\n\t\tget array() {\n\n\t\t\treturn this.data.array;\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\tthis.data.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBuffer( array, stride ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tInterleavedBuffer.prototype = {\n\n\t\tconstructor: InterleavedBuffer,\n\n\t\tisInterleavedBuffer: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.count = source.count;\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n\t\tInterleavedBuffer.call( this, array, stride );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );\n\tInstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;\n\n\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\n\tInstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\n\t\tBufferAttribute.call( this, array, itemSize );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tInstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;\n\n\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\n\tInstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\t\tBufferAttribute.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author bhouston / http://clara.io/\n\t * @author stephomi / http://stephaneginier.com/\n\t */\n\n\tfunction Raycaster( origin, direction, near, far ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tRaycaster.prototype = {\n\n\t\tconstructor: Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( (camera && camera.isPerspectiveCamera) ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( (camera && camera.isOrthographicCamera) ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Clock( autoStart ) {\n\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tClock.prototype = {\n\n\t\tconstructor: Clock,\n\n\t\tstart: function () {\n\n\t\t\tthis.startTime = ( performance || Date ).now();\n\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\n\t\t},\n\n\t\tgetElapsedTime: function () {\n\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\n\t\t},\n\n\t\tgetDelta: function () {\n\n\t\t\tvar diff = 0;\n\n\t\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\t\tthis.start();\n\n\t\t\t}\n\n\t\t\tif ( this.running ) {\n\n\t\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\n\t\t\t\tthis.elapsedTime += diff;\n\n\t\t\t}\n\n\t\t\treturn diff;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Spline from Tween.js, slightly optimized (and trashed)\n\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t *\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Spline( points ) {\n\n\t\tthis.points = points;\n\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\tpoint, intPoint, weight, w2, w3,\n\t\tpa, pb, pc, pd;\n\n\t\tthis.initFromArray = function ( a ) {\n\n\t\t\tthis.points = [];\n\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getPoint = function ( k ) {\n\n\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\tc[ 1 ] = intPoint;\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\tpd = this.points[ c[ 3 ] ];\n\n\t\t\tw2 = weight * weight;\n\t\t\tw3 = weight * w2;\n\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\t\treturn v3;\n\n\t\t};\n\n\t\tthis.getControlPointsArray = function () {\n\n\t\t\tvar i, p, l = this.points.length,\n\t\t\t\tcoords = [];\n\n\t\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\t\tp = this.points[ i ];\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t\t}\n\n\t\t\treturn coords;\n\n\t\t};\n\n\t\t// approximate length by summing linear segments\n\n\t\tthis.getLength = function ( nSubDivisions ) {\n\n\t\t\tvar i, index, nSamples, position,\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\toldPosition = new Vector3(),\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tchunkLengths = [],\n\t\t\t\ttotalLength = 0;\n\n\t\t\t// first point has 0 length\n\n\t\t\tchunkLengths[ 0 ] = 0;\n\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\t\tindex = i / nSamples;\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\ttmpVec.copy( position );\n\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\t\toldPosition.copy( position );\n\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\tintPoint = Math.floor( point );\n\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// last point ends with total length\n\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t\t};\n\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\t\tvar i, j,\n\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\trealDistance,\n\t\t\t\tsampling, position,\n\t\t\t\tnewpoints = [],\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tsl = this.getLength();\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t\t}\n\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tthis.points = newpoints;\n\n\t\t};\n\n\t\t// Catmull-Rom\n\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The poles (phi) are at the positive and negative y axis.\n\t * The equator starts at positive z.\n\t */\n\n\tfunction Spherical( radius, phi, theta ) {\n\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\t\treturn this;\n\n\t}\n\n\tSpherical.prototype = {\n\n\t\tconstructor: Spherical,\n\n\t\tset: function ( radius, phi, theta ) {\n\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( other ) {\n\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tmakeSafe: function() {\n\n\t\t\tvar EPS = 0.000001;\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromVector3: function( vec3 ) {\n\n\t\t\tthis.radius = vec3.length();\n\n\t\t\tif ( this.radius === 0 ) {\n\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t};\n\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\r\n\tfunction MorphBlendMesh( geometry, material ) {\n\r\n\t\tMesh.call( this, geometry, material );\r\n\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\t\tvar name = \"__default\";\r\n\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\r\n\t\tvar fps = numFrames / 1;\r\n\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\r\n\t}\r\n\r\n\tMorphBlendMesh.prototype = Object.create( Mesh.prototype );\r\n\tMorphBlendMesh.prototype.constructor = MorphBlendMesh;\r\n\r\n\tMorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\t\tvar animation = {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\r\n\t\t\tlength: end - start + 1,\r\n\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\r\n\t\t\tactive: false,\r\n\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\r\n\t\t};\r\n\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\r\n\t\tvar geometry = this.geometry;\r\n\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in frameRanges ) {\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t\t}\r\n\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.weight = weight;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = time;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\t\tvar time = 0;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\ttime = animation.time;\r\n\r\n\t\t}\r\n\r\n\t\treturn time;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\t\tvar duration = - 1;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tduration = animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\treturn duration;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.active = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\t\tif ( ! animation.active ) continue;\r\n\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction ImmediateRenderObject( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.material = material;\n\t\tthis.render = function ( renderCallback ) {};\n\n\t}\n\n\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\n\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length * 3;\n\n\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\n\tVertexNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\t\tvar faces = objGeometry.faces;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction SpotLightHelper( light ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = [\n\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t0, 0, 0,   0, - 1,   1\n\t\t];\n\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\n\tSpotLightHelper.prototype.dispose = function () {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t};\n\n\tSpotLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\t\tvar vector2 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author Sean Griffin / http://twitter.com/sgrif\n\t * @author Michael Guerrero / http://realitymeltdown.com\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkeletonHelper( object ) {\n\n\t\tthis.bones = this.getBoneList( object );\n\n\t\tvar geometry = new Geometry();\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.colors.push( new Color( 0, 0, 1 ) );\n\t\t\t\tgeometry.colors.push( new Color( 0, 1, 0 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.dynamic = true;\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.root = object;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\n\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\n\tSkeletonHelper.prototype.getBoneList = function( object ) {\n\n\t\tvar boneList = [];\n\n\t\tif ( (object && object.isBone) ) {\n\n\t\t\tboneList.push( object );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t\t}\n\n\t\treturn boneList;\n\n\t};\n\n\tSkeletonHelper.prototype.update = function () {\n\n\t\tvar geometry = this.geometry;\n\n\t\tvar matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );\n\n\t\tvar boneMatrix = new Matrix4();\n\n\t\tvar j = 0;\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\tgeometry.computeBoundingSphere();\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PointLightHelper( light, sphereSize ) {\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\t/*\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\t\tvar d = light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\n\t\tthis.add( this.lightDistance );\n\t\t*/\n\n\t}\n\n\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\tPointLightHelper.prototype.constructor = PointLightHelper;\n\n\tPointLightHelper.prototype.dispose = function () {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t};\n\n\tPointLightHelper.prototype.update = function () {\n\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t/*\n\t\tvar d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction HemisphereLightHelper( light, sphereSize ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.colors = [ new Color(), new Color() ];\n\n\t\tvar geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t\t}\n\n\t\tvar material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );\n\n\t\tthis.lightSphere = new Mesh( geometry, material );\n\t\tthis.add( this.lightSphere );\n\n\t\tthis.update();\n\n\t}\n\n\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\n\tHemisphereLightHelper.prototype.dispose = function () {\n\n\t\tthis.lightSphere.geometry.dispose();\n\t\tthis.lightSphere.material.dispose();\n\n\t};\n\n\tHemisphereLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction GridHelper( size, divisions, color1, color2 ) {\n\n\t\tdivisions = divisions || 1;\n\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\t\tvar center = divisions / 2;\n\t\tvar step = ( size * 2 ) / divisions;\n\t\tvar vertices = [], colors = [];\n\n\t\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\t\tvertices.push( k, 0, - size, k, 0, size );\n\n\t\t\tvar color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\tGridHelper.prototype.constructor = GridHelper;\n\n\tGridHelper.prototype.setColors = function () {\n\n\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\n\t\t// FaceNormalsHelper only supports THREE.Geometry\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\t\tthis.update();\n\n\t}\n\n\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\n\tFaceNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction DirectionalLightHelper( light, size ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [\n\t\t\t- size,   size, 0,\n\t\t\t  size,   size, 0,\n\t\t\t  size, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size,   size, 0\n\t\t], 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.add( new Line( geometry, material ) );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.add( new Line( geometry, material ));\n\n\t\tthis.update();\n\n\t}\n\n\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\n\tDirectionalLightHelper.prototype.dispose = function () {\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.geometry.dispose();\n\t\tlightPlane.material.dispose();\n\t\ttargetLine.geometry.dispose();\n\t\ttargetLine.material.dispose();\n\n\t};\n\n\tDirectionalLightHelper.prototype.update = function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar v3 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\tv3.subVectors( v2, v1 );\n\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\n\t\t\tlightPlane.lookAt( v3 );\n\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t\ttargetLine.lookAt( v3 );\n\t\t\ttargetLine.scale.z = v3.length();\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\n\tfunction CameraHelper( camera ) {\n\n\t\tvar geometry = new Geometry();\n\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\n\t\tvar pointMap = {};\n\n\t\t// colors\n\n\t\tvar hexFrustum = 0xffaa00;\n\t\tvar hexCone = 0xff0000;\n\t\tvar hexUp = 0x00aaff;\n\t\tvar hexTarget = 0xffffff;\n\t\tvar hexCross = 0x333333;\n\n\t\t// near\n\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t\t// far\n\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t\t// sides\n\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t\t// cone\n\n\t\taddLine( \"p\", \"n1\", hexCone );\n\t\taddLine( \"p\", \"n2\", hexCone );\n\t\taddLine( \"p\", \"n3\", hexCone );\n\t\taddLine( \"p\", \"n4\", hexCone );\n\n\t\t// up\n\n\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\taddLine( \"u3\", \"u1\", hexUp );\n\n\t\t// target\n\n\t\taddLine( \"c\", \"t\", hexTarget );\n\t\taddLine( \"p\", \"c\", hexCross );\n\n\t\t// cross\n\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\t\tfunction addLine( a, b, hex ) {\n\n\t\t\taddPoint( a, hex );\n\t\t\taddPoint( b, hex );\n\n\t\t}\n\n\t\tfunction addPoint( id, hex ) {\n\n\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\tgeometry.colors.push( new Color( hex ) );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t\t}\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.camera = camera;\n\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t}\n\n\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\tCameraHelper.prototype.constructor = CameraHelper;\n\n\tCameraHelper.prototype.update = function () {\n\n\t\tvar geometry, pointMap;\n\n\t\tvar vector = new Vector3();\n\t\tvar camera = new Camera();\n\n\t\tfunction setPoint( point, x, y, z ) {\n\n\t\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\t\tvar points = pointMap[ point ];\n\n\t\t\tif ( points !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function update() {\n\n\t\t\tgeometry = this.geometry;\n\t\t\tpointMap = this.pointMap;\n\n\t\t\tvar w = 1, h = 1;\n\n\t\t\t// we need just camera projection matrix\n\t\t\t// world matrix must be identity\n\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t\t// center / target\n\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t\t// near\n\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t\t// far\n\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t\t// up\n\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t\t// cross\n\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\t\tgeometry.verticesNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\t// a helper to show the world-axis-aligned bounding box for an object\n\n\tfunction BoundingBoxHelper( object, hex ) {\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\t\tthis.object = object;\n\n\t\tthis.box = new Box3();\n\n\t\tMesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n\t}\n\n\tBoundingBoxHelper.prototype = Object.create( Mesh.prototype );\n\tBoundingBoxHelper.prototype.constructor = BoundingBoxHelper;\n\n\tBoundingBoxHelper.prototype.update = function () {\n\n\t\tthis.box.setFromObject( this.object );\n\n\t\tthis.box.getSize( this.scale );\n\n\t\tthis.box.getCenter( this.position );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BoxHelper( object, color ) {\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tvar positions = new Float32Array( 8 * 3 );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tthis.update( object );\n\n\t\t}\n\n\t}\n\n\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\tBoxHelper.prototype.constructor = BoxHelper;\n\n\tBoxHelper.prototype.update = ( function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function update( object ) {\n\n\t\t\tif ( (object && object.isBox3) ) {\n\n\t\t\t\tbox.copy( object );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromObject( object );\n\n\t\t\t}\n\n\t\t\tif ( box.isEmpty() ) return;\n\n\t\t\tvar min = box.min;\n\t\t\tvar max = box.max;\n\n\t\t\t/*\n\t\t\t  5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\n\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\n\t\t\tvar position = this.geometry.attributes.position;\n\t\t\tvar array = position.array;\n\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t};\n\n\t} )();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author zz85 / http://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t *\n\t * Creates an arrow for visualizing directions\n\t *\n\t * Parameters:\n\t *  dir - Vector3\n\t *  origin - Vector3\n\t *  length - Number\n\t *  color - color in hex value\n\t *  headLength - Number\n\t *  headWidth - Number\n\t */\n\n\tvar lineGeometry = new BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tObject3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\tArrowHelper.prototype.constructor = ArrowHelper;\n\n\tArrowHelper.prototype.setDirection = ( function () {\n\n\t\tvar axis = new Vector3();\n\t\tvar radians;\n\n\t\treturn function setDirection( dir ) {\n\n\t\t\t// dir is assumed to be normalized\n\n\t\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\t\tradians = Math.acos( dir.y );\n\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t};\n\n\tArrowHelper.prototype.setColor = function ( color ) {\n\n\t\tthis.line.material.color.copy( color );\n\t\tthis.cone.material.color.copy( color );\n\n\t};\n\n\t/**\n\t * @author sroucheray / http://sroucheray.org/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AxisHelper( size ) {\n\n\t\tsize = size || 1;\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t0, 0, 0,  0, 0, size\n\t\t] );\n\n\t\tvar colors = new Float32Array( [\n\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t] );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tAxisHelper.prototype = Object.create( LineSegments.prototype );\n\tAxisHelper.prototype.constructor = AxisHelper;\n\n\t/**\n\t * @author zz85 https://github.com/zz85\n\t *\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\tvar CatmullRomCurve3 = ( function() {\n\n\t\tvar\n\t\t\ttmp = new Vector3(),\n\t\t\tpx = new CubicPoly(),\n\t\t\tpy = new CubicPoly(),\n\t\t\tpz = new CubicPoly();\n\n\t\t/*\n\t\tBased on an optimized c++ solution in\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t - http://ideone.com/NoEbVM\n\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\twhich can be placed in CurveUtils.\n\t\t*/\n\n\t\tfunction CubicPoly() {}\n\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *   p(0) = x0, p(1) = x1\n\t\t *  and\n\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t */\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\t\tthis.c0 = x0;\n\t\t\tthis.c1 = t0;\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t\t};\n\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\t// initCubicPoly\n\t\t\tthis.init( x1, x2, t1, t2 );\n\n\t\t};\n\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t};\n\n\t\tCubicPoly.prototype.calc = function( t ) {\n\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t\t};\n\n\t\t// Subclass Three.js curve\n\t\treturn Curve.create(\n\n\t\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\t\tthis.points = p || [];\n\t\t\t\tthis.closed = false;\n\n\t\t\t},\n\n\t\t\tfunction ( t ) {\n\n\t\t\t\tvar points = this.points,\n\t\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\t\tl = points.length;\n\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\n\t\t\t\tif ( this.closed ) {\n\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\tweight = 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate first point\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\tp0 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate last point\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\tp3 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t\t}\n\n\t\t\t\tvar v = new Vector3(\n\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\tpz.calc( weight )\n\t\t\t\t);\n\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t);\n\n\t} )();\n\n\t/**************************************************************\n\t *\tClosed Spline 3D curve\n\t **************************************************************/\n\n\n\tfunction ClosedSplineCurve3( points ) {\n\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\t\tCatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\t\tthis.closed = true;\n\n\t}\n\n\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n\t/**************************************************************\n\t *\tSpline 3D curve\n\t **************************************************************/\n\n\n\tvar SplineCurve3 = Curve.create(\n\n\t\tfunction ( points /* array of Vector3 */ ) {\n\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\t\treturn new Vector3(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tCubic Bezier 3D curve\n\t **************************************************************/\n\n\tvar CubicBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2, v3 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b3 = ShapeUtils.b3;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tQuadratic Bezier 3D curve\n\t **************************************************************/\n\n\tvar QuadraticBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b2 = ShapeUtils.b2;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tLine3D\n\t **************************************************************/\n\n\tvar LineCurve3 = Curve.create(\n\n\t\tfunction ( v1, v2 ) {\n\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tif ( t === 1 ) {\n\n\t\t\t\treturn this.v2.clone();\n\n\t\t\t}\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\tvector.multiplyScalar( t );\n\t\t\tvector.add( this.v1 );\n\n\t\t\treturn vector;\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tArc curve\n\t **************************************************************/\n\n\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t}\n\n\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\tArcCurve.prototype.constructor = ArcCurve;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tvar SceneUtils = {\n\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\t\tvar group = new Group();\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t},\n\n\t\tdetach: function ( child, parent, scene ) {\n\n\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\tparent.remove( child );\n\t\t\tscene.add( child );\n\n\t\t},\n\n\t\tattach: function ( child, scene, parent ) {\n\n\t\t\tvar matrixWorldInverse = new Matrix4();\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\t\tscene.remove( child );\n\t\t\tparent.add( child );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Face4 ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\t}\n\n\tvar LineStrip = 0;\n\n\tvar LinePieces = 1;\n\n\tfunction PointCloud ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction ParticleSystem ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction PointCloudMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleBasicMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleSystemMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction Vertex ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new Vector3( x, y, z );\n\t}\n\n\t//\n\n\tfunction EdgesHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\tfunction WireframeHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\t//\n\n\tObject.assign( Box2.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Box3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Line3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix3.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix3( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix4.prototype, {\n\t\textractPosition: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\treturn this.copyPosition( m );\n\t\t},\n\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t},\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\treturn vector.applyProjection( this );\n\t\t},\n\t\tmultiplyVector4: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t},\n\t\trotateAxis: function ( v ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\tv.transformDirection( this );\n\t\t},\n\t\tcrossVector: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\ttranslate: function ( v ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t},\n\t\trotateX: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t},\n\t\trotateY: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t},\n\t\trotateZ: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t},\n\t\trotateByAxis: function ( axis, angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.assign( Plane.prototype, {\n\t\tisIntersectionLine: function ( line ) {\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\treturn this.intersectsLine( line );\n\t\t}\n\t} );\n\n\tObject.assign( Quaternion.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\treturn vector.applyQuaternion( this );\n\t\t}\n\t} );\n\n\tObject.assign( Ray.prototype, {\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionPlane: function ( plane ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\treturn this.intersectsPlane( plane );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t}\n\t} );\n\n\tObject.assign( Shape.prototype, {\n\t\textrude: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\treturn new ExtrudeGeometry( this, options );\n\t\t},\n\t\tmakeGeometry: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\treturn new ShapeGeometry( this, options );\n\t\t}\n\t} );\n\n\tObject.assign( Vector3.prototype, {\n\t\tsetEulerFromRotationMatrix: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t},\n\t\tsetEulerFromQuaternion: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t},\n\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\treturn this.setFromMatrixPosition( m );\n\t\t},\n\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\treturn this.setFromMatrixScale( m );\n\t\t},\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Object3D.prototype, {\n\t\tgetChildByName: function ( name ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\treturn this.getObjectByName( name );\n\t\t},\n\t\trenderDepth: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t},\n\t\ttranslate: function ( distance, axis ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t}\n\t} );\n\n\tObject.defineProperties( Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( LOD.prototype, {\n\t\tobjects: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\treturn this.levels;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength( focalLength );\n\n\t};\n\n\t//\n\n\tObject.defineProperties( Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.assign( BufferGeometry.prototype, {\n\t\taddIndex: function ( index ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\tthis.setIndex( index );\n\t\t},\n\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t}\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\tthis.addGroup( start, count );\n\t\t},\n\t\tclearDrawCalls: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\tthis.clearGroups();\n\t\t},\n\t\tcomputeTangents: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t},\n\t\tcomputeOffsets: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\treturn new Color();\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\t\tmetal: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tEventDispatcher.prototype = Object.assign( Object.create( {\n\n\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\t\tconstructor: EventDispatcher,\n\n\t\tapply: function ( target ) {\n\n\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\t\tObject.assign( target, this );\n\n\t\t}\n\n\t} ), EventDispatcher.prototype );\n\n\t//\n\n\tObject.defineProperties( Uniform.prototype, {\n\t\tdynamic: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t}\n\t\t},\n\t\tonUpdate: {\n\t\t\tvalue: function () {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( WebGLRenderer.prototype, {\n\t\tsupportsFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t},\n\t\tsupportsHalfFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t},\n\t\tsupportsStandardDerivatives: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t},\n\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t},\n\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t},\n\t\tsupportsBlendMinMax: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t},\n\t\tsupportsVertexTextures: function () {\n\t\t\treturn this.capabilities.vertexTextures;\n\t\t},\n\t\tsupportsInstancedArrays: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t},\n\t\tenableScissorTest: function ( boolean ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\tthis.setScissorTest( boolean );\n\t\t},\n\t\tinitMaterial: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t},\n\t\taddPrePlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t},\n\t\taddPostPlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t},\n\t\tupdateShadowMap: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\n\t\t\t},\n\t\t\tset: function ( cullFace ) {\n\t\t\t\tvar value = ( cullFace !== CullFaceBack );\n\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\tthis.renderReverseSided = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Audio.prototype, {\n\t\tload: function ( file ) {\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\tvar scope = this;\n\t\t\tvar audioLoader = new AudioLoader();\n\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\tscope.setBuffer( buffer );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\n\tObject.assign( AudioAnalyser.prototype, {\n\t\tgetData: function ( file ) {\n\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\treturn this.getFrequencyData();\n\t\t}\n\t} );\n\n\t//\n\n\tvar GeometryUtils = {\n\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\t\tvar matrix;\n\n\t\t\tif ( geometry2.isMesh ) {\n\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t\t}\n\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t\t},\n\n\t\tcenter: function ( geometry ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\treturn geometry.center();\n\n\t\t}\n\n\t};\n\n\tvar ImageUtils = {\n\n\t\tcrossOrigin: undefined,\n\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\t\tvar loader = new TextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\t\tvar loader = new CubeTextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadCompressedTexture: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t},\n\n\t\tloadCompressedTextureCube: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Projector () {\n\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\t\tthis.projectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\n\t\t};\n\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\n\t\t};\n\n\t\tthis.pickingRay = function ( vector, camera ) {\n\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t\t};\n\n\t}\n\n\t//\n\n\tfunction CanvasRenderer () {\n\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tthis.clear = function () {};\n\t\tthis.render = function () {};\n\t\tthis.setClearColor = function () {};\n\t\tthis.setSize = function () {};\n\n\t}\n\n\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\texports.WebGLRenderTarget = WebGLRenderTarget;\n\texports.WebGLRenderer = WebGLRenderer;\n\texports.ShaderLib = ShaderLib;\n\texports.UniformsLib = UniformsLib;\n\texports.UniformsUtils = UniformsUtils;\n\texports.ShaderChunk = ShaderChunk;\n\texports.FogExp2 = FogExp2;\n\texports.Fog = Fog;\n\texports.Scene = Scene;\n\texports.LensFlare = LensFlare;\n\texports.Sprite = Sprite;\n\texports.LOD = LOD;\n\texports.SkinnedMesh = SkinnedMesh;\n\texports.Skeleton = Skeleton;\n\texports.Bone = Bone;\n\texports.Mesh = Mesh;\n\texports.LineSegments = LineSegments;\n\texports.Line = Line;\n\texports.Points = Points;\n\texports.Group = Group;\n\texports.VideoTexture = VideoTexture;\n\texports.DataTexture = DataTexture;\n\texports.CompressedTexture = CompressedTexture;\n\texports.CubeTexture = CubeTexture;\n\texports.CanvasTexture = CanvasTexture;\n\texports.DepthTexture = DepthTexture;\n\texports.TextureIdCount = TextureIdCount;\n\texports.Texture = Texture;\n\texports.MaterialIdCount = MaterialIdCount;\n\texports.CompressedTextureLoader = CompressedTextureLoader;\n\texports.BinaryTextureLoader = BinaryTextureLoader;\n\texports.DataTextureLoader = DataTextureLoader;\n\texports.CubeTextureLoader = CubeTextureLoader;\n\texports.TextureLoader = TextureLoader;\n\texports.ObjectLoader = ObjectLoader;\n\texports.MaterialLoader = MaterialLoader;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.DefaultLoadingManager = DefaultLoadingManager;\n\texports.LoadingManager = LoadingManager;\n\texports.JSONLoader = JSONLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.FontLoader = FontLoader;\n\texports.XHRLoader = XHRLoader;\n\texports.Loader = Loader;\n\texports.Cache = Cache;\n\texports.AudioLoader = AudioLoader;\n\texports.SpotLightShadow = SpotLightShadow;\n\texports.SpotLight = SpotLight;\n\texports.PointLight = PointLight;\n\texports.HemisphereLight = HemisphereLight;\n\texports.DirectionalLightShadow = DirectionalLightShadow;\n\texports.DirectionalLight = DirectionalLight;\n\texports.AmbientLight = AmbientLight;\n\texports.LightShadow = LightShadow;\n\texports.Light = Light;\n\texports.StereoCamera = StereoCamera;\n\texports.PerspectiveCamera = PerspectiveCamera;\n\texports.OrthographicCamera = OrthographicCamera;\n\texports.CubeCamera = CubeCamera;\n\texports.Camera = Camera;\n\texports.AudioListener = AudioListener;\n\texports.PositionalAudio = PositionalAudio;\n\texports.getAudioContext = getAudioContext;\n\texports.AudioAnalyser = AudioAnalyser;\n\texports.Audio = Audio;\n\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\texports.StringKeyframeTrack = StringKeyframeTrack;\n\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\texports.PropertyMixer = PropertyMixer;\n\texports.PropertyBinding = PropertyBinding;\n\texports.KeyframeTrack = KeyframeTrack;\n\texports.AnimationUtils = AnimationUtils;\n\texports.AnimationObjectGroup = AnimationObjectGroup;\n\texports.AnimationMixer = AnimationMixer;\n\texports.AnimationClip = AnimationClip;\n\texports.Uniform = Uniform;\n\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\texports.BufferGeometry = BufferGeometry;\n\texports.GeometryIdCount = GeometryIdCount;\n\texports.Geometry = Geometry;\n\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\texports.InterleavedBuffer = InterleavedBuffer;\n\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\texports.Float64Attribute = Float64Attribute;\n\texports.Float32Attribute = Float32Attribute;\n\texports.Uint32Attribute = Uint32Attribute;\n\texports.Int32Attribute = Int32Attribute;\n\texports.Uint16Attribute = Uint16Attribute;\n\texports.Int16Attribute = Int16Attribute;\n\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\texports.Uint8Attribute = Uint8Attribute;\n\texports.Int8Attribute = Int8Attribute;\n\texports.BufferAttribute = BufferAttribute;\n\texports.Face3 = Face3;\n\texports.Object3DIdCount = Object3DIdCount;\n\texports.Object3D = Object3D;\n\texports.Raycaster = Raycaster;\n\texports.Layers = Layers;\n\texports.EventDispatcher = EventDispatcher;\n\texports.Clock = Clock;\n\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\texports.LinearInterpolant = LinearInterpolant;\n\texports.DiscreteInterpolant = DiscreteInterpolant;\n\texports.CubicInterpolant = CubicInterpolant;\n\texports.Interpolant = Interpolant;\n\texports.Triangle = Triangle;\n\texports.Spline = Spline;\n\texports.Math = _Math;\n\texports.Spherical = Spherical;\n\texports.Plane = Plane;\n\texports.Frustum = Frustum;\n\texports.Sphere = Sphere;\n\texports.Ray = Ray;\n\texports.Matrix4 = Matrix4;\n\texports.Matrix3 = Matrix3;\n\texports.Box3 = Box3;\n\texports.Box2 = Box2;\n\texports.Line3 = Line3;\n\texports.Euler = Euler;\n\texports.Vector4 = Vector4;\n\texports.Vector3 = Vector3;\n\texports.Vector2 = Vector2;\n\texports.Quaternion = Quaternion;\n\texports.ColorKeywords = ColorKeywords;\n\texports.Color = Color;\n\texports.MorphBlendMesh = MorphBlendMesh;\n\texports.ImmediateRenderObject = ImmediateRenderObject;\n\texports.VertexNormalsHelper = VertexNormalsHelper;\n\texports.SpotLightHelper = SpotLightHelper;\n\texports.SkeletonHelper = SkeletonHelper;\n\texports.PointLightHelper = PointLightHelper;\n\texports.HemisphereLightHelper = HemisphereLightHelper;\n\texports.GridHelper = GridHelper;\n\texports.FaceNormalsHelper = FaceNormalsHelper;\n\texports.DirectionalLightHelper = DirectionalLightHelper;\n\texports.CameraHelper = CameraHelper;\n\texports.BoundingBoxHelper = BoundingBoxHelper;\n\texports.BoxHelper = BoxHelper;\n\texports.ArrowHelper = ArrowHelper;\n\texports.AxisHelper = AxisHelper;\n\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\texports.SplineCurve3 = SplineCurve3;\n\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\texports.LineCurve3 = LineCurve3;\n\texports.ArcCurve = ArcCurve;\n\texports.EllipseCurve = EllipseCurve;\n\texports.SplineCurve = SplineCurve;\n\texports.CubicBezierCurve = CubicBezierCurve;\n\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\texports.LineCurve = LineCurve;\n\texports.Shape = Shape;\n\texports.ShapePath = ShapePath;\n\texports.Path = Path;\n\texports.Font = Font;\n\texports.CurvePath = CurvePath;\n\texports.Curve = Curve;\n\texports.ShapeUtils = ShapeUtils;\n\texports.SceneUtils = SceneUtils;\n\texports.CurveUtils = CurveUtils;\n\texports.WireframeGeometry = WireframeGeometry;\n\texports.ParametricGeometry = ParametricGeometry;\n\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\texports.TetrahedronGeometry = TetrahedronGeometry;\n\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\texports.OctahedronGeometry = OctahedronGeometry;\n\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\texports.IcosahedronGeometry = IcosahedronGeometry;\n\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\texports.DodecahedronGeometry = DodecahedronGeometry;\n\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\texports.PolyhedronGeometry = PolyhedronGeometry;\n\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\texports.TubeGeometry = TubeGeometry;\n\texports.TubeBufferGeometry = TubeBufferGeometry;\n\texports.TorusKnotGeometry = TorusKnotGeometry;\n\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\texports.TorusGeometry = TorusGeometry;\n\texports.TorusBufferGeometry = TorusBufferGeometry;\n\texports.TextGeometry = TextGeometry;\n\texports.SphereBufferGeometry = SphereBufferGeometry;\n\texports.SphereGeometry = SphereGeometry;\n\texports.RingGeometry = RingGeometry;\n\texports.RingBufferGeometry = RingBufferGeometry;\n\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\texports.PlaneGeometry = PlaneGeometry;\n\texports.LatheGeometry = LatheGeometry;\n\texports.LatheBufferGeometry = LatheBufferGeometry;\n\texports.ShapeGeometry = ShapeGeometry;\n\texports.ExtrudeGeometry = ExtrudeGeometry;\n\texports.EdgesGeometry = EdgesGeometry;\n\texports.ConeGeometry = ConeGeometry;\n\texports.ConeBufferGeometry = ConeBufferGeometry;\n\texports.CylinderGeometry = CylinderGeometry;\n\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\texports.CircleBufferGeometry = CircleBufferGeometry;\n\texports.CircleGeometry = CircleGeometry;\n\texports.BoxBufferGeometry = BoxBufferGeometry;\n\texports.BoxGeometry = BoxGeometry;\n\texports.ShadowMaterial = ShadowMaterial;\n\texports.SpriteMaterial = SpriteMaterial;\n\texports.RawShaderMaterial = RawShaderMaterial;\n\texports.ShaderMaterial = ShaderMaterial;\n\texports.PointsMaterial = PointsMaterial;\n\texports.MultiMaterial = MultiMaterial;\n\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\texports.MeshStandardMaterial = MeshStandardMaterial;\n\texports.MeshPhongMaterial = MeshPhongMaterial;\n\texports.MeshNormalMaterial = MeshNormalMaterial;\n\texports.MeshLambertMaterial = MeshLambertMaterial;\n\texports.MeshDepthMaterial = MeshDepthMaterial;\n\texports.MeshBasicMaterial = MeshBasicMaterial;\n\texports.LineDashedMaterial = LineDashedMaterial;\n\texports.LineBasicMaterial = LineBasicMaterial;\n\texports.Material = Material;\n\texports.REVISION = REVISION;\n\texports.MOUSE = MOUSE;\n\texports.CullFaceNone = CullFaceNone;\n\texports.CullFaceBack = CullFaceBack;\n\texports.CullFaceFront = CullFaceFront;\n\texports.CullFaceFrontBack = CullFaceFrontBack;\n\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\texports.BasicShadowMap = BasicShadowMap;\n\texports.PCFShadowMap = PCFShadowMap;\n\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\texports.FrontSide = FrontSide;\n\texports.BackSide = BackSide;\n\texports.DoubleSide = DoubleSide;\n\texports.FlatShading = FlatShading;\n\texports.SmoothShading = SmoothShading;\n\texports.NoColors = NoColors;\n\texports.FaceColors = FaceColors;\n\texports.VertexColors = VertexColors;\n\texports.NoBlending = NoBlending;\n\texports.NormalBlending = NormalBlending;\n\texports.AdditiveBlending = AdditiveBlending;\n\texports.SubtractiveBlending = SubtractiveBlending;\n\texports.MultiplyBlending = MultiplyBlending;\n\texports.CustomBlending = CustomBlending;\n\texports.BlendingMode = BlendingMode;\n\texports.AddEquation = AddEquation;\n\texports.SubtractEquation = SubtractEquation;\n\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\texports.MinEquation = MinEquation;\n\texports.MaxEquation = MaxEquation;\n\texports.ZeroFactor = ZeroFactor;\n\texports.OneFactor = OneFactor;\n\texports.SrcColorFactor = SrcColorFactor;\n\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\texports.SrcAlphaFactor = SrcAlphaFactor;\n\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\texports.DstAlphaFactor = DstAlphaFactor;\n\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\texports.DstColorFactor = DstColorFactor;\n\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\texports.NeverDepth = NeverDepth;\n\texports.AlwaysDepth = AlwaysDepth;\n\texports.LessDepth = LessDepth;\n\texports.LessEqualDepth = LessEqualDepth;\n\texports.EqualDepth = EqualDepth;\n\texports.GreaterEqualDepth = GreaterEqualDepth;\n\texports.GreaterDepth = GreaterDepth;\n\texports.NotEqualDepth = NotEqualDepth;\n\texports.MultiplyOperation = MultiplyOperation;\n\texports.MixOperation = MixOperation;\n\texports.AddOperation = AddOperation;\n\texports.NoToneMapping = NoToneMapping;\n\texports.LinearToneMapping = LinearToneMapping;\n\texports.ReinhardToneMapping = ReinhardToneMapping;\n\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\texports.CineonToneMapping = CineonToneMapping;\n\texports.UVMapping = UVMapping;\n\texports.CubeReflectionMapping = CubeReflectionMapping;\n\texports.CubeRefractionMapping = CubeRefractionMapping;\n\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\texports.TextureMapping = TextureMapping;\n\texports.RepeatWrapping = RepeatWrapping;\n\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\texports.TextureWrapping = TextureWrapping;\n\texports.NearestFilter = NearestFilter;\n\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\texports.LinearFilter = LinearFilter;\n\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\texports.TextureFilter = TextureFilter;\n\texports.UnsignedByteType = UnsignedByteType;\n\texports.ByteType = ByteType;\n\texports.ShortType = ShortType;\n\texports.UnsignedShortType = UnsignedShortType;\n\texports.IntType = IntType;\n\texports.UnsignedIntType = UnsignedIntType;\n\texports.FloatType = FloatType;\n\texports.HalfFloatType = HalfFloatType;\n\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\texports.UnsignedShort565Type = UnsignedShort565Type;\n\texports.UnsignedInt248Type = UnsignedInt248Type;\n\texports.AlphaFormat = AlphaFormat;\n\texports.RGBFormat = RGBFormat;\n\texports.RGBAFormat = RGBAFormat;\n\texports.LuminanceFormat = LuminanceFormat;\n\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\texports.RGBEFormat = RGBEFormat;\n\texports.DepthFormat = DepthFormat;\n\texports.DepthStencilFormat = DepthStencilFormat;\n\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\texports.LoopOnce = LoopOnce;\n\texports.LoopRepeat = LoopRepeat;\n\texports.LoopPingPong = LoopPingPong;\n\texports.InterpolateDiscrete = InterpolateDiscrete;\n\texports.InterpolateLinear = InterpolateLinear;\n\texports.InterpolateSmooth = InterpolateSmooth;\n\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\texports.WrapAroundEnding = WrapAroundEnding;\n\texports.TrianglesDrawMode = TrianglesDrawMode;\n\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\texports.LinearEncoding = LinearEncoding;\n\texports.sRGBEncoding = sRGBEncoding;\n\texports.GammaEncoding = GammaEncoding;\n\texports.RGBEEncoding = RGBEEncoding;\n\texports.LogLuvEncoding = LogLuvEncoding;\n\texports.RGBM7Encoding = RGBM7Encoding;\n\texports.RGBM16Encoding = RGBM16Encoding;\n\texports.RGBDEncoding = RGBDEncoding;\n\texports.BasicDepthPacking = BasicDepthPacking;\n\texports.RGBADepthPacking = RGBADepthPacking;\n\texports.CubeGeometry = BoxGeometry;\n\texports.Face4 = Face4;\n\texports.LineStrip = LineStrip;\n\texports.LinePieces = LinePieces;\n\texports.MeshFaceMaterial = MultiMaterial;\n\texports.PointCloud = PointCloud;\n\texports.Particle = Sprite;\n\texports.ParticleSystem = ParticleSystem;\n\texports.PointCloudMaterial = PointCloudMaterial;\n\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\texports.Vertex = Vertex;\n\texports.EdgesHelper = EdgesHelper;\n\texports.WireframeHelper = WireframeHelper;\n\texports.GeometryUtils = GeometryUtils;\n\texports.ImageUtils = ImageUtils;\n\texports.Projector = Projector;\n\texports.CanvasRenderer = CanvasRenderer;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n\tObject.defineProperty( exports, 'AudioContext', {\n\t\tget: function () {\n\t\t\treturn exports.getAudioContext();\n\t\t}\n\t});\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/three/build/three.js\n// module id = 3\n// module chunks = 0","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time > prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\nif ( typeof module === 'object' ) {\n\n\tmodule.exports = Stats;\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/libs/stats.js","module.exports = require('./vendor/dat.gui')\nmodule.exports.color = require('./vendor/dat.color')\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dat-gui/index.js\n// module id = 5\n// module chunks = 0","/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n/** @namespace */\nvar dat = module.exports = dat || {};\n\n/** @namespace */\ndat.gui = dat.gui || {};\n\n/** @namespace */\ndat.utils = dat.utils || {};\n\n/** @namespace */\ndat.controllers = dat.controllers || {};\n\n/** @namespace */\ndat.dom = dat.dom || {};\n\n/** @namespace */\ndat.color = dat.color || {};\n\ndat.utils.css = (function () {\n  return {\n    load: function (url, doc) {\n      doc = doc || document;\n      var link = doc.createElement('link');\n      link.type = 'text/css';\n      link.rel = 'stylesheet';\n      link.href = url;\n      doc.getElementsByTagName('head')[0].appendChild(link);\n    },\n    inject: function(css, doc) {\n      doc = doc || document;\n      var injected = document.createElement('style');\n      injected.type = 'text/css';\n      injected.innerHTML = css;\n      doc.getElementsByTagName('head')[0].appendChild(injected);\n    }\n  }\n})();\n\n\ndat.utils.common = (function () {\n  \n  var ARR_EACH = Array.prototype.forEach;\n  var ARR_SLICE = Array.prototype.slice;\n\n  /**\n   * Band-aid methods for things that should be a lot easier in JavaScript.\n   * Implementation and structure inspired by underscore.js\n   * http://documentcloud.github.com/underscore/\n   */\n\n  return { \n    \n    BREAK: {},\n  \n    extend: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (!this.isUndefined(obj[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n      \n    },\n    \n    defaults: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (this.isUndefined(target[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n    \n    },\n    \n    compose: function() {\n      var toCall = ARR_SLICE.call(arguments);\n            return function() {\n              var args = ARR_SLICE.call(arguments);\n              for (var i = toCall.length -1; i >= 0; i--) {\n                args = [toCall[i].apply(this, args)];\n              }\n              return args[0];\n            }\n    },\n    \n    each: function(obj, itr, scope) {\n\n      \n      if (ARR_EACH && obj.forEach === ARR_EACH) { \n        \n        obj.forEach(itr, scope);\n        \n      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n        \n        for (var key = 0, l = obj.length; key < l; key++)\n          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n            return;\n            \n      } else {\n\n        for (var key in obj) \n          if (itr.call(scope, obj[key], key) === this.BREAK)\n            return;\n            \n      }\n            \n    },\n    \n    defer: function(fnc) {\n      setTimeout(fnc, 0);\n    },\n    \n    toArray: function(obj) {\n      if (obj.toArray) return obj.toArray();\n      return ARR_SLICE.call(obj);\n    },\n\n    isUndefined: function(obj) {\n      return obj === undefined;\n    },\n    \n    isNull: function(obj) {\n      return obj === null;\n    },\n    \n    isNaN: function(obj) {\n      return obj !== obj;\n    },\n    \n    isArray: Array.isArray || function(obj) {\n      return obj.constructor === Array;\n    },\n    \n    isObject: function(obj) {\n      return obj === Object(obj);\n    },\n    \n    isNumber: function(obj) {\n      return obj === obj+0;\n    },\n    \n    isString: function(obj) {\n      return obj === obj+'';\n    },\n    \n    isBoolean: function(obj) {\n      return obj === false || obj === true;\n    },\n    \n    isFunction: function(obj) {\n      return Object.prototype.toString.call(obj) === '[object Function]';\n    }\n  \n  };\n    \n})();\n\n\ndat.controllers.Controller = (function (common) {\n\n  /**\n   * @class An \"abstract\" class that represents a given property of an object.\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var Controller = function(object, property) {\n\n    this.initialValue = object[property];\n\n    /**\n     * Those who extend this class will put their DOM elements in here.\n     * @type {DOMElement}\n     */\n    this.domElement = document.createElement('div');\n\n    /**\n     * The object to manipulate\n     * @type {Object}\n     */\n    this.object = object;\n\n    /**\n     * The name of the property to manipulate\n     * @type {String}\n     */\n    this.property = property;\n\n    /**\n     * The function to be called on change.\n     * @type {Function}\n     * @ignore\n     */\n    this.__onChange = undefined;\n\n    /**\n     * The function to be called on finishing change.\n     * @type {Function}\n     * @ignore\n     */\n    this.__onFinishChange = undefined;\n\n  };\n\n  common.extend(\n\n      Controller.prototype,\n\n      /** @lends dat.controllers.Controller.prototype */\n      {\n\n        /**\n         * Specify that a function fire every time someone changes the value with\n         * this Controller.\n         *\n         * @param {Function} fnc This function will be called whenever the value\n         * is modified via this Controller.\n         * @returns {dat.controllers.Controller} this\n         */\n        onChange: function(fnc) {\n          this.__onChange = fnc;\n          return this;\n        },\n\n        /**\n         * Specify that a function fire every time someone \"finishes\" changing\n         * the value wih this Controller. Useful for values that change\n         * incrementally like numbers or strings.\n         *\n         * @param {Function} fnc This function will be called whenever\n         * someone \"finishes\" changing the value via this Controller.\n         * @returns {dat.controllers.Controller} this\n         */\n        onFinishChange: function(fnc) {\n          this.__onFinishChange = fnc;\n          return this;\n        },\n\n        /**\n         * Change the value of <code>object[property]</code>\n         *\n         * @param {Object} newValue The new value of <code>object[property]</code>\n         */\n        setValue: function(newValue) {\n          this.object[this.property] = newValue;\n          if (this.__onChange) {\n            this.__onChange.call(this, newValue);\n          }\n          this.updateDisplay();\n          return this;\n        },\n\n        /**\n         * Gets the value of <code>object[property]</code>\n         *\n         * @returns {Object} The current value of <code>object[property]</code>\n         */\n        getValue: function() {\n          return this.object[this.property];\n        },\n\n        /**\n         * Refreshes the visual display of a Controller in order to keep sync\n         * with the object's current value.\n         * @returns {dat.controllers.Controller} this\n         */\n        updateDisplay: function() {\n          return this;\n        },\n\n        /**\n         * @returns {Boolean} true if the value has deviated from initialValue\n         */\n        isModified: function() {\n          return this.initialValue !== this.getValue()\n        }\n\n      }\n\n  );\n\n  return Controller;\n\n\n})(dat.utils.common);\n\n\ndat.dom.dom = (function (common) {\n\n  var EVENT_MAP = {\n    'HTMLEvents': ['change'],\n    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],\n    'KeyboardEvents': ['keydown']\n  };\n\n  var EVENT_MAP_INV = {};\n  common.each(EVENT_MAP, function(v, k) {\n    common.each(v, function(e) {\n      EVENT_MAP_INV[e] = k;\n    });\n  });\n\n  var CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\n\n  function cssValueToPixels(val) {\n\n    if (val === '0' || common.isUndefined(val)) return 0;\n\n    var match = val.match(CSS_VALUE_PIXELS);\n\n    if (!common.isNull(match)) {\n      return parseFloat(match[1]);\n    }\n\n    // TODO ...ems? %?\n\n    return 0;\n\n  }\n\n  /**\n   * @namespace\n   * @member dat.dom\n   */\n  var dom = {\n\n    /**\n     * \n     * @param elem\n     * @param selectable\n     */\n    makeSelectable: function(elem, selectable) {\n\n      if (elem === undefined || elem.style === undefined) return;\n\n      elem.onselectstart = selectable ? function() {\n        return false;\n      } : function() {\n      };\n\n      elem.style.MozUserSelect = selectable ? 'auto' : 'none';\n      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\n      elem.unselectable = selectable ? 'on' : 'off';\n\n    },\n\n    /**\n     *\n     * @param elem\n     * @param horizontal\n     * @param vertical\n     */\n    makeFullscreen: function(elem, horizontal, vertical) {\n\n      if (common.isUndefined(horizontal)) horizontal = true;\n      if (common.isUndefined(vertical)) vertical = true;\n\n      elem.style.position = 'absolute';\n\n      if (horizontal) {\n        elem.style.left = 0;\n        elem.style.right = 0;\n      }\n      if (vertical) {\n        elem.style.top = 0;\n        elem.style.bottom = 0;\n      }\n\n    },\n\n    /**\n     *\n     * @param elem\n     * @param eventType\n     * @param params\n     */\n    fakeEvent: function(elem, eventType, params, aux) {\n      params = params || {};\n      var className = EVENT_MAP_INV[eventType];\n      if (!className) {\n        throw new Error('Event type ' + eventType + ' not supported.');\n      }\n      var evt = document.createEvent(className);\n      switch (className) {\n        case 'MouseEvents':\n          var clientX = params.x || params.clientX || 0;\n          var clientY = params.y || params.clientY || 0;\n          evt.initMouseEvent(eventType, params.bubbles || false,\n              params.cancelable || true, window, params.clickCount || 1,\n              0, //screen X\n              0, //screen Y\n              clientX, //client X\n              clientY, //client Y\n              false, false, false, false, 0, null);\n          break;\n        case 'KeyboardEvents':\n          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz\n          common.defaults(params, {\n            cancelable: true,\n            ctrlKey: false,\n            altKey: false,\n            shiftKey: false,\n            metaKey: false,\n            keyCode: undefined,\n            charCode: undefined\n          });\n          init(eventType, params.bubbles || false,\n              params.cancelable, window,\n              params.ctrlKey, params.altKey,\n              params.shiftKey, params.metaKey,\n              params.keyCode, params.charCode);\n          break;\n        default:\n          evt.initEvent(eventType, params.bubbles || false,\n              params.cancelable || true);\n          break;\n      }\n      common.defaults(evt, aux);\n      elem.dispatchEvent(evt);\n    },\n\n    /**\n     *\n     * @param elem\n     * @param event\n     * @param func\n     * @param bool\n     */\n    bind: function(elem, event, func, bool) {\n      bool = bool || false;\n      if (elem.addEventListener)\n        elem.addEventListener(event, func, bool);\n      else if (elem.attachEvent)\n        elem.attachEvent('on' + event, func);\n      return dom;\n    },\n\n    /**\n     *\n     * @param elem\n     * @param event\n     * @param func\n     * @param bool\n     */\n    unbind: function(elem, event, func, bool) {\n      bool = bool || false;\n      if (elem.removeEventListener)\n        elem.removeEventListener(event, func, bool);\n      else if (elem.detachEvent)\n        elem.detachEvent('on' + event, func);\n      return dom;\n    },\n\n    /**\n     *\n     * @param elem\n     * @param className\n     */\n    addClass: function(elem, className) {\n      if (elem.className === undefined) {\n        elem.className = className;\n      } else if (elem.className !== className) {\n        var classes = elem.className.split(/ +/);\n        if (classes.indexOf(className) == -1) {\n          classes.push(className);\n          elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\n        }\n      }\n      return dom;\n    },\n\n    /**\n     *\n     * @param elem\n     * @param className\n     */\n    removeClass: function(elem, className) {\n      if (className) {\n        if (elem.className === undefined) {\n          // elem.className = className;\n        } else if (elem.className === className) {\n          elem.removeAttribute('class');\n        } else {\n          var classes = elem.className.split(/ +/);\n          var index = classes.indexOf(className);\n          if (index != -1) {\n            classes.splice(index, 1);\n            elem.className = classes.join(' ');\n          }\n        }\n      } else {\n        elem.className = undefined;\n      }\n      return dom;\n    },\n\n    hasClass: function(elem, className) {\n      return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\n    },\n\n    /**\n     *\n     * @param elem\n     */\n    getWidth: function(elem) {\n\n      var style = getComputedStyle(elem);\n\n      return cssValueToPixels(style['border-left-width']) +\n          cssValueToPixels(style['border-right-width']) +\n          cssValueToPixels(style['padding-left']) +\n          cssValueToPixels(style['padding-right']) +\n          cssValueToPixels(style['width']);\n    },\n\n    /**\n     *\n     * @param elem\n     */\n    getHeight: function(elem) {\n\n      var style = getComputedStyle(elem);\n\n      return cssValueToPixels(style['border-top-width']) +\n          cssValueToPixels(style['border-bottom-width']) +\n          cssValueToPixels(style['padding-top']) +\n          cssValueToPixels(style['padding-bottom']) +\n          cssValueToPixels(style['height']);\n    },\n\n    /**\n     *\n     * @param elem\n     */\n    getOffset: function(elem) {\n      var offset = {left: 0, top:0};\n      if (elem.offsetParent) {\n        do {\n          offset.left += elem.offsetLeft;\n          offset.top += elem.offsetTop;\n        } while (elem = elem.offsetParent);\n      }\n      return offset;\n    },\n\n    // http://stackoverflow.com/posts/2684561/revisions\n    /**\n     * \n     * @param elem\n     */\n    isActive: function(elem) {\n      return elem === document.activeElement && ( elem.type || elem.href );\n    }\n\n  };\n\n  return dom;\n\n})(dat.utils.common);\n\n\ndat.controllers.OptionController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a select input to alter the property of an object, using a\n   * list of accepted values.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Object|string[]} options A map of labels to acceptable values, or\n   * a list of acceptable string values.\n   *\n   * @member dat.controllers\n   */\n  var OptionController = function(object, property, options) {\n\n    OptionController.superclass.call(this, object, property);\n\n    var _this = this;\n\n    /**\n     * The drop down menu\n     * @ignore\n     */\n    this.__select = document.createElement('select');\n\n    if (common.isArray(options)) {\n      var map = {};\n      common.each(options, function(element) {\n        map[element] = element;\n      });\n      options = map;\n    }\n\n    common.each(options, function(value, key) {\n\n      var opt = document.createElement('option');\n      opt.innerHTML = key;\n      opt.setAttribute('value', value);\n      _this.__select.appendChild(opt);\n\n    });\n\n    // Acknowledge original value\n    this.updateDisplay();\n\n    dom.bind(this.__select, 'change', function() {\n      var desiredValue = this.options[this.selectedIndex].value;\n      _this.setValue(desiredValue);\n    });\n\n    this.domElement.appendChild(this.__select);\n\n  };\n\n  OptionController.superclass = Controller;\n\n  common.extend(\n\n      OptionController.prototype,\n      Controller.prototype,\n\n      {\n\n        setValue: function(v) {\n          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);\n          if (this.__onFinishChange) {\n            this.__onFinishChange.call(this, this.getValue());\n          }\n          return toReturn;\n        },\n\n        updateDisplay: function() {\n          this.__select.value = this.getValue();\n          return OptionController.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n  );\n\n  return OptionController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.controllers.NumberController = (function (Controller, common) {\n\n  /**\n   * @class Represents a given property of an object that is a number.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Object} [params] Optional parameters\n   * @param {Number} [params.min] Minimum allowed value\n   * @param {Number} [params.max] Maximum allowed value\n   * @param {Number} [params.step] Increment by which to change value\n   *\n   * @member dat.controllers\n   */\n  var NumberController = function(object, property, params) {\n\n    NumberController.superclass.call(this, object, property);\n\n    params = params || {};\n\n    this.__min = params.min;\n    this.__max = params.max;\n    this.__step = params.step;\n\n    if (common.isUndefined(this.__step)) {\n\n      if (this.initialValue == 0) {\n        this.__impliedStep = 1; // What are we, psychics?\n      } else {\n        // Hey Doug, check this out.\n        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;\n      }\n\n    } else {\n\n      this.__impliedStep = this.__step;\n\n    }\n\n    this.__precision = numDecimals(this.__impliedStep);\n\n\n  };\n\n  NumberController.superclass = Controller;\n\n  common.extend(\n\n      NumberController.prototype,\n      Controller.prototype,\n\n      /** @lends dat.controllers.NumberController.prototype */\n      {\n\n        setValue: function(v) {\n\n          if (this.__min !== undefined && v < this.__min) {\n            v = this.__min;\n          } else if (this.__max !== undefined && v > this.__max) {\n            v = this.__max;\n          }\n\n          if (this.__step !== undefined && v % this.__step != 0) {\n            v = Math.round(v / this.__step) * this.__step;\n          }\n\n          return NumberController.superclass.prototype.setValue.call(this, v);\n\n        },\n\n        /**\n         * Specify a minimum value for <code>object[property]</code>.\n         *\n         * @param {Number} minValue The minimum value for\n         * <code>object[property]</code>\n         * @returns {dat.controllers.NumberController} this\n         */\n        min: function(v) {\n          this.__min = v;\n          return this;\n        },\n\n        /**\n         * Specify a maximum value for <code>object[property]</code>.\n         *\n         * @param {Number} maxValue The maximum value for\n         * <code>object[property]</code>\n         * @returns {dat.controllers.NumberController} this\n         */\n        max: function(v) {\n          this.__max = v;\n          return this;\n        },\n\n        /**\n         * Specify a step value that dat.controllers.NumberController\n         * increments by.\n         *\n         * @param {Number} stepValue The step value for\n         * dat.controllers.NumberController\n         * @default if minimum and maximum specified increment is 1% of the\n         * difference otherwise stepValue is 1\n         * @returns {dat.controllers.NumberController} this\n         */\n        step: function(v) {\n          this.__step = v;\n          return this;\n        }\n\n      }\n\n  );\n\n  function numDecimals(x) {\n    x = x.toString();\n    if (x.indexOf('.') > -1) {\n      return x.length - x.indexOf('.') - 1;\n    } else {\n      return 0;\n    }\n  }\n\n  return NumberController;\n\n})(dat.controllers.Controller,\ndat.utils.common);\n\n\ndat.controllers.NumberControllerBox = (function (NumberController, dom, common) {\n\n  /**\n   * @class Represents a given property of an object that is a number and\n   * provides an input element with which to manipulate it.\n   *\n   * @extends dat.controllers.Controller\n   * @extends dat.controllers.NumberController\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Object} [params] Optional parameters\n   * @param {Number} [params.min] Minimum allowed value\n   * @param {Number} [params.max] Maximum allowed value\n   * @param {Number} [params.step] Increment by which to change value\n   *\n   * @member dat.controllers\n   */\n  var NumberControllerBox = function(object, property, params) {\n\n    this.__truncationSuspended = false;\n\n    NumberControllerBox.superclass.call(this, object, property, params);\n\n    var _this = this;\n\n    /**\n     * {Number} Previous mouse y position\n     * @ignore\n     */\n    var prev_y;\n\n    this.__input = document.createElement('input');\n    this.__input.setAttribute('type', 'text');\n\n    // Makes it so manually specified values are not truncated.\n\n    dom.bind(this.__input, 'change', onChange);\n    dom.bind(this.__input, 'blur', onBlur);\n    dom.bind(this.__input, 'mousedown', onMouseDown);\n    dom.bind(this.__input, 'keydown', function(e) {\n\n      // When pressing entire, you can be as precise as you want.\n      if (e.keyCode === 13) {\n        _this.__truncationSuspended = true;\n        this.blur();\n        _this.__truncationSuspended = false;\n      }\n\n    });\n\n    function onChange() {\n      var attempted = parseFloat(_this.__input.value);\n      if (!common.isNaN(attempted)) _this.setValue(attempted);\n    }\n\n    function onBlur() {\n      onChange();\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n\n    function onMouseDown(e) {\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n      prev_y = e.clientY;\n    }\n\n    function onMouseDrag(e) {\n\n      var diff = prev_y - e.clientY;\n      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\n\n      prev_y = e.clientY;\n\n    }\n\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n    }\n\n    this.updateDisplay();\n\n    this.domElement.appendChild(this.__input);\n\n  };\n\n  NumberControllerBox.superclass = NumberController;\n\n  common.extend(\n\n      NumberControllerBox.prototype,\n      NumberController.prototype,\n\n      {\n\n        updateDisplay: function() {\n\n          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\n          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n  );\n\n  function roundToDecimal(value, decimals) {\n    var tenTo = Math.pow(10, decimals);\n    return Math.round(value * tenTo) / tenTo;\n  }\n\n  return NumberControllerBox;\n\n})(dat.controllers.NumberController,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {\n\n  /**\n   * @class Represents a given property of an object that is a number, contains\n   * a minimum and maximum, and provides a slider element with which to\n   * manipulate it. It should be noted that the slider element is made up of\n   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5\n   * <code>&lt;slider&gt;</code> element.\n   *\n   * @extends dat.controllers.Controller\n   * @extends dat.controllers.NumberController\n   * \n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Number} minValue Minimum allowed value\n   * @param {Number} maxValue Maximum allowed value\n   * @param {Number} stepValue Increment by which to change value\n   *\n   * @member dat.controllers\n   */\n  var NumberControllerSlider = function(object, property, min, max, step) {\n\n    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });\n\n    var _this = this;\n\n    this.__background = document.createElement('div');\n    this.__foreground = document.createElement('div');\n    \n\n\n    dom.bind(this.__background, 'mousedown', onMouseDown);\n    \n    dom.addClass(this.__background, 'slider');\n    dom.addClass(this.__foreground, 'slider-fg');\n\n    function onMouseDown(e) {\n\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n\n      onMouseDrag(e);\n    }\n\n    function onMouseDrag(e) {\n\n      e.preventDefault();\n\n      var offset = dom.getOffset(_this.__background);\n      var width = dom.getWidth(_this.__background);\n      \n      _this.setValue(\n        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)\n      );\n\n      return false;\n\n    }\n\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n\n    this.updateDisplay();\n\n    this.__background.appendChild(this.__foreground);\n    this.domElement.appendChild(this.__background);\n\n  };\n\n  NumberControllerSlider.superclass = NumberController;\n\n  /**\n   * Injects default stylesheet for slider elements.\n   */\n  NumberControllerSlider.useDefaultStyles = function() {\n    css.inject(styleSheet);\n  };\n\n  common.extend(\n\n      NumberControllerSlider.prototype,\n      NumberController.prototype,\n\n      {\n\n        updateDisplay: function() {\n          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);\n          this.__foreground.style.width = pct*100+'%';\n          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n\n\n  );\n\n  function map(v, i1, i2, o1, o2) {\n    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\n  }\n\n  return NumberControllerSlider;\n  \n})(dat.controllers.NumberController,\ndat.dom.dom,\ndat.utils.css,\ndat.utils.common,\n\".slider {\\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\\n  height: 1em;\\n  border-radius: 1em;\\n  background-color: #eee;\\n  padding: 0 0.5em;\\n  overflow: hidden;\\n}\\n\\n.slider-fg {\\n  padding: 1px 0 2px 0;\\n  background-color: #aaa;\\n  height: 1em;\\n  margin-left: -0.5em;\\n  padding-right: 0.5em;\\n  border-radius: 1em 0 0 1em;\\n}\\n\\n.slider-fg:after {\\n  display: inline-block;\\n  border-radius: 1em;\\n  background-color: #fff;\\n  border:  1px solid #aaa;\\n  content: '';\\n  float: right;\\n  margin-right: -1em;\\n  margin-top: -1px;\\n  height: 0.9em;\\n  width: 0.9em;\\n}\");\n\n\ndat.controllers.FunctionController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a GUI interface to fire a specified method, a property of an object.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var FunctionController = function(object, property, text) {\n\n    FunctionController.superclass.call(this, object, property);\n\n    var _this = this;\n\n    this.__button = document.createElement('div');\n    this.__button.innerHTML = text === undefined ? 'Fire' : text;\n    dom.bind(this.__button, 'click', function(e) {\n      e.preventDefault();\n      _this.fire();\n      return false;\n    });\n\n    dom.addClass(this.__button, 'button');\n\n    this.domElement.appendChild(this.__button);\n\n\n  };\n\n  FunctionController.superclass = Controller;\n\n  common.extend(\n\n      FunctionController.prototype,\n      Controller.prototype,\n      {\n        \n        fire: function() {\n          if (this.__onChange) {\n            this.__onChange.call(this);\n          }\n          if (this.__onFinishChange) {\n            this.__onFinishChange.call(this, this.getValue());\n          }\n          this.getValue().call(this.object);\n        }\n      }\n\n  );\n\n  return FunctionController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.controllers.BooleanController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a checkbox input to alter the boolean property of an object.\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var BooleanController = function(object, property) {\n\n    BooleanController.superclass.call(this, object, property);\n\n    var _this = this;\n    this.__prev = this.getValue();\n\n    this.__checkbox = document.createElement('input');\n    this.__checkbox.setAttribute('type', 'checkbox');\n\n\n    dom.bind(this.__checkbox, 'change', onChange, false);\n\n    this.domElement.appendChild(this.__checkbox);\n\n    // Match original value\n    this.updateDisplay();\n\n    function onChange() {\n      _this.setValue(!_this.__prev);\n    }\n\n  };\n\n  BooleanController.superclass = Controller;\n\n  common.extend(\n\n      BooleanController.prototype,\n      Controller.prototype,\n\n      {\n\n        setValue: function(v) {\n          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);\n          if (this.__onFinishChange) {\n            this.__onFinishChange.call(this, this.getValue());\n          }\n          this.__prev = this.getValue();\n          return toReturn;\n        },\n\n        updateDisplay: function() {\n          \n          if (this.getValue() === true) {\n            this.__checkbox.setAttribute('checked', 'checked');\n            this.__checkbox.checked = true;    \n          } else {\n              this.__checkbox.checked = false;\n          }\n\n          return BooleanController.superclass.prototype.updateDisplay.call(this);\n\n        }\n\n\n      }\n\n  );\n\n  return BooleanController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.color.toString = (function (common) {\n\n  return function(color) {\n\n    if (color.a == 1 || common.isUndefined(color.a)) {\n\n      var s = color.hex.toString(16);\n      while (s.length < 6) {\n        s = '0' + s;\n      }\n\n      return '#' + s;\n\n    } else {\n\n      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\n    }\n\n  }\n\n})(dat.utils.common);\n\n\ndat.color.interpret = (function (toString, common) {\n\n  var result, toReturn;\n\n  var interpret = function() {\n\n    toReturn = false;\n\n    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\n    common.each(INTERPRETATIONS, function(family) {\n\n      if (family.litmus(original)) {\n\n        common.each(family.conversions, function(conversion, conversionName) {\n\n          result = conversion.read(original);\n\n          if (toReturn === false && result !== false) {\n            toReturn = result;\n            result.conversionName = conversionName;\n            result.conversion = conversion;\n            return common.BREAK;\n\n          }\n\n        });\n\n        return common.BREAK;\n\n      }\n\n    });\n\n    return toReturn;\n\n  };\n\n  var INTERPRETATIONS = [\n\n    // Strings\n    {\n\n      litmus: common.isString,\n\n      conversions: {\n\n        THREE_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt(\n                  '0x' +\n                      test[1].toString() + test[1].toString() +\n                      test[2].toString() + test[2].toString() +\n                      test[3].toString() + test[3].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        SIX_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9]{6})$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt('0x' + test[1].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGB: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3])\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGBA: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3]),\n              a: parseFloat(test[4])\n            };\n\n          },\n\n          write: toString\n\n        }\n\n      }\n\n    },\n\n    // Numbers\n    {\n\n      litmus: common.isNumber,\n\n      conversions: {\n\n        HEX: {\n          read: function(original) {\n            return {\n              space: 'HEX',\n              hex: original,\n              conversionName: 'HEX'\n            }\n          },\n\n          write: function(color) {\n            return color.hex;\n          }\n        }\n\n      }\n\n    },\n\n    // Arrays\n    {\n\n      litmus: common.isArray,\n\n      conversions: {\n\n        RGB_ARRAY: {\n          read: function(original) {\n            if (original.length != 3) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b];\n          }\n\n        },\n\n        RGBA_ARRAY: {\n          read: function(original) {\n            if (original.length != 4) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2],\n              a: original[3]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b, color.a];\n          }\n\n        }\n\n      }\n\n    },\n\n    // Objects\n    {\n\n      litmus: common.isObject,\n\n      conversions: {\n\n        RGBA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: color.a\n            }\n          }\n        },\n\n        RGB_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b\n            }\n          }\n        },\n\n        HSVA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v,\n              a: color.a\n            }\n          }\n        },\n\n        HSV_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v\n            }\n          }\n\n        }\n\n      }\n\n    }\n\n\n  ];\n\n  return interpret;\n\n\n})(dat.color.toString,\ndat.utils.common);\n\n\ndat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {\n\n  css.inject(styleSheet);\n\n  /** Outer-most className for GUI's */\n  var CSS_NAMESPACE = 'dg';\n\n  var HIDE_KEY_CODE = 72;\n\n  /** The only value shared between the JS and SCSS. Use caution. */\n  var CLOSE_BUTTON_HEIGHT = 20;\n\n  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';\n\n  var SUPPORTS_LOCAL_STORAGE = (function() {\n    try {\n      return 'localStorage' in window && window['localStorage'] !== null;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  var SAVE_DIALOGUE;\n\n  /** Have we yet to create an autoPlace GUI? */\n  var auto_place_virgin = true;\n\n  /** Fixed position div that auto place GUI's go inside */\n  var auto_place_container;\n\n  /** Are we hiding the GUI's ? */\n  var hide = false;\n\n  /** GUI's which should be hidden */\n  var hideable_guis = [];\n\n  /**\n   * A lightweight controller library for JavaScript. It allows you to easily\n   * manipulate variables and fire functions on the fly.\n   * @class\n   *\n   * @member dat.gui\n   *\n   * @param {Object} [params]\n   * @param {String} [params.name] The name of this GUI.\n   * @param {Object} [params.load] JSON object representing the saved state of\n   * this GUI.\n   * @param {Boolean} [params.auto=true]\n   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.\n   * @param {Boolean} [params.closed] If true, starts closed\n   */\n  var GUI = function(params) {\n\n    var _this = this;\n\n    /**\n     * Outermost DOM Element\n     * @type DOMElement\n     */\n    this.domElement = document.createElement('div');\n    this.__ul = document.createElement('ul');\n    this.domElement.appendChild(this.__ul);\n\n    dom.addClass(this.domElement, CSS_NAMESPACE);\n\n    /**\n     * Nested GUI's by name\n     * @ignore\n     */\n    this.__folders = {};\n\n    this.__controllers = [];\n\n    /**\n     * List of objects I'm remembering for save, only used in top level GUI\n     * @ignore\n     */\n    this.__rememberedObjects = [];\n\n    /**\n     * Maps the index of remembered objects to a map of controllers, only used\n     * in top level GUI.\n     *\n     * @private\n     * @ignore\n     *\n     * @example\n     * [\n     *  {\n     *    propertyName: Controller,\n     *    anotherPropertyName: Controller\n     *  },\n     *  {\n     *    propertyName: Controller\n     *  }\n     * ]\n     */\n    this.__rememberedObjectIndecesToControllers = [];\n\n    this.__listening = [];\n\n    params = params || {};\n\n    // Default parameters\n    params = common.defaults(params, {\n      autoPlace: true,\n      width: GUI.DEFAULT_WIDTH\n    });\n\n    params = common.defaults(params, {\n      resizable: params.autoPlace,\n      hideable: params.autoPlace\n    });\n\n\n    if (!common.isUndefined(params.load)) {\n\n      // Explicit preset\n      if (params.preset) params.load.preset = params.preset;\n\n    } else {\n\n      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\n\n    }\n\n    if (common.isUndefined(params.parent) && params.hideable) {\n      hideable_guis.push(this);\n    }\n\n    // Only root level GUI's are resizable.\n    params.resizable = common.isUndefined(params.parent) && params.resizable;\n\n\n    if (params.autoPlace && common.isUndefined(params.scrollable)) {\n      params.scrollable = true;\n    }\n//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;\n\n    // Not part of params because I don't want people passing this in via\n    // constructor. Should be a 'remembered' value.\n    var use_local_storage =\n        SUPPORTS_LOCAL_STORAGE &&\n            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\n\n    Object.defineProperties(this,\n\n        /** @lends dat.gui.GUI.prototype */\n        {\n\n          /**\n           * The parent <code>GUI</code>\n           * @type dat.gui.GUI\n           */\n          parent: {\n            get: function() {\n              return params.parent;\n            }\n          },\n\n          scrollable: {\n            get: function() {\n              return params.scrollable;\n            }\n          },\n\n          /**\n           * Handles <code>GUI</code>'s element placement for you\n           * @type Boolean\n           */\n          autoPlace: {\n            get: function() {\n              return params.autoPlace;\n            }\n          },\n\n          /**\n           * The identifier for a set of saved values\n           * @type String\n           */\n          preset: {\n\n            get: function() {\n              if (_this.parent) {\n                return _this.getRoot().preset;\n              } else {\n                return params.load.preset;\n              }\n            },\n\n            set: function(v) {\n              if (_this.parent) {\n                _this.getRoot().preset = v;\n              } else {\n                params.load.preset = v;\n              }\n              setPresetSelectIndex(this);\n              _this.revert();\n            }\n\n          },\n\n          /**\n           * The width of <code>GUI</code> element\n           * @type Number\n           */\n          width: {\n            get: function() {\n              return params.width;\n            },\n            set: function(v) {\n              params.width = v;\n              setWidth(_this, v);\n            }\n          },\n\n          /**\n           * The name of <code>GUI</code>. Used for folders. i.e\n           * a folder's name\n           * @type String\n           */\n          name: {\n            get: function() {\n              return params.name;\n            },\n            set: function(v) {\n              // TODO Check for collisions among sibling folders\n              params.name = v;\n              if (title_row_name) {\n                title_row_name.innerHTML = params.name;\n              }\n            }\n          },\n\n          /**\n           * Whether the <code>GUI</code> is collapsed or not\n           * @type Boolean\n           */\n          closed: {\n            get: function() {\n              return params.closed;\n            },\n            set: function(v) {\n              params.closed = v;\n              if (params.closed) {\n                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\n              } else {\n                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\n              }\n              // For browsers that aren't going to respect the CSS transition,\n              // Lets just check our height against the window height right off\n              // the bat.\n              this.onResize();\n\n              if (_this.__closeButton) {\n                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\n              }\n            }\n          },\n\n          /**\n           * Contains all presets\n           * @type Object\n           */\n          load: {\n            get: function() {\n              return params.load;\n            }\n          },\n\n          /**\n           * Determines whether or not to use <a href=\"https://developer.mozilla.org/en/DOM/Storage#localStorage\">localStorage</a> as the means for\n           * <code>remember</code>ing\n           * @type Boolean\n           */\n          useLocalStorage: {\n\n            get: function() {\n              return use_local_storage;\n            },\n            set: function(bool) {\n              if (SUPPORTS_LOCAL_STORAGE) {\n                use_local_storage = bool;\n                if (bool) {\n                  dom.bind(window, 'unload', saveToLocalStorage);\n                } else {\n                  dom.unbind(window, 'unload', saveToLocalStorage);\n                }\n                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\n              }\n            }\n\n          }\n\n        });\n\n    // Are we a root level GUI?\n    if (common.isUndefined(params.parent)) {\n\n      params.closed = false;\n\n      dom.addClass(this.domElement, GUI.CLASS_MAIN);\n      dom.makeSelectable(this.domElement, false);\n\n      // Are we supposed to be loading locally?\n      if (SUPPORTS_LOCAL_STORAGE) {\n\n        if (use_local_storage) {\n\n          _this.useLocalStorage = true;\n\n          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\n\n          if (saved_gui) {\n            params.load = JSON.parse(saved_gui);\n          }\n\n        }\n\n      }\n\n      this.__closeButton = document.createElement('div');\n      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\n      this.domElement.appendChild(this.__closeButton);\n\n      dom.bind(this.__closeButton, 'click', function() {\n\n        _this.closed = !_this.closed;\n\n\n      });\n\n\n      // Oh, you're a nested GUI!\n    } else {\n\n      if (params.closed === undefined) {\n        params.closed = true;\n      }\n\n      var title_row_name = document.createTextNode(params.name);\n      dom.addClass(title_row_name, 'controller-name');\n\n      var title_row = addRow(_this, title_row_name);\n\n      var on_click_title = function(e) {\n        e.preventDefault();\n        _this.closed = !_this.closed;\n        return false;\n      };\n\n      dom.addClass(this.__ul, GUI.CLASS_CLOSED);\n\n      dom.addClass(title_row, 'title');\n      dom.bind(title_row, 'click', on_click_title);\n\n      if (!params.closed) {\n        this.closed = false;\n      }\n\n    }\n\n    if (params.autoPlace) {\n\n      if (common.isUndefined(params.parent)) {\n\n        if (auto_place_virgin) {\n          auto_place_container = document.createElement('div');\n          dom.addClass(auto_place_container, CSS_NAMESPACE);\n          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);\n          document.body.appendChild(auto_place_container);\n          auto_place_virgin = false;\n        }\n\n        // Put it in the dom for you.\n        auto_place_container.appendChild(this.domElement);\n\n        // Apply the auto styles\n        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\n\n      }\n\n\n      // Make it not elastic.\n      if (!this.parent) setWidth(_this, params.width);\n\n    }\n\n    dom.bind(window, 'resize', function() { _this.onResize() });\n    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });\n    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });\n    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });\n    this.onResize();\n\n\n    if (params.resizable) {\n      addResizeHandle(this);\n    }\n\n    function saveToLocalStorage() {\n      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\n    }\n\n    var root = _this.getRoot();\n    function resetWidth() {\n        var root = _this.getRoot();\n        root.width += 1;\n        common.defer(function() {\n          root.width -= 1;\n        });\n      }\n\n      if (!params.parent) {\n        resetWidth();\n      }\n\n  };\n\n  GUI.toggleHide = function() {\n\n    hide = !hide;\n    common.each(hideable_guis, function(gui) {\n      gui.domElement.style.zIndex = hide ? -999 : 999;\n      gui.domElement.style.opacity = hide ? 0 : 1;\n    });\n  };\n\n  GUI.CLASS_AUTO_PLACE = 'a';\n  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\n  GUI.CLASS_MAIN = 'main';\n  GUI.CLASS_CONTROLLER_ROW = 'cr';\n  GUI.CLASS_TOO_TALL = 'taller-than-window';\n  GUI.CLASS_CLOSED = 'closed';\n  GUI.CLASS_CLOSE_BUTTON = 'close-button';\n  GUI.CLASS_DRAG = 'drag';\n\n  GUI.DEFAULT_WIDTH = 245;\n  GUI.TEXT_CLOSED = 'Close Controls';\n  GUI.TEXT_OPEN = 'Open Controls';\n\n  dom.bind(window, 'keydown', function(e) {\n\n    if (document.activeElement.type !== 'text' &&\n        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {\n      GUI.toggleHide();\n    }\n\n  }, false);\n\n  common.extend(\n\n      GUI.prototype,\n\n      /** @lends dat.gui.GUI */\n      {\n\n        /**\n         * @param object\n         * @param property\n         * @returns {dat.controllers.Controller} The new controller that was added.\n         * @instance\n         */\n        add: function(object, property) {\n\n          return add(\n              this,\n              object,\n              property,\n              {\n                factoryArgs: Array.prototype.slice.call(arguments, 2)\n              }\n          );\n\n        },\n\n        /**\n         * @param object\n         * @param property\n         * @returns {dat.controllers.ColorController} The new controller that was added.\n         * @instance\n         */\n        addColor: function(object, property) {\n\n          return add(\n              this,\n              object,\n              property,\n              {\n                color: true\n              }\n          );\n\n        },\n\n        /**\n         * @param controller\n         * @instance\n         */\n        remove: function(controller) {\n\n          // TODO listening?\n          this.__ul.removeChild(controller.__li);\n          this.__controllers.slice(this.__controllers.indexOf(controller), 1);\n          var _this = this;\n          common.defer(function() {\n            _this.onResize();\n          });\n\n        },\n\n        destroy: function() {\n\n          if (this.autoPlace) {\n            auto_place_container.removeChild(this.domElement);\n          }\n\n        },\n\n        /**\n         * @param name\n         * @returns {dat.gui.GUI} The new folder.\n         * @throws {Error} if this GUI already has a folder by the specified\n         * name\n         * @instance\n         */\n        addFolder: function(name) {\n\n          // We have to prevent collisions on names in order to have a key\n          // by which to remember saved values\n          if (this.__folders[name] !== undefined) {\n            throw new Error('You already have a folder in this GUI by the' +\n                ' name \"' + name + '\"');\n          }\n\n          var new_gui_params = { name: name, parent: this };\n\n          // We need to pass down the autoPlace trait so that we can\n          // attach event listeners to open/close folder actions to\n          // ensure that a scrollbar appears if the window is too short.\n          new_gui_params.autoPlace = this.autoPlace;\n\n          // Do we have saved appearance data for this folder?\n\n          if (this.load && // Anything loaded?\n              this.load.folders && // Was my parent a dead-end?\n              this.load.folders[name]) { // Did daddy remember me?\n\n            // Start me closed if I was closed\n            new_gui_params.closed = this.load.folders[name].closed;\n\n            // Pass down the loaded data\n            new_gui_params.load = this.load.folders[name];\n\n          }\n\n          var gui = new GUI(new_gui_params);\n          this.__folders[name] = gui;\n\n          var li = addRow(this, gui.domElement);\n          dom.addClass(li, 'folder');\n          return gui;\n\n        },\n\n        open: function() {\n          this.closed = false;\n        },\n\n        close: function() {\n          this.closed = true;\n        },\n\n        onResize: function() {\n\n          var root = this.getRoot();\n\n          if (root.scrollable) {\n\n            var top = dom.getOffset(root.__ul).top;\n            var h = 0;\n\n            common.each(root.__ul.childNodes, function(node) {\n              if (! (root.autoPlace && node === root.__save_row))\n                h += dom.getHeight(node);\n            });\n\n            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\n              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\n              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\n            } else {\n              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\n              root.__ul.style.height = 'auto';\n            }\n\n          }\n\n          if (root.__resize_handle) {\n            common.defer(function() {\n              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\n            });\n          }\n\n          if (root.__closeButton) {\n            root.__closeButton.style.width = root.width + 'px';\n          }\n\n        },\n\n        /**\n         * Mark objects for saving. The order of these objects cannot change as\n         * the GUI grows. When remembering new objects, append them to the end\n         * of the list.\n         *\n         * @param {Object...} objects\n         * @throws {Error} if not called on a top level GUI.\n         * @instance\n         */\n        remember: function() {\n\n          if (common.isUndefined(SAVE_DIALOGUE)) {\n            SAVE_DIALOGUE = new CenteredDiv();\n            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;\n          }\n\n          if (this.parent) {\n            throw new Error(\"You can only call remember on a top level GUI.\");\n          }\n\n          var _this = this;\n\n          common.each(Array.prototype.slice.call(arguments), function(object) {\n            if (_this.__rememberedObjects.length == 0) {\n              addSaveMenu(_this);\n            }\n            if (_this.__rememberedObjects.indexOf(object) == -1) {\n              _this.__rememberedObjects.push(object);\n            }\n          });\n\n          if (this.autoPlace) {\n            // Set save row width\n            setWidth(this, this.width);\n          }\n\n        },\n\n        /**\n         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.\n         * @instance\n         */\n        getRoot: function() {\n          var gui = this;\n          while (gui.parent) {\n            gui = gui.parent;\n          }\n          return gui;\n        },\n\n        /**\n         * @returns {Object} a JSON object representing the current state of\n         * this GUI as well as its remembered properties.\n         * @instance\n         */\n        getSaveObject: function() {\n\n          var toReturn = this.load;\n\n          toReturn.closed = this.closed;\n\n          // Am I remembering any values?\n          if (this.__rememberedObjects.length > 0) {\n\n            toReturn.preset = this.preset;\n\n            if (!toReturn.remembered) {\n              toReturn.remembered = {};\n            }\n\n            toReturn.remembered[this.preset] = getCurrentPreset(this);\n\n          }\n\n          toReturn.folders = {};\n          common.each(this.__folders, function(element, key) {\n            toReturn.folders[key] = element.getSaveObject();\n          });\n\n          return toReturn;\n\n        },\n\n        save: function() {\n\n          if (!this.load.remembered) {\n            this.load.remembered = {};\n          }\n\n          this.load.remembered[this.preset] = getCurrentPreset(this);\n          markPresetModified(this, false);\n\n        },\n\n        saveAs: function(presetName) {\n\n          if (!this.load.remembered) {\n\n            // Retain default values upon first save\n            this.load.remembered = {};\n            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\n\n          }\n\n          this.load.remembered[presetName] = getCurrentPreset(this);\n          this.preset = presetName;\n          addPresetOption(this, presetName, true);\n\n        },\n\n        revert: function(gui) {\n\n          common.each(this.__controllers, function(controller) {\n            // Make revert work on Default.\n            if (!this.getRoot().load.remembered) {\n              controller.setValue(controller.initialValue);\n            } else {\n              recallSavedValue(gui || this.getRoot(), controller);\n            }\n          }, this);\n\n          common.each(this.__folders, function(folder) {\n            folder.revert(folder);\n          });\n\n          if (!gui) {\n            markPresetModified(this.getRoot(), false);\n          }\n\n\n        },\n\n        listen: function(controller) {\n\n          var init = this.__listening.length == 0;\n          this.__listening.push(controller);\n          if (init) updateDisplays(this.__listening);\n\n        }\n\n      }\n\n  );\n\n  function add(gui, object, property, params) {\n\n    if (object[property] === undefined) {\n      throw new Error(\"Object \" + object + \" has no property \\\"\" + property + \"\\\"\");\n    }\n\n    var controller;\n\n    if (params.color) {\n\n      controller = new ColorController(object, property);\n\n    } else {\n\n      var factoryArgs = [object,property].concat(params.factoryArgs);\n      controller = controllerFactory.apply(gui, factoryArgs);\n\n    }\n\n    if (params.before instanceof Controller) {\n      params.before = params.before.__li;\n    }\n\n    recallSavedValue(gui, controller);\n\n    dom.addClass(controller.domElement, 'c');\n\n    var name = document.createElement('span');\n    dom.addClass(name, 'property-name');\n    name.innerHTML = controller.property;\n\n    var container = document.createElement('div');\n    container.appendChild(name);\n    container.appendChild(controller.domElement);\n\n    var li = addRow(gui, container, params.before);\n\n    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\n    dom.addClass(li, typeof controller.getValue());\n\n    augmentController(gui, li, controller);\n\n    gui.__controllers.push(controller);\n\n    return controller;\n\n  }\n\n  /**\n   * Add a row to the end of the GUI or before another row.\n   *\n   * @param gui\n   * @param [dom] If specified, inserts the dom content in the new row\n   * @param [liBefore] If specified, places the new row before another row\n   */\n  function addRow(gui, dom, liBefore) {\n    var li = document.createElement('li');\n    if (dom) li.appendChild(dom);\n    if (liBefore) {\n      gui.__ul.insertBefore(li, params.before);\n    } else {\n      gui.__ul.appendChild(li);\n    }\n    gui.onResize();\n    return li;\n  }\n\n  function augmentController(gui, li, controller) {\n\n    controller.__li = li;\n    controller.__gui = gui;\n\n    common.extend(controller, {\n\n      options: function(options) {\n\n        if (arguments.length > 1) {\n          controller.remove();\n\n          return add(\n              gui,\n              controller.object,\n              controller.property,\n              {\n                before: controller.__li.nextElementSibling,\n                factoryArgs: [common.toArray(arguments)]\n              }\n          );\n\n        }\n\n        if (common.isArray(options) || common.isObject(options)) {\n          controller.remove();\n\n          return add(\n              gui,\n              controller.object,\n              controller.property,\n              {\n                before: controller.__li.nextElementSibling,\n                factoryArgs: [options]\n              }\n          );\n\n        }\n\n      },\n\n      name: function(v) {\n        controller.__li.firstElementChild.firstElementChild.innerHTML = v;\n        return controller;\n      },\n\n      listen: function() {\n        controller.__gui.listen(controller);\n        return controller;\n      },\n\n      remove: function() {\n        controller.__gui.remove(controller);\n        return controller;\n      }\n\n    });\n\n    // All sliders should be accompanied by a box.\n    if (controller instanceof NumberControllerSlider) {\n\n      var box = new NumberControllerBox(controller.object, controller.property,\n          { min: controller.__min, max: controller.__max, step: controller.__step });\n\n      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {\n        var pc = controller[method];\n        var pb = box[method];\n        controller[method] = box[method] = function() {\n          var args = Array.prototype.slice.call(arguments);\n          pc.apply(controller, args);\n          return pb.apply(box, args);\n        }\n      });\n\n      dom.addClass(li, 'has-slider');\n      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\n\n    }\n    else if (controller instanceof NumberControllerBox) {\n\n      var r = function(returned) {\n\n        // Have we defined both boundaries?\n        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {\n\n          // Well, then lets just replace this with a slider.\n          controller.remove();\n          return add(\n              gui,\n              controller.object,\n              controller.property,\n              {\n                before: controller.__li.nextElementSibling,\n                factoryArgs: [controller.__min, controller.__max, controller.__step]\n              });\n\n        }\n\n        return returned;\n\n      };\n\n      controller.min = common.compose(r, controller.min);\n      controller.max = common.compose(r, controller.max);\n\n    }\n    else if (controller instanceof BooleanController) {\n\n      dom.bind(li, 'click', function() {\n        dom.fakeEvent(controller.__checkbox, 'click');\n      });\n\n      dom.bind(controller.__checkbox, 'click', function(e) {\n        e.stopPropagation(); // Prevents double-toggle\n      })\n\n    }\n    else if (controller instanceof FunctionController) {\n\n      dom.bind(li, 'click', function() {\n        dom.fakeEvent(controller.__button, 'click');\n      });\n\n      dom.bind(li, 'mouseover', function() {\n        dom.addClass(controller.__button, 'hover');\n      });\n\n      dom.bind(li, 'mouseout', function() {\n        dom.removeClass(controller.__button, 'hover');\n      });\n\n    }\n    else if (controller instanceof ColorController) {\n\n      dom.addClass(li, 'color');\n      controller.updateDisplay = common.compose(function(r) {\n        li.style.borderLeftColor = controller.__color.toString();\n        return r;\n      }, controller.updateDisplay);\n\n      controller.updateDisplay();\n\n    }\n\n    controller.setValue = common.compose(function(r) {\n      if (gui.getRoot().__preset_select && controller.isModified()) {\n        markPresetModified(gui.getRoot(), true);\n      }\n      return r;\n    }, controller.setValue);\n\n  }\n\n  function recallSavedValue(gui, controller) {\n\n    // Find the topmost GUI, that's where remembered objects live.\n    var root = gui.getRoot();\n\n    // Does the object we're controlling match anything we've been told to\n    // remember?\n    var matched_index = root.__rememberedObjects.indexOf(controller.object);\n\n    // Why yes, it does!\n    if (matched_index != -1) {\n\n      // Let me fetch a map of controllers for thcommon.isObject.\n      var controller_map =\n          root.__rememberedObjectIndecesToControllers[matched_index];\n\n      // Ohp, I believe this is the first controller we've created for this\n      // object. Lets make the map fresh.\n      if (controller_map === undefined) {\n        controller_map = {};\n        root.__rememberedObjectIndecesToControllers[matched_index] =\n            controller_map;\n      }\n\n      // Keep track of this controller\n      controller_map[controller.property] = controller;\n\n      // Okay, now have we saved any values for this controller?\n      if (root.load && root.load.remembered) {\n\n        var preset_map = root.load.remembered;\n\n        // Which preset are we trying to load?\n        var preset;\n\n        if (preset_map[gui.preset]) {\n\n          preset = preset_map[gui.preset];\n\n        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {\n\n          // Uhh, you can have the default instead?\n          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];\n\n        } else {\n\n          // Nada.\n\n          return;\n\n        }\n\n\n        // Did the loaded object remember thcommon.isObject?\n        if (preset[matched_index] &&\n\n          // Did we remember this particular property?\n            preset[matched_index][controller.property] !== undefined) {\n\n          // We did remember something for this guy ...\n          var value = preset[matched_index][controller.property];\n\n          // And that's what it is.\n          controller.initialValue = value;\n          controller.setValue(value);\n\n        }\n\n      }\n\n    }\n\n  }\n\n  function getLocalStorageHash(gui, key) {\n    // TODO how does this deal with multiple GUI's?\n    return document.location.href + '.' + key;\n\n  }\n\n  function addSaveMenu(gui) {\n\n    var div = gui.__save_row = document.createElement('li');\n\n    dom.addClass(gui.domElement, 'has-save');\n\n    gui.__ul.insertBefore(div, gui.__ul.firstChild);\n\n    dom.addClass(div, 'save-row');\n\n    var gears = document.createElement('span');\n    gears.innerHTML = '&nbsp;';\n    dom.addClass(gears, 'button gears');\n\n    // TODO replace with FunctionController\n    var button = document.createElement('span');\n    button.innerHTML = 'Save';\n    dom.addClass(button, 'button');\n    dom.addClass(button, 'save');\n\n    var button2 = document.createElement('span');\n    button2.innerHTML = 'New';\n    dom.addClass(button2, 'button');\n    dom.addClass(button2, 'save-as');\n\n    var button3 = document.createElement('span');\n    button3.innerHTML = 'Revert';\n    dom.addClass(button3, 'button');\n    dom.addClass(button3, 'revert');\n\n    var select = gui.__preset_select = document.createElement('select');\n\n    if (gui.load && gui.load.remembered) {\n\n      common.each(gui.load.remembered, function(value, key) {\n        addPresetOption(gui, key, key == gui.preset);\n      });\n\n    } else {\n      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\n    }\n\n    dom.bind(select, 'change', function() {\n\n\n      for (var index = 0; index < gui.__preset_select.length; index++) {\n        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\n      }\n\n      gui.preset = this.value;\n\n    });\n\n    div.appendChild(select);\n    div.appendChild(gears);\n    div.appendChild(button);\n    div.appendChild(button2);\n    div.appendChild(button3);\n\n    if (SUPPORTS_LOCAL_STORAGE) {\n\n      var saveLocally = document.getElementById('dg-save-locally');\n      var explain = document.getElementById('dg-local-explain');\n\n      saveLocally.style.display = 'block';\n\n      var localStorageCheckBox = document.getElementById('dg-local-storage');\n\n      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\n        localStorageCheckBox.setAttribute('checked', 'checked');\n      }\n\n      function showHideExplain() {\n        explain.style.display = gui.useLocalStorage ? 'block' : 'none';\n      }\n\n      showHideExplain();\n\n      // TODO: Use a boolean controller, fool!\n      dom.bind(localStorageCheckBox, 'change', function() {\n        gui.useLocalStorage = !gui.useLocalStorage;\n        showHideExplain();\n      });\n\n    }\n\n    var newConstructorTextArea = document.getElementById('dg-new-constructor');\n\n    dom.bind(newConstructorTextArea, 'keydown', function(e) {\n      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {\n        SAVE_DIALOGUE.hide();\n      }\n    });\n\n    dom.bind(gears, 'click', function() {\n      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\n      SAVE_DIALOGUE.show();\n      newConstructorTextArea.focus();\n      newConstructorTextArea.select();\n    });\n\n    dom.bind(button, 'click', function() {\n      gui.save();\n    });\n\n    dom.bind(button2, 'click', function() {\n      var presetName = prompt('Enter a new preset name.');\n      if (presetName) gui.saveAs(presetName);\n    });\n\n    dom.bind(button3, 'click', function() {\n      gui.revert();\n    });\n\n//    div.appendChild(button2);\n\n  }\n\n  function addResizeHandle(gui) {\n\n    gui.__resize_handle = document.createElement('div');\n\n    common.extend(gui.__resize_handle.style, {\n\n      width: '6px',\n      marginLeft: '-3px',\n      height: '200px',\n      cursor: 'ew-resize',\n      position: 'absolute'\n//      border: '1px solid blue'\n\n    });\n\n    var pmouseX;\n\n    dom.bind(gui.__resize_handle, 'mousedown', dragStart);\n    dom.bind(gui.__closeButton, 'mousedown', dragStart);\n\n    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\n\n    function dragStart(e) {\n\n      e.preventDefault();\n\n      pmouseX = e.clientX;\n\n      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\n      dom.bind(window, 'mousemove', drag);\n      dom.bind(window, 'mouseup', dragStop);\n\n      return false;\n\n    }\n\n    function drag(e) {\n\n      e.preventDefault();\n\n      gui.width += pmouseX - e.clientX;\n      gui.onResize();\n      pmouseX = e.clientX;\n\n      return false;\n\n    }\n\n    function dragStop() {\n\n      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\n      dom.unbind(window, 'mousemove', drag);\n      dom.unbind(window, 'mouseup', dragStop);\n\n    }\n\n  }\n\n  function setWidth(gui, w) {\n    gui.domElement.style.width = w + 'px';\n    // Auto placed save-rows are position fixed, so we have to\n    // set the width manually if we want it to bleed to the edge\n    if (gui.__save_row && gui.autoPlace) {\n      gui.__save_row.style.width = w + 'px';\n    }if (gui.__closeButton) {\n      gui.__closeButton.style.width = w + 'px';\n    }\n  }\n\n  function getCurrentPreset(gui, useInitialValues) {\n\n    var toReturn = {};\n\n    // For each object I'm remembering\n    common.each(gui.__rememberedObjects, function(val, index) {\n\n      var saved_values = {};\n\n      // The controllers I've made for thcommon.isObject by property\n      var controller_map =\n          gui.__rememberedObjectIndecesToControllers[index];\n\n      // Remember each value for each property\n      common.each(controller_map, function(controller, property) {\n        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();\n      });\n\n      // Save the values for thcommon.isObject\n      toReturn[index] = saved_values;\n\n    });\n\n    return toReturn;\n\n  }\n\n  function addPresetOption(gui, name, setSelected) {\n    var opt = document.createElement('option');\n    opt.innerHTML = name;\n    opt.value = name;\n    gui.__preset_select.appendChild(opt);\n    if (setSelected) {\n      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\n    }\n  }\n\n  function setPresetSelectIndex(gui) {\n    for (var index = 0; index < gui.__preset_select.length; index++) {\n      if (gui.__preset_select[index].value == gui.preset) {\n        gui.__preset_select.selectedIndex = index;\n      }\n    }\n  }\n\n  function markPresetModified(gui, modified) {\n    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\n//    console.log('mark', modified, opt);\n    if (modified) {\n      opt.innerHTML = opt.value + \"*\";\n    } else {\n      opt.innerHTML = opt.value;\n    }\n  }\n\n  function updateDisplays(controllerArray) {\n\n\n    if (controllerArray.length != 0) {\n\n      requestAnimationFrame(function() {\n        updateDisplays(controllerArray);\n      });\n\n    }\n\n    common.each(controllerArray, function(c) {\n      c.updateDisplay();\n    });\n\n  }\n\n  return GUI;\n\n})(dat.utils.css,\n\"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n      \\n    </div>\\n    \\n  </div>\\n\\n</div>\",\n\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\",\ndat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {\n\n      return function(object, property) {\n\n        var initialValue = object[property];\n\n        // Providing options?\n        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {\n          return new OptionController(object, property, arguments[2]);\n        }\n\n        // Providing a map?\n\n        if (common.isNumber(initialValue)) {\n\n          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {\n\n            // Has min and max.\n            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\n\n          } else {\n\n            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\n\n          }\n\n        }\n\n        if (common.isString(initialValue)) {\n          return new StringController(object, property);\n        }\n\n        if (common.isFunction(initialValue)) {\n          return new FunctionController(object, property, '');\n        }\n\n        if (common.isBoolean(initialValue)) {\n          return new BooleanController(object, property);\n        }\n\n      }\n\n    })(dat.controllers.OptionController,\ndat.controllers.NumberControllerBox,\ndat.controllers.NumberControllerSlider,\ndat.controllers.StringController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a text input to alter the string property of an object.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var StringController = function(object, property) {\n\n    StringController.superclass.call(this, object, property);\n\n    var _this = this;\n\n    this.__input = document.createElement('input');\n    this.__input.setAttribute('type', 'text');\n\n    dom.bind(this.__input, 'keyup', onChange);\n    dom.bind(this.__input, 'change', onChange);\n    dom.bind(this.__input, 'blur', onBlur);\n    dom.bind(this.__input, 'keydown', function(e) {\n      if (e.keyCode === 13) {\n        this.blur();\n      }\n    });\n    \n\n    function onChange() {\n      _this.setValue(_this.__input.value);\n    }\n\n    function onBlur() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n\n    this.updateDisplay();\n\n    this.domElement.appendChild(this.__input);\n\n  };\n\n  StringController.superclass = Controller;\n\n  common.extend(\n\n      StringController.prototype,\n      Controller.prototype,\n\n      {\n\n        updateDisplay: function() {\n          // Stops the caret from moving on account of:\n          // keyup -> setValue -> updateDisplay\n          if (!dom.isActive(this.__input)) {\n            this.__input.value = this.getValue();\n          }\n          return StringController.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n  );\n\n  return StringController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common),\ndat.controllers.FunctionController,\ndat.controllers.BooleanController,\ndat.utils.common),\ndat.controllers.Controller,\ndat.controllers.BooleanController,\ndat.controllers.FunctionController,\ndat.controllers.NumberControllerBox,\ndat.controllers.NumberControllerSlider,\ndat.controllers.OptionController,\ndat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {\n\n  var ColorController = function(object, property) {\n\n    ColorController.superclass.call(this, object, property);\n\n    this.__color = new Color(this.getValue());\n    this.__temp = new Color(0);\n\n    var _this = this;\n\n    this.domElement = document.createElement('div');\n\n    dom.makeSelectable(this.domElement, false);\n\n    this.__selector = document.createElement('div');\n    this.__selector.className = 'selector';\n\n    this.__saturation_field = document.createElement('div');\n    this.__saturation_field.className = 'saturation-field';\n\n    this.__field_knob = document.createElement('div');\n    this.__field_knob.className = 'field-knob';\n    this.__field_knob_border = '2px solid ';\n\n    this.__hue_knob = document.createElement('div');\n    this.__hue_knob.className = 'hue-knob';\n\n    this.__hue_field = document.createElement('div');\n    this.__hue_field.className = 'hue-field';\n\n    this.__input = document.createElement('input');\n    this.__input.type = 'text';\n    this.__input_textShadow = '0 1px 1px ';\n\n    dom.bind(this.__input, 'keydown', function(e) {\n      if (e.keyCode === 13) { // on enter\n        onBlur.call(this);\n      }\n    });\n\n    dom.bind(this.__input, 'blur', onBlur);\n\n    dom.bind(this.__selector, 'mousedown', function(e) {\n\n      dom\n        .addClass(this, 'drag')\n        .bind(window, 'mouseup', function(e) {\n          dom.removeClass(_this.__selector, 'drag');\n        });\n\n    });\n\n    var value_field = document.createElement('div');\n\n    common.extend(this.__selector.style, {\n      width: '122px',\n      height: '102px',\n      padding: '3px',\n      backgroundColor: '#222',\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\n    });\n\n    common.extend(this.__field_knob.style, {\n      position: 'absolute',\n      width: '12px',\n      height: '12px',\n      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\n      borderRadius: '12px',\n      zIndex: 1\n    });\n    \n    common.extend(this.__hue_knob.style, {\n      position: 'absolute',\n      width: '15px',\n      height: '2px',\n      borderRight: '4px solid #fff',\n      zIndex: 1\n    });\n\n    common.extend(this.__saturation_field.style, {\n      width: '100px',\n      height: '100px',\n      border: '1px solid #555',\n      marginRight: '3px',\n      display: 'inline-block',\n      cursor: 'pointer'\n    });\n\n    common.extend(value_field.style, {\n      width: '100%',\n      height: '100%',\n      background: 'none'\n    });\n    \n    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');\n\n    common.extend(this.__hue_field.style, {\n      width: '15px',\n      height: '100px',\n      display: 'inline-block',\n      border: '1px solid #555',\n      cursor: 'ns-resize'\n    });\n\n    hueGradient(this.__hue_field);\n\n    common.extend(this.__input.style, {\n      outline: 'none',\n//      width: '120px',\n      textAlign: 'center',\n//      padding: '4px',\n//      marginBottom: '6px',\n      color: '#fff',\n      border: 0,\n      fontWeight: 'bold',\n      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'\n    });\n\n    dom.bind(this.__saturation_field, 'mousedown', fieldDown);\n    dom.bind(this.__field_knob, 'mousedown', fieldDown);\n\n    dom.bind(this.__hue_field, 'mousedown', function(e) {\n      setH(e);\n      dom.bind(window, 'mousemove', setH);\n      dom.bind(window, 'mouseup', unbindH);\n    });\n\n    function fieldDown(e) {\n      setSV(e);\n      // document.body.style.cursor = 'none';\n      dom.bind(window, 'mousemove', setSV);\n      dom.bind(window, 'mouseup', unbindSV);\n    }\n\n    function unbindSV() {\n      dom.unbind(window, 'mousemove', setSV);\n      dom.unbind(window, 'mouseup', unbindSV);\n      // document.body.style.cursor = 'default';\n    }\n\n    function onBlur() {\n      var i = interpret(this.value);\n      if (i !== false) {\n        _this.__color.__state = i;\n        _this.setValue(_this.__color.toOriginal());\n      } else {\n        this.value = _this.__color.toString();\n      }\n    }\n\n    function unbindH() {\n      dom.unbind(window, 'mousemove', setH);\n      dom.unbind(window, 'mouseup', unbindH);\n    }\n\n    this.__saturation_field.appendChild(value_field);\n    this.__selector.appendChild(this.__field_knob);\n    this.__selector.appendChild(this.__saturation_field);\n    this.__selector.appendChild(this.__hue_field);\n    this.__hue_field.appendChild(this.__hue_knob);\n\n    this.domElement.appendChild(this.__input);\n    this.domElement.appendChild(this.__selector);\n\n    this.updateDisplay();\n\n    function setSV(e) {\n\n      e.preventDefault();\n\n      var w = dom.getWidth(_this.__saturation_field);\n      var o = dom.getOffset(_this.__saturation_field);\n      var s = (e.clientX - o.left + document.body.scrollLeft) / w;\n      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;\n\n      if (v > 1) v = 1;\n      else if (v < 0) v = 0;\n\n      if (s > 1) s = 1;\n      else if (s < 0) s = 0;\n\n      _this.__color.v = v;\n      _this.__color.s = s;\n\n      _this.setValue(_this.__color.toOriginal());\n\n\n      return false;\n\n    }\n\n    function setH(e) {\n\n      e.preventDefault();\n\n      var s = dom.getHeight(_this.__hue_field);\n      var o = dom.getOffset(_this.__hue_field);\n      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;\n\n      if (h > 1) h = 1;\n      else if (h < 0) h = 0;\n\n      _this.__color.h = h * 360;\n\n      _this.setValue(_this.__color.toOriginal());\n\n      return false;\n\n    }\n\n  };\n\n  ColorController.superclass = Controller;\n\n  common.extend(\n\n      ColorController.prototype,\n      Controller.prototype,\n\n      {\n\n        updateDisplay: function() {\n\n          var i = interpret(this.getValue());\n\n          if (i !== false) {\n\n            var mismatch = false;\n\n            // Check for mismatch on the interpreted value.\n\n            common.each(Color.COMPONENTS, function(component) {\n              if (!common.isUndefined(i[component]) &&\n                  !common.isUndefined(this.__color.__state[component]) &&\n                  i[component] !== this.__color.__state[component]) {\n                mismatch = true;\n                return {}; // break\n              }\n            }, this);\n\n            // If nothing diverges, we keep our previous values\n            // for statefulness, otherwise we recalculate fresh\n            if (mismatch) {\n              common.extend(this.__color.__state, i);\n            }\n\n          }\n\n          common.extend(this.__temp.__state, this.__color.__state);\n\n          this.__temp.a = 1;\n\n          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;\n          var _flip = 255 - flip;\n\n          common.extend(this.__field_knob.style, {\n            marginLeft: 100 * this.__color.s - 7 + 'px',\n            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\n            backgroundColor: this.__temp.toString(),\n            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'\n          });\n\n          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'\n\n          this.__temp.s = 1;\n          this.__temp.v = 1;\n\n          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());\n\n          common.extend(this.__input.style, {\n            backgroundColor: this.__input.value = this.__color.toString(),\n            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',\n            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'\n          });\n\n        }\n\n      }\n\n  );\n  \n  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];\n  \n  function linearGradient(elem, x, a, b) {\n    elem.style.background = '';\n    common.each(vendors, function(vendor) {\n      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';\n    });\n  }\n  \n  function hueGradient(elem) {\n    elem.style.background = '';\n    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'\n    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n  }\n\n\n  return ColorController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.color.Color = (function (interpret, math, toString, common) {\n\n  var Color = function() {\n\n    this.__state = interpret.apply(this, arguments);\n\n    if (this.__state === false) {\n      throw 'Failed to interpret color arguments';\n    }\n\n    this.__state.a = this.__state.a || 1;\n\n\n  };\n\n  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\n  common.extend(Color.prototype, {\n\n    toString: function() {\n      return toString(this);\n    },\n\n    toOriginal: function() {\n      return this.__state.conversion.write(this);\n    }\n\n  });\n\n  defineRGBComponent(Color.prototype, 'r', 2);\n  defineRGBComponent(Color.prototype, 'g', 1);\n  defineRGBComponent(Color.prototype, 'b', 0);\n\n  defineHSVComponent(Color.prototype, 'h');\n  defineHSVComponent(Color.prototype, 's');\n  defineHSVComponent(Color.prototype, 'v');\n\n  Object.defineProperty(Color.prototype, 'a', {\n\n    get: function() {\n      return this.__state.a;\n    },\n\n    set: function(v) {\n      this.__state.a = v;\n    }\n\n  });\n\n  Object.defineProperty(Color.prototype, 'hex', {\n\n    get: function() {\n\n      if (!this.__state.space !== 'HEX') {\n        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n      }\n\n      return this.__state.hex;\n\n    },\n\n    set: function(v) {\n\n      this.__state.space = 'HEX';\n      this.__state.hex = v;\n\n    }\n\n  });\n\n  function defineRGBComponent(target, component, componentHexIndex) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'RGB') {\n          return this.__state[component];\n        }\n\n        recalculateRGB(this, component, componentHexIndex);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'RGB') {\n          recalculateRGB(this, component, componentHexIndex);\n          this.__state.space = 'RGB';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function defineHSVComponent(target, component) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'HSV')\n          return this.__state[component];\n\n        recalculateHSV(this);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'HSV') {\n          recalculateHSV(this);\n          this.__state.space = 'HSV';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function recalculateRGB(color, component, componentHexIndex) {\n\n    if (color.__state.space === 'HEX') {\n\n      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\n    } else if (color.__state.space === 'HSV') {\n\n      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\n    } else {\n\n      throw 'Corrupted color state';\n\n    }\n\n  }\n\n  function recalculateHSV(color) {\n\n    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\n    common.extend(color.__state,\n        {\n          s: result.s,\n          v: result.v\n        }\n    );\n\n    if (!common.isNaN(result.h)) {\n      color.__state.h = result.h;\n    } else if (common.isUndefined(color.__state.h)) {\n      color.__state.h = 0;\n    }\n\n  }\n\n  return Color;\n\n})(dat.color.interpret,\ndat.color.math = (function () {\n\n  var tmpComponent;\n\n  return {\n\n    hsv_to_rgb: function(h, s, v) {\n\n      var hi = Math.floor(h / 60) % 6;\n\n      var f = h / 60 - Math.floor(h / 60);\n      var p = v * (1.0 - s);\n      var q = v * (1.0 - (f * s));\n      var t = v * (1.0 - ((1.0 - f) * s));\n      var c = [\n        [v, t, p],\n        [q, v, p],\n        [p, v, t],\n        [p, q, v],\n        [t, p, v],\n        [v, p, q]\n      ][hi];\n\n      return {\n        r: c[0] * 255,\n        g: c[1] * 255,\n        b: c[2] * 255\n      };\n\n    },\n\n    rgb_to_hsv: function(r, g, b) {\n\n      var min = Math.min(r, g, b),\n          max = Math.max(r, g, b),\n          delta = max - min,\n          h, s;\n\n      if (max != 0) {\n        s = delta / max;\n      } else {\n        return {\n          h: NaN,\n          s: 0,\n          v: 0\n        };\n      }\n\n      if (r == max) {\n        h = (g - b) / delta;\n      } else if (g == max) {\n        h = 2 + (b - r) / delta;\n      } else {\n        h = 4 + (r - g) / delta;\n      }\n      h /= 6;\n      if (h < 0) {\n        h += 1;\n      }\n\n      return {\n        h: h * 360,\n        s: s,\n        v: max / 255\n      };\n    },\n\n    rgb_to_hex: function(r, g, b) {\n      var hex = this.hex_with_component(0, 2, r);\n      hex = this.hex_with_component(hex, 1, g);\n      hex = this.hex_with_component(hex, 0, b);\n      return hex;\n    },\n\n    component_from_hex: function(hex, componentIndex) {\n      return (hex >> (componentIndex * 8)) & 0xFF;\n    },\n\n    hex_with_component: function(hex, componentIndex, value) {\n      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n    }\n\n  }\n\n})(),\ndat.color.toString,\ndat.utils.common),\ndat.color.interpret,\ndat.utils.common),\ndat.utils.requestAnimationFrame = (function () {\n\n  /**\n   * requirejs version of Paul Irish's RequestAnimationFrame\n   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   */\n\n  return window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(callback, element) {\n\n        window.setTimeout(callback, 1000 / 60);\n\n      };\n})(),\ndat.dom.CenteredDiv = (function (dom, common) {\n\n\n  var CenteredDiv = function() {\n\n    this.backgroundElement = document.createElement('div');\n    common.extend(this.backgroundElement.style, {\n      backgroundColor: 'rgba(0,0,0,0.8)',\n      top: 0,\n      left: 0,\n      display: 'none',\n      zIndex: '1000',\n      opacity: 0,\n      WebkitTransition: 'opacity 0.2s linear'\n    });\n\n    dom.makeFullscreen(this.backgroundElement);\n    this.backgroundElement.style.position = 'fixed';\n\n    this.domElement = document.createElement('div');\n    common.extend(this.domElement.style, {\n      position: 'fixed',\n      display: 'none',\n      zIndex: '1001',\n      opacity: 0,\n      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'\n    });\n\n\n    document.body.appendChild(this.backgroundElement);\n    document.body.appendChild(this.domElement);\n\n    var _this = this;\n    dom.bind(this.backgroundElement, 'click', function() {\n      _this.hide();\n    });\n\n\n  };\n\n  CenteredDiv.prototype.show = function() {\n\n    var _this = this;\n    \n\n\n    this.backgroundElement.style.display = 'block';\n\n    this.domElement.style.display = 'block';\n    this.domElement.style.opacity = 0;\n//    this.domElement.style.top = '52%';\n    this.domElement.style.webkitTransform = 'scale(1.1)';\n\n    this.layout();\n\n    common.defer(function() {\n      _this.backgroundElement.style.opacity = 1;\n      _this.domElement.style.opacity = 1;\n      _this.domElement.style.webkitTransform = 'scale(1)';\n    });\n\n  };\n\n  CenteredDiv.prototype.hide = function() {\n\n    var _this = this;\n\n    var hide = function() {\n\n      _this.domElement.style.display = 'none';\n      _this.backgroundElement.style.display = 'none';\n\n      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\n      dom.unbind(_this.domElement, 'transitionend', hide);\n      dom.unbind(_this.domElement, 'oTransitionEnd', hide);\n\n    };\n\n    dom.bind(this.domElement, 'webkitTransitionEnd', hide);\n    dom.bind(this.domElement, 'transitionend', hide);\n    dom.bind(this.domElement, 'oTransitionEnd', hide);\n\n    this.backgroundElement.style.opacity = 0;\n//    this.domElement.style.top = '48%';\n    this.domElement.style.opacity = 0;\n    this.domElement.style.webkitTransform = 'scale(1.1)';\n\n  };\n\n  CenteredDiv.prototype.layout = function() {\n    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';\n    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';\n  };\n  \n  function lockScroll(e) {\n    console.log(e);\n  }\n\n  return CenteredDiv;\n\n})(dat.dom.dom,\ndat.utils.common),\ndat.dom.dom,\ndat.utils.common);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dat-gui/vendor/dat.gui.js\n// module id = 6\n// module chunks = 0","/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n/** @namespace */\nvar dat = module.exports = dat || {};\n\n/** @namespace */\ndat.color = dat.color || {};\n\n/** @namespace */\ndat.utils = dat.utils || {};\n\ndat.utils.common = (function () {\n  \n  var ARR_EACH = Array.prototype.forEach;\n  var ARR_SLICE = Array.prototype.slice;\n\n  /**\n   * Band-aid methods for things that should be a lot easier in JavaScript.\n   * Implementation and structure inspired by underscore.js\n   * http://documentcloud.github.com/underscore/\n   */\n\n  return { \n    \n    BREAK: {},\n  \n    extend: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (!this.isUndefined(obj[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n      \n    },\n    \n    defaults: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (this.isUndefined(target[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n    \n    },\n    \n    compose: function() {\n      var toCall = ARR_SLICE.call(arguments);\n            return function() {\n              var args = ARR_SLICE.call(arguments);\n              for (var i = toCall.length -1; i >= 0; i--) {\n                args = [toCall[i].apply(this, args)];\n              }\n              return args[0];\n            }\n    },\n    \n    each: function(obj, itr, scope) {\n\n      \n      if (ARR_EACH && obj.forEach === ARR_EACH) { \n        \n        obj.forEach(itr, scope);\n        \n      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n        \n        for (var key = 0, l = obj.length; key < l; key++)\n          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n            return;\n            \n      } else {\n\n        for (var key in obj) \n          if (itr.call(scope, obj[key], key) === this.BREAK)\n            return;\n            \n      }\n            \n    },\n    \n    defer: function(fnc) {\n      setTimeout(fnc, 0);\n    },\n    \n    toArray: function(obj) {\n      if (obj.toArray) return obj.toArray();\n      return ARR_SLICE.call(obj);\n    },\n\n    isUndefined: function(obj) {\n      return obj === undefined;\n    },\n    \n    isNull: function(obj) {\n      return obj === null;\n    },\n    \n    isNaN: function(obj) {\n      return obj !== obj;\n    },\n    \n    isArray: Array.isArray || function(obj) {\n      return obj.constructor === Array;\n    },\n    \n    isObject: function(obj) {\n      return obj === Object(obj);\n    },\n    \n    isNumber: function(obj) {\n      return obj === obj+0;\n    },\n    \n    isString: function(obj) {\n      return obj === obj+'';\n    },\n    \n    isBoolean: function(obj) {\n      return obj === false || obj === true;\n    },\n    \n    isFunction: function(obj) {\n      return Object.prototype.toString.call(obj) === '[object Function]';\n    }\n  \n  };\n    \n})();\n\n\ndat.color.toString = (function (common) {\n\n  return function(color) {\n\n    if (color.a == 1 || common.isUndefined(color.a)) {\n\n      var s = color.hex.toString(16);\n      while (s.length < 6) {\n        s = '0' + s;\n      }\n\n      return '#' + s;\n\n    } else {\n\n      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\n    }\n\n  }\n\n})(dat.utils.common);\n\n\ndat.Color = dat.color.Color = (function (interpret, math, toString, common) {\n\n  var Color = function() {\n\n    this.__state = interpret.apply(this, arguments);\n\n    if (this.__state === false) {\n      throw 'Failed to interpret color arguments';\n    }\n\n    this.__state.a = this.__state.a || 1;\n\n\n  };\n\n  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\n  common.extend(Color.prototype, {\n\n    toString: function() {\n      return toString(this);\n    },\n\n    toOriginal: function() {\n      return this.__state.conversion.write(this);\n    }\n\n  });\n\n  defineRGBComponent(Color.prototype, 'r', 2);\n  defineRGBComponent(Color.prototype, 'g', 1);\n  defineRGBComponent(Color.prototype, 'b', 0);\n\n  defineHSVComponent(Color.prototype, 'h');\n  defineHSVComponent(Color.prototype, 's');\n  defineHSVComponent(Color.prototype, 'v');\n\n  Object.defineProperty(Color.prototype, 'a', {\n\n    get: function() {\n      return this.__state.a;\n    },\n\n    set: function(v) {\n      this.__state.a = v;\n    }\n\n  });\n\n  Object.defineProperty(Color.prototype, 'hex', {\n\n    get: function() {\n\n      if (!this.__state.space !== 'HEX') {\n        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n      }\n\n      return this.__state.hex;\n\n    },\n\n    set: function(v) {\n\n      this.__state.space = 'HEX';\n      this.__state.hex = v;\n\n    }\n\n  });\n\n  function defineRGBComponent(target, component, componentHexIndex) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'RGB') {\n          return this.__state[component];\n        }\n\n        recalculateRGB(this, component, componentHexIndex);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'RGB') {\n          recalculateRGB(this, component, componentHexIndex);\n          this.__state.space = 'RGB';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function defineHSVComponent(target, component) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'HSV')\n          return this.__state[component];\n\n        recalculateHSV(this);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'HSV') {\n          recalculateHSV(this);\n          this.__state.space = 'HSV';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function recalculateRGB(color, component, componentHexIndex) {\n\n    if (color.__state.space === 'HEX') {\n\n      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\n    } else if (color.__state.space === 'HSV') {\n\n      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\n    } else {\n\n      throw 'Corrupted color state';\n\n    }\n\n  }\n\n  function recalculateHSV(color) {\n\n    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\n    common.extend(color.__state,\n        {\n          s: result.s,\n          v: result.v\n        }\n    );\n\n    if (!common.isNaN(result.h)) {\n      color.__state.h = result.h;\n    } else if (common.isUndefined(color.__state.h)) {\n      color.__state.h = 0;\n    }\n\n  }\n\n  return Color;\n\n})(dat.color.interpret = (function (toString, common) {\n\n  var result, toReturn;\n\n  var interpret = function() {\n\n    toReturn = false;\n\n    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\n    common.each(INTERPRETATIONS, function(family) {\n\n      if (family.litmus(original)) {\n\n        common.each(family.conversions, function(conversion, conversionName) {\n\n          result = conversion.read(original);\n\n          if (toReturn === false && result !== false) {\n            toReturn = result;\n            result.conversionName = conversionName;\n            result.conversion = conversion;\n            return common.BREAK;\n\n          }\n\n        });\n\n        return common.BREAK;\n\n      }\n\n    });\n\n    return toReturn;\n\n  };\n\n  var INTERPRETATIONS = [\n\n    // Strings\n    {\n\n      litmus: common.isString,\n\n      conversions: {\n\n        THREE_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt(\n                  '0x' +\n                      test[1].toString() + test[1].toString() +\n                      test[2].toString() + test[2].toString() +\n                      test[3].toString() + test[3].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        SIX_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9]{6})$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt('0x' + test[1].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGB: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3])\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGBA: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3]),\n              a: parseFloat(test[4])\n            };\n\n          },\n\n          write: toString\n\n        }\n\n      }\n\n    },\n\n    // Numbers\n    {\n\n      litmus: common.isNumber,\n\n      conversions: {\n\n        HEX: {\n          read: function(original) {\n            return {\n              space: 'HEX',\n              hex: original,\n              conversionName: 'HEX'\n            }\n          },\n\n          write: function(color) {\n            return color.hex;\n          }\n        }\n\n      }\n\n    },\n\n    // Arrays\n    {\n\n      litmus: common.isArray,\n\n      conversions: {\n\n        RGB_ARRAY: {\n          read: function(original) {\n            if (original.length != 3) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b];\n          }\n\n        },\n\n        RGBA_ARRAY: {\n          read: function(original) {\n            if (original.length != 4) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2],\n              a: original[3]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b, color.a];\n          }\n\n        }\n\n      }\n\n    },\n\n    // Objects\n    {\n\n      litmus: common.isObject,\n\n      conversions: {\n\n        RGBA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: color.a\n            }\n          }\n        },\n\n        RGB_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b\n            }\n          }\n        },\n\n        HSVA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v,\n              a: color.a\n            }\n          }\n        },\n\n        HSV_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v\n            }\n          }\n\n        }\n\n      }\n\n    }\n\n\n  ];\n\n  return interpret;\n\n\n})(dat.color.toString,\ndat.utils.common),\ndat.color.math = (function () {\n\n  var tmpComponent;\n\n  return {\n\n    hsv_to_rgb: function(h, s, v) {\n\n      var hi = Math.floor(h / 60) % 6;\n\n      var f = h / 60 - Math.floor(h / 60);\n      var p = v * (1.0 - s);\n      var q = v * (1.0 - (f * s));\n      var t = v * (1.0 - ((1.0 - f) * s));\n      var c = [\n        [v, t, p],\n        [q, v, p],\n        [p, v, t],\n        [p, q, v],\n        [t, p, v],\n        [v, p, q]\n      ][hi];\n\n      return {\n        r: c[0] * 255,\n        g: c[1] * 255,\n        b: c[2] * 255\n      };\n\n    },\n\n    rgb_to_hsv: function(r, g, b) {\n\n      var min = Math.min(r, g, b),\n          max = Math.max(r, g, b),\n          delta = max - min,\n          h, s;\n\n      if (max != 0) {\n        s = delta / max;\n      } else {\n        return {\n          h: NaN,\n          s: 0,\n          v: 0\n        };\n      }\n\n      if (r == max) {\n        h = (g - b) / delta;\n      } else if (g == max) {\n        h = 2 + (b - r) / delta;\n      } else {\n        h = 4 + (r - g) / delta;\n      }\n      h /= 6;\n      if (h < 0) {\n        h += 1;\n      }\n\n      return {\n        h: h * 360,\n        s: s,\n        v: max / 255\n      };\n    },\n\n    rgb_to_hex: function(r, g, b) {\n      var hex = this.hex_with_component(0, 2, r);\n      hex = this.hex_with_component(hex, 1, g);\n      hex = this.hex_with_component(hex, 0, b);\n      return hex;\n    },\n\n    component_from_hex: function(hex, componentIndex) {\n      return (hex >> (componentIndex * 8)) & 0xFF;\n    },\n\n    hex_with_component: function(hex, componentIndex, value) {\n      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n    }\n\n  }\n\n})(),\ndat.color.toString,\ndat.utils.common);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dat-gui/vendor/dat.color.js\n// module id = 7\n// module chunks = 0","window.THREE = require('three');\n\n(function(){\n  /**\n   * Cubeクラス\n   */\n  var Cube = window.Cube || {};\n\n  window.Cube = function () {\n    //Cubeクラスをイニシャライズ\n    p.init();\n  };\n\n  var p, s;\n\n  s = window.Cube;\n  p = s.prototype;\n\n  /**\n   * Cubeクラスイニシャライズ\n   **/\n  p.init = function () {\n    var self = this;\n\n    //cubeGeometry\n    self.cubeGeometry = new THREE.BoxGeometry(4,4,4);\n\n    //cubeMaterial\n    self.cubeMaterial = new THREE.MeshLambertMaterial({\n      color: 0xff0000, wireframe: false\n    });\n\n    //cube\n    self.CubeObject = new THREE.Mesh(self.cubeGeometry,self.cubeMaterial);\n    self.CubeObject.castShadow = true;\n    //CubeObjectを回転\n    self.CubeObject.position.x = -4;\n    self.CubeObject.position.y = 3;\n    self.CubeObject.position.z = 0;\n\n    //オブジェクトとしてCubeObject返す\n    return self.CubeObject;\n  };\n\n})();\n\n\n// WEBPACK FOOTER //\n// ./src/js/object/Cube.js"],"sourceRoot":""}