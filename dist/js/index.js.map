{"version":3,"sources":["webpack:///index.js","webpack:///webpack/bootstrap ac0fe0884a29cb671be0","webpack:///./src/js/app.js","webpack:///./src/js/main.js","webpack:///./~/jquery/dist/jquery.js","webpack:///./~/three/build/three.js","webpack:///./src/js/libs/stats.js","webpack:///./~/dat-gui/index.js","webpack:///./~/dat-gui/vendor/dat.gui.js","webpack:///./~/dat-gui/vendor/dat.color.js","webpack:///./src/js/object/Cube.js","webpack:///./src/js/object/Plane.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","$","window","THREE","Stats","dat","sample","MainDisplay","CubeObject","Cube","PlaneObject","Plane","initStats","stats","setMode","domElement","style","position","left","top","document","getElementById","appendChild","init","s","prototype","renderScene","self","this","$window","$MainDisplay","renderer","WebGLRenderer","alert","setClearColor","Color","setSize","innerWidth","innerHeight","shadowMap","enabled","pixelRatio","Math","min","devicePixelRatio","setPixelRatio","scene","Scene","camera","PerspectiveCamera","x","y","z","lookAt","on","e","onResize","trigger","add","spotLight","SpotLight","set","castShadow","update","updateAnimation","bind","controls","rotationSpeed","bouncingSpeed","gui","GUI","render","requestAnimationFrame","width","height","aspect","updateProjectionMatrix","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","factory","w","Error","noGlobal","DOMEval","code","doc","script","createElement","text","head","parentNode","removeChild","isArrayLike","obj","length","type","jQuery","isWindow","winnow","elements","qualifier","not","isFunction","grep","elem","i","nodeType","indexOf","risSimple","test","filter","sibling","cur","dir","createOptions","options","object","each","match","rnothtmlwhite","_","flag","Identity","v","Thrower","ex","adoptValue","value","resolve","reject","method","promise","done","fail","then","undefined","completed","removeEventListener","ready","Data","expando","uid","getData","data","rbrace","JSON","parse","dataAttr","key","name","replace","rmultiDash","toLowerCase","getAttribute","dataUser","adjustCSS","prop","valueParts","tween","adjusted","scale","maxIterations","currentValue","css","initial","unit","cssNumber","initialInUnit","rcssNum","exec","start","end","getDefaultDisplay","temp","ownerDocument","nodeName","display","defaultDisplayMap","body","showHide","show","values","index","dataPriv","get","isHiddenWithinTree","getAll","context","tag","ret","getElementsByTagName","querySelectorAll","merge","setGlobalEval","elems","refElements","l","buildFragment","scripts","selection","ignored","tmp","wrap","contains","j","fragment","createDocumentFragment","nodes","rhtml","rtagName","wrapMap","_default","innerHTML","htmlPrefilter","lastChild","childNodes","firstChild","textContent","push","createTextNode","inArray","rscriptType","returnTrue","returnFalse","safeActiveElement","activeElement","err","types","selector","fn","one","origFn","event","off","apply","arguments","guid","manipulationTarget","content","disableScript","restoreScript","rscriptTypeMasked","removeAttribute","cloneCopyEvent","src","dest","pdataOld","pdataCur","udataOld","udataCur","events","hasData","access","handle","extend","fixInput","rcheckableType","checked","defaultValue","domManip","collection","args","callback","concat","first","hasScripts","node","iNoClone","support","checkClone","rchecked","eq","html","map","clone","_evalUrl","rcleanScript","remove","keepData","cleanData","curCSS","computed","minWidth","maxWidth","getStyles","getPropertyValue","pixelMarginRight","rnumnonpx","rmargin","addGetHookIf","conditionFn","hookFn","vendorPropName","emptyStyle","capName","toUpperCase","slice","cssPrefixes","setPositiveNumber","subtract","matches","max","augmentWidthOrHeight","extra","isBorderBox","styles","val","cssExpand","getWidthOrHeight","valueIsBorderBox","getClientRects","getBoundingClientRect","boxSizingReliable","parseFloat","Tween","easing","raf","timerId","fx","tick","createFxNow","setTimeout","fxNow","now","genFx","includeWidth","which","attrs","opacity","createTween","animation","Animation","tweeners","defaultPrefilter","props","opts","toggle","hooks","oldfire","propTween","restoreDisplay","isBox","anim","orig","hidden","dataShow","queue","_queueHooks","unqueued","empty","fire","always","rfxtypes","isEmptyObject","overflow","overflowX","overflowY","propFilter","specialEasing","camelCase","isArray","cssHooks","expand","properties","result","stopped","prefilters","deferred","Deferred","currentTime","remaining","startTime","duration","percent","tweens","run","notifyWith","resolveWith","originalProperties","originalOptions","stop","gotoEnd","rejectWith","proxy","timer","progress","complete","stripAndCollapse","tokens","join","getClass","buildParams","prefix","traditional","rbracket","addToPrefiltersOrTransports","structure","dataTypeExpression","func","dataType","dataTypes","unshift","inspectPrefiltersOrTransports","jqXHR","inspect","selected","inspected","prefilterOrFactory","dataTypeOrTransport","seekingTransport","transports","ajaxExtend","target","deep","flatOptions","ajaxSettings","ajaxHandleResponses","responses","ct","finalDataType","firstDataType","contents","shift","mimeType","getResponseHeader","converters","ajaxConvert","response","isSuccess","conv2","current","conv","prev","responseFields","dataFilter","split","throws","state","error","getWindow","defaultView","arr","getProto","Object","getPrototypeOf","class2type","toString","hasOwn","hasOwnProperty","fnToString","ObjectFunctionString","version","rtrim","rmsPrefix","rdashAlpha","fcamelCase","all","letter","jquery","constructor","toArray","num","pushStack","prevObject","last","len","sort","splice","copy","copyIsArray","isPlainObject","random","isReady","msg","noop","Array","isNumeric","isNaN","proto","Ctor","globalEval","string","trim","makeArray","results","second","invert","callbackInverse","callbackExpect","arg","Date","Symbol","iterator","Sizzle","seed","nid","groups","newSelector","newContext","preferredDoc","setDocument","documentIsHTML","rquickExpr","getElementsByClassName","qsa","compilerCache","rbuggyQSA","rcssescape","fcssescape","setAttribute","tokenize","toSelector","rsibling","testContext","qsaError","select","createCache","cache","keys","Expr","cacheLength","markFunction","assert","el","addHandle","handler","attrHandle","siblingCheck","a","b","diff","sourceIndex","nextSibling","createInputPseudo","createButtonPseudo","createDisabledPseudo","disabled","isDisabled","disabledAncestor","createPositionalPseudo","argument","matchIndexes","setFilters","addCombinator","matcher","combinator","base","skip","next","checkNonElements","doneName","xml","oldCache","uniqueCache","outerCache","newCache","dirruns","uniqueID","elementMatcher","matchers","multipleContexts","contexts","condense","unmatched","newUnmatched","mapped","setMatcher","preFilter","postFilter","postFinder","postSelector","preMap","postMap","preexisting","matcherIn","matcherOut","matcherFromTokens","checkContext","leadingRelative","relative","implicitRelative","matchContext","matchAnyContext","outermostContext","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","find","dirrunsUnique","pop","uniqueSort","getText","isXML","compile","sortInput","hasDuplicate","docElem","rbuggyMatches","classCache","tokenCache","sortOrder","push_native","list","booleans","whitespace","identifier","attributes","pseudos","rwhitespace","RegExp","rcomma","rcombinators","rattributeQuotes","rpseudo","ridentifier","matchExpr","ID","CLASS","TAG","ATTR","PSEUDO","CHILD","bool","needsContext","rinputs","rheader","rnative","runescape","funescape","escaped","escapedWhitespace","high","String","fromCharCode","ch","asCodePoint","charCodeAt","unloadHandler","els","documentElement","hasCompare","subWindow","addEventListener","attachEvent","className","createComment","getById","getElementsByName","attrId","getAttributeNode","input","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","expr","attr","specified","escape","sel","duplicates","detectDuplicates","sortStable","nodeValue","selectors","createPseudo",">"," ","+","~","excess","unquoted","nodeNameSelector","pattern","operator","check","what","simple","forward","ofType","nodeIndex","parent","useCache","pseudo","idx","matched","has","innerText","lang","elemLang","hash","location","root","focus","hasFocus","href","tabIndex","selectedIndex","header","button","even","odd","lt","gt","radio","checkbox","file","password","image","submit","reset","filters","parseOnly","soFar","preFilters","cached","token","compiled","unique","isXMLDoc","escapeSelector","until","truncate","is","siblings","n","rneedsContext","rsingleTag","rootjQuery","parseHTML","rparentsprev","guaranteedUnique","children","targets","closest","prevAll","addBack","parents","parentsUntil","nextAll","nextUntil","prevUntil","contentDocument","reverse","Callbacks","firing","memory","fired","locked","firingIndex","once","stopOnFalse","disable","lock","fireWith","tuples","catch","pipe","fns","newDefer","tuple","returned","notify","onFulfilled","onRejected","onProgress","depth","special","that","mightThrow","maxDepth","TypeError","process","exceptionHook","stackTrace","getStackHook","stateString","when","singleValue","resolveContexts","resolveValues","master","updateFunc","rerrorNames","stack","console","warn","message","readyException","readyList","readyWait","holdReady","hold","wait","readyState","doScroll","chainable","emptyGet","raw","bulk","acceptData","owner","defineProperty","configurable","removeData","_data","_removeData","dequeue","startLength","setter","clearQueue","count","defer","pnum","source","swap","old","hide","option","thead","col","tr","td","optgroup","tbody","tfoot","colgroup","caption","th","div","cloneNode","noCloneChecked","rkeyEvent","rmouseEvent","rtypenamespace","handleObjIn","eventHandle","t","handleObj","handlers","namespaces","origType","elemData","triggered","dispatch","delegateType","bindType","namespace","delegateCount","setup","mappedTypes","origCount","teardown","removeEvent","nativeEvent","handlerQueue","fix","delegateTarget","preDispatch","isPropagationStopped","currentTarget","isImmediatePropagationStopped","rnamespace","preventDefault","stopPropagation","postDispatch","matchedHandlers","matchedSelectors","addProp","hook","Event","enumerable","originalEvent","writable","load","noBubble","blur","click","beforeunload","returnValue","isDefaultPrevented","defaultPrevented","relatedTarget","timeStamp","isSimulated","stopImmediatePropagation","altKey","bubbles","cancelable","changedTouches","ctrlKey","detail","eventPhase","metaKey","pageX","pageY","shiftKey","view","char","charCode","keyCode","buttons","clientX","clientY","offsetX","offsetY","pointerId","pointerType","screenX","screenY","targetTouches","toElement","touches","mouseenter","mouseleave","pointerenter","pointerleave","related","rxhtmlTag","rnoInnerhtml","dataAndEvents","deepDataAndEvents","srcElements","destElements","inPage","detach","append","prepend","insertBefore","before","after","replaceWith","replaceChild","appendTo","prependTo","insertAfter","replaceAll","original","insert","opener","getComputedStyle","computeStyleTests","cssText","container","divStyle","pixelPositionVal","reliableMarginLeftVal","marginLeft","boxSizingReliableVal","marginRight","pixelMarginRightVal","backgroundClip","clearCloneStyle","pixelPosition","reliableMarginLeft","rdisplayswap","cssShow","visibility","cssNormalTransform","letterSpacing","fontWeight","animationIterationCount","columnCount","fillOpacity","flexGrow","flexShrink","lineHeight","order","orphans","widows","zIndex","zoom","cssProps","float","origName","isFinite","margin","padding","border","suffix","expanded","parts","propHooks","eased","pos","step","scrollTop","scrollLeft","linear","swing","cos","PI","rrun","*","tweener","prefilter","speed","opt","speeds","fadeTo","to","animate","optall","doAnimation","finish","stopQueue","timers","cssFn","slideDown","slideUp","slideToggle","fadeIn","fadeOut","fadeToggle","interval","setInterval","cancelAnimationFrame","clearInterval","slow","fast","delay","time","timeout","clearTimeout","checkOn","optSelected","radioValue","boolHook","removeAttr","nType","attrHooks","attrNames","getter","lowercaseName","rfocusable","rclickable","removeProp","propFix","tabindex","parseInt","for","class","addClass","classes","curValue","clazz","finalValue","removeClass","toggleClass","stateVal","classNames","hasClass","rreturn","valHooks","optionSet","rfocusMorph","onlyHandlers","bubbleType","ontype","eventPath","isTrigger","parentWindow","simulate","triggerHandler","hover","fnOver","fnOut","focusin","attaches","nonce","rquery","parseXML","DOMParser","parseFromString","rCRLF","rsubmitterTypes","rsubmittable","param","valueOrFunction","encodeURIComponent","serialize","serializeArray","r20","rhash","rantiCache","rheaders","rlocalProtocol","rnoContent","rprotocol","allTypes","originAnchor","active","lastModified","etag","url","isLocal","protocol","processData","async","contentType","accepts","json","* text","text html","text json","text xml","ajaxSetup","settings","ajaxPrefilter","ajaxTransport","ajax","status","nativeStatusText","headers","success","modified","statusText","timeoutTimer","transport","responseHeadersString","ifModified","cacheURL","callbackContext","statusCode","fireGlobals","globalEventContext","completeDeferred","responseHeaders","urlAnchor","uncached","requestHeaders","requestHeadersNames","strAbort","getAllResponseHeaders","setRequestHeader","overrideMimeType","abort","finalText","crossDomain","host","hasContent","beforeSend","send","getJSON","getScript","wrapAll","firstElementChild","wrapInner","unwrap","visible","offsetWidth","offsetHeight","xhr","XMLHttpRequest","xhrSuccessStatus","0","1223","xhrSupported","cors","errorCallback","open","username","xhrFields","onload","onerror","onabort","onreadystatechange","responseType","responseText","binary","text script","charset","scriptCharset","evt","oldCallbacks","rjsonp","jsonp","jsonpCallback","originalSettings","callbackName","overwritten","responseContainer","jsonProp","createHTMLDocument","implementation","keepScripts","parsed","params","animated","offset","setOffset","curPosition","curLeft","curCSSTop","curTop","curOffset","curCSSLeft","calculatePosition","curElem","using","win","rect","pageYOffset","clientTop","pageXOffset","clientLeft","offsetParent","parentOffset","scrollTo","Height","Width","","defaultExtra","funcName","unbind","delegate","undelegate","parseJSON","_jQuery","_$","noConflict","EventDispatcher","Vector2","Texture","mapping","wrapS","wrapT","magFilter","minFilter","format","anisotropy","encoding","TextureIdCount","uuid","_Math","generateUUID","sourceFile","DEFAULT_IMAGE","mipmaps","DEFAULT_MAPPING","ClampToEdgeWrapping","LinearFilter","LinearMipMapLinearFilter","RGBAFormat","UnsignedByteType","repeat","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","LinearEncoding","onUpdate","Vector4","WebGLRenderTarget","scissor","scissorTest","viewport","texture","depthBuffer","stencilBuffer","depthTexture","WebGLRenderTargetCube","activeCubeFace","activeMipMapLevel","Quaternion","_x","_y","_z","_w","Vector3","Matrix4","Float32Array","CubeTexture","images","CubeReflectionMapping","UniformContainer","seq","flatten","array","nBlocks","blockSize","firstElem","r","arrayCacheF32","allocTexUnits","arrayCacheI32","Int32Array","allocTextureUnit","setValue1f","gl","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","g","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","setTexture2D","emptyTexture","setValueT6","setTextureCube","emptyCubeTexture","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","size","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","units","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","setValue","PureArrayUniform","StructuredUniform","addUniform","uniformObject","parseUniform","path","pathLength","RePathPart","lastIndex","matchEnd","idIsIndex","subscript","WebGLUniforms","program","getProgramParameter","ACTIVE_UNIFORMS","info","getActiveUniform","getUniformLocation","setRGB","Box2","Infinity","LensFlarePlugin","flares","vertices","faces","Uint16Array","vertexBuffer","createBuffer","elementBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","tempTexture","createTexture","occlusionTexture","bindTexture","TEXTURE_2D","texImage2D","RGB","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","RGBA","shader","vertexShader","fragmentShader","createProgram","vertex","getAttribLocation","uv","uniforms","renderType","occlusionMap","color","rotation","screenPosition","createShader","FRAGMENT_SHADER","VERTEX_SHADER","getPrecision","shaderSource","compileShader","attachShader","linkProgram","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","useProgram","initAttributes","enableAttribute","disableUnusedAttributes","vertexAttribPointer","FLOAT","CULL_FACE","setDepthWrite","flare","matrixWorld","applyMatrix4","matrixWorldInverse","applyProjection","projectionMatrix","containsPoint","activeTexture","TEXTURE0","TEXTURE1","copyTexImage2D","BLEND","enable","DEPTH_TEST","drawElements","TRIANGLES","UNSIGNED_SHORT","positionScreen","customUpdateCallback","updateLensFlares","jl","lensFlares","sprite","setBlending","blending","blendEquation","blendSrc","blendDst","resetGLState","SpritePlugin","sprites","uvOffset","uvScale","modelViewMatrix","fogType","fogDensity","fogNear","fogFar","fogColor","alphaTest","canvas","createElementNS","getContext","fillStyle","fillRect","needsUpdate","painterSortStable","renderOrder","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","fog","isFog","near","far","isFogExp2","density","multiplyMatrices","material","decompose","setDepthTest","depthTest","depthWrite","Material","MaterialIdCount","lights","NormalBlending","side","FrontSide","shading","SmoothShading","vertexColors","NoColors","transparent","SrcAlphaFactor","OneMinusSrcAlphaFactor","AddEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","LessEqualDepth","clippingPlanes","clipIntersection","clipShadows","colorWrite","precision","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","count$1","ShaderMaterial","parameters","defines","linewidth","wireframe","wireframeLinewidth","clipping","skinning","morphTargets","morphNormals","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","uv2","index0AttributeName","setValues","MeshDepthMaterial","depthPacking","BasicDepthPacking","alphaMap","displacementMap","displacementScale","displacementBias","Box3","Sphere","center","radius","Matrix3","normal","constant","Frustum","p0","p1","p2","p3","p4","p5","planes","WebGLShadowMap","_renderer","_lights","_objects","capabilities","getDepthMaterial","isPointLight","lightPositionWorld","geometry","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","isBufferGeometry","morphAttributes","isGeometry","useSkinning","isSkinnedMesh","variantIndex","_MorphingFlag","_SkinningFlag","localClippingEnabled","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","scope","renderSingleSided","DoubleSide","renderReverseSided","BackSide","lightPos","projectObject","shadowCamera","layers","mask","isMesh","isLine","isPoints","frustumCulled","_frustum","intersectsObject","_renderList","_gl","_state","_projScreenMatrix","_lightShadows","shadows","_shadowMapSize","_maxShadowMapSize","maxTextureSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","RGBADepthPacking","distanceShader","ShaderLib","distanceUniforms","UniformsUtils","depthMaterial","distanceMaterial","USE_SHADOWMAP","autoUpdate","PCFShadowMap","clearColor","setScissorTest","faceCount","il","light","shadow","mapSize","vpWidth","vpHeight","pars","NearestFilter","isSpotLightShadow","shadowMatrix","matrix","setFromMatrixPosition","setRenderTarget","clear","face","up","vpDimensions","updateMatrixWorld","getInverse","multiply","setFromMatrix","isMultiMaterial","materials","k","kl","group","groupMaterial","materialIndex","renderBufferDirect","getClearColor","clearAlpha","getClearAlpha","Ray","origin","direction","Euler","_order","DefaultOrder","Layers","Object3D","onRotationChange","quaternion","setFromEuler","onQuaternionChange","setFromQuaternion","Object3DIdCount","DefaultUp","onChange","defineProperties","normalMatrix","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","receiveShadow","userData","onBeforeRender","onAfterRender","count$2","Line3","Triangle","Face3","isVector3","vertexNormals","isColor","MeshBasicMaterial","aoMap","aoMapIntensity","specularMap","envMap","combine","MultiplyOperation","reflectivity","refractionRatio","wireframeLinecap","wireframeLinejoin","BufferAttribute","itemSize","normalized","dynamic","updateRange","Int8Attribute","Int8Array","Uint8Attribute","Uint8Array","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Int32Attribute","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","setDynamic","Geometry","GeometryIdCount","colors","faceVertexUvs","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","count$3","DirectGeometry","indices","normals","uvs","uvs2","BufferGeometry","drawRange","Mesh","drawMode","TrianglesDrawMode","updateMorphTargets","BoxBufferGeometry","widthSegments","heightSegments","depthSegments","calculateVertexCount","h","d","calculateIndexCount","buildPlane","u","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","vector","iy","ix","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","addGroup","groupStart","floor","vertexCount","indexCount","setIndex","addAttribute","PlaneBufferGeometry","width_half","height_half","segment_width","segment_height","offset2","Camera","fov","filmGauge","filmOffset","OrthographicCamera","right","bottom","WebGLIndexedBufferRenderer","infoRender","mode","UNSIGNED_INT","calls","renderInstances","extension","drawElementsInstancedANGLE","maxInstancedCount","WebGLBufferRenderer","drawArrays","isInterleavedBufferAttribute","drawArraysInstancedANGLE","WebGLLights","shadowBias","shadowRadius","shadowMapSize","distance","coneCos","penumbraCos","decay","skyColor","groundColor","addLineNumbers","lines","WebGLShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","getEncodingComponents","sRGBEncoding","RGBEEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","GammaEncoding","getTexelDecodingFunction","functionName","components","getTexelEncodingFunction","getToneMappingFunction","toneMapping","toneMappingName","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","generateExtensions","rendererExtensions","chunks","envMapCubeUV","bumpMap","normalMap","flatShading","logarithmicDepthBuffer","filterEmptyLine","generateDefines","fetchAttributeLocations","identifiers","ACTIVE_ATTRIBUTES","getActiveAttrib","replaceLightNums","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","ShaderChunk","unrollLoops","snippet","unroll","WebGLProgram","__webglShader","shadowMapTypeDefine","shadowMapType","PCFSoftShadowMap","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","CubeRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","MixOperation","AddOperation","prefixVertex","prefixFragment","gammaFactorDefine","gammaFactor","customExtensions","customDefines","isRawShaderMaterial","supportsVertexTextures","maxBones","lightMap","emissiveMap","roughnessMap","metalnessMap","useVertexTexture","doubleSided","flipSided","numClippingPlanes","shadowMapEnabled","sizeAttenuation","useFog","fogExp","numClipIntersection","physicallyCorrectLights","NoToneMapping","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","isShaderMaterial","vertexGlsl","fragmentGlsl","glVertexShader","glFragmentShader","bindAttribLocation","programLog","getProgramInfoLog","vertexLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","log","deleteShader","cachedUniforms","getUniforms","cachedAttributes","getAttributes","destroy","deleteProgram","programIdCount","usedTimes","WebGLPrograms","allocateBones","floatVertexTextures","skeleton","nVertexUniforms","maxVertexUniforms","nVertexMatrices","bones","getTextureEncodingFromMap","gammaOverrideLinear","isTexture","isWebGLRenderTarget","programs","shaderIDs","MeshNormalMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshStandardMaterial","MeshPhysicalMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","parameterNames","getParameters","nClipPlanes","nClipIntersection","shaderID","getMaxPrecision","currentRenderTarget","getCurrentRenderTarget","vertexTextures","gammaOutput","gammaInput","envMapMode","FlatShading","maxMorphTargets","maxMorphNormals","directional","point","spot","hemi","getProgramCode","acquireProgram","pl","programInfo","releaseProgram","WebGLGeometries","onGeometryDispose","buffergeometry","geometries","deleteAttribute","deleteAttributes","property","delete","bufferproperty","getAttributeBuffer","attribute","__webglBuffer","buffer","deleteBuffer","removeAttributeBuffer","_bufferGeometry","setFromObject","WebGLObjects","updateFromObject","updateAttribute","bufferType","attributeProperties","updateBuffer","usage","DYNAMIC_DRAW","bufferSubData","BYTES_PER_ELEMENT","subarray","getWireframeAttribute","TypeArray","WebGLTextures","paramThreeToGL","clampToMaxSize","maxSize","drawImage","isPowerOfTwo","makePowerOfTwo","HTMLImageElement","HTMLCanvasElement","nearestPowerOfTwo","textureNeedsPowerOfTwo","filterFallback","f","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LINEAR","onTextureDispose","deallocateTexture","_infoMemory","textures","onRenderTargetDispose","renderTarget","deallocateRenderTarget","textureProperties","__image__webglTextureCube","deleteTexture","__webglInit","__webglTexture","renderTargetProperties","dispose","isWebGLRenderTargetCube","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","slot","__version","uploadTexture","TEXTURE_CUBE_MAP","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isCompressedTexture","isDataTexture","cubeImage","maxCubemapSize","isPowerOfTwoImage","glFormat","glType","setTextureParameters","mipmap","RGBFormat","getCompressedTextureFormats","compressedTexImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","generateMipmap","setTextureCubeDynamic","textureType","FloatType","HalfFloatType","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","isDepthTexture","internalFormat","DEPTH_COMPONENT","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","DepthStencilFormat","DEPTH_STENCIL","setupFrameBufferTexture","framebuffer","attachment","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","isCube","webglDepthTexture","DepthFormat","setupDepthRenderbuffer","createRenderbuffer","setupRenderTarget","isTargetPowerOfTwo","createFramebuffer","COLOR_ATTACHMENT0","updateRenderTargetMipmap","webglTexture","WebGL2RenderingContext","WebGLProperties","WebGLState","ColorBuffer","currentColorMask","currentColorClear","setMask","colorMask","setLocked","setClear","equals","DepthBuffer","currentDepthMask","currentDepthFunc","currentDepthClear","setTest","depthMask","setFunc","NeverDepth","NEVER","AlwaysDepth","ALWAYS","LessDepth","LESS","LEQUAL","EqualDepth","EQUAL","GreaterEqualDepth","GEQUAL","GreaterDepth","GREATER","NotEqualDepth","NOTEQUAL","clearDepth","StencilBuffer","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilTest","STENCIL_TEST","stencilMask","stencilFunc","stencilRef","setOp","stencilFail","stencilZFail","stencilZPass","stencilOp","stencil","clearStencil","setDepthFunc","setFlipSided","setCullFace","CullFaceBack","newAttributes","enabledAttributes","enableVertexAttribArray","attributeDivisors","vertexAttribDivisorANGLE","enableAttributeAndDivisor","meshPerAttribute","disableVertexAttribArray","compressedTextureFormats","formats","getParameter","COMPRESSED_TEXTURE_FORMATS","NoBlending","currentBlending","currentPremultipledAlpha","AdditiveBlending","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","blendFunc","SRC_ALPHA","SubtractiveBlending","ZERO","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","MultiplyBlending","SRC_COLOR","CustomBlending","currentBlendEquation","currentBlendEquationAlpha","currentBlendSrc","currentBlendDst","currentBlendSrcAlpha","currentBlendDstAlpha","setColorWrite","colorBuffer","setStencilTest","setStencilWrite","stencilWrite","setStencilFunc","setStencilOp","currentFlipSided","frontFace","CW","CCW","cullFace","CullFaceNone","currentCullFace","BACK","CullFaceFront","FRONT","FRONT_AND_BACK","setLineWidth","currentLineWidth","lineWidth","setPolygonOffset","factor","POLYGON_OFFSET_FILL","currentPolygonOffsetFactor","currentPolygonOffsetUnits","getScissorTest","currentScissorTest","SCISSOR_TEST","webglSlot","maxTextures","currentTextureSlot","webglType","boundTexture","currentBoundTextures","emptyTextures","currentScissor","currentViewport","maxVertexAttributes","MAX_VERTEX_ATTRIBS","MAX_TEXTURE_IMAGE_UNITS","buffers","WebGLCapabilities","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getShaderPrecisionFormat","HIGH_FLOAT","MEDIUM_FLOAT","maxPrecision","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","floatFragmentTextures","WebGLExtensions","getExtension","WebGLClipping","resetGlobalState","uniform","globalState","numGlobalPlanes","numPlanes","numIntersection","projectPlanes","dstOffset","skipTransform","nPlanes","dstArray","flatSize","viewMatrix","viewNormalMatrix","getNormalMatrix","i4","plane","renderingShadows","enableLocalClipping","beginShadows","endShadows","setState","fromCache","nGlobal","lGlobal","clippingState","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","setDefaultGLState","_currentScissor","_scissor","multiplyScalar","_currentViewport","_viewport","_clearColor","_clearAlpha","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReference","programCache","setupVertexAttributes","startIndex","isInstancedBufferGeometry","geometryAttributes","programAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","SHORT","INT","BYTE","objects","stride","isInstancedInterleavedBuffer","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","absNumericalSort","abs","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","computeBoundingSphere","_sphere","isSphereViewable","isSpriteViewable","sphere","intersectsSphere","_clipping","_this","negRad","distanceToPoint","isLight","isSprite","isLensFlare","isImmediateRenderObject","sortObjects","renderObjects","renderList","overrideMaterial","setMaterial","setProgram","renderBufferImmediate","initMaterial","materialProperties","programChange","numSupportedMorphTargets","numSupportedMorphNormals","lightsHash","ambientLightColor","ambient","directionalLights","spotLights","pointLights","hemisphereLights","directionalShadowMap","directionalShadowMatrix","spotShadowMap","spotShadowMatrix","pointShadowMap","pointShadowMatrix","progUniforms","uniformsList","seqWithValue","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","LN2","isMeshPhongMaterial","isMeshStandardMaterial","uCamPos","cameraPosition","isMeshLambertMaterial","isMeshBasicMaterial","setOptional","markUniformsLightsNeedsUpdate","refreshUniformsFog","isMeshDepthMaterial","refreshUniformsCommon","isLineBasicMaterial","refreshUniformsLine","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","isMeshPhysicalMaterial","refreshUniformsPhysical","refreshUniformsStandard","isMeshNormalMaterial","upload","diffuse","emissive","emissiveIntensity","uvScaleMap","offsetRepeat","flipEnvMap","isCubeTexture","dashSize","totalSize","gapSize","_height","lightMapIntensity","specular","shininess","bumpScale","normalScale","roughness","metalness","envMapIntensity","clearCoat","clearCoatRoughness","setupShadows","lightShadowsLength","setupLights","ll","intensity","directionalLength","pointLength","spotLength","hemiLength","isAmbientLight","isDirectionalLight","lightCache","sub","transformDirection","bias","isSpotLight","angle","penumbra","negate","identity","setPosition","isHemisphereLight","normalize","textureUnit","RepeatWrapping","REPEAT","MirroredRepeatWrapping","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LinearMipMapNearestFilter","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UnsignedShort4444Type","UNSIGNED_SHORT_4_4_4_4","UnsignedShort5551Type","UNSIGNED_SHORT_5_5_5_1","UnsignedShort565Type","UNSIGNED_SHORT_5_6_5","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","HALF_FLOAT_OES","AlphaFormat","ALPHA","LuminanceFormat","LUMINANCE","LuminanceAlphaFormat","LUMINANCE_ALPHA","SubtractEquation","FUNC_SUBTRACT","ReverseSubtractEquation","FUNC_REVERSE_SUBTRACT","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","DstAlphaFactor","DST_ALPHA","OneMinusDstAlphaFactor","ONE_MINUS_DST_ALPHA","DstColorFactor","DST_COLOR","OneMinusDstColorFactor","ONE_MINUS_DST_COLOR","SrcAlphaSaturateFactor","SRC_ALPHA_SATURATE","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","RGB_ETC1_Format","COMPRESSED_RGB_ETC1_WEBGL","MinEquation","MaxEquation","MIN_EXT","MAX_EXT","UnsignedInt248Type","UNSIGNED_INT_24_8_WEBGL","REVISION","_canvas","_context","_alpha","alpha","_depth","_stencil","_antialias","antialias","_preserveDrawingBuffer","preserveDrawingBuffer","morphInfluences","autoClear","autoClearColor","autoClearDepth","autoClearStencil","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_scissorTest","_infoRender","points","rangeMin","rangeMax","MaxIndex","bufferRenderer","indexedBufferRenderer","backgroundCamera","backgroundCamera2","backgroundPlaneMesh","backgroundBoxShader","backgroundBoxMesh","spritePlugin","lensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","getPixelRatio","getSize","updateStyle","setViewport","setScissor","boolean","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearTarget","hasPositions","hasNormals","hasUvs","hasColors","positionArray","normalArray","nx","ny","nz","uvArray","colorArray","updateBuffers","geometryProgram","morphTargetInfluences","activeInfluences","influence","rangeFactor","dataCount","rangeStart","rangeCount","drawStart","drawEnd","drawCount","LINES","TriangleStripDrawMode","TRIANGLE_STRIP","TriangleFanDrawMode","TRIANGLE_FAN","isLineSegments","LINE_STRIP","POINTS","forceClear","isCamera","background","extractRotation","setFaceCulling","frontFaceDirection","FrontFaceDirectionCW","warned","setTexture","readRenderTargetPixels","restore","textureFormat","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","FogExp2","Fog","LensFlare","SpriteMaterial","Sprite","LOD","levels","DataTexture","Skeleton","boneInverses","identityMatrix","sqrt","nextPowerOfTwo","ceil","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","Bone","skin","SkinnedMesh","bindMode","bindMatrix","bindMatrixInverse","bone","gbone","fromArray","rotq","scl","normalizeSkinWeights","linecap","linejoin","Line","LineSegments","Points","Group","VideoTexture","video","HAVE_CURRENT_DATA","CompressedTexture","CanvasTexture","DepthTexture","WireframeGeometry","sortFunction","edge","numEdges","edges","coords","o","ol","index2","getX","getY","getZ","numTris","index1","ParametricBufferGeometry","slices","stacks","sliceCount","computeVertexNormals","ParametricGeometry","fromBufferGeometry","mergeVertices","PolyhedronBufferGeometry","subdivide","getVertexByIndex","subdivideFace","cols","pow","aj","lerp","bj","rows","pushVertex","appplyRadius","generateUVs","azimuth","inclination","uvBuffer","correctUVs","correctSeam","x0","x1","x2","centroid","uvA","uvB","uvC","divideScalar","azi","correctUV","atan2","normalizeNormals","TetrahedronBufferGeometry","TetrahedronGeometry","OctahedronBufferGeometry","OctahedronGeometry","IcosahedronBufferGeometry","IcosahedronGeometry","DodecahedronBufferGeometry","DodecahedronGeometry","PolyhedronGeometry","TubeBufferGeometry","tubularSegments","radialSegments","closed","generateBufferData","generateSegment","generateIndices","P","getPointAt","N","frames","B","binormals","sin","computeFrenetFrames","tangents","TubeGeometry","taper","bufferGeometry","TorusKnotBufferGeometry","tube","q","calculatePositionOnCurve","cu","su","quOverP","cs","indexOffset","P1","P2","T","subVectors","addVectors","crossVectors","cx","cy","setXYZ","setXY","setX","TorusKnotGeometry","heightScale","TorusBufferGeometry","arc","TorusGeometry","ExtrudeGeometry","shapes","addShapeList","computeFaceNormals","TextGeometry","font","isFont","generateShapes","curveSegments","amount","bevelThickness","bevelSize","bevelEnabled","SphereBufferGeometry","phiStart","phiLength","thetaStart","thetaLength","thetaEnd","positions","verticesRow","px","py","pz","v1","v2","v3","v4","SphereGeometry","RingBufferGeometry","innerRadius","outerRadius","thetaSegments","phiSegments","segment","radiusStep","thetaSegmentLevel","RingGeometry","PlaneGeometry","LatheBufferGeometry","segments","clamp","inverseSegments","phi","n1","n2","LatheGeometry","ShapeGeometry","EdgesGeometry","thresholdAngle","geometry2","thresholdDot","DEG2RAD","vert1","vert2","face1","face2","dot","CylinderBufferGeometry","radiusTop","radiusBottom","openEnded","nbCap","generateTorso","slope","indexRow","theta","sinTheta","cosTheta","halfHeight","indexArray","i1","i2","i3","generateCap","centerIndexStart","centerIndexEnd","sign","CylinderGeometry","ConeGeometry","ConeBufferGeometry","CircleBufferGeometry","ii","CircleGeometry","BoxGeometry","ShadowMaterial","UniformsLib","RawShaderMaterial","MultiMaterial","STANDARD","PHYSICAL","LoadingManager","onLoad","onError","isLoading","itemsLoaded","itemsTotal","onStart","itemStart","itemEnd","itemError","XHRLoader","manager","DefaultLoadingManager","CompressedTextureLoader","_parser","BinaryTextureLoader","ImageLoader","CubeTextureLoader","TextureLoader","Light","HemisphereLight","updateMatrix","LightShadow","SpotLightShadow","power","PointLight","DirectionalLightShadow","DirectionalLight","AmbientLight","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","LinearInterpolant","DiscreteInterpolant","KeyframeTrackConstructor","times","interpolation","AnimationUtils","convertArray","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","optimize","VectorKeyframeTrack","QuaternionLinearInterpolant","QuaternionKeyframeTrack","NumberKeyframeTrack","StringKeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","KeyframeTrack","AnimationClip","tracks","resetDuration","MaterialLoader","BufferGeometryLoader","Loader","onLoadStart","onLoadProgress","onLoadComplete","JSONLoader","withCredentials","ObjectLoader","texturePath","Curve","LineCurve","CurvePath","curves","autoClose","EllipseCurve","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","aRotation","SplineCurve","CubicBezierCurve","v0","QuadraticBezierCurve","Shape","Path","holes","currentPoint","fromPoints","ShapePath","subPaths","currentPath","Font","FontLoader","getAudioContext","AudioContext","webkitAudioContext","AudioLoader","StereoCamera","eyeSep","cameraL","cameraR","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","updateCubeMap","AudioListener","gain","createGain","connect","destination","Audio","listener","createBufferSource","onended","onEnded","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","PositionalAudio","panner","createPanner","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getOutput","PropertyMixer","binding","typeName","mixFunction","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","useCount","referenceCount","PropertyBinding","rootNode","parsedPath","parseTrackName","findNode","AnimationObjectGroup","var_args","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath","total","inUse","bindingsPerObject","AnimationAction","mixer","clip","localRoot","_mixer","_clip","_localRoot","nTracks","interpolants","interpolantSettings","endingStart","ZeroCurvatureEnding","endingEnd","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","LoopRepeat","_loopCount","_startTime","timeScale","_effectiveTimeScale","weight","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","AnimationMixer","_root","_initMemoryManager","_accuIndex","Uniform","InstancedBufferGeometry","InterleavedBufferAttribute","interleavedBuffer","InterleavedBuffer","InstancedInterleavedBuffer","InstancedBufferAttribute","Raycaster","ray","threshold","PointCloud","ascSort","intersectObject","raycaster","intersects","recursive","raycast","Clock","autoStart","oldTime","elapsedTime","running","Spline","interpolate","t2","t3","intPoint","w2","w3","pa","pb","pc","pd","initFromArray","getPoint","getControlPointsArray","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","distanceTo","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Spherical","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","fps","createAnimation","setAnimationWeight","ImmediateRenderObject","renderCallback","VertexNormalsHelper","hex","nNormals","objGeometry","SpotLightHelper","cone","SkeletonHelper","getBoneList","isBone","VertexColors","PointLightHelper","sphereSize","HemisphereLightHelper","rotateX","FaceColors","lightSphere","GridHelper","divisions","color1","color2","FaceNormalsHelper","DirectionalLightHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","BoundingBoxHelper","box","BoxHelper","ArrowHelper","headLength","headWidth","line","lineGeometry","coneGeometry","setDirection","setLength","AxisHelper","ClosedSplineCurve3","CatmullRomCurve3","ArcCurve","aRadius","Face4","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","EdgesHelper","WireframeHelper","Projector","projectVector","project","unprojectVector","unproject","pickingRay","CanvasRenderer","Number","EPSILON","Function","assign","output","nextKey","_listeners","listeners","hasEventListener","listenerArray","dispatchEvent","MOUSE","LEFT","MIDDLE","RIGHT","CullFaceFrontBack","FrontFaceDirectionCCW","BasicShadowMap","BlendingMode","UVMapping","TextureMapping","TextureWrapping","TextureFilter","RGBEFormat","LoopOnce","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroSlopeEnding","WrapAroundEnding","LogLuvEncoding","RAD2DEG","chars","rnd","euclideanModulo","mapLinear","a1","a2","b1","b2","smoothstep","smootherstep","random16","randInt","low","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","round","isVector2","setScalar","scalar","setY","setComponent","getComponent","addScalar","addScaledVector","subScalar","divide","clampScalar","minVal","maxVal","clampLength","roundToZero","lengthSq","lengthManhattan","distanceToSquared","dx","dy","distanceToManhattan","lerpVectors","fromAttribute","rotateAround","toJSON","meta","getDataURL","toDataURL","metadata","generator","transformUv","isVector4","setZ","setW","setAxisAngleFromQuaternion","acos","setAxisAngleFromRotationMatrix","epsilon","epsilon2","te","m11","m12","m13","m21","m22","m23","m31","m32","m33","xx","yy","zz","xy","xz","yz","create","onChangeCallback","euler","isEuler","c1","c2","c3","s1","s2","s3","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","trace","setFromUnitVectors","EPS","vFrom","vTo","inverse","conjugate","multiplyQuaternions","premultiply","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","qa","qm","slerpFlat","dst","src0","srcOffset0","src1","srcOffset1","y0","z0","w0","y1","z1","w1","sqrSin","tDir","multiplyVectors","applyEuler","applyQuaternion","applyAxisAngle","applyMatrix3","qx","qy","qz","qw","iz","iw","cross","ax","ay","az","bx","by","bz","projectOnVector","projectOnPlane","planeNormal","reflect","angleTo","dz","setFromSpherical","sinPhiRadius","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","isMatrix4","n11","n12","n13","n14","n21","n22","n23","n24","n31","n32","n33","n34","n41","n42","n43","n44","copyPosition","me","extractBasis","xAxis","yAxis","zAxis","makeBasis","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","y2","z2","wx","wy","wz","eye","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","applyToVector3Array","applyToBuffer","determinant","transpose","flattenToArrayOffset","getPosition","throwOnDegenerate","t11","t12","t13","t14","det","detInv","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","invSX","invSY","invSZ","makeFrustum","makePerspective","ymax","tan","ymin","xmin","xmax","makeOrthographic","merged","uniforms_src","uniforms_dst","parameter_src","isMatrix3","alphamap_fragment","alphamap_pars_fragment","alphatest_fragment","aomap_fragment","aomap_pars_fragment","begin_vertex","beginnormal_vertex","bsdfs","bumpmap_pars_fragment","clipping_planes_fragment","clipping_planes_pars_fragment","clipping_planes_pars_vertex","clipping_planes_vertex","color_fragment","color_pars_fragment","color_pars_vertex","color_vertex","common","cube_uv_reflection_fragment","defaultnormal_vertex","displacementmap_pars_vertex","displacementmap_vertex","emissivemap_fragment","emissivemap_pars_fragment","encodings_fragment","encodings_pars_fragment","envmap_fragment","envmap_pars_fragment","envmap_pars_vertex","envmap_vertex","fog_fragment","fog_pars_fragment","lightmap_fragment","lightmap_pars_fragment","lights_lambert_vertex","lights_pars","lights_phong_fragment","lights_phong_pars_fragment","lights_physical_fragment","lights_physical_pars_fragment","lights_template","logdepthbuf_fragment","logdepthbuf_pars_fragment","logdepthbuf_pars_vertex","logdepthbuf_vertex","map_fragment","map_pars_fragment","map_particle_fragment","map_particle_pars_fragment","metalnessmap_fragment","metalnessmap_pars_fragment","morphnormal_vertex","morphtarget_pars_vertex","morphtarget_vertex","normal_flip","normal_fragment","normalmap_pars_fragment","packing","premultiplied_alpha_fragment","project_vertex","roughnessmap_fragment","roughnessmap_pars_fragment","shadowmap_pars_fragment","shadowmap_pars_vertex","shadowmap_vertex","shadowmask_pars_fragment","skinbase_vertex","skinning_pars_vertex","skinning_vertex","skinnormal_vertex","specularmap_fragment","specularmap_pars_fragment","tonemapping_fragment","tonemapping_pars_fragment","uv_pars_fragment","uv_pars_vertex","uv_vertex","uv2_pars_fragment","uv2_pars_vertex","uv2_vertex","worldpos_vertex","cube_frag","cube_vert","depth_frag","depth_vert","distanceRGBA_frag","distanceRGBA_vert","equirect_frag","equirect_vert","linedashed_frag","linedashed_vert","meshbasic_frag","meshbasic_vert","meshlambert_frag","meshlambert_vert","meshphong_frag","meshphong_vert","meshphysical_frag","meshphysical_vert","normal_frag","normal_vert","points_frag","points_vert","shadow_frag","shadow_vert","setHex","setStyle","setHSL","hue2rgb","handleAlpha","charAt","ColorKeywords","copyGammaToLinear","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","getHex","getHexString","getHSL","optionalTarget","hue","saturation","hsl","lightness","delta","getStyle","offsetHSL","addColors","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","basic","lambert","phong","standard","dashed","cube","tCube","tFlip","equirect","tEquirect","distanceRGBA","physical","setFromPoints","makeEmpty","expandByPoint","setFromCenterAndSize","halfSize","isEmpty","getCenter","expandByVector","expandByScalar","containsBox","intersectsBox","clampPoint","clampedPoint","intersect","union","translate","isMaterial","newValue","extractFromCache","isRoot","srcPlanes","dstPlanes","isBox3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","traverse","closestPoint","intersectsPlane","getBoundingSphere","optionalCenter","maxRadiusSq","radiusSum","deltaLengthSq","getBoundingBox","setFromMatrix4","matrix4","transposeIntoArray","setComponents","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","denominator","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","frustum","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","intersectsSprite","negRadius","d1","d2","at","recast","closestPointToPoint","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","invDet","intersectSphere","tca","radius2","thc","t0","t1","distanceToPlane","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","RotationOrders","asin","setFromVector3","reorder","newOrder","toVector3","optionalResult","channel","isObject3D","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","force","isRootObject","stringify","distanceSq","closestPointToPointParameter","startP","startEnd","clampToLine","startEnd2","startEnd_startP","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","setFromPointsAndIndices","i0","triangle","area","midpoint","edgeList","projectedPoint","minDistance","isBufferAttribute","setArray","copyAt","copyArray","copyColorsArray","copyIndicesArray","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXYZW","computeBoundingBox","addFace","tempNormals","tempUVs","tempUVs2","cb","ab","fl","vA","vB","vC","areaWeighted","vl","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","colors1","colors2","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","verticesMap","changes","precisionPoints","faceIndicesToRemove","dupIndex","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","getNormalIndex","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","getIndex","clearGroups","setDrawRange","direct","__directGeometry","lineDistance","fromDirectGeometry","pA","pB","pC","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","array2","setDrawMode","morphTargetDictionary","ml","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","faceIndex","inverseMatrix","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","tl","uvs_f","isPerspectiveCamera","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","clearViewOffset","skew","isOrthographicCamera","zoomW","zoomH","scaleW","scaleH","vecX","vecY","wantedRotation","matrixPosition","guessSizeSq","level","addLevel","getObjectForDistance","pose","offsetMatrix","sw","vec","skinWeight","linePrecision","precisionSq","vStart","vEnd","interSegment","interRay","distSq","nbVertices","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","ShapeUtils","contour","triangulate","snip","verts","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","removeDupEndPts","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","forEach","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","addShape","scalePt2","pt","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","getSpacedPoints","shapePoints","extractPoints","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","indexA","indexB","indexC","indexD","Geometries","freeze","isShadowMaterial","Materials","Cache","files","dataUriRegex","dataUriRegexResult","isBase64","decodeURIComponent","atob","ArrayBuffer","Blob","parser","request","setPath","setResponseType","setWithCredentials","loadTexture","loader","texDatas","mipmapCount","isCubemap","DataTextureLoader","texData","URL","revokeObjectURL","blob","createObjectURL","setCrossOrigin","crossOrigin","urls","isJPEG","search","arraySlice","from","isTypedArray","forceClone","isView","DataView","getKeyframeOrder","compareTime","sortedArray","nValues","srcOffset","flattenJSON","jsonKeys","valuePropertyName","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","DefaultSettings_","getSettings_","copySampleValue_","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","offset1","offset0","weight1","weight0","KeyframeTrackPrototype","InterpolantFactoryMethodDiscrete","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","ValueTypeName","getInterpolation","timeOffset","endTime","nKeys","valid","prevTime","currTime","smoothInterpolation","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","trackType","_getTrackTypeForValueTypeName","track","jsonTracks","frameTime","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","findByName","objectOrClipArray","clipArray","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","animationMorphTargets","clips","parseAnimation","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","setTextures","getTexture","TYPED_ARRAYS","typedArray","drawcalls","offsets","extractUrlBase","initMaterials","createMaterial","textureLoader","materialLoader","fullPath","Handlers","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","mapEmissiveRepeat","mapEmissiveOffset","mapEmissiveWrap","mapEmissiveAnisotropy","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","mapMetalnessRepeat","mapMetalnessOffset","mapMetalnessWrap","mapMetalnessAnisotropy","mapRoughnessRepeat","mapRoughnessOffset","mapRoughnessWrap","mapRoughnessAnisotropy","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","regex","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","morphAnimationClips","substring","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","loadImage","parseConstant","getGeometry","getMaterial","isInteger","getUtoTmapping","getPoints","lengths","getLengths","cacheArcLengths","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","mat","MAX_VALUE","tz","getPointFunc","isLineCurve","tangent","curve","closePath","startPoint","endPoint","curveLengths","getCurveLengths","lens","cacheLengths","sums","resolution","isEllipseCurve","isSplineCurve","createPointsGeometry","createGeometry","createSpacedPointsGeometry","twoPi","deltaAngle","samePoints","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","point0","point1","point2","point3","PathPrototype","moveTo","lineTo","quadraticCurveTo","aCPx","aCPy","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","absarc","absellipse","ellipse","firstPoint","lastPoint","getPointsHoles","holesPts","extractAllPoints","toShapes","isCCW","noHoles","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","isPointInsidePolygon","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","createPaths","paths","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","outline","_cachedOutline","action","ha","decodeAudioData","audioBuffer","instance","eyeRight","eyeLeft","eyeSepOnProjection","removeFilter","disconnect","getFilter","setFilter","getMasterVolume","setMasterVolume","orientation","setOrientation","setNodeSource","audioNode","setBuffer","play","pause","getFilters","setPlaybackRate","getPlaybackRate","getLoop","setLoop","getVolume","setVolume","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","getFrequencyData","getByteFrequencyData","getAverageFrequency","accumulate","accuIndex","currentWeight","mix","originalValueOffset","saveOriginalState","getValue","restoreOriginalState","targetArray","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","_getValue_unbound","_setValue_unbound","Composite","targetGroup","optionalParsedPath","_targetGroup","subscribe_","firstValidIndex","bindings","isAnimationObjectGroup","re","searchSkeleton","searchNodeSubtree","childNode","subTreeNode","nObjects","nCachedObjects","indicesByUUID","parsedPaths","nBindings","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastObject","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setEffectiveWeight","getEffectiveWeight","_scheduleFading","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","startTimeScale","endTimeScale","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","getRoot","_update","deltaTime","timeDirection","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","pending","atStart","atEnd","weightNow","weightThen","clipAction","optionalRoot","rootUuid","clipObject","clipUuid","actionsForClip","_actionsByClip","prototypeAction","existingAction","actionByRoot","knownActions","newAction","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","_nActiveBindings","uncacheClip","actionsByClip","actionsToRemove","cacheIndex","lastInactiveAction","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","_removeInactiveBinding","uncacheAction","bindingsByName","_addInactiveBinding","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","lastInactiveBinding","remove_empty_map","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","isInterleavedBuffer","setFromCamera","intersectObjects","performance","getElapsedTime","getDelta","newTime","other","makeSafe","vec3","lastFrame","currentFrame","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe","objPos","objNorm","vector2","coneLength","coneWidth","boneList","matrixWorldInv","boneMatrix","setColors","lightPlane","targetLine","setPoint","setColor","CubicPoly","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","SplineCurve3","CubicBezierCurve3","QuadraticBezierCurve3","LineCurve3","SceneUtils","createMultiMaterialObject","attach","LineStrip","LinePieces","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","extrude","makeGeometry","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","audioLoader","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","CubeGeometry","MeshFaceMaterial","Particle","addPanel","panel","dom","showPanel","beginTime","fpsPanel","Panel","msPanel","memPanel","begin","usedJSHeapSize","jsHeapSizeLimit","fg","bg","PR","WIDTH","HEIGHT","TEXT_X","TEXT_Y","GRAPH_X","GRAPH_Y","GRAPH_WIDTH","GRAPH_HEIGHT","textBaseline","fillText","globalAlpha","maxValue","utils","controllers","link","rel","inject","injected","ARR_EACH","ARR_SLICE","BREAK","isUndefined","defaults","toCall","itr","fnc","isNull","isObject","isNumber","isString","isBoolean","Controller","initialValue","__onChange","__onFinishChange","onFinishChange","updateDisplay","isModified","cssValueToPixels","CSS_VALUE_PIXELS","EVENT_MAP","HTMLEvents","MouseEvents","KeyboardEvents","EVENT_MAP_INV","makeSelectable","selectable","onselectstart","MozUserSelect","KhtmlUserSelect","unselectable","makeFullscreen","horizontal","vertical","fakeEvent","eventType","aux","createEvent","initMouseEvent","clickCount","initKeyboardEvent","initKeyEvent","initEvent","detachEvent","getWidth","getHeight","getOffset","offsetLeft","offsetTop","isActive","OptionController","superclass","__select","element","desiredValue","toReturn","NumberController","numDecimals","__min","__max","__step","__impliedStep","LN10","__precision","NumberControllerBox","roundToDecimal","decimals","tenTo","attempted","__input","onBlur","onMouseDown","onMouseDrag","onMouseUp","prev_y","__truncationSuspended","NumberControllerSlider","styleSheet","o2","__background","__foreground","useDefaultStyles","pct","FunctionController","__button","BooleanController","__prev","__checkbox","interpret","INTERPRETATIONS","family","litmus","conversions","conversion","conversionName","read","THREE_CHAR_HEX","space","write","SIX_CHAR_HEX","CSS_RGB","CSS_RGBA","HEX","RGB_ARRAY","RGBA_ARRAY","RGBA_OBJ","RGB_OBJ","HSVA_OBJ","HSV_OBJ","saveDialogueContents","controllerFactory","ColorController","CenteredDiv","controller","factoryArgs","__li","recallSavedValue","li","addRow","CLASS_CONTROLLER_ROW","augmentController","__controllers","liBefore","__ul","__gui","nextElementSibling","listen","borderLeftColor","__color","__preset_select","markPresetModified","matched_index","__rememberedObjects","controller_map","__rememberedObjectIndecesToControllers","remembered","preset","preset_map","DEFAULT_DEFAULT_PRESET_NAME","getLocalStorageHash","addSaveMenu","showHideExplain","explain","useLocalStorage","__save_row","gears","button2","button3","addPresetOption","SUPPORTS_LOCAL_STORAGE","saveLocally","localStorageCheckBox","localStorage","getItem","newConstructorTextArea","SAVE_DIALOGUE","getSaveObject","save","presetName","prompt","saveAs","revert","addResizeHandle","dragStart","pmouseX","__closeButton","CLASS_DRAG","drag","dragStop","__resize_handle","cursor","setWidth","autoPlace","getCurrentPreset","useInitialValues","saved_values","setSelected","setPresetSelectIndex","updateDisplays","controllerArray","auto_place_container","CSS_NAMESPACE","HIDE_KEY_CODE","CLOSE_BUTTON_HEIGHT","auto_place_virgin","hideable_guis","saveToLocalStorage","setItem","resetWidth","__folders","__listening","DEFAULT_WIDTH","resizable","hideable","scrollable","use_local_storage","title_row_name","CLASS_CLOSED","TEXT_OPEN","TEXT_CLOSED","CLASS_MAIN","saved_gui","CLASS_CLOSE_BUTTON","title_row","on_click_title","CLASS_AUTO_PLACE_CONTAINER","CLASS_AUTO_PLACE","toggleHide","CLASS_TOO_TALL","addColor","addFolder","new_gui_params","folders","close","remember","folder","StringController","linearGradient","vendors","vendor","hueGradient","fieldDown","setSV","unbindSV","__state","toOriginal","unbindH","setH","__saturation_field","__hue_field","__temp","__selector","__field_knob","__field_knob_border","__hue_knob","__input_textShadow","value_field","backgroundColor","boxShadow","borderRadius","borderRight","textAlign","textShadow","mismatch","COMPONENTS","component","flip","_flip","marginTop","math","defineRGBComponent","componentHexIndex","recalculateRGB","defineHSVComponent","recalculateHSV","component_from_hex","hsv_to_rgb","rgb_to_hsv","rgb_to_hex","tmpComponent","hi","NaN","hex_with_component","componentIndex","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","backgroundElement","WebkitTransition","webkitTransform","layout","cubeGeometry","cubeMaterial","planeGeometry","planeMaterial"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GE5CrBA,EAAQ,IFoDb,SAASI,EAAQD,EAASH,IGpDhC,SAAAW,GAAAC,OAAOC,MAAQb,EAAQ,EACvB,IAAIc,GAAQd,EAAQ,GAChBe,EAAMf,EAAQ,EAElBA,GAAQ,GACRA,EAAQ,GAER,WAEE,GAAIgB,GAASJ,OAAOI,UACpBJ,QAAOI,OAASA,EAGhBL,EAAE,WACA,GAAIK,GAAOC,gBAMf,IAAIC,GAAa,GAAIC,MAGjBC,EAAc,GAAIC,QAGtB,WAsJE,QAASC,KAEP,GAAIC,GAAQ,GAAIT,EAWhB,OATAS,GAAMC,QAAQ,GAGdD,EAAME,WAAWC,MAAMC,SAAW,WAClCJ,EAAME,WAAWC,MAAME,KAAO,MAC9BL,EAAME,WAAWC,MAAMG,IAAM,MAE7BC,SAASC,eAAe,gBAAgBC,YAAYT,EAAME,YAEnDF,EAlKT,GAAIP,GAASJ,OAAOI,UACpBJ,QAAOI,OAASA,EAKhBA,EAAOC,YAAc,WAEnBP,EAAEuB,OAGJ,IAAIvB,GAAGwB,CAEPA,GAAIlB,EAAOC,YACXP,EAAIwB,EAAEC,SAEN,IAAIC,EAKJ1B,GAAEuB,KAAO,WACP,GAAII,GAAOC,IAEXA,MAAKC,QAAU5B,EAAEC,QACjB0B,KAAKE,aAAe7B,EAAE,iBAGtB2B,KAAKG,SAAW,GAAI5B,OAAM6B,cACrBJ,KAAKG,UACRE,MAAM,wBAERL,KAAKG,SAASG,cAAc,GAAI/B,OAAMgC,MAAM,WAC5CP,KAAKG,SAASK,QAASlC,OAAOmC,WAAYnC,OAAOoC,aACjDV,KAAKG,SAASQ,UAAUC,SAAU,CAGlC,IAAIC,GAAaC,KAAKC,IAAIzC,OAAO0C,kBAAoB,EAAG,EACxDhB,MAAKG,SAASc,cAAcJ,GAG5Bb,KAAKkB,MAAQ,GAAI3C,OAAM4C,MAGvBnB,KAAKoB,OAAS,GAAI7C,OAAM8C,kBAAkB,GAAI/C,OAAOmC,WAAanC,OAAOoC,YAAa,GAAK,KAC3FV,KAAKoB,OAAO/B,SAASiC,GAAI,GACzBtB,KAAKoB,OAAO/B,SAASkC,EAAI,GACzBvB,KAAKoB,OAAO/B,SAASmC,EAAI,GACzBxB,KAAKoB,OAAOK,OAAOzB,KAAKkB,MAAM7B,UAG9BW,KAAKC,QAAQyB,GAAG,SAAU,SAASC,GACjC5B,EAAK6B,aAIP5B,KAAKC,QAAQ4B,QAAQ,UAOrB7B,KAAKkB,MAAMY,IAAIhD,EAAYa,QAG3BK,KAAKkB,MAAMY,IAAIlD,EAAWe,OAoB1B,IAAIoC,GAAY,GAAIxD,OAAMyD,UAAU,SACpCD,GAAU1C,SAAS4C,KAAI,GAAK,IAAI,GAChCF,EAAUG,YAAa,EACvBlC,KAAKkB,MAAMY,IAAIC,GAEfvC,SAASC,eAAe,gBAAgBC,YAAYM,KAAKG,SAAShB,WAGlE,IAAIF,GAAQD,GACZc,GAAc,WACZb,EAAMkD,SAYNnC,KAAKoC,mBACLC,KAAKrC,KAIPF,IAOA,IAAIwC,GAAW,GAAI,YACjBtC,KAAKuC,cAAgB,KACrBvC,KAAKwC,cAAgB,MAGnBC,EAAM,GAAIhE,GAAIiE,GAClBD,GAAIX,IAAIQ,EAAU,gBAAiB,EAAG,IACtCG,EAAIX,IAAIQ,EAAU,gBAAiB,EAAG,GAEtC,IAAIK,GAAU,WACZ1D,EAAMkD,SAWNS,sBAAsBD,GACtB3C,KAAKG,SAASwC,OAAO3C,KAAKkB,MAAOlB,KAAKoB,SACtCiB,KAAKrC,KACP2C,MAsCFvE,EAAEgE,gBAAkB,WAClBQ,sBAAsB9C,GACtBE,KAAKG,SAASwC,OAAO3C,KAAKkB,MAAOlB,KAAKoB,SAQxChD,EAAEwD,SAAW,WAEX5B,KAAK6C,MAAQ7C,KAAKC,QAAQ4C,QAC1B7C,KAAK8C,OAAS9C,KAAKC,QAAQ6C,SAE3B9C,KAAKoB,OAAO2B,OAAS/C,KAAK6C,MAAQ7C,KAAK8C,OACvC9C,KAAKoB,OAAO4B,yBAEZhD,KAAKG,SAASK,QAAQR,KAAK6C,MAAO7C,KAAK8C,cHuDb7E,KAAKJ,EAASH,EAAoB,KAI1D,SAASI,EAAQD,EAASH,GI9RhC,GAAAuF,GAAAC;;;;;;;;;;;;;CAaA,SAAAC,EAAAC,GAEA,YAEA,iBAAAtF,IAAA,gBAAAA,GAAAD,QASAC,EAAAD,QAAAsF,EAAA3D,SACA4D,EAAAD,GAAA,GACA,SAAAE,GACA,IAAAA,EAAA7D,SACA,SAAA8D,OAAA,2CAEA,OAAAF,GAAAC,IAGAD,EAAAD,IAIC,mBAAA7E,eAAA0B,KAAA,SAAA1B,EAAAiF,GAMD,YA8BA,SAAAC,GAAAC,EAAAC,GACAA,KAAAlE,EAEA,IAAAmE,GAAAD,EAAAE,cAAA,SAEAD,GAAAE,KAAAJ,EACAC,EAAAI,KAAApE,YAAAiE,GAAAI,WAAAC,YAAAL,GA8bA,QAAAM,GAAAC,GAMA,GAAAC,KAAAD,GAAA,UAAAA,MAAAC,OACAC,EAAAC,GAAAD,KAAAF,EAEA,oBAAAE,IAAAC,GAAAC,SAAAJ,KAIA,UAAAE,GAAA,IAAAD,GACA,gBAAAA,MAAA,GAAAA,EAAA,IAAAD,IAuwEA,QAAAK,GAAAC,EAAAC,EAAAC,GACA,MAAAL,IAAAM,WAAAF,GACAJ,GAAAO,KAAAJ,EAAA,SAAAK,EAAAC,GACA,QAAAL,EAAAxG,KAAA4G,EAAAC,EAAAD,KAAAH,IAKAD,EAAAM,SACAV,GAAAO,KAAAJ,EAAA,SAAAK,GACA,MAAAA,KAAAJ,IAAAC,IAKA,gBAAAD,GACAJ,GAAAO,KAAAJ,EAAA,SAAAK,GACA,MAAAG,IAAA/G,KAAAwG,EAAAI,IAAA,IAAAH,IAKAO,GAAAC,KAAAT,GACAJ,GAAAc,OAAAV,EAAAD,EAAAE,IAIAD,EAAAJ,GAAAc,OAAAV,EAAAD,GACAH,GAAAO,KAAAJ,EAAA,SAAAK,GACA,MAAAG,IAAA/G,KAAAwG,EAAAI,IAAA,IAAAH,GAAA,IAAAG,EAAAE,YAkRA,QAAAK,GAAAC,EAAAC,GACA,MAAAD,IAAAC,KAAA,IAAAD,EAAAN,WACA,MAAAM,GA0EA,QAAAE,GAAAC,GACA,GAAAC,KAIA,OAHApB,IAAAqB,KAAAF,EAAAG,MAAAC,QAAA,SAAAC,EAAAC,GACAL,EAAAK,IAAA,IAEAL,EA4NA,QAAAM,GAAAC,GACA,MAAAA,GAEA,QAAAC,GAAAC,GACA,KAAAA,GAGA,QAAAC,GAAAC,EAAAC,EAAAC,GACA,GAAAC,EAEA,KAGAH,GAAA/B,GAAAM,WAAA4B,EAAAH,EAAAI,SACAD,EAAAtI,KAAAmI,GAAAK,KAAAJ,GAAAK,KAAAJ,GAGGF,GAAA/B,GAAAM,WAAA4B,EAAAH,EAAAO,MACHJ,EAAAtI,KAAAmI,EAAAC,EAAAC,GAOAD,EAAApI,KAAA2I,OAAAR,GAME,MAAAA,GAIFE,EAAArI,KAAA2I,OAAAR,IA8aA,QAAAS,KACArH,GAAAsH,oBAAA,mBAAAD,GACAvI,EAAAwI,oBAAA,OAAAD,GACAxC,GAAA0C,QAmGA,QAAAC,KACAhH,KAAAiH,QAAA5C,GAAA4C,QAAAD,EAAAE,MAwKA,QAAAC,GAAAC,GACA,eAAAA,GAIA,UAAAA,IAIA,SAAAA,EACA,KAIAA,OAAA,IACAA,EAGAC,GAAAnC,KAAAkC,GACAE,KAAAC,MAAAH,GAGAA,GAGA,QAAAI,GAAA3C,EAAA4C,EAAAL,GACA,GAAAM,EAIA,IAAAd,SAAAQ,GAAA,IAAAvC,EAAAE,SAIA,GAHA2C,EAAA,QAAAD,EAAAE,QAAAC,GAAA,OAAAC,cACAT,EAAAvC,EAAAiD,aAAAJ,GAEA,gBAAAN,GAAA,CACA,IACAA,EAAAD,EAAAC,GACI,MAAAzF,IAGJoG,GAAA9F,IAAA4C,EAAA4C,EAAAL,OAEAA,GAAAR,MAGA,OAAAQ,GAqSA,QAAAY,GAAAnD,EAAAoD,EAAAC,EAAAC,GACA,GAAAC,GACAC,EAAA,EACAC,EAAA,GACAC,EAAAJ,EACA,WACA,MAAAA,GAAA9C,OAEA,WACA,MAAAhB,IAAAmE,IAAA3D,EAAAoD,EAAA,KAEAQ,EAAAF,IACAG,EAAAR,KAAA,KAAA7D,GAAAsE,UAAAV,GAAA,SAGAW,GAAAvE,GAAAsE,UAAAV,IAAA,OAAAS,IAAAD,IACAI,GAAAC,KAAAzE,GAAAmE,IAAA3D,EAAAoD,GAEA,IAAAW,KAAA,KAAAF,EAAA,CAGAA,KAAAE,EAAA,GAGAV,QAGAU,GAAAH,GAAA,CAEA,GAIAJ,MAAA,KAGAO,GAAAP,EACAhE,GAAAjF,MAAAyF,EAAAoD,EAAAW,EAAAF,SAKAL,OAAAE,IAAAE,IAAA,IAAAJ,KAAAC,GAiBA,MAbAJ,KACAU,OAAAH,GAAA,EAGAL,EAAAF,EAAA,GACAU,GAAAV,EAAA,MAAAA,EAAA,IACAA,EAAA,GACAC,IACAA,EAAAO,OACAP,EAAAY,MAAAH,EACAT,EAAAa,IAAAZ,IAGAA,EAMA,QAAAa,GAAApE,GACA,GAAAqE,GACAxF,EAAAmB,EAAAsE,cACAC,EAAAvE,EAAAuE,SACAC,EAAAC,GAAAF,EAEA,OAAAC,GACAA,GAGAH,EAAAxF,EAAA6F,KAAA7J,YAAAgE,EAAAE,cAAAwF,IACAC,EAAAhF,GAAAmE,IAAAU,EAAA,WAEAA,EAAAnF,WAAAC,YAAAkF,GAEA,SAAAG,IACAA,EAAA,SAEAC,GAAAF,GAAAC,EAEAA,GAGA,QAAAG,GAAAhF,EAAAiF,GAOA,IANA,GAAAJ,GAAAxE,EACA6E,KACAC,EAAA,EACAxF,EAAAK,EAAAL,OAGQwF,EAAAxF,EAAgBwF,IACxB9E,EAAAL,EAAAmF,GACA9E,EAAAzF,QAIAiK,EAAAxE,EAAAzF,MAAAiK,QACAI,GAKA,SAAAJ,IACAK,EAAAC,GAAAC,GAAAC,IAAAhF,EAAA,iBACA6E,EAAAC,KACA9E,EAAAzF,MAAAiK,QAAA,KAGA,KAAAxE,EAAAzF,MAAAiK,SAAAS,GAAAjF,KACA6E,EAAAC,GAAAV,EAAApE,KAGA,SAAAwE,IACAK,EAAAC,GAAA,OAGAC,GAAA3H,IAAA4C,EAAA,UAAAwE,IAMA,KAAAM,EAAA,EAAiBA,EAAAxF,EAAgBwF,IACjC,MAAAD,EAAAC,KACAnF,EAAAmF,GAAAvK,MAAAiK,QAAAK,EAAAC,GAIA,OAAAnF,GAwDA,QAAAuF,GAAAC,EAAAC,GAIA,GAAAC,EAYA,OATAA,GADA,mBAAAF,GAAAG,qBACAH,EAAAG,qBAAAF,GAAA,KAEE,mBAAAD,GAAAI,iBACFJ,EAAAI,iBAAAH,GAAA,QAMArD,SAAAqD,MAAA5F,GAAA+E,SAAAY,EAAAC,GACA5F,GAAAgG,OAAAL,GAAAE,GAGAA,EAKA,QAAAI,GAAAC,EAAAC,GAIA,IAHA,GAAA1F,GAAA,EACA2F,EAAAF,EAAApG,OAEQW,EAAA2F,EAAO3F,IACf8E,GAAA3H,IACAsI,EAAAzF,GACA,cACA0F,GAAAZ,GAAAC,IAAAW,EAAA1F,GAAA,eAQA,QAAA4F,GAAAH,EAAAP,EAAAW,EAAAC,EAAAC,GAOA,IANA,GAAAhG,GAAAiG,EAAAb,EAAAc,EAAAC,EAAAC,EACAC,EAAAlB,EAAAmB,yBACAC,KACAtG,EAAA,EACA2F,EAAAF,EAAApG,OAEQW,EAAA2F,EAAO3F,IAGf,GAFAD,EAAA0F,EAAAzF,GAEAD,GAAA,IAAAA,EAGA,cAAAR,GAAAD,KAAAS,GAIAR,GAAAgG,MAAAe,EAAAvG,EAAAE,UAAAF,UAGI,IAAAwG,GAAAnG,KAAAL,GAIA,CAUJ,IATAiG,KAAAI,EAAAxL,YAAAsK,EAAApG,cAAA,QAGAqG,GAAAqB,GAAAxC,KAAAjE,KAAA,WAAAgD,cACAkD,EAAAQ,GAAAtB,IAAAsB,GAAAC,SACAV,EAAAW,UAAAV,EAAA,GAAA1G,GAAAqH,cAAA7G,GAAAkG,EAAA,GAGAE,EAAAF,EAAA,GACAE,KACAH,IAAAa,SAKAtH,IAAAgG,MAAAe,EAAAN,EAAAc,YAGAd,EAAAI,EAAAW,WAGAf,EAAAgB,YAAA,OAzBAV,GAAAW,KAAA/B,EAAAgC,eAAAnH,GAkCA,KAHAqG,EAAAY,YAAA,GAEAhH,EAAA,EACAD,EAAAuG,EAAAtG,MAGA,GAAA8F,GAAAvG,GAAA4H,QAAApH,EAAA+F,IAAA,EACAC,GACAA,EAAAkB,KAAAlH,OAgBA,IAXAmG,EAAA3G,GAAA2G,SAAAnG,EAAAsE,cAAAtE,GAGAiG,EAAAf,EAAAmB,EAAAxL,YAAAmF,GAAA,UAGAmG,GACAV,EAAAQ,GAIAH,EAEA,IADAM,EAAA,EACApG,EAAAiG,EAAAG,MACAiB,GAAAhH,KAAAL,EAAAT,MAAA,KACAuG,EAAAoB,KAAAlH,EAMA,OAAAqG,GAqCA,QAAAiB,KACA,SAGA,QAAAC,KACA,SAKA,QAAAC,KACA,IACA,MAAA7M,IAAA8M,cACE,MAAAC,KAGF,QAAA7K,GAAAmD,EAAA2H,EAAAC,EAAArF,EAAAsF,EAAAC,GACA,GAAAC,GAAAxI,CAGA,oBAAAoI,GAAA,CAGA,gBAAAC,KAGArF,KAAAqF,EACAA,EAAA7F,OAEA,KAAAxC,IAAAoI,GACA9K,EAAAmD,EAAAT,EAAAqI,EAAArF,EAAAoF,EAAApI,GAAAuI,EAEA,OAAA9H,GAsBA,GAnBA,MAAAuC,GAAA,MAAAsF,GAGAA,EAAAD,EACArF,EAAAqF,EAAA7F,QACE,MAAA8F,IACF,gBAAAD,IAGAC,EAAAtF,EACAA,EAAAR,SAIA8F,EAAAtF,EACAA,EAAAqF,EACAA,EAAA7F,SAGA8F,KAAA,EACAA,EAAAN,MACE,KAAAM,EACF,MAAA7H,EAeA,OAZA,KAAA8H,IACAC,EAAAF,EACAA,EAAA,SAAAG,GAIA,MADAxI,MAAAyI,IAAAD,GACAD,EAAAG,MAAA/M,KAAAgN,YAIAN,EAAAO,KAAAL,EAAAK,OAAAL,EAAAK,KAAA5I,GAAA4I,SAEApI,EAAAa,KAAA,WACArB,GAAAwI,MAAA/K,IAAA9B,KAAAwM,EAAAE,EAAAtF,EAAAqF,KA+pBA,QAAAS,GAAArI,EAAAsI,GACA,MAAA9I,IAAA+E,SAAAvE,EAAA,UACAR,GAAA+E,SAAA,KAAA+D,EAAApI,SAAAoI,IAAAtB,WAAA,MAEAhH,EAAAsF,qBAAA,aAAAtF,EAGAA,EAIA,QAAAuI,GAAAvI,GAEA,MADAA,GAAAT,MAAA,OAAAS,EAAAiD,aAAA,aAAAjD,EAAAT,KACAS,EAEA,QAAAwI,GAAAxI,GACA,GAAAc,GAAA2H,GAAAxE,KAAAjE,EAAAT,KAQA,OANAuB,GACAd,EAAAT,KAAAuB,EAAA,GAEAd,EAAA0I,gBAAA,QAGA1I,EAGA,QAAA2I,GAAAC,EAAAC,GACA,GAAA5I,GAAA2F,EAAArG,EAAAuJ,EAAAC,EAAAC,EAAAC,EAAAC,CAEA,QAAAL,EAAA3I,SAAA,CAKA,GAAA6E,GAAAoE,QAAAP,KACAE,EAAA/D,GAAAqE,OAAAR,GACAG,EAAAhE,GAAA3H,IAAAyL,EAAAC,GACAI,EAAAJ,EAAAI,QAEA,OACAH,GAAAM,OACAN,EAAAG,SAEA,KAAA3J,IAAA2J,GACA,IAAAjJ,EAAA,EAAA2F,EAAAsD,EAAA3J,GAAAD,OAA2CW,EAAA2F,EAAO3F,IAClDT,GAAAwI,MAAA/K,IAAA4L,EAAAtJ,EAAA2J,EAAA3J,GAAAU,IAOAiD,GAAAiG,QAAAP,KACAI,EAAA9F,GAAAkG,OAAAR,GACAK,EAAAzJ,GAAA8J,UAA8BN,GAE9B9F,GAAA9F,IAAAyL,EAAAI,KAKA,QAAAM,GAAAX,EAAAC,GACA,GAAAtE,GAAAsE,EAAAtE,SAAAvB,aAGA,WAAAuB,GAAAiF,GAAAnJ,KAAAuI,EAAArJ,MACAsJ,EAAAY,QAAAb,EAAAa,QAGE,UAAAlF,GAAA,aAAAA,IACFsE,EAAAa,aAAAd,EAAAc,cAIA,QAAAC,GAAAC,EAAAC,EAAAC,EAAA9D,GAGA6D,EAAAE,GAAA7B,SAAA2B,EAEA,IAAAxD,GAAA2D,EAAAlE,EAAAmE,EAAAC,EAAArL,EACAoB,EAAA,EACA2F,EAAAgE,EAAAtK,OACA6K,EAAAvE,EAAA,EACArE,EAAAsI,EAAA,GACA/J,EAAAN,GAAAM,WAAAyB,EAGA,IAAAzB,GACA8F,EAAA,mBAAArE,KACA6I,GAAAC,YAAAC,GAAAjK,KAAAkB,GACA,MAAAqI,GAAA/I,KAAA,SAAAiE,GACA,GAAA5J,GAAA0O,EAAAW,GAAAzF,EACAhF,KACA+J,EAAA,GAAAtI,EAAAnI,KAAA+B,KAAA2J,EAAA5J,EAAAsP,SAEAb,EAAAzO,EAAA2O,EAAAC,EAAA9D,IAIA,IAAAJ,IACAS,EAAAR,EAAAgE,EAAAD,EAAA,GAAAtF,eAAA,EAAAsF,EAAA5D,GACAgE,EAAA3D,EAAAW,WAEA,IAAAX,EAAAU,WAAAzH,SACA+G,EAAA2D,GAIAA,GAAAhE,GAAA,CAOA,IANAF,EAAAtG,GAAAiL,IAAAvF,EAAAmB,EAAA,UAAAkC,GACA0B,EAAAnE,EAAAxG,OAKUW,EAAA2F,EAAO3F,IACjBiK,EAAA7D,EAEApG,IAAAkK,IACAD,EAAA1K,GAAAkL,MAAAR,GAAA,MAGAD,GAIAzK,GAAAgG,MAAAM,EAAAZ,EAAAgF,EAAA,YAIAJ,EAAA1Q,KAAAwQ,EAAA3J,GAAAiK,EAAAjK,EAGA,IAAAgK,EAOA,IANApL,EAAAiH,IAAAxG,OAAA,GAAAgF,cAGA9E,GAAAiL,IAAA3E,EAAA0C,GAGAvI,EAAA,EAAgBA,EAAAgK,EAAgBhK,IAChCiK,EAAApE,EAAA7F,GACAoH,GAAAhH,KAAA6J,EAAA3K,MAAA,MACAwF,GAAAqE,OAAAc,EAAA,eACA1K,GAAA2G,SAAAtH,EAAAqL,KAEAA,EAAAtB,IAGApJ,GAAAmL,UACAnL,GAAAmL,SAAAT,EAAAtB,KAGAjK,EAAAuL,EAAAjD,YAAAnE,QAAA8H,GAAA,IAAA/L,IAQA,MAAA+K,GAGA,QAAAiB,GAAA7K,EAAA4H,EAAAkD,GAKA,IAJA,GAAAZ,GACA3D,EAAAqB,EAAApI,GAAAc,OAAAsH,EAAA5H,KACAC,EAAA,EAEQ,OAAAiK,EAAA3D,EAAAtG,IAA+BA,IACvC6K,GAAA,IAAAZ,EAAAhK,UACAV,GAAAuL,UAAA7F,EAAAgF,IAGAA,EAAAhL,aACA4L,GAAAtL,GAAA2G,SAAA+D,EAAA5F,cAAA4F,IACAzE,EAAAP,EAAAgF,EAAA,WAEAA,EAAAhL,WAAAC,YAAA+K,GAIA,OAAAlK,GA6VA,QAAAgL,GAAAhL,EAAA6C,EAAAoI,GACA,GAAAjN,GAAAkN,EAAAC,EAAA9F,EACA9K,EAAAyF,EAAAzF,KAoCA,OAlCA0Q,MAAAG,GAAApL,GAIAiL,IACA5F,EAAA4F,EAAAI,iBAAAxI,IAAAoI,EAAApI,GAEA,KAAAwC,GAAA7F,GAAA2G,SAAAnG,EAAAsE,cAAAtE,KACAqF,EAAA7F,GAAAjF,MAAAyF,EAAA6C,KAQAuH,GAAAkB,oBAAAC,GAAAlL,KAAAgF,IAAAmG,GAAAnL,KAAAwC,KAGA7E,EAAAzD,EAAAyD,MACAkN,EAAA3Q,EAAA2Q,SACAC,EAAA5Q,EAAA4Q,SAGA5Q,EAAA2Q,SAAA3Q,EAAA4Q,SAAA5Q,EAAAyD,MAAAqH,EACAA,EAAA4F,EAAAjN,MAGAzD,EAAAyD,QACAzD,EAAA2Q,WACA3Q,EAAA4Q,aAIApJ,SAAAsD,EAIAA,EAAA,GACAA,EAIA,QAAAoG,GAAAC,EAAAC,GAGA,OACA3G,IAAA,WACA,MAAA0G,gBAIAvQ,MAAA6J,KAKA7J,KAAA6J,IAAA2G,GAAAzD,MAAA/M,KAAAgN,aAsBA,QAAAyD,GAAA/I,GAGA,GAAAA,IAAAgJ,IACA,MAAAhJ,EAOA,KAHA,GAAAiJ,GAAAjJ,EAAA,GAAAkJ,cAAAlJ,EAAAmJ,MAAA,GACA/L,EAAAgM,GAAA3M,OAEAW,KAEA,GADA4C,EAAAoJ,GAAAhM,GAAA6L,EACAjJ,IAAAgJ,IACA,MAAAhJ,GAKA,QAAAqJ,GAAAlM,EAAAuB,EAAA4K,GAIA,GAAAC,GAAApI,GAAAC,KAAA1C,EACA,OAAA6K,GAGAnQ,KAAAoQ,IAAA,EAAAD,EAAA,IAAAD,GAAA,KAAAC,EAAA,UACA7K,EAGA,QAAA+K,GAAAtM,EAAA6C,EAAA0J,EAAAC,EAAAC,GACA,GAAAxM,GACAyM,EAAA,CAWA,KAPAzM,EADAsM,KAAAC,EAAA,oBACA,EAIA,UAAA3J,EAAA,IAGQ5C,EAAA,EAAOA,GAAA,EAGf,WAAAsM,IACAG,GAAAlN,GAAAmE,IAAA3D,EAAAuM,EAAAI,GAAA1M,IAAA,EAAAwM,IAGAD,GAGA,YAAAD,IACAG,GAAAlN,GAAAmE,IAAA3D,EAAA,UAAA2M,GAAA1M,IAAA,EAAAwM,IAIA,WAAAF,IACAG,GAAAlN,GAAAmE,IAAA3D,EAAA,SAAA2M,GAAA1M,GAAA,WAAAwM,MAKAC,GAAAlN,GAAAmE,IAAA3D,EAAA,UAAA2M,GAAA1M,IAAA,EAAAwM,GAGA,YAAAF,IACAG,GAAAlN,GAAAmE,IAAA3D,EAAA,SAAA2M,GAAA1M,GAAA,WAAAwM,IAKA,OAAAC,GAGA,QAAAE,GAAA5M,EAAA6C,EAAA0J,GAGA,GAAAG,GACAG,GAAA,EACAJ,EAAArB,GAAApL,GACAwM,EAAA,eAAAhN,GAAAmE,IAAA3D,EAAA,eAAAyM,EAYA,IAPAzM,EAAA8M,iBAAAxN,SACAoN,EAAA1M,EAAA+M,wBAAAlK,IAMA6J,GAAA,SAAAA,EAAA,CASA,GANAA,EAAA1B,EAAAhL,EAAA6C,EAAA4J,IACAC,EAAA,SAAAA,KACAA,EAAA1M,EAAAzF,MAAAsI,IAIA0I,GAAAlL,KAAAqM,GACA,MAAAA,EAKAG,GAAAL,IACApC,GAAA4C,qBAAAN,IAAA1M,EAAAzF,MAAAsI,IAGA6J,EAAAO,WAAAP,IAAA,EAIA,MAAAA,GACAJ,EACAtM,EACA6C,EACA0J,IAAAC,EAAA,oBACAK,EACAJ,GAEA,KAmQA,QAAAS,GAAAlN,EAAAW,EAAAyC,EAAAe,EAAAgJ,GACA,UAAAD,GAAAlS,UAAAF,KAAAkF,EAAAW,EAAAyC,EAAAe,EAAAgJ,GA0HA,QAAAC,KACAC,KACA5T,EAAAsE,sBAAAqP,GACA5N,GAAA8N,GAAAC,QAKA,QAAAC,KAIA,MAHA/T,GAAAgU,WAAA,WACAC,GAAA3L,SAEA2L,GAAAlO,GAAAmO,MAIA,QAAAC,GAAArO,EAAAsO,GACA,GAAAC,GACA7N,EAAA,EACA8N,GAAW9P,OAAAsB,EAKX,KADAsO,IAAA,IACQ5N,EAAA,EAAOA,GAAA,EAAA4N,EACfC,EAAAnB,GAAA1M,GACA8N,EAAA,SAAAD,GAAAC,EAAA,UAAAD,GAAAvO,CAOA,OAJAsO,KACAE,EAAAC,QAAAD,EAAA/P,MAAAuB,GAGAwO,EAGA,QAAAE,GAAA1M,EAAA6B,EAAA8K,GAKA,IAJA,GAAA5K,GACAsG,GAAAuE,EAAAC,SAAAhL,QAAA2G,OAAAoE,EAAAC,SAAA,MACAtJ,EAAA,EACAxF,EAAAsK,EAAAtK,OACQwF,EAAAxF,EAAgBwF,IACxB,GAAAxB,EAAAsG,EAAA9E,GAAA1L,KAAA8U,EAAA9K,EAAA7B,GAGA,MAAA+B,GAKA,QAAA+K,GAAArO,EAAAsO,EAAAC,GACA,GAAAnL,GAAA7B,EAAAiN,EAAAC,EAAAC,EAAAC,EAAAC,EAAApK,EACAqK,EAAA,SAAAP,IAAA,UAAAA,GACAQ,EAAA3T,KACA4T,KACAxU,EAAAyF,EAAAzF,MACAyU,EAAAhP,EAAAE,UAAA+E,GAAAjF,GACAiP,EAAAlK,GAAAC,IAAAhF,EAAA,SAGAuO,GAAAW,QACAT,EAAAjP,GAAA2P,YAAAnP,EAAA,MACA,MAAAyO,EAAAW,WACAX,EAAAW,SAAA,EACAV,EAAAD,EAAAY,MAAAC,KACAb,EAAAY,MAAAC,KAAA,WACAb,EAAAW,UACAV,MAIAD,EAAAW,WAEAN,EAAAS,OAAA,WAGAT,EAAAS,OAAA,WACAd,EAAAW,WACA5P,GAAA0P,MAAAlP,EAAA,MAAAV,QACAmP,EAAAY,MAAAC,WAOA,KAAAlM,IAAAkL,GAEA,GADA/M,EAAA+M,EAAAlL,GACAoM,GAAAnP,KAAAkB,GAAA,CAGA,SAFA+M,GAAAlL,GACAoL,KAAA,WAAAjN,EACAA,KAAAyN,EAAA,gBAIA,YAAAzN,IAAA0N,GAAAlN,SAAAkN,EAAA7L,GAKA,QAJA4L,IAAA,EAOAD,EAAA3L,GAAA6L,KAAA7L,IAAA5D,GAAAjF,MAAAyF,EAAAoD,GAMA,GADAuL,GAAAnP,GAAAiQ,cAAAnB,GACAK,IAAAnP,GAAAiQ,cAAAV,GAAA,CAKAF,GAAA,IAAA7O,EAAAE,WAKAqO,EAAAmB,UAAAnV,EAAAmV,SAAAnV,EAAAoV,UAAApV,EAAAqV,WAGAhB,EAAAK,KAAAzK,QACA,MAAAoK,IACAA,EAAA7J,GAAAC,IAAAhF,EAAA,YAEAwE,EAAAhF,GAAAmE,IAAA3D,EAAA,WACA,SAAAwE,IACAoK,EACApK,EAAAoK,GAIAjK,GAAA3E,IAAA,GACA4O,EAAA5O,EAAAzF,MAAAiK,SAAAoK,EACApK,EAAAhF,GAAAmE,IAAA3D,EAAA,WACA2E,GAAA3E,OAKA,WAAAwE,GAAA,iBAAAA,GAAA,MAAAoK,IACA,SAAApP,GAAAmE,IAAA3D,EAAA,WAGA2O,IACAG,EAAAlN,KAAA,WACArH,EAAAiK,QAAAoK,IAEA,MAAAA,IACApK,EAAAjK,EAAAiK,QACAoK,EAAA,SAAApK,EAAA,GAAAA,IAGAjK,EAAAiK,QAAA,iBAKA+J,EAAAmB,WACAnV,EAAAmV,SAAA,SACAZ,EAAAS,OAAA,WACAhV,EAAAmV,SAAAnB,EAAAmB,SAAA,GACAnV,EAAAoV,UAAApB,EAAAmB,SAAA,GACAnV,EAAAqV,UAAArB,EAAAmB,SAAA,MAKAf,GAAA,CACA,KAAAvL,IAAA2L,GAGAJ,IACAM,EACA,UAAAA,KACAD,EAAAC,EAAAD,QAGAC,EAAAlK,GAAAqE,OAAApJ,EAAA,UAAiDwE,QAAAoK,IAIjDJ,IACAS,EAAAD,WAIAA,GACArK,GAAA3E,IAAA,GAKA8O,EAAAlN,KAAA,WAKAoN,GACArK,GAAA3E,IAEA+E,GAAA8F,OAAA7K,EAAA,SACA,KAAAoD,IAAA2L,GACAvP,GAAAjF,MAAAyF,EAAAoD,EAAA2L,EAAA3L,OAMAuL,EAAAV,EAAAe,EAAAC,EAAA7L,GAAA,EAAAA,EAAA0L,GACA1L,IAAA6L,KACAA,EAAA7L,GAAAuL,EAAAzK,MACA8K,IACAL,EAAAxK,IAAAwK,EAAAzK,MACAyK,EAAAzK,MAAA,KAMA,QAAA2L,GAAAvB,EAAAwB,GACA,GAAAhL,GAAAjC,EAAAsK,EAAA5L,EAAAkN,CAGA,KAAA3J,IAAAwJ,GAeA,GAdAzL,EAAArD,GAAAuQ,UAAAjL,GACAqI,EAAA2C,EAAAjN,GACAtB,EAAA+M,EAAAxJ,GACAtF,GAAAwQ,QAAAzO,KACA4L,EAAA5L,EAAA,GACAA,EAAA+M,EAAAxJ,GAAAvD,EAAA,IAGAuD,IAAAjC,IACAyL,EAAAzL,GAAAtB,QACA+M,GAAAxJ,IAGA2J,EAAAjP,GAAAyQ,SAAApN,GACA4L,GAAA,UAAAA,GAAA,CACAlN,EAAAkN,EAAAyB,OAAA3O,SACA+M,GAAAzL,EAIA,KAAAiC,IAAAvD,GACAuD,IAAAwJ,KACAA,EAAAxJ,GAAAvD,EAAAuD,GACAgL,EAAAhL,GAAAqI,OAIA2C,GAAAjN,GAAAsK,EAKA,QAAAgB,GAAAnO,EAAAmQ,EAAAxP,GACA,GAAAyP,GACAC,EACAvL,EAAA,EACAxF,EAAA6O,EAAAmC,WAAAhR,OACAiR,EAAA/Q,GAAAgR,WAAAjB,OAAA,iBAGAhC,GAAAvN,OAEAuN,EAAA,WACA,GAAA8C,EACA,QAYA,KAVA,GAAAI,GAAA/C,IAAAF,IACAkD,EAAAzU,KAAAoQ,IAAA,EAAA6B,EAAAyC,UAAAzC,EAAA0C,SAAAH,GAIApM,EAAAqM,EAAAxC,EAAA0C,UAAA,EACAC,EAAA,EAAAxM,EACAS,EAAA,EACAxF,EAAA4O,EAAA4C,OAAAxR,OAEUwF,EAAAxF,EAAgBwF,IAC1BoJ,EAAA4C,OAAAhM,GAAAiM,IAAAF,EAKA,OAFAN,GAAAS,WAAAhR,GAAAkO,EAAA2C,EAAAH,IAEAG,EAAA,GAAAvR,EACAoR,GAEAH,EAAAU,YAAAjR,GAAAkO,KACA,IAGAA,EAAAqC,EAAA5O,SACA3B,OACAsO,MAAA9O,GAAA8J,UAA2B6G,GAC3B5B,KAAA/O,GAAA8J,QAAA,GACAwG,iBACA3C,OAAA3N,GAAA2N,OAAAxG,UACIhG,GACJuQ,mBAAAf,EACAgB,gBAAAxQ,EACAgQ,UAAAjD,IAAAF,IACAoD,SAAAjQ,EAAAiQ,SACAE,UACA7C,YAAA,SAAA7K,EAAAe,GACA,GAAAb,GAAA9D,GAAA0N,MAAAlN,EAAAkO,EAAAK,KAAAnL,EAAAe,EACA+J,EAAAK,KAAAuB,cAAA1M,IAAA8K,EAAAK,KAAApB,OAEA,OADAe,GAAA4C,OAAA5J,KAAA5D,GACAA,GAEA8N,KAAA,SAAAC,GACA,GAAAvM,GAAA,EAIAxF,EAAA+R,EAAAnD,EAAA4C,OAAAxR,OAAA,CACA,IAAA+Q,EACA,MAAAlV,KAGA,KADAkV,GAAA,EACWvL,EAAAxF,EAAgBwF,IAC3BoJ,EAAA4C,OAAAhM,GAAAiM,IAAA,EAUA,OANAM,IACAd,EAAAS,WAAAhR,GAAAkO,EAAA,MACAqC,EAAAU,YAAAjR,GAAAkO,EAAAmD,KAEAd,EAAAe,WAAAtR,GAAAkO,EAAAmD,IAEAlW,QAGAmT,EAAAJ,EAAAI,KAIA,KAFAuB,EAAAvB,EAAAJ,EAAAK,KAAAuB,eAEQhL,EAAAxF,EAAgBwF,IAExB,GADAsL,EAAAjC,EAAAmC,WAAAxL,GAAA1L,KAAA8U,EAAAlO,EAAAsO,EAAAJ,EAAAK,MAMA,MAJA/O,IAAAM,WAAAsQ,EAAAgB,QACA5R,GAAA2P,YAAAjB,EAAAlO,KAAAkO,EAAAK,KAAAW,OAAAkC,KACA5R,GAAA+R,MAAAnB,EAAAgB,KAAAhB,IAEAA,CAmBA,OAfA5Q,IAAAiL,IAAA6D,EAAAL,EAAAC,GAEA1O,GAAAM,WAAAoO,EAAAK,KAAArK,QACAgK,EAAAK,KAAArK,MAAA9K,KAAA4G,EAAAkO,GAGA1O,GAAA8N,GAAAkE,MACAhS,GAAA8J,OAAAiE,GACAvN,OACA8O,KAAAZ,EACAgB,MAAAhB,EAAAK,KAAAW,SAKAhB,EAAAuD,SAAAvD,EAAAK,KAAAkD,UACA7P,KAAAsM,EAAAK,KAAA3M,KAAAsM,EAAAK,KAAAmD,UACA7P,KAAAqM,EAAAK,KAAA1M,MACA0N,OAAArB,EAAAK,KAAAgB,QA0lBA,QAAAoC,GAAApQ,GACA,GAAAqQ,GAAArQ,EAAAT,MAAAC,OACA,OAAA6Q,GAAAC,KAAA,KAIA,QAAAC,GAAA9R,GACA,MAAAA,GAAAiD,cAAAjD,EAAAiD,aAAA,aA+mBA,QAAA8O,GAAAC,EAAA3S,EAAA4S,EAAAhV,GACA,GAAA4F,EAEA,IAAArD,GAAAwQ,QAAA3Q,GAGAG,GAAAqB,KAAAxB,EAAA,SAAAY,EAAAkB,GACA8Q,GAAAC,GAAA7R,KAAA2R,GAGA/U,EAAA+U,EAAA7Q,GAKA4Q,EACAC,EAAA,qBAAA7Q,IAAA,MAAAA,EAAAlB,EAAA,QACAkB,EACA8Q,EACAhV,SAKE,IAAAgV,GAAA,WAAAzS,GAAAD,KAAAF,GAUFpC,EAAA+U,EAAA3S,OAPA,KAAAwD,IAAAxD,GACA0S,EAAAC,EAAA,IAAAnP,EAAA,IAAAxD,EAAAwD,GAAAoP,EAAAhV,GA0HA,QAAAkV,GAAAC,GAGA,gBAAAC,EAAAC,GAEA,gBAAAD,KACAC,EAAAD,EACAA,EAAA,IAGA,IAAAE,GACAtS,EAAA,EACAuS,EAAAH,EAAArP,cAAAlC,MAAAC,OAEA,IAAAvB,GAAAM,WAAAwS,GAGA,KAAAC,EAAAC,EAAAvS,MAGA,MAAAsS,EAAA,IACAA,IAAAvG,MAAA,SACAoG,EAAAG,GAAAH,EAAAG,QAAAE,QAAAH,KAIAF,EAAAG,GAAAH,EAAAG,QAAArL,KAAAoL,IAQA,QAAAI,GAAAN,EAAAzR,EAAAwQ,EAAAwB,GAKA,QAAAC,GAAAL,GACA,GAAAM,EAcA,OAbAC,GAAAP,IAAA,EACA/S,GAAAqB,KAAAuR,EAAAG,OAAA,SAAAvR,EAAA+R,GACA,GAAAC,GAAAD,EAAApS,EAAAwQ,EAAAwB,EACA,uBAAAK,IACAC,GAAAH,EAAAE,GAKIC,IACJJ,EAAAG,GADI,QAHJrS,EAAA6R,UAAAC,QAAAO,GACAJ,EAAAI,IACA,KAKAH,EAlBA,GAAAC,MACAG,EAAAb,IAAAc,EAoBA,OAAAN,GAAAjS,EAAA6R,UAAA,MAAAM,EAAA,MAAAF,EAAA,KAMA,QAAAO,IAAAC,EAAAxK,GACA,GAAAhG,GAAAyQ,EACAC,EAAA9T,GAAA+T,aAAAD,eAEA,KAAA1Q,IAAAgG,GACA7G,SAAA6G,EAAAhG,MACA0Q,EAAA1Q,GAAAwQ,EAAAC,WAAwDzQ,GAAAgG,EAAAhG,GAOxD,OAJAyQ,IACA7T,GAAA8J,QAAA,EAAA8J,EAAAC,GAGAD,EAOA,QAAAI,IAAAzY,EAAA4X,EAAAc,GAOA,IALA,GAAAC,GAAAnU,EAAAoU,EAAAC,EACAC,EAAA9Y,EAAA8Y,SACArB,EAAAzX,EAAAyX,UAGA,MAAAA,EAAA,IACAA,EAAAsB,QACA/R,SAAA2R,IACAA,EAAA3Y,EAAAgZ,UAAApB,EAAAqB,kBAAA,gBAKA,IAAAN,EACA,IAAAnU,IAAAsU,GACA,GAAAA,EAAAtU,IAAAsU,EAAAtU,GAAAc,KAAAqT,GAAA,CACAlB,EAAAC,QAAAlT,EACA,OAMA,GAAAiT,EAAA,IAAAiB,GACAE,EAAAnB,EAAA,OACE,CAGF,IAAAjT,IAAAkU,GAAA,CACA,IAAAjB,EAAA,IAAAzX,EAAAkZ,WAAA1U,EAAA,IAAAiT,EAAA,KACAmB,EAAApU,CACA,OAEAqU,IACAA,EAAArU,GAKAoU,KAAAC,EAMA,GAAAD,EAIA,MAHAA,KAAAnB,EAAA,IACAA,EAAAC,QAAAkB,GAEAF,EAAAE,GAOA,QAAAO,IAAAnZ,EAAAoZ,EAAAxB,EAAAyB,GACA,GAAAC,GAAAC,EAAAC,EAAAtO,EAAAuO,EACAP,KAGAzB,EAAAzX,EAAAyX,UAAAxG,OAGA,IAAAwG,EAAA,GACA,IAAA+B,IAAAxZ,GAAAkZ,WACAA,EAAAM,EAAAvR,eAAAjI,EAAAkZ,WAAAM,EAOA,KAHAD,EAAA9B,EAAAsB,QAGAQ,GAcA,GAZAvZ,EAAA0Z,eAAAH,KACA3B,EAAA5X,EAAA0Z,eAAAH,IAAAH,IAIAK,GAAAJ,GAAArZ,EAAA2Z,aACAP,EAAApZ,EAAA2Z,WAAAP,EAAApZ,EAAAwX,WAGAiC,EAAAF,EACAA,EAAA9B,EAAAsB,QAKA,SAAAQ,EAEAA,EAAAE,MAGI,UAAAA,OAAAF,EAAA,CAMJ,GAHAC,EAAAN,EAAAO,EAAA,IAAAF,IAAAL,EAAA,KAAAK,IAGAC,EACA,IAAAF,IAAAJ,GAIA,GADAhO,EAAAoO,EAAAM,MAAA,KACA1O,EAAA,KAAAqO,IAGAC,EAAAN,EAAAO,EAAA,IAAAvO,EAAA,KACAgO,EAAA,KAAAhO,EAAA,KACA,CAGAsO,KAAA,EACAA,EAAAN,EAAAI,GAGSJ,EAAAI,MAAA,IACTC,EAAArO,EAAA,GACAuM,EAAAC,QAAAxM,EAAA,IAEA,OAOA,GAAAsO,KAAA,EAGA,GAAAA,GAAAxZ,EAAA6Z,OACAT,EAAAI,EAAAJ,OAEA,KACAA,EAAAI,EAAAJ,GACO,MAAArX,GACP,OACA+X,MAAA,cACAC,MAAAP,EAAAzX,EAAA,sBAAA0X,EAAA,OAAAF,IASA,OAASO,MAAA,UAAAtS,KAAA4R,GAynCT,QAAAY,IAAA/U,GACA,MAAAR,IAAAC,SAAAO,KAAA,IAAAA,EAAAE,UAAAF,EAAAgV,YA3mTA,GAAAC,OAEAta,GAAAlB,EAAAkB,SAEAua,GAAAC,OAAAC,eAEApJ,GAAAiJ,GAAAjJ,MAEAjC,GAAAkL,GAAAlL,OAEA7C,GAAA+N,GAAA/N,KAEA/G,GAAA8U,GAAA9U,QAEAkV,MAEAC,GAAAD,GAAAC,SAEAC,GAAAF,GAAAG,eAEAC,GAAAF,GAAAD,SAEAI,GAAAD,GAAArc,KAAA+b,QAEA/K,MAmBAuL,GAAA,QAGAnW,GAAA,SAAAoI,EAAAzC,GAIA,UAAA3F,IAAAqI,GAAA/M,KAAA8M,EAAAzC,IAKAyQ,GAAA,qCAGAC,GAAA,QACAC,GAAA,YAGAC,GAAA,SAAAC,EAAAC,GACA,MAAAA,GAAAlK,cAGAvM,IAAAqI,GAAArI,GAAAxE,WAGAkb,OAAAP,GAEAQ,YAAA3W,GAGAF,OAAA,EAEA8W,QAAA,WACA,MAAApK,IAAA5S,KAAA+B,OAKA6J,IAAA,SAAAqR,GAGA,aAAAA,EACArK,GAAA5S,KAAA+B,MAIAkb,EAAA,EAAAlb,KAAAkb,EAAAlb,KAAAmE,QAAAnE,KAAAkb,IAKAC,UAAA,SAAA5Q,GAGA,GAAAL,GAAA7F,GAAAgG,MAAArK,KAAAgb,cAAAzQ,EAMA,OAHAL,GAAAkR,WAAApb,KAGAkK,GAIAxE,KAAA,SAAAiJ,GACA,MAAAtK,IAAAqB,KAAA1F,KAAA2O,IAGAW,IAAA,SAAAX,GACA,MAAA3O,MAAAmb,UAAA9W,GAAAiL,IAAAtP,KAAA,SAAA6E,EAAAC,GACA,MAAA6J,GAAA1Q,KAAA4G,EAAAC,EAAAD,OAIAgM,MAAA,WACA,MAAA7Q,MAAAmb,UAAAtK,GAAA9D,MAAA/M,KAAAgN,aAGA6B,MAAA,WACA,MAAA7O,MAAAoP,GAAA,IAGAiM,KAAA,WACA,MAAArb,MAAAoP,IAAA,IAGAA,GAAA,SAAAtK,GACA,GAAAwW,GAAAtb,KAAAmE,OACA8G,GAAAnG,KAAA,EAAAwW,EAAA,EACA,OAAAtb,MAAAmb,UAAAlQ,GAAA,GAAAA,EAAAqQ,GAAAtb,KAAAiL,SAGAjC,IAAA,WACA,MAAAhJ,MAAAob,YAAApb,KAAAgb,eAKAjP,QACAwP,KAAAzB,GAAAyB,KACAC,OAAA1B,GAAA0B,QAGAnX,GAAA8J,OAAA9J,GAAAqI,GAAAyB,OAAA,WACA,GAAA3I,GAAAkC,EAAA+F,EAAAgO,EAAAC,EAAAnM,EACA0I,EAAAjL,UAAA,OACAlI,EAAA,EACAX,EAAA6I,UAAA7I,OACA+T,GAAA,CAsBA,KAnBA,iBAAAD,KACAC,EAAAD,EAGAA,EAAAjL,UAAAlI,OACAA,KAIA,gBAAAmT,IAAA5T,GAAAM,WAAAsT,KACAA,MAIAnT,IAAAX,IACA8T,EAAAjY,KACA8E,KAGQA,EAAAX,EAAYW,IAGpB,UAAAU,EAAAwH,UAAAlI,IAGA,IAAA4C,IAAAlC,GACAiI,EAAAwK,EAAAvQ,GACA+T,EAAAjW,EAAAkC,GAGAuQ,IAAAwD,IAKAvD,GAAAuD,IAAApX,GAAAsX,cAAAF,KACAC,EAAArX,GAAAwQ,QAAA4G,MAEAC,GACAA,GAAA,EACAnM,EAAA9B,GAAApJ,GAAAwQ,QAAApH,SAGA8B,EAAA9B,GAAApJ,GAAAsX,cAAAlO,QAIAwK,EAAAvQ,GAAArD,GAAA8J,OAAA+J,EAAA3I,EAAAkM,IAGK7U,SAAA6U,IACLxD,EAAAvQ,GAAA+T,GAOA,OAAAxD,IAGA5T,GAAA8J,QAGAlH,QAAA,UAAAuT,GAAA1Z,KAAA8a,UAAAjU,QAAA,UAGAkU,SAAA,EAEAlC,MAAA,SAAAmC,GACA,SAAAxY,OAAAwY,IAGAC,KAAA,aAEApX,WAAA,SAAAT,GACA,mBAAAG,GAAAD,KAAAF,IAGA2Q,QAAAmH,MAAAnH,QAEAvQ,SAAA,SAAAJ,GACA,aAAAA,SAAA5F,QAGA2d,UAAA,SAAA/X,GAKA,GAAAE,GAAAC,GAAAD,KAAAF,EACA,mBAAAE,GAAA,WAAAA,KAKA8X,MAAAhY,EAAA4N,WAAA5N,KAGAyX,cAAA,SAAAzX,GACA,GAAAiY,GAAAC,CAIA,UAAAlY,GAAA,oBAAAiW,GAAAlc,KAAAiG,QAIAiY,EAAApC,GAAA7V,MAQAkY,EAAAhC,GAAAnc,KAAAke,EAAA,gBAAAA,EAAAnB,YACA,kBAAAoB,IAAA9B,GAAArc,KAAAme,KAAA7B,MAGAjG,cAAA,SAAApQ,GAIA,GAAAwD,EAEA,KAAAA,IAAAxD,GACA,QAEA,WAGAE,KAAA,SAAAF,GACA,aAAAA,EACAA,EAAA,GAIA,gBAAAA,IAAA,kBAAAA,GACAgW,GAAAC,GAAAlc,KAAAiG,KAAA,eACAA,IAIAmY,WAAA,SAAA5Y,GACAD,EAAAC,IAMAmR,UAAA,SAAA0H,GACA,MAAAA,GAAA3U,QAAA+S,GAAA,OAAA/S,QAAAgT,GAAAC,KAGAxR,SAAA,SAAAvE,EAAA6C,GACA,MAAA7C,GAAAuE,UAAAvE,EAAAuE,SAAAvB,gBAAAH,EAAAG,eAGAnC,KAAA,SAAAxB,EAAAyK,GACA,GAAAxK,GAAAW,EAAA,CAEA,IAAAb,EAAAC,GAEA,IADAC,EAAAD,EAAAC,OACUW,EAAAX,GACVwK,EAAA1Q,KAAAiG,EAAAY,KAAAZ,EAAAY,OAAA,EADsBA,SAMtB,KAAAA,IAAAZ,GACA,GAAAyK,EAAA1Q,KAAAiG,EAAAY,KAAAZ,EAAAY,OAAA,EACA,KAKA,OAAAZ,IAIAqY,KAAA,SAAA1Y,GACA,aAAAA,EACA,IACAA,EAAA,IAAA8D,QAAA8S,GAAA,KAIA+B,UAAA,SAAA1C,EAAA2C,GACA,GAAAvS,GAAAuS,KAaA,OAXA,OAAA3C,IACA7V,EAAA+V,OAAAF,IACAzV,GAAAgG,MAAAH,EACA,gBAAA4P,IACAA,MAGA/N,GAAA9N,KAAAiM,EAAA4P,IAIA5P,GAGA+B,QAAA,SAAApH,EAAAiV,EAAAhV,GACA,aAAAgV,GAAA,EAAA9U,GAAA/G,KAAA6b,EAAAjV,EAAAC,IAKAuF,MAAA,SAAAwE,EAAA6N,GAKA,IAJA,GAAApB,IAAAoB,EAAAvY,OACA8G,EAAA,EACAnG,EAAA+J,EAAA1K,OAES8G,EAAAqQ,EAASrQ,IAClB4D,EAAA/J,KAAA4X,EAAAzR,EAKA,OAFA4D,GAAA1K,OAAAW,EAEA+J,GAGAjK,KAAA,SAAA2F,EAAAoE,EAAAgO,GASA,IARA,GAAAC,GACA3L,KACAnM,EAAA,EACAX,EAAAoG,EAAApG,OACA0Y,GAAAF,EAIS7X,EAAAX,EAAYW,IACrB8X,GAAAjO,EAAApE,EAAAzF,MACA8X,IAAAC,GACA5L,EAAAlF,KAAAxB,EAAAzF,GAIA,OAAAmM,IAIA3B,IAAA,SAAA/E,EAAAoE,EAAAmO,GACA,GAAA3Y,GAAAiC,EACAtB,EAAA,EACAoF,IAGA,IAAAjG,EAAAsG,GAEA,IADApG,EAAAoG,EAAApG,OACUW,EAAAX,EAAYW,IACtBsB,EAAAuI,EAAApE,EAAAzF,KAAAgY,GAEA,MAAA1W,GACA8D,EAAA6B,KAAA3F,OAMA,KAAAtB,IAAAyF,GACAnE,EAAAuI,EAAApE,EAAAzF,KAAAgY,GAEA,MAAA1W,GACA8D,EAAA6B,KAAA3F,EAMA,OAAAwI,IAAA7B,SAAA7C,IAIA+C,KAAA,EAIAmJ,MAAA,SAAA1J,EAAA1C,GACA,GAAAc,GAAA4D,EAAA0H,CAUA,IARA,gBAAApM,KACAc,EAAA4B,EAAA1C,GACAA,EAAA0C,EACAA,EAAA5B,GAKAzG,GAAAM,WAAA+H,GAaA,MARAgC,GAAAmC,GAAA5S,KAAA+O,UAAA,GACAoJ,EAAA,WACA,MAAA1J,GAAAK,MAAA/C,GAAAhK,KAAA0O,EAAAE,OAAAiC,GAAA5S,KAAA+O,cAIAoJ,EAAAnJ,KAAAP,EAAAO,KAAAP,EAAAO,MAAA5I,GAAA4I,OAEAmJ,GAGA5D,IAAAuK,KAAAvK,IAIAvD,aAGA,kBAAA+N,UACA3Y,GAAAqI,GAAAsQ,OAAAC,UAAAnD,GAAAkD,OAAAC,WAIA5Y,GAAAqB,KAAA,uEAAA8T,MAAA,KACA,SAAA1U,EAAA4C,GACAwS,GAAA,WAAAxS,EAAA,KAAAA,EAAAG,eAmBA,IAAAqV;;;;;;;;;;AAWA,SAAA5e,GA6MA,QAAA4e,GAAAzQ,EAAAzC,EAAAyS,EAAAU,GACA,GAAAjf,GAAA4G,EAAAD,EAAAuY,EAAAzX,EAAA0X,EAAAC,EACAC,EAAAvT,KAAAb,cAGApE,EAAAiF,IAAAjF,SAAA,CAKA,IAHA0X,QAGA,gBAAAhQ,QACA,IAAA1H,GAAA,IAAAA,GAAA,KAAAA,EAEA,MAAA0X,EAIA,KAAAU,KAEAnT,IAAAb,eAAAa,EAAAwT,KAAAhe,GACAie,EAAAzT,GAEAA,KAAAxK,EAEAke,GAAA,CAIA,QAAA3Y,IAAAY,EAAAgY,GAAA7U,KAAA2D,IAGA,GAAAvO,EAAAyH,EAAA,IAGA,OAAAZ,EAAA,CACA,KAAAF,EAAAmF,EAAAvK,eAAAvB,IAUA,MAAAue,EALA,IAAA5X,EAAA9G,KAAAG,EAEA,MADAue,GAAA1Q,KAAAlH,GACA4X,MAYA,IAAAc,IAAA1Y,EAAA0Y,EAAA9d,eAAAvB,KACA8M,EAAAhB,EAAAnF,IACAA,EAAA9G,KAAAG,EAGA,MADAue,GAAA1Q,KAAAlH,GACA4X,MAKK,IAAA9W,EAAA,GAEL,MADAoG,GAAAgB,MAAA0P,EAAAzS,EAAAG,qBAAAsC,IACAgQ,CAGK,KAAAve,EAAAyH,EAAA,KAAAsJ,EAAA2O,wBACL5T,EAAA4T,uBAGA,MADA7R,GAAAgB,MAAA0P,EAAAzS,EAAA4T,uBAAA1f,IACAue,EAKA,GAAAxN,EAAA4O,MACAC,EAAArR,EAAA,QACAsR,MAAA7Y,KAAAuH,IAAA,CAEA,OAAA1H,EACAwY,EAAAvT,EACAsT,EAAA7Q,MAMK,eAAAzC,EAAAZ,SAAAvB,cAAA,CAYL,KATAuV,EAAApT,EAAAlC,aAAA,OACAsV,IAAAzV,QAAAqW,GAAAC,IAEAjU,EAAAkU,aAAA,KAAAd,EAAAnW,GAIAoW,EAAAc,EAAA1R,GACA3H,EAAAuY,EAAAlZ,OACAW,KACAuY,EAAAvY,GAAA,IAAAsY,EAAA,IAAAgB,EAAAf,EAAAvY,GAEAwY,GAAAD,EAAA3G,KAAA,KAGA6G,EAAAc,GAAAnZ,KAAAuH,IAAA6R,EAAAtU,EAAAjG,aACAiG,EAGA,GAAAsT,EACA,IAIA,MAHAvR,GAAAgB,MAAA0P,EACAc,EAAAnT,iBAAAkT,IAEAb,EACM,MAAA8B,IACA,QACNnB,IAAAnW,GACA+C,EAAAuD,gBAAA,QASA,MAAAiR,GAAA/R,EAAA9E,QAAA8S,GAAA,MAAAzQ,EAAAyS,EAAAU,GASA,QAAAsB,KAGA,QAAAC,GAAAjX,EAAArB,GAMA,MAJAuY,GAAA5S,KAAAtE,EAAA,KAAAmX,EAAAC,mBAEAH,GAAAC,EAAAhG,SAEA+F,EAAAjX,EAAA,KAAArB,EARA,GAAAuY,KAUA,OAAAD,GAOA,QAAAI,GAAApS,GAEA,MADAA,GAAAzF,IAAA,EACAyF,EAOA,QAAAqS,GAAArS,GACA,GAAAsS,GAAAxf,EAAAoE,cAAA,WAEA,KACA,QAAA8I,EAAAsS,GACE,MAAArd,GACF,SACE,QAEFqd,EAAAjb,YACAib,EAAAjb,WAAAC,YAAAgb,GAGAA,EAAA,MASA,QAAAC,GAAArM,EAAAsM,GAIA,IAHA,GAAApF,GAAAlH,EAAA4G,MAAA,KACA1U,EAAAgV,EAAA3V,OAEAW,KACA8Z,EAAAO,WAAArF,EAAAhV,IAAAoa,EAUA,QAAAE,GAAAC,EAAAC,GACA,GAAAja,GAAAia,GAAAD,EACAE,EAAAla,GAAA,IAAAga,EAAAta,UAAA,IAAAua,EAAAva,UACAsa,EAAAG,YAAAF,EAAAE,WAGA,IAAAD,EACA,MAAAA,EAIA,IAAAla,EACA,KAAAA,IAAAoa,aACA,GAAApa,IAAAia,EACA,QAKA,OAAAD,GAAA,KAOA,QAAAK,GAAAtb,GACA,gBAAAS,GACA,GAAA6C,GAAA7C,EAAAuE,SAAAvB,aACA,iBAAAH,GAAA7C,EAAAT,UAQA,QAAAub,GAAAvb,GACA,gBAAAS,GACA,GAAA6C,GAAA7C,EAAAuE,SAAAvB,aACA,kBAAAH,GAAA,WAAAA,IAAA7C,EAAAT,UAQA,QAAAwb,GAAAC,GAGA,gBAAAhb,GAKA,cAAAA,GASAA,EAAAd,YAAAc,EAAAgb,YAAA,EAGA,SAAAhb,GACA,SAAAA,GAAAd,WACAc,EAAAd,WAAA8b,aAEAhb,EAAAgb,aAMAhb,EAAAib,aAAAD,GAIAhb,EAAAib,cAAAD,GACAE,GAAAlb,KAAAgb,EAGAhb,EAAAgb,aAKG,SAAAhb,IACHA,EAAAgb,cAYA,QAAAG,GAAAtT,GACA,MAAAoS,GAAA,SAAAmB,GAEA,MADAA,MACAnB,EAAA,SAAA3B,EAAAlM,GAMA,IALA,GAAAhG,GACAiV,EAAAxT,KAAAyQ,EAAAhZ,OAAA8b,GACAnb,EAAAob,EAAA/b,OAGAW,KACAqY,EAAAlS,EAAAiV,EAAApb,MACAqY,EAAAlS,KAAAgG,EAAAhG,GAAAkS,EAAAlS,SAYA,QAAAqT,GAAAtU,GACA,MAAAA,IAAA,mBAAAA,GAAAG,sBAAAH,EAyjCA,QAAAmW,MAuEA,QAAA/B,GAAA3H,GAIA,IAHA,GAAA3R,GAAA,EACAwW,EAAA7E,EAAAtS,OACAsI,EAAA,GACQ3H,EAAAwW,EAASxW,IACjB2H,GAAAgK,EAAA3R,GAAAsB,KAEA,OAAAqG,GAGA,QAAA2T,GAAAC,EAAAC,EAAAC,GACA,GAAAjb,GAAAgb,EAAAhb,IACAkb,EAAAF,EAAAG,KACAhZ,EAAA+Y,GAAAlb,EACAob,EAAAH,GAAA,eAAA9Y,EACAkZ,EAAAla,GAEA,OAAA6Z,GAAAzR,MAEA,SAAAhK,EAAAmF,EAAA4W,GACA,KAAA/b,IAAAS,IACA,OAAAT,EAAAE,UAAA2b,EACA,MAAAL,GAAAxb,EAAAmF,EAAA4W,EAGA,WAIA,SAAA/b,EAAAmF,EAAA4W,GACA,GAAAC,GAAAC,EAAAC,EACAC,GAAAC,EAAAN,EAGA,IAAAC,GACA,KAAA/b,IAAAS,IACA,QAAAT,EAAAE,UAAA2b,IACAL,EAAAxb,EAAAmF,EAAA4W,GACA,aAKA,MAAA/b,IAAAS,IACA,OAAAT,EAAAE,UAAA2b,EAOA,GANAK,EAAAlc,EAAAoC,KAAApC,EAAAoC,OAIA6Z,EAAAC,EAAAlc,EAAAqc,YAAAH,EAAAlc,EAAAqc,cAEAV,OAAA3b,EAAAuE,SAAAvB,cACAhD,IAAAS,IAAAT,MACO,KAAAgc,EAAAC,EAAArZ,KACPoZ,EAAA,KAAAI,GAAAJ,EAAA,KAAAF,EAGA,MAAAK,GAAA,GAAAH,EAAA,EAMA,IAHAC,EAAArZ,GAAAuZ,EAGAA,EAAA,GAAAX,EAAAxb,EAAAmF,EAAA4W,GACA,SAMA,UAIA,QAAAO,GAAAC,GACA,MAAAA,GAAAjd,OAAA,EACA,SAAAU,EAAAmF,EAAA4W,GAEA,IADA,GAAA9b,GAAAsc,EAAAjd,OACAW,KACA,IAAAsc,EAAAtc,GAAAD,EAAAmF,EAAA4W,GACA,QAGA,WAEAQ,EAAA,GAGA,QAAAC,GAAA5U,EAAA6U,EAAA7E,GAGA,IAFA,GAAA3X,GAAA,EACAwW,EAAAgG,EAAAnd,OACQW,EAAAwW,EAASxW,IACjBoY,EAAAzQ,EAAA6U,EAAAxc,GAAA2X,EAEA,OAAAA,GAGA,QAAA8E,GAAAC,EAAAlS,EAAAnK,EAAA6E,EAAA4W,GAOA,IANA,GAAA/b,GACA4c,KACA3c,EAAA,EACAwW,EAAAkG,EAAArd,OACAud,EAAA,MAAApS,EAEQxK,EAAAwW,EAASxW,KACjBD,EAAA2c,EAAA1c,MACAK,MAAAN,EAAAmF,EAAA4W,KACAa,EAAA1V,KAAAlH,GACA6c,GACApS,EAAAvD,KAAAjH,IAMA,OAAA2c,GAGA,QAAAE,GAAAC,EAAAnV,EAAA4T,EAAAwB,EAAAC,EAAAC,GAOA,MANAF,OAAA5a,KACA4a,EAAAF,EAAAE,IAEAC,MAAA7a,KACA6a,EAAAH,EAAAG,EAAAC,IAEAjD,EAAA,SAAA3B,EAAAV,EAAAzS,EAAA4W,GACA,GAAA1X,GAAApE,EAAAD,EACAmd,KACAC,KACAC,EAAAzF,EAAAtY,OAGAoG,EAAA4S,GAAAkE,EAAA5U,GAAA,IAAAzC,EAAAjF,UAAAiF,SAGAmY,GAAAP,IAAAzE,GAAA1Q,EAEAlC,EADAgX,EAAAhX,EAAAyX,EAAAJ,EAAA5X,EAAA4W,GAGAwB,EAAA/B,EAEAyB,IAAA3E,EAAAyE,EAAAM,GAAAL,MAMApF,EACA0F,CAQA,IALA9B,GACAA,EAAA8B,EAAAC,EAAApY,EAAA4W,GAIAiB,EAMA,IALA3Y,EAAAqY,EAAAa,EAAAH,GACAJ,EAAA3Y,KAAAc,EAAA4W,GAGA9b,EAAAoE,EAAA/E,OACAW,MACAD,EAAAqE,EAAApE,MACAsd,EAAAH,EAAAnd,MAAAqd,EAAAF,EAAAnd,IAAAD,GAKA,IAAAsY,GACA,GAAA2E,GAAAF,EAAA,CACA,GAAAE,EAAA,CAIA,IAFA5Y,KACApE,EAAAsd,EAAAje,OACAW,MACAD,EAAAud,EAAAtd,KAEAoE,EAAA6C,KAAAoW,EAAArd,GAAAD,EAGAid,GAAA,KAAAM,KAAAlZ,EAAA0X,GAKA,IADA9b,EAAAsd,EAAAje,OACAW,MACAD,EAAAud,EAAAtd,MACAoE,EAAA4Y,EAAA9c,GAAAmY,EAAAtY,GAAAmd,EAAAld,KAAA,IAEAqY,EAAAjU,KAAAuT,EAAAvT,GAAArE,SAOAud,GAAAb,EACAa,IAAA3F,EACA2F,EAAA5G,OAAA0G,EAAAE,EAAAje,QACAie,GAEAN,EACAA,EAAA,KAAArF,EAAA2F,EAAAxB,GAEA7U,EAAAgB,MAAA0P,EAAA2F,KAMA,QAAAC,GAAA5L,GAwBA,IAvBA,GAAA6L,GAAAjC,EAAApV,EACAqQ,EAAA7E,EAAAtS,OACAoe,EAAA3D,EAAA4D,SAAA/L,EAAA,GAAArS,MACAqe,EAAAF,GAAA3D,EAAA4D,SAAA,KACA1d,EAAAyd,EAAA,IAGAG,EAAAtC,EAAA,SAAAvb,GACA,MAAAA,KAAAyd,GACGG,GAAA,GACHE,EAAAvC,EAAA,SAAAvb,GACA,MAAAG,IAAAsd,EAAAzd,IAAA,GACG4d,GAAA,GACHrB,GAAA,SAAAvc,EAAAmF,EAAA4W,GACA,GAAA1W,IAAAqY,IAAA3B,GAAA5W,IAAA4Y,MACAN,EAAAtY,GAAAjF,SACA2d,EAAA7d,EAAAmF,EAAA4W,GACA+B,EAAA9d,EAAAmF,EAAA4W,GAGA,OADA0B,GAAA,KACApY,IAGQpF,EAAAwW,EAASxW,IACjB,GAAAub,EAAAzB,EAAA4D,SAAA/L,EAAA3R,GAAAV,MACAgd,GAAAhB,EAAAe,EAAAC,GAAAf,QACG,CAIH,GAHAA,EAAAzB,EAAAzZ,OAAAsR,EAAA3R,GAAAV,MAAA2I,MAAA,KAAA0J,EAAA3R,GAAAmM,SAGAoP,EAAApZ,GAAA,CAGA,IADAgE,IAAAnG,EACWmG,EAAAqQ,IACXsD,EAAA4D,SAAA/L,EAAAxL,GAAA7G,MADoB6G,KAKpB,MAAA0W,GACA7c,EAAA,GAAAqc,EAAAC,GACAtc,EAAA,GAAAsZ,EAEA3H,EAAA5F,MAAA,EAAA/L,EAAA,GAAA8J,QAAuCxI,MAAA,MAAAqQ,EAAA3R,EAAA,GAAAV,KAAA,UACvCuD,QAAA8S,GAAA,MACA4F,EACAvb,EAAAmG,GAAAoX,EAAA5L,EAAA5F,MAAA/L,EAAAmG,IACAA,EAAAqQ,GAAA+G,EAAA5L,IAAA5F,MAAA5F,IACAA,EAAAqQ,GAAA8C,EAAA3H,IAGA2K,EAAArV,KAAAsU,GAIA,MAAAc,GAAAC,GAGA,QAAAyB,GAAAC,EAAAC,GACA,GAAAC,GAAAD,EAAA5e,OAAA,EACA8e,EAAAH,EAAA3e,OAAA,EACA+e,EAAA,SAAA/F,EAAAnT,EAAA4W,EAAAnE,EAAA0G,GACA,GAAAte,GAAAoG,EAAAoV,EACA+C,EAAA,EACAte,EAAA,IACA0c,EAAArE,MACAkG,KACAC,EAAAV,EAEArY,EAAA4S,GAAA8F,GAAArE,EAAA2E,KAAA,QAAAJ,GAEAK,EAAAvC,GAAA,MAAAqC,EAAA,EAAAxiB,KAAA8a,UAAA,GACAN,EAAA/Q,EAAApG,MASA,KAPAgf,IACAP,EAAA5Y,IAAAxK,GAAAwK,GAAAmZ,GAMUre,IAAAwW,GAAA,OAAAzW,EAAA0F,EAAAzF,IAAwCA,IAAA,CAClD,GAAAme,GAAApe,EAAA,CAMA,IALAoG,EAAA,EACAjB,GAAAnF,EAAAsE,gBAAA3J,IACAie,EAAA5Y,GACA+b,GAAAlD,GAEA2C,EAAAyC,EAAA7X,MACA,GAAAoV,EAAAxb,EAAAmF,GAAAxK,EAAAohB,GAAA,CACAnE,EAAA1Q,KAAAlH,EACA,OAGAse,IACAlC,EAAAuC,GAKAR,KAEAne,GAAAwb,GAAAxb,IACAue,IAIAjG,GACAqE,EAAAzV,KAAAlH,IAgBA,GATAue,GAAAte,EASAke,GAAAle,IAAAse,EAAA,CAEA,IADAnY,EAAA,EACAoV,EAAA0C,EAAA9X,MACAoV,EAAAmB,EAAA6B,EAAArZ,EAAA4W,EAGA,IAAAzD,EAAA,CAEA,GAAAiG,EAAA,EACA,KAAAte,KACA0c,EAAA1c,IAAAue,EAAAve,KACAue,EAAAve,GAAA2e,EAAAxlB,KAAAwe,GAMA4G,GAAA9B,EAAA8B,GAIAtX,EAAAgB,MAAA0P,EAAA4G,GAGAF,IAAAhG,GAAAkG,EAAAlf,OAAA,GACAif,EAAAL,EAAA5e,OAAA,GAEA+Y,EAAAwG,WAAAjH,GAUA,MALA0G,KACAlC,EAAAuC,EACAZ,EAAAU,GAGA9B,EAGA,OAAAwB,GACAlE,EAAAoE,GACAA,EA/gEA,GAAApe,GACAmK,EACA2P,EACA+E,EACAC,EACAzF,EACA0F,EACArF,EACAoE,EACAkB,EACAC,EAGAtG,EACAje,EACAwkB,EACAtG,EACAK,EACAkG,EACAhT,EACAjG,EAGA/D,EAAA,cAAA8V,MACAS,EAAAlf,EAAAkB,SACAyhB,EAAA,EACAxa,EAAA,EACAyd,EAAAzF,IACA0F,EAAA1F,IACAX,EAAAW,IACA2F,EAAA,SAAA/E,EAAAC,GAIA,MAHAD,KAAAC,IACAyE,GAAA,GAEA,GAIA3J,KAAaC,eACbP,KACA2J,EAAA3J,EAAA2J,IACAY,EAAAvK,EAAA/N,KACAA,EAAA+N,EAAA/N,KACA8E,EAAAiJ,EAAAjJ,MAGA7L,GAAA,SAAAsf,EAAAzf,GAGA,IAFA,GAAAC,GAAA,EACAwW,EAAAgJ,EAAAngB,OACSW,EAAAwW,EAASxW,IAClB,GAAAwf,EAAAxf,KAAAD,EACA,MAAAC,EAGA,WAGAyf,GAAA,6HAKAC,GAAA,sBAGAC,GAAA,gCAGAC,GAAA,MAAAF,GAAA,KAAAC,GAAA,OAAAD,GAEA,gBAAAA,GAEA,2DAAAC,GAAA,OAAAD,GACA,OAEAG,GAAA,KAAAF,GAAA,wFAKAC,GAAA,eAMAE,GAAA,GAAAC,QAAAL,GAAA,SACA/J,GAAA,GAAAoK,QAAA,IAAAL,GAAA,8BAAAA,GAAA,UAEAM,GAAA,GAAAD,QAAA,IAAAL,GAAA,KAAAA,GAAA,KACAO,GAAA,GAAAF,QAAA,IAAAL,GAAA,WAAAA,GAAA,IAAAA,GAAA,KAEAQ,GAAA,GAAAH,QAAA,IAAAL,GAAA,iBAAAA,GAAA,YAEAS,GAAA,GAAAJ,QAAAF,IACAO,GAAA,GAAAL,QAAA,IAAAJ,GAAA,KAEAU,IACAC,GAAA,GAAAP,QAAA,MAAAJ,GAAA,KACAY,MAAA,GAAAR,QAAA,QAAAJ,GAAA,KACAa,IAAA,GAAAT,QAAA,KAAAJ,GAAA,SACAc,KAAA,GAAAV,QAAA,IAAAH,IACAc,OAAA,GAAAX,QAAA,IAAAF,IACAc,MAAA,GAAAZ,QAAA,yDAAAL,GACA,+BAAAA,GAAA,cAAAA,GACA,aAAAA,GAAA,cACAkB,KAAA,GAAAb,QAAA,OAAAN,GAAA,UAGAoB,aAAA,GAAAd,QAAA,IAAAL,GAAA,mDACAA,GAAA,mBAAAA,GAAA,yBAGAoB,GAAA,sCACAC,GAAA,SAEAC,GAAA,yBAGAnI,GAAA,mCAEAU,GAAA,OAIA0H,GAAA,GAAAlB,QAAA,qBAA4CL,GAAA,MAAAA,GAAA,aAC5CwB,GAAA,SAAAngB,EAAAogB,EAAAC,GACA,GAAAC,GAAA,KAAAF,EAAA,KAIA,OAAAE,QAAAD,EACAD,EACAE,EAAA,EAEAC,OAAAC,aAAAF,EAAA,OAEAC,OAAAC,aAAAF,GAAA,cAAAA,EAAA,QAKAnI,GAAA,sDACAC,GAAA,SAAAqI,EAAAC,GACA,MAAAA,GAGA,OAAAD,EACA,IAIAA,EAAAzV,MAAA,WAAAyV,EAAAE,WAAAF,EAAAniB,OAAA,GAAAgW,SAAA,QAIA,KAAAmM,GAOAG,GAAA,WACAhJ,KAGAsC,GAAAK,EACA,SAAAvb,GACA,MAAAA,GAAAgb,YAAA,YAAAhb,IAAA,SAAAA,MAEGS,IAAA,aAAAmb,KAAA,UAIH,KACA1U,EAAAgB,MACA+M,EAAAjJ,EAAA5S,KAAAuf,EAAA5R,YACA4R,EAAA5R,YAIAkO,EAAA0D,EAAA5R,WAAAzH,QAAAY,SACC,MAAApD,GACDoK,GAASgB,MAAA+M,EAAA3V,OAGT,SAAA8T,EAAAyO,GACArC,EAAAtX,MAAAkL,EAAApH,EAAA5S,KAAAyoB,KAKA,SAAAzO,EAAAyO,GAIA,IAHA,GAAAzb,GAAAgN,EAAA9T,OACAW,EAAA,EAEAmT,EAAAhN,KAAAyb,EAAA5hB,OACAmT,EAAA9T,OAAA8G,EAAA,IAoVAgE,EAAAiO,EAAAjO,WAOA2U,EAAA1G,EAAA0G,MAAA,SAAA/e,GAGA,GAAA8hB,GAAA9hB,MAAAsE,eAAAtE,GAAA8hB,eACA,SAAAA,GAAA,SAAAA,EAAAvd,UAQAqU,EAAAP,EAAAO,YAAA,SAAA1O,GACA,GAAA6X,GAAAC,EACAnjB,EAAAqL,IAAA5F,eAAA4F,EAAAyO,CAGA,OAAA9Z,KAAAlE,GAAA,IAAAkE,EAAAqB,UAAArB,EAAAijB,iBAKAnnB,EAAAkE,EACAsgB,EAAAxkB,EAAAmnB,gBACAjJ,GAAAkG,EAAApkB,GAIAge,IAAAhe,IACAqnB,EAAArnB,EAAAqa,cAAAgN,EAAAtnB,MAAAsnB,IAGAA,EAAAC,iBACAD,EAAAC,iBAAA,SAAAL,IAAA,GAGGI,EAAAE,aACHF,EAAAE,YAAA,WAAAN,KAUAxX,EAAAyV,WAAA3F,EAAA,SAAAC,GAEA,MADAA,GAAAgI,UAAA,KACAhI,EAAAlX,aAAA,eAOAmH,EAAA9E,qBAAA4U,EAAA,SAAAC,GAEA,MADAA,GAAAtf,YAAAF,EAAAynB,cAAA,MACAjI,EAAA7U,qBAAA,KAAAhG,SAIA8K,EAAA2O,uBAAAkI,GAAA5gB,KAAA1F,EAAAoe,wBAMA3O,EAAAiY,QAAAnI,EAAA,SAAAC,GAEA,MADAgF,GAAAtkB,YAAAsf,GAAAjhB,GAAAkJ,GACAzH,EAAA2nB,oBAAA3nB,EAAA2nB,kBAAAlgB,GAAA9C,SAIA8K,EAAAiY,SACAtI,EAAAzZ,OAAA,YAAApH,GACA,GAAAqpB,GAAArpB,EAAA4J,QAAAoe,GAAAC,GACA,iBAAAnhB,GACA,MAAAA,GAAAiD,aAAA,QAAAsf,IAGAxI,EAAA2E,KAAA,YAAAxlB,EAAAiM,GACA,sBAAAA,GAAAvK,gBAAAie,EAAA,CACA,GAAA7Y,GAAAmF,EAAAvK,eAAA1B,EACA,OAAA8G,cAIA+Z,EAAAzZ,OAAA,YAAApH,GACA,GAAAqpB,GAAArpB,EAAA4J,QAAAoe,GAAAC,GACA,iBAAAnhB,GACA,GAAAkK,GAAA,mBAAAlK,GAAAwiB,kBACAxiB,EAAAwiB,iBAAA,KACA,OAAAtY,MAAA3I,QAAAghB,IAMAxI,EAAA2E,KAAA,YAAAxlB,EAAAiM,GACA,sBAAAA,GAAAvK,gBAAAie,EAAA,CACA,GAAA3O,GAAAjK,EAAAyF,EACA1F,EAAAmF,EAAAvK,eAAA1B,EAEA,IAAA8G,EAAA,CAIA,GADAkK,EAAAlK,EAAAwiB,iBAAA,MACAtY,KAAA3I,QAAArI,EACA,OAAA8G,EAMA,KAFA0F,EAAAP,EAAAmd,kBAAAppB,GACA+G,EAAA,EACAD,EAAA0F,EAAAzF,MAEA,GADAiK,EAAAlK,EAAAwiB,iBAAA,MACAtY,KAAA3I,QAAArI,EACA,OAAA8G,GAKA,YAMA+Z,EAAA2E,KAAA,IAAAtU,EAAA9E,qBACA,SAAAF,EAAAD,GACA,yBAAAA,GAAAG,qBACAH,EAAAG,qBAAAF,GAGIgF,EAAA4O,IACJ7T,EAAAI,iBAAAH,GADI,QAKJ,SAAAA,EAAAD,GACA,GAAAnF,GACAiG,KACAhG,EAAA,EAEA2X,EAAAzS,EAAAG,qBAAAF,EAGA,UAAAA,EAAA,CACA,KAAApF,EAAA4X,EAAA3X,MACA,IAAAD,EAAAE,UACA+F,EAAAiB,KAAAlH,EAIA,OAAAiG,GAEA,MAAA2R,IAIAmC,EAAA2E,KAAA,MAAAtU,EAAA2O,wBAAA,SAAAoJ,EAAAhd,GACA,sBAAAA,GAAA4T,wBAAAF,EACA,MAAA1T,GAAA4T,uBAAAoJ,IAUA/C,KAOAlG,MAEA9O,EAAA4O,IAAAiI,GAAA5gB,KAAA1F,EAAA4K,qBAGA2U,EAAA,SAAAC,GAMAgF,EAAAtkB,YAAAsf,GAAAvT,UAAA,UAAAxE,EAAA,qBACAA,EAAA,kEAOA+X,EAAA5U,iBAAA,wBAAAjG,QACA4Z,EAAAhS,KAAA,SAAAyY,GAAA,gBAKAxF,EAAA5U,iBAAA,cAAAjG,QACA4Z,EAAAhS,KAAA,MAAAyY,GAAA,aAAAD,GAAA,KAIAvF,EAAA5U,iBAAA,QAAAnD,EAAA,MAAA9C,QACA4Z,EAAAhS,KAAA,MAMAiT,EAAA5U,iBAAA,YAAAjG,QACA4Z,EAAAhS,KAAA,YAMAiT,EAAA5U,iBAAA,KAAAnD,EAAA,MAAA9C,QACA4Z,EAAAhS,KAAA,cAIAgT,EAAA,SAAAC,GACAA,EAAAvT,UAAA,mFAKA,IAAA6b,GAAA9nB,EAAAoE,cAAA,QACA0jB,GAAApJ,aAAA,iBACAc,EAAAtf,YAAA4nB,GAAApJ,aAAA,YAIAc,EAAA5U,iBAAA,YAAAjG,QACA4Z,EAAAhS,KAAA,OAAAyY,GAAA,eAKA,IAAAxF,EAAA5U,iBAAA,YAAAjG,QACA4Z,EAAAhS,KAAA,wBAKAiY,EAAAtkB,YAAAsf,GAAAa,UAAA,EACA,IAAAb,EAAA5U,iBAAA,aAAAjG,QACA4Z,EAAAhS,KAAA,wBAIAiT,EAAA5U,iBAAA,QACA2T,EAAAhS,KAAA,YAIAkD,EAAAsY,gBAAAzB,GAAA5gB,KAAA+L,EAAA+S,EAAA/S,SACA+S,EAAAwD,uBACAxD,EAAAyD,oBACAzD,EAAA0D,kBACA1D,EAAA2D,qBAEA5I,EAAA,SAAAC,GAGA/P,EAAA2Y,kBAAA3W,EAAAhT,KAAA+gB,EAAA,KAIA/N,EAAAhT,KAAA+gB,EAAA,aACAiF,EAAAlY,KAAA,KAAA4Y,MAIA5G,IAAA5Z,QAAA,GAAA0gB,QAAA9G,EAAArH,KAAA,MACAuN,IAAA9f,QAAA,GAAA0gB,QAAAZ,EAAAvN,KAAA,MAIAkQ,EAAAd,GAAA5gB,KAAA8e,EAAA6D,yBAKA7c,EAAA4b,GAAAd,GAAA5gB,KAAA8e,EAAAhZ,UACA,SAAAqU,EAAAC,GACA,GAAAwI,GAAA,IAAAzI,EAAAta,SAAAsa,EAAAsH,gBAAAtH,EACA0I,EAAAzI,KAAAvb,UACA,OAAAsb,KAAA0I,SAAA,IAAAA,EAAAhjB,YACA+iB,EAAA9c,SACA8c,EAAA9c,SAAA+c,GACA1I,EAAAwI,yBAAA,GAAAxI,EAAAwI,wBAAAE,MAGA,SAAA1I,EAAAC,GACA,GAAAA,EACA,KAAAA,IAAAvb,YACA,GAAAub,IAAAD,EACA,QAIA,WAOA+E,EAAAwC,EACA,SAAAvH,EAAAC,GAGA,GAAAD,IAAAC,EAEA,MADAyE,IAAA,EACA,CAIA,IAAAiE,IAAA3I,EAAAwI,yBAAAvI,EAAAuI,uBACA,OAAAG,GACAA,GAIAA,GAAA3I,EAAAlW,eAAAkW,MAAAC,EAAAnW,eAAAmW,GACAD,EAAAwI,wBAAAvI,GAGA,EAGA,EAAA0I,IACA/Y,EAAAgZ,cAAA3I,EAAAuI,wBAAAxI,KAAA2I,EAGA3I,IAAA7f,GAAA6f,EAAAlW,gBAAAqU,GAAAxS,EAAAwS,EAAA6B,IACA,EAEAC,IAAA9f,GAAA8f,EAAAnW,gBAAAqU,GAAAxS,EAAAwS,EAAA8B,GACA,EAIAwE,EACA9e,GAAA8e,EAAAzE,GAAAra,GAAA8e,EAAAxE,GACA,EAGA,EAAA0I,GAAA,MAEA,SAAA3I,EAAAC,GAEA,GAAAD,IAAAC,EAEA,MADAyE,IAAA,EACA,CAGA,IAAA1e,GACAP,EAAA,EACAojB,EAAA7I,EAAAtb,WACAgkB,EAAAzI,EAAAvb,WACAokB,GAAA9I,GACA+I,GAAA9I,EAGA,KAAA4I,IAAAH,EACA,MAAA1I,KAAA7f,GAAA,EACA8f,IAAA9f,EAAA,EACA0oB,GAAA,EACAH,EAAA,EACAjE,EACA9e,GAAA8e,EAAAzE,GAAAra,GAAA8e,EAAAxE,GACA,CAGG,IAAA4I,IAAAH,EACH,MAAA3I,GAAAC,EAAAC,EAKA,KADAja,EAAAga,EACAha,IAAAtB,YACAokB,EAAA7Q,QAAAjS,EAGA,KADAA,EAAAia,EACAja,IAAAtB,YACAqkB,EAAA9Q,QAAAjS,EAIA,MAAA8iB,EAAArjB,KAAAsjB,EAAAtjB,IACAA,GAGA,OAAAA,GAEAsa,EAAA+I,EAAArjB,GAAAsjB,EAAAtjB,IAGAqjB,EAAArjB,KAAA0Y,GAAA,EACA4K,EAAAtjB,KAAA0Y,EAAA,EACA,GAGAhe,GA3YAA,GA8YA0d,EAAAjM,QAAA,SAAAoX,EAAA7jB,GACA,MAAA0Y,GAAAmL,EAAA,UAAA7jB,IAGA0Y,EAAAqK,gBAAA,SAAA1iB,EAAAwjB,GASA,IAPAxjB,EAAAsE,eAAAtE,KAAArF,GACAie,EAAA5Y,GAIAwjB,IAAA1gB,QAAAqd,GAAA,UAEA/V,EAAAsY,iBAAA7J,IACAI,EAAAuK,EAAA,QACApE,MAAA/e,KAAAmjB,OACAtK,MAAA7Y,KAAAmjB,IAEA,IACA,GAAAne,GAAA+G,EAAAhT,KAAA4G,EAAAwjB,EAGA,IAAAne,GAAA+E,EAAA2Y,mBAGA/iB,EAAArF,UAAA,KAAAqF,EAAArF,SAAAuF,SACA,MAAAmF,GAEG,MAAAvI,IAGH,MAAAub,GAAAmL,EAAA7oB,EAAA,MAAAqF,IAAAV,OAAA,GAGA+Y,EAAAlS,SAAA,SAAAhB,EAAAnF,GAKA,OAHAmF,EAAAb,eAAAa,KAAAxK,GACAie,EAAAzT,GAEAgB,EAAAhB,EAAAnF,IAGAqY,EAAAoL,KAAA,SAAAzjB,EAAA6C,IAEA7C,EAAAsE,eAAAtE,KAAArF,GACAie,EAAA5Y,EAGA,IAAA6H,GAAAkS,EAAAO,WAAAzX,EAAAG,eAEA0J,EAAA7E,GAAA0N,EAAAnc,KAAA2gB,EAAAO,WAAAzX,EAAAG,eACA6E,EAAA7H,EAAA6C,GAAAgW,GACA9W,MAEA,OAAAA,UAAA2K,EACAA,EACAtC,EAAAyV,aAAAhH,EACA7Y,EAAAiD,aAAAJ,IACA6J,EAAA1M,EAAAwiB,iBAAA3f,KAAA6J,EAAAgX,UACAhX,EAAAnL,MACA,MAGA8W,EAAAsL,OAAA,SAAAC,GACA,OAAAA,EAAA,IAAA9gB,QAAAqW,GAAAC,KAGAf,EAAAvD,MAAA,SAAAmC,GACA,SAAAxY,OAAA,0CAAAwY,IAOAoB,EAAAwG,WAAA,SAAAjH,GACA,GAAA5X,GACA6jB,KACAzd,EAAA,EACAnG,EAAA,CAOA,IAJAif,GAAA9U,EAAA0Z,iBACA7E,GAAA7U,EAAA2Z,YAAAnM,EAAA5L,MAAA,GACA4L,EAAAlB,KAAA6I,GAEAL,EAAA,CACA,KAAAlf,EAAA4X,EAAA3X,MACAD,IAAA4X,EAAA3X,KACAmG,EAAAyd,EAAA3c,KAAAjH,GAGA,MAAAmG,KACAwR,EAAAjB,OAAAkN,EAAAzd,GAAA,GAQA,MAFA6Y,GAAA,KAEArH,GAOAkH,EAAAzG,EAAAyG,QAAA,SAAA9e,GACA,GAAAkK,GACA7E,EAAA,GACApF,EAAA,EACAC,EAAAF,EAAAE,QAEA,IAAAA,GAME,OAAAA,GAAA,IAAAA,GAAA,KAAAA,EAAA,CAGF,mBAAAF,GAAAiH,YACA,MAAAjH,GAAAiH,WAGA,KAAAjH,IAAAgH,WAAgChH,EAAMA,IAAA4a,YACtCvV,GAAAyZ,EAAA9e,OAGE,QAAAE,GAAA,IAAAA,EACF,MAAAF,GAAAgkB,cAhBA,MAAA9Z,EAAAlK,EAAAC,MAEAoF,GAAAyZ,EAAA5U,EAkBA,OAAA7E,IAGA0U,EAAA1B,EAAA4L,WAGAjK,YAAA,GAEAkK,aAAAjK,EAEAnZ,MAAAwf,GAEAhG,cAEAoE,QAEAf,UACAwG,KAAQ1jB,IAAA,aAAAuJ,OAAA,GACRoa,KAAQ3jB,IAAA,cACR4jB,KAAQ5jB,IAAA,kBAAAuJ,OAAA,GACRsa,KAAQ7jB,IAAA,oBAGRsc,WACA2D,KAAA,SAAA5f,GAUA,MATAA,GAAA,GAAAA,EAAA,GAAAgC,QAAAoe,GAAAC,IAGArgB,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,QAAAgC,QAAAoe,GAAAC,IAEA,OAAArgB,EAAA,KACAA,EAAA,OAAAA,EAAA,QAGAA,EAAAkL,MAAA,MAGA4U,MAAA,SAAA9f,GA6BA,MAlBAA,GAAA,GAAAA,EAAA,GAAAkC,cAEA,QAAAlC,EAAA,GAAAkL,MAAA,MAEAlL,EAAA,IACAuX,EAAAvD,MAAAhU,EAAA,IAKAA,EAAA,KAAAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,mBAAAA,EAAA,YAAAA,EAAA,KACAA,EAAA,KAAAA,EAAA,GAAAA,EAAA,YAAAA,EAAA,KAGIA,EAAA,IACJuX,EAAAvD,MAAAhU,EAAA,IAGAA,GAGA6f,OAAA,SAAA7f,GACA,GAAAyjB,GACAC,GAAA1jB,EAAA,IAAAA,EAAA,EAEA,OAAAwf,IAAA,MAAAjgB,KAAAS,EAAA,IACA,MAIAA,EAAA,GACAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,OAGI0jB,GAAApE,GAAA/f,KAAAmkB,KAEJD,EAAAjL,EAAAkL,GAAA,MAEAD,EAAAC,EAAArkB,QAAA,IAAAqkB,EAAAllB,OAAAilB,GAAAC,EAAAllB,UAGAwB,EAAA,GAAAA,EAAA,GAAAkL,MAAA,EAAAuY,GACAzjB,EAAA,GAAA0jB,EAAAxY,MAAA,EAAAuY,IAIAzjB,EAAAkL,MAAA,QAIA1L,QAEAmgB,IAAA,SAAAgE,GACA,GAAAlgB,GAAAkgB,EAAA3hB,QAAAoe,GAAAC,IAAAne,aACA,aAAAyhB,EACA,WAAgB,UAChB,SAAAzkB,GACA,MAAAA,GAAAuE,UAAAvE,EAAAuE,SAAAvB,gBAAAuB,IAIAic,MAAA,SAAA2B,GACA,GAAAuC,GAAArF,EAAA8C,EAAA,IAEA,OAAAuC,KACAA,EAAA,GAAA1E,QAAA,MAAAL,GAAA,IAAAwC,EAAA,IAAAxC,GAAA,SACAN,EAAA8C,EAAA,SAAAniB,GACA,MAAA0kB,GAAArkB,KAAA,gBAAAL,GAAAmiB,WAAAniB,EAAAmiB,WAAA,mBAAAniB,GAAAiD,cAAAjD,EAAAiD,aAAA,iBAIAyd,KAAA,SAAA7d,EAAA8hB,EAAAC,GACA,gBAAA5kB,GACA,GAAAoQ,GAAAiI,EAAAoL,KAAAzjB,EAAA6C,EAEA,cAAAuN,EACA,OAAAuU,GAEAA,IAIAvU,GAAA,GAEA,MAAAuU,EAAAvU,IAAAwU,EACA,OAAAD,EAAAvU,IAAAwU,EACA,OAAAD,EAAAC,GAAA,IAAAxU,EAAAjQ,QAAAykB,GACA,OAAAD,EAAAC,GAAAxU,EAAAjQ,QAAAykB,IAAA,EACA,OAAAD,EAAAC,GAAAxU,EAAApE,OAAA4Y,EAAAtlB,UAAAslB,EACA,OAAAD,GAAA,IAAAvU,EAAAtN,QAAAid,GAAA,UAAA5f,QAAAykB,IAAA,EACA,OAAAD,IAAAvU,IAAAwU,GAAAxU,EAAApE,MAAA,EAAA4Y,EAAAtlB,OAAA,KAAAslB,EAAA,QAKAhE,MAAA,SAAArhB,EAAAslB,EAAAzJ,EAAApR,EAAAwM,GACA,GAAAsO,GAAA,QAAAvlB,EAAAyM,MAAA,KACA+Y,EAAA,SAAAxlB,EAAAyM,OAAA,GACAgZ,EAAA,YAAAH,CAEA,YAAA7a,GAAA,IAAAwM,EAGA,SAAAxW,GACA,QAAAA,EAAAd,YAGA,SAAAc,EAAAmF,EAAA4W,GACA,GAAAlC,GAAAoC,EAAAC,EAAAhS,EAAA+a,EAAA/gB,EACAzD,EAAAqkB,IAAAC,EAAA,gCACAG,EAAAllB,EAAAd,WACA2D,EAAAmiB,GAAAhlB,EAAAuE,SAAAvB,cACAmiB,GAAApJ,IAAAiJ,EACAtK,GAAA,CAEA,IAAAwK,EAAA,CAGA,GAAAJ,EAAA,CACA,KAAArkB,GAAA,CAEA,IADAyJ,EAAAlK,EACAkK,IAAAzJ,IACA,GAAAukB,EACA9a,EAAA3F,SAAAvB,gBAAAH,EACA,IAAAqH,EAAAhK,SAEA,QAIAgE,GAAAzD,EAAA,SAAAlB,IAAA2E,GAAA,cAEA,SAMA,GAHAA,GAAA6gB,EAAAG,EAAAle,WAAAke,EAAApe,WAGAie,GAAAI,GAkBA,IAbAjb,EAAAgb,EACAhJ,EAAAhS,EAAA9H,KAAA8H,EAAA9H,OAIA6Z,EAAAC,EAAAhS,EAAAmS,YACAH,EAAAhS,EAAAmS,cAEAxC,EAAAoC,EAAA1c,OACA0lB,EAAApL,EAAA,KAAAuC,GAAAvC,EAAA,GACAa,EAAAuK,GAAApL,EAAA,GACA3P,EAAA+a,GAAAC,EAAAne,WAAAke,GAEA/a,IAAA+a,GAAA/a,KAAAzJ,KAGAia,EAAAuK,EAAA,IAAA/gB,EAAA0a,OAGA,OAAA1U,EAAAhK,YAAAwa,GAAAxQ,IAAAlK,EAAA,CACAic,EAAA1c,IAAA6c,EAAA6I,EAAAvK,EACA,YAuBA,IAjBAyK,IAEAjb,EAAAlK,EACAkc,EAAAhS,EAAA9H,KAAA8H,EAAA9H,OAIA6Z,EAAAC,EAAAhS,EAAAmS,YACAH,EAAAhS,EAAAmS,cAEAxC,EAAAoC,EAAA1c,OACA0lB,EAAApL,EAAA,KAAAuC,GAAAvC,EAAA,GACAa,EAAAuK,GAKAvK,KAAA,EAEA,MAAAxQ,IAAA+a,GAAA/a,KAAAzJ,KACAia,EAAAuK,EAAA,IAAA/gB,EAAA0a,UAEAoG,EACA9a,EAAA3F,SAAAvB,gBAAAH,EACA,IAAAqH,EAAAhK,cACAwa,IAGAyK,IACAjJ,EAAAhS,EAAA9H,KAAA8H,EAAA9H,OAIA6Z,EAAAC,EAAAhS,EAAAmS,YACAH,EAAAhS,EAAAmS,cAEAJ,EAAA1c,IAAA6c,EAAA1B,IAGAxQ,IAAAlK,MAUA,MADA0a,IAAAlE,EACAkE,IAAA1Q,GAAA0Q,EAAA1Q,IAAA,GAAA0Q,EAAA1Q,GAAA,KAKA2W,OAAA,SAAAyE,EAAAhK,GAKA,GAAAvR,GACAhC,EAAAkS,EAAA+F,QAAAsF,IAAArL,EAAAuB,WAAA8J,EAAApiB,gBACAqV,EAAAvD,MAAA,uBAAAsQ,EAKA,OAAAvd,GAAAzF,GACAyF,EAAAuT,GAIAvT,EAAAvI,OAAA,GACAuK,GAAAub,IAAA,GAAAhK,GACArB,EAAAuB,WAAA9F,eAAA4P,EAAApiB,eACAiX,EAAA,SAAA3B,EAAAlM,GAIA,IAHA,GAAAiZ,GACAC,EAAAzd,EAAAyQ,EAAA8C,GACAnb,EAAAqlB,EAAAhmB,OACAW,KACAolB,EAAAllB,GAAAmY,EAAAgN,EAAArlB,IACAqY,EAAA+M,KAAAjZ,EAAAiZ,GAAAC,EAAArlB,MAGA,SAAAD,GACA,MAAA6H,GAAA7H,EAAA,EAAA6J,KAIAhC,IAIAiY,SAEAjgB,IAAAoa,EAAA,SAAArS,GAIA,GAAA6a,MACA7K,KACA4D,EAAAwD,EAAApX,EAAA9E,QAAA8S,GAAA,MAEA,OAAA4F,GAAApZ,GACA6X,EAAA,SAAA3B,EAAAlM,EAAAjH,EAAA4W,GAMA,IALA,GAAA/b,GACA2c,EAAAnB,EAAAlD,EAAA,KAAAyD,MACA9b,EAAAqY,EAAAhZ,OAGAW,MACAD,EAAA2c,EAAA1c,MACAqY,EAAArY,KAAAmM,EAAAnM,GAAAD,MAIA,SAAAA,EAAAmF,EAAA4W,GAKA,MAJA0G,GAAA,GAAAziB,EACAwb,EAAAiH,EAAA,KAAA1G,EAAAnE,GAEA6K,EAAA,SACA7K,EAAAgH,SAIA2G,IAAAtL,EAAA,SAAArS,GACA,gBAAA5H,GACA,MAAAqY,GAAAzQ,EAAA5H,GAAAV,OAAA,KAIA6G,SAAA8T,EAAA,SAAAjb,GAEA,MADAA,KAAA8D,QAAAoe,GAAAC,IACA,SAAAnhB,GACA,OAAAA,EAAAiH,aAAAjH,EAAAwlB,WAAA1G,EAAA9e,IAAAG,QAAAnB,IAAA,KAWAymB,KAAAxL,EAAA,SAAAwL,GAMA,MAJApF,IAAAhgB,KAAAolB,GAAA,KACApN,EAAAvD,MAAA,qBAAA2Q,GAEAA,IAAA3iB,QAAAoe,GAAAC,IAAAne,cACA,SAAAhD,GACA,GAAA0lB,EACA,GACA,IAAAA,EAAA7M,EACA7Y,EAAAylB,KACAzlB,EAAAiD,aAAA,aAAAjD,EAAAiD,aAAA,QAGA,MADAyiB,KAAA1iB,cACA0iB,IAAAD,GAAA,IAAAC,EAAAvlB,QAAAslB,EAAA,YAEKzlB,IAAAd,aAAA,IAAAc,EAAAE,SACL,aAKAkT,OAAA,SAAApT,GACA,GAAA2lB,GAAAlsB,EAAAmsB,UAAAnsB,EAAAmsB,SAAAD,IACA,OAAAA,MAAA3Z,MAAA,KAAAhM,EAAA9G,IAGA2sB,KAAA,SAAA7lB,GACA,MAAAA,KAAAmf,GAGA2G,MAAA,SAAA9lB,GACA,MAAAA,KAAArF,EAAA8M,iBAAA9M,EAAAorB,UAAAprB,EAAAorB,gBAAA/lB,EAAAT,MAAAS,EAAAgmB,OAAAhmB,EAAAimB,WAIAlqB,QAAAgf,GAAA,GACAC,SAAAD,GAAA,GAEAtR,QAAA,SAAAzJ,GAGA,GAAAuE,GAAAvE,EAAAuE,SAAAvB,aACA,iBAAAuB,KAAAvE,EAAAyJ,SAAA,WAAAlF,KAAAvE,EAAA6S,UAGAA,SAAA,SAAA7S,GAOA,MAJAA,GAAAd,YACAc,EAAAd,WAAAgnB,cAGAlmB,EAAA6S,YAAA,GAIAxD,MAAA,SAAArP,GAKA,IAAAA,IAAAgH,WAAgChH,EAAMA,IAAA4a,YACtC,GAAA5a,EAAAE,SAAA,EACA,QAGA,WAGAglB,OAAA,SAAAllB,GACA,OAAA+Z,EAAA+F,QAAA,MAAA9f,IAIAmmB,OAAA,SAAAnmB,GACA,MAAAghB,IAAA3gB,KAAAL,EAAAuE,WAGAke,MAAA,SAAAziB,GACA,MAAA+gB,IAAA1gB,KAAAL,EAAAuE,WAGA6hB,OAAA,SAAApmB,GACA,GAAA6C,GAAA7C,EAAAuE,SAAAvB,aACA,iBAAAH,GAAA,WAAA7C,EAAAT,MAAA,WAAAsD,GAGA7D,KAAA,SAAAgB,GACA,GAAAyjB,EACA,iBAAAzjB,EAAAuE,SAAAvB,eACA,SAAAhD,EAAAT,OAIA,OAAAkkB,EAAAzjB,EAAAiD,aAAA,mBAAAwgB,EAAAzgB,gBAIAgH,MAAAmR,EAAA,WACA,YAGA3E,KAAA2E,EAAA,SAAAE,EAAA/b,GACA,OAAAA,EAAA,KAGAiL,GAAA4Q,EAAA,SAAAE,EAAA/b,EAAA8b,GACA,OAAAA,EAAA,EAAAA,EAAA9b,EAAA8b,KAGAiL,KAAAlL,EAAA,SAAAE,EAAA/b,GAEA,IADA,GAAAW,GAAA,EACUA,EAAAX,EAAYW,GAAA,EACtBob,EAAAnU,KAAAjH,EAEA,OAAAob,KAGAiL,IAAAnL,EAAA,SAAAE,EAAA/b,GAEA,IADA,GAAAW,GAAA,EACUA,EAAAX,EAAYW,GAAA,EACtBob,EAAAnU,KAAAjH,EAEA,OAAAob,KAGAkL,GAAApL,EAAA,SAAAE,EAAA/b,EAAA8b,GAEA,IADA,GAAAnb,GAAAmb,EAAA,EAAAA,EAAA9b,EAAA8b,IACUnb,GAAA,GACVob,EAAAnU,KAAAjH,EAEA,OAAAob,KAGAmL,GAAArL,EAAA,SAAAE,EAAA/b,EAAA8b,GAEA,IADA,GAAAnb,GAAAmb,EAAA,EAAAA,EAAA9b,EAAA8b,IACUnb,EAAAX,GACV+b,EAAAnU,KAAAjH,EAEA,OAAAob,OAKAtB,EAAA+F,QAAA,IAAA/F,EAAA+F,QAAA,EAGA,KAAA7f,KAAYwmB,OAAA,EAAAC,UAAA,EAAAC,MAAA,EAAAC,UAAA,EAAAC,OAAA,GACZ9M,EAAA+F,QAAA7f,GAAA4a,EAAA5a,EAEA,KAAAA,KAAY6mB,QAAA,EAAAC,OAAA,GACZhN,EAAA+F,QAAA7f,GAAA6a,EAAA7a,EAmnBA,OA9mBAqb,GAAAtgB,UAAA+e,EAAAiN,QAAAjN,EAAA+F,QACA/F,EAAAuB,WAAA,GAAAA,GAEAhC,EAAAjB,EAAAiB,SAAA,SAAA1R,EAAAqf,GACA,GAAA3B,GAAAxkB,EAAA8Q,EAAArS,EACA2nB,EAAA1O,EAAA2O,EACAC,EAAA9H,EAAA1X,EAAA,IAEA,IAAAwf,EACA,MAAAH,GAAA,EAAAG,EAAApb,MAAA,EAOA,KAJAkb,EAAAtf,EACA4Q,KACA2O,EAAApN,EAAAgD,UAEAmK,GAAA,CAGA5B,KAAAxkB,EAAAmf,GAAAhc,KAAAijB,MACApmB,IAEAomB,IAAAlb,MAAAlL,EAAA,GAAAxB,SAAA4nB,GAEA1O,EAAAtR,KAAA0K,OAGA0T,GAAA,GAGAxkB,EAAAof,GAAAjc,KAAAijB,MACA5B,EAAAxkB,EAAAgT,QACAlC,EAAA1K,MACA3F,MAAA+jB,EAEA/lB,KAAAuB,EAAA,GAAAgC,QAAA8S,GAAA,OAEAsR,IAAAlb,MAAAsZ,EAAAhmB,QAIA,KAAAC,IAAAwa,GAAAzZ,SACAQ,EAAAwf,GAAA/gB,GAAA0E,KAAAijB,KAAAC,EAAA5nB,MACAuB,EAAAqmB,EAAA5nB,GAAAuB,MACAwkB,EAAAxkB,EAAAgT,QACAlC,EAAA1K,MACA3F,MAAA+jB,EACA/lB,OACA6M,QAAAtL,IAEAomB,IAAAlb,MAAAsZ,EAAAhmB,QAIA,KAAAgmB,EACA,MAOA,MAAA2B,GACAC,EAAA5nB,OACA4nB,EACA7O,EAAAvD,MAAAlN,GAEA0X,EAAA1X,EAAA4Q,GAAAxM,MAAA,IA+XAgT,EAAA3G,EAAA2G,QAAA,SAAApX,EAAA9G,GACA,GAAAb,GACAie,KACAD,KACAmJ,EAAAnO,EAAArR,EAAA,IAEA,KAAAwf,EAAA,CAMA,IAJAtmB,IACAA,EAAAwY,EAAA1R,IAEA3H,EAAAa,EAAAxB,OACAW,KACAmnB,EAAA5J,EAAA1c,EAAAb,IACAmnB,EAAAhlB,GACA8b,EAAAhX,KAAAkgB,GAEAnJ,EAAA/W,KAAAkgB,EAKAA,GAAAnO,EAAArR,EAAAoW,EAAAC,EAAAC,IAGAkJ,EAAAxf,WAEA,MAAAwf,IAYAzN,EAAAtB,EAAAsB,OAAA,SAAA/R,EAAAzC,EAAAyS,EAAAU,GACA,GAAArY,GAAA2R,EAAAyV,EAAA9nB,EAAAmf,EACA4I,EAAA,kBAAA1f,MACA9G,GAAAwX,GAAAgB,EAAA1R,EAAA0f,EAAA1f,YAMA,IAJAgQ,QAIA,IAAA9W,EAAAxB,OAAA,CAIA,GADAsS,EAAA9Q,EAAA,GAAAA,EAAA,GAAAkL,MAAA,GACA4F,EAAAtS,OAAA,WAAA+nB,EAAAzV,EAAA,IAAArS,MACA,IAAA4F,EAAAjF,UAAA2Y,GAAAkB,EAAA4D,SAAA/L,EAAA,GAAArS,MAAA,CAGA,GADA4F,GAAA4U,EAAA2E,KAAA,GAAA2I,EAAAjb,QAAA,GAAAtJ,QAAAoe,GAAAC,IAAAhc,QAAA,IACAA,EACA,MAAAyS,EAGI0P,KACJniB,IAAAjG,YAGA0I,IAAAoE,MAAA4F,EAAAkC,QAAAvS,MAAAjC,QAKA,IADAW,EAAAqgB,GAAA,aAAAjgB,KAAAuH,GAAA,EAAAgK,EAAAtS,OACAW,MACAonB,EAAAzV,EAAA3R,IAGA8Z,EAAA4D,SAAApe,EAAA8nB,EAAA9nB,QAGA,IAAAmf,EAAA3E,EAAA2E,KAAAnf,MAEA+Y,EAAAoG,EACA2I,EAAAjb,QAAA,GAAAtJ,QAAAoe,GAAAC,IACA3H,GAAAnZ,KAAAuR,EAAA,GAAArS,OAAAka,EAAAtU,EAAAjG,aAAAiG,IACA,CAKA,GAFAyM,EAAA+E,OAAA1W,EAAA,GACA2H,EAAA0Q,EAAAhZ,QAAAia,EAAA3H,IACAhK,EAEA,MADAV,GAAAgB,MAAA0P,EAAAU,GACAV,CAGA,QAeA,OAPA0P,GAAAtI,EAAApX,EAAA9G,IACAwX,EACAnT,GACA0T,EACAjB,GACAzS,GAAAqU,GAAAnZ,KAAAuH,IAAA6R,EAAAtU,EAAAjG,aAAAiG,GAEAyS,GAMAxN,EAAA2Z,WAAA3hB,EAAAuS,MAAA,IAAA+B,KAAA6I,GAAA1N,KAAA,MAAAzP,EAIAgI,EAAA0Z,mBAAA5E,EAGAtG,IAIAxO,EAAAgZ,aAAAlJ,EAAA,SAAAC,GAEA,SAAAA,EAAA6I,wBAAAroB,EAAAoE,cAAA,eAMAmb,EAAA,SAAAC,GAEA,MADAA,GAAAvT,UAAA,mBACA,MAAAuT,EAAAnT,WAAA/D,aAAA,WAEAmX,EAAA,kCAAApa,EAAA6C,EAAAkc,GACA,IAAAA,EACA,MAAA/e,GAAAiD,aAAAJ,EAAA,SAAAA,EAAAG,cAAA,OAOAoH,EAAAyV,YAAA3F,EAAA,SAAAC,GAGA,MAFAA,GAAAvT,UAAA,WACAuT,EAAAnT,WAAAqS,aAAA,YACA,KAAAc,EAAAnT,WAAA/D,aAAA,YAEAmX,EAAA,iBAAApa,EAAA6C,EAAAkc,GACA,IAAAA,GAAA,UAAA/e,EAAAuE,SAAAvB,cACA,MAAAhD,GAAA0J,eAOAwQ,EAAA,SAAAC,GACA,aAAAA,EAAAlX,aAAA,eAEAmX,EAAAsF,GAAA,SAAA1f,EAAA6C,EAAAkc,GACA,GAAArS,EACA,KAAAqS,EACA,MAAA/e,GAAA6C,MAAA,EAAAA,EAAAG,eACA0J,EAAA1M,EAAAwiB,iBAAA3f,KAAA6J,EAAAgX,UACAhX,EAAAnL,MACA,OAKA8W,GAEC5e,EAID+F,IAAAkf,KAAArG,GACA7Y,GAAAgkB,KAAAnL,GAAA4L,UAGAzkB,GAAAgkB,KAAA,KAAAhkB,GAAAgkB,KAAA1D,QACAtgB,GAAAqf,WAAArf,GAAA+nB,OAAAlP,GAAAwG,WACArf,GAAAR,KAAAqZ,GAAAyG,QACAtf,GAAAgoB,SAAAnP,GAAA0G,MACAvf,GAAA2G,SAAAkS,GAAAlS,SACA3G,GAAAioB,eAAApP,GAAAsL,MAKA,IAAAljB,IAAA,SAAAT,EAAAS,EAAAinB,GAIA,IAHA,GAAApC,MACAqC,EAAA5lB,SAAA2lB,GAEA1nB,IAAAS,KAAA,IAAAT,EAAAE,UACA,OAAAF,EAAAE,SAAA,CACA,GAAAynB,GAAAnoB,GAAAQ,GAAA4nB,GAAAF,GACA,KAEApC,GAAApe,KAAAlH,GAGA,MAAAslB,IAIAuC,GAAA,SAAAC,EAAA9nB,GAGA,IAFA,GAAAslB,MAEQwC,EAAGA,IAAAlN,YACX,IAAAkN,EAAA5nB,UAAA4nB,IAAA9nB,GACAslB,EAAApe,KAAA4gB,EAIA,OAAAxC,IAIAyC,GAAAvoB,GAAAgkB,KAAA1iB,MAAAggB,aAEAkH,GAAA,kEAIA5nB,GAAA,gBAoCAZ,IAAAc,OAAA,SAAAkjB,EAAA9d,EAAA7F,GACA,GAAAG,GAAA0F,EAAA,EAMA,OAJA7F,KACA2jB,EAAA,QAAAA,EAAA,KAGA,IAAA9d,EAAApG,QAAA,IAAAU,EAAAE,SACAV,GAAAkf,KAAAgE,gBAAA1iB,EAAAwjB,IAAAxjB,MAGAR,GAAAkf,KAAAtS,QAAAoX,EAAAhkB,GAAAO,KAAA2F,EAAA,SAAA1F,GACA,WAAAA,EAAAE,aAIAV,GAAAqI,GAAAyB,QACAoV,KAAA,SAAA9W,GACA,GAAA3H,GAAAoF,EACAoR,EAAAtb,KAAAmE,OACApE,EAAAC,IAEA,oBAAAyM,GACA,MAAAzM,MAAAmb,UAAA9W,GAAAoI,GAAAtH,OAAA,WACA,IAAAL,EAAA,EAAgBA,EAAAwW,EAASxW,IACzB,GAAAT,GAAA2G,SAAAjL,EAAA+E,GAAA9E,MACA,WAQA,KAFAkK,EAAAlK,KAAAmb,cAEArW,EAAA,EAAcA,EAAAwW,EAASxW,IACvBT,GAAAkf,KAAA9W,EAAA1M,EAAA+E,GAAAoF,EAGA,OAAAoR,GAAA,EAAAjX,GAAAqf,WAAAxZ,MAEA/E,OAAA,SAAAsH,GACA,MAAAzM,MAAAmb,UAAA5W,EAAAvE,KAAAyM,OAAA,KAEA/H,IAAA,SAAA+H,GACA,MAAAzM,MAAAmb,UAAA5W,EAAAvE,KAAAyM,OAAA,KAEAggB,GAAA,SAAAhgB,GACA,QAAAlI,EACAvE,KAIA,gBAAAyM,IAAAmgB,GAAA1nB,KAAAuH,GACApI,GAAAoI,GACAA,OACA,GACAtI,SASA,IAAA2oB,IAMAnP,GAAA,sCAEAhe,GAAA0E,GAAAqI,GAAA/M,KAAA,SAAA8M,EAAAzC,EAAA0gB,GACA,GAAA/kB,GAAAd,CAGA,KAAA4H,EACA,MAAAzM,KAQA,IAHA0qB,KAAAoC,GAGA,gBAAArgB,GAAA,CAaA,GAPA9G,EALA,MAAA8G,EAAA,IACA,MAAAA,IAAAtI,OAAA,IACAsI,EAAAtI,QAAA,GAGA,KAAAsI,EAAA,MAGAkR,GAAA7U,KAAA2D,IAIA9G,MAAA,IAAAqE,EA6CI,OAAAA,KAAA+Q,QACJ/Q,GAAA0gB,GAAAnH,KAAA9W,GAKAzM,KAAAgb,YAAAhR,GAAAuZ,KAAA9W,EAhDA,IAAA9G,EAAA,IAYA,GAXAqE,cAAA3F,IAAA2F,EAAA,GAAAA,EAIA3F,GAAAgG,MAAArK,KAAAqE,GAAA0oB,UACApnB,EAAA,GACAqE,KAAAjF,SAAAiF,EAAAb,eAAAa,EAAAxK,IACA,IAIAqtB,GAAA3nB,KAAAS,EAAA,KAAAtB,GAAAsX,cAAA3R,GACA,IAAArE,IAAAqE,GAGA3F,GAAAM,WAAA3E,KAAA2F,IACA3F,KAAA2F,GAAAqE,EAAArE,IAIA3F,KAAAsoB,KAAA3iB,EAAAqE,EAAArE,GAKA,OAAA3F,MAYA,MARA6E,GAAArF,GAAAC,eAAAkG,EAAA,IAEAd,IAGA7E,KAAA,GAAA6E,EACA7E,KAAAmE,OAAA,GAEAnE,KAcG,MAAAyM,GAAA1H,UACH/E,KAAA,GAAAyM,EACAzM,KAAAmE,OAAA,EACAnE,MAIGqE,GAAAM,WAAA8H,GACH7F,SAAA8jB,EAAA3jB,MACA2jB,EAAA3jB,MAAA0F,GAGAA,EAAApI,IAGAA,GAAAmY,UAAA/P,EAAAzM,MAIAL,IAAAE,UAAAwE,GAAAqI,GAGAogB,GAAAzoB,GAAA7E,GAGA,IAAAwtB,IAAA,iCAGAC,IACAC,UAAA,EACAxU,UAAA,EACA+H,MAAA,EACApH,MAAA,EAGAhV,IAAAqI,GAAAyB,QACAic,IAAA,SAAAnS,GACA,GAAAkV,GAAA9oB,GAAA4T,EAAAjY,MACAyK,EAAA0iB,EAAAhpB,MAEA,OAAAnE,MAAAmF,OAAA,WAEA,IADA,GAAAL,GAAA,EACUA,EAAA2F,EAAO3F,IACjB,GAAAT,GAAA2G,SAAAhL,KAAAmtB,EAAAroB,IACA,YAMAsoB,QAAA,SAAAtE,EAAA9e,GACA,GAAA3E,GACAP,EAAA,EACA2F,EAAAzK,KAAAmE,OACAgmB,KACAgD,EAAA,gBAAArE,IAAAzkB,GAAAykB,EAGA,KAAA8D,GAAA1nB,KAAA4jB,GACA,KAAUhkB,EAAA2F,EAAO3F,IACjB,IAAAO,EAAArF,KAAA8E,GAA0BO,OAAA2E,EAAwB3E,IAAAtB,WAGlD,GAAAsB,EAAAN,SAAA,KAAAooB,EACAA,EAAAxjB,MAAAtE,IAAA,EAGA,IAAAA,EAAAN,UACAV,GAAAkf,KAAAgE,gBAAAliB,EAAAyjB,IAAA,CAEAqB,EAAApe,KAAA1G,EACA,OAMA,MAAArF,MAAAmb,UAAAgP,EAAAhmB,OAAA,EAAAE,GAAAqf,WAAAyG,OAIAxgB,MAAA,SAAA9E,GAGA,MAAAA,GAKA,gBAAAA,GACAG,GAAA/G,KAAAoG,GAAAQ,GAAA7E,KAAA,IAIAgF,GAAA/G,KAAA+B,KAGA6E,EAAAkW,OAAAlW,EAAA,GAAAA,GAZA7E,KAAA,IAAAA,KAAA,GAAA+D,WAAA/D,KAAA6O,QAAAwe,UAAAlpB,QAAA,GAgBArC,IAAA,SAAA2K,EAAAzC,GACA,MAAAhK,MAAAmb,UACA9W,GAAAqf,WACArf,GAAAgG,MAAArK,KAAA6J,MAAAxF,GAAAoI,EAAAzC,OAKAsjB,QAAA,SAAA7gB,GACA,MAAAzM,MAAA8B,IAAA,MAAA2K,EACAzM,KAAAob,WAAApb,KAAAob,WAAAjW,OAAAsH,OAUApI,GAAAqB,MACAqkB,OAAA,SAAAllB,GACA,GAAAklB,GAAAllB,EAAAd,UACA,OAAAgmB,IAAA,KAAAA,EAAAhlB,SAAAglB,EAAA,MAEAwD,QAAA,SAAA1oB,GACA,MAAAS,IAAAT,EAAA,eAEA2oB,aAAA,SAAA3oB,EAAAC,EAAAynB,GACA,MAAAjnB,IAAAT,EAAA,aAAA0nB,IAEA9L,KAAA,SAAA5b,GACA,MAAAO,GAAAP,EAAA,gBAEAwU,KAAA,SAAAxU,GACA,MAAAO,GAAAP,EAAA,oBAEA4oB,QAAA,SAAA5oB,GACA,MAAAS,IAAAT,EAAA,gBAEAwoB,QAAA,SAAAxoB,GACA,MAAAS,IAAAT,EAAA,oBAEA6oB,UAAA,SAAA7oB,EAAAC,EAAAynB,GACA,MAAAjnB,IAAAT,EAAA,cAAA0nB,IAEAoB,UAAA,SAAA9oB,EAAAC,EAAAynB,GACA,MAAAjnB,IAAAT,EAAA,kBAAA0nB,IAEAG,SAAA,SAAA7nB,GACA,MAAA6nB,KAAA7nB,EAAAd,gBAA0C8H,WAAAhH,IAE1CqoB,SAAA,SAAAroB,GACA,MAAA6nB,IAAA7nB,EAAAgH,aAEA6M,SAAA,SAAA7T,GACA,MAAAA,GAAA+oB,iBAAAvpB,GAAAgG,SAAAxF,EAAA+G,cAEC,SAAAlE,EAAAgF,GACDrI,GAAAqI,GAAAhF,GAAA,SAAA6kB,EAAA9f,GACA,GAAA0d,GAAA9lB,GAAAiL,IAAAtP,KAAA0M,EAAA6f,EAuBA,OArBA,UAAA7kB,EAAAmJ,OAAA,KACApE,EAAA8f,GAGA9f,GAAA,gBAAAA,KACA0d,EAAA9lB,GAAAc,OAAAsH,EAAA0d,IAGAnqB,KAAAmE,OAAA,IAGA8oB,GAAAvlB,IACArD,GAAAqf,WAAAyG,GAIA6C,GAAA9nB,KAAAwC,IACAyiB,EAAA0D,WAIA7tB,KAAAmb,UAAAgP,KAGA,IAAAvkB,IAAA,mBAmCAvB,IAAAypB,UAAA,SAAAtoB,GAIAA,EAAA,gBAAAA,GACAD,EAAAC,GACAnB,GAAA8J,UAAmB3I,EAEnB,IACAuoB,GAGAC,EAGAC,EAGAC,EAGA5J,KAGAvQ,KAGAoa,GAAA,EAGAha,EAAA,WAQA,IALA+Z,EAAA1oB,EAAA4oB,KAIAH,EAAAF,GAAA,EACUha,EAAA5P,OAAcgqB,GAAA,EAExB,IADAH,EAAAja,EAAA4E,UACAwV,EAAA7J,EAAAngB,QAGAmgB,EAAA6J,GAAAphB,MAAAihB,EAAA,GAAAA,EAAA,UACAxoB,EAAA6oB,cAGAF,EAAA7J,EAAAngB,OACA6pB,GAAA,EAMAxoB,GAAAwoB,SACAA,GAAA,GAGAD,GAAA,EAGAG,IAIA5J,EADA0J,KAKA,KAMAjuB,GAGA+B,IAAA,WA2BA,MA1BAwiB,KAGA0J,IAAAD,IACAI,EAAA7J,EAAAngB,OAAA,EACA4P,EAAAhI,KAAAiiB,IAGA,QAAAlsB,GAAA4M,GACArK,GAAAqB,KAAAgJ,EAAA,SAAA7I,EAAAiX,GACAzY,GAAAM,WAAAmY,GACAtX,EAAA4mB,QAAArsB,EAAAqqB,IAAAtN,IACAwH,EAAAvY,KAAA+Q,GAEQA,KAAA3Y,QAAA,WAAAE,GAAAD,KAAA0Y,IAGRhb,EAAAgb,MAGM9P,WAENghB,IAAAD,GACA5Z,KAGAnU,MAIA0P,OAAA,WAYA,MAXArL,IAAAqB,KAAAsH,UAAA,SAAAnH,EAAAiX,GAEA,IADA,GAAAnT,IACAA,EAAAtF,GAAA4H,QAAA6Q,EAAAwH,EAAA3a,KAAA,GACA2a,EAAA9I,OAAA7R,EAAA,GAGAA,GAAAwkB,GACAA,MAIAnuB,MAKAoqB,IAAA,SAAA1d,GACA,MAAAA,GACArI,GAAA4H,QAAAS,EAAA4X,IAAA,EACAA,EAAAngB,OAAA,GAIA+P,MAAA,WAIA,MAHAoQ,KACAA,MAEAtkB,MAMAsuB,QAAA,WAGA,MAFAJ,GAAAna,KACAuQ,EAAA0J,EAAA,GACAhuB,MAEA6f,SAAA,WACA,OAAAyE,GAMAiK,KAAA,WAKA,MAJAL,GAAAna,KACAia,GAAAD,IACAzJ,EAAA0J,EAAA,IAEAhuB,MAEAkuB,OAAA,WACA,QAAAA,GAIAM,SAAA,SAAAxkB,EAAA0E,GASA,MARAwf,KACAxf,QACAA,GAAA1E,EAAA0E,EAAAmC,MAAAnC,EAAAmC,QAAAnC,GACAqF,EAAAhI,KAAA2C,GACAqf,GACA5Z,KAGAnU,MAIAmU,KAAA,WAEA,MADApU,GAAAyuB,SAAAxuB,KAAAgN,WACAhN,MAIAiuB,MAAA,WACA,QAAAA,GAIA,OAAAluB,IA2CAsE,GAAA8J,QAEAkH,SAAA,SAAA8B,GACA,GAAAsX,KAIA,oBAAApqB,GAAAypB,UAAA,UACAzpB,GAAAypB,UAAA,cACA,iBAAAzpB,GAAAypB,UAAA,eACAzpB,GAAAypB,UAAA,8BACA,gBAAAzpB,GAAAypB,UAAA,eACAzpB,GAAAypB,UAAA,8BAEApU,EAAA,UACAlT,GACAkT,MAAA,WACA,MAAAA,IAEAtF,OAAA,WAEA,MADAgB,GAAA3O,KAAAuG,WAAAtG,KAAAsG,WACAhN,MAEA0uB,MAAA,SAAAhiB,GACA,MAAAlG,GAAAG,KAAA,KAAA+F,IAIAiiB,KAAA,WACA,GAAAC,GAAA5hB,SAEA,OAAA3I,IAAAgR,SAAA,SAAAwZ,GACAxqB,GAAAqB,KAAA+oB,EAAA,SAAA3pB,EAAAgqB,GAGA,GAAApiB,GAAArI,GAAAM,WAAAiqB,EAAAE,EAAA,MAAAF,EAAAE,EAAA,GAKA1Z,GAAA0Z,EAAA,eACA,GAAAC,GAAAriB,KAAAK,MAAA/M,KAAAgN,UACA+hB,IAAA1qB,GAAAM,WAAAoqB,EAAAvoB,SACAuoB,EAAAvoB,UACA8P,SAAAuY,EAAAG,QACAvoB,KAAAooB,EAAAxoB,SACAK,KAAAmoB,EAAAvoB,QAEAuoB,EAAAC,EAAA,WACA9uB,KACA0M,GAAAqiB,GAAA/hB,eAKA4hB,EAAA,OACMpoB,WAENG,KAAA,SAAAsoB,EAAAC,EAAAC,GAEA,QAAA9oB,GAAA+oB,EAAAha,EAAA8J,EAAAmQ,GACA,kBACA,GAAAC,GAAAtvB,KACA0O,EAAA1B,UACAuiB,EAAA,WACA,GAAAR,GAAApoB,CAKA,MAAAyoB,EAAAI,GAAA,CAQA,GAJAT,EAAA7P,EAAAnS,MAAAuiB,EAAA5gB,GAIAqgB,IAAA3Z,EAAA5O,UACA,SAAAipB,WAAA,2BAOA9oB,GAAAooB,IAKA,gBAAAA,IACA,kBAAAA,KACAA,EAAApoB,KAGAtC,GAAAM,WAAAgC,GAGA0oB,EACA1oB,EAAA1I,KACA8wB,EACA1oB,EAAAmpB,EAAApa,EAAArP,EAAAspB,GACAhpB,EAAAmpB,EAAApa,EAAAnP,EAAAopB,KAOAG,IAEA7oB,EAAA1I,KACA8wB,EACA1oB,EAAAmpB,EAAApa,EAAArP,EAAAspB,GACAhpB,EAAAmpB,EAAApa,EAAAnP,EAAAopB,GACAhpB,EAAAmpB,EAAApa,EAAArP,EACAqP,EAAAS,eASAqJ,IAAAnZ,IACAupB,EAAA1oB,OACA8H,GAAAqgB,KAKAM,GAAAja,EAAAU,aAAAwZ,EAAA5gB,MAKAghB,EAAAL,EACAE,EACA,WACA,IACAA,IACW,MAAA5tB,GAEX0C,GAAAgR,SAAAsa,eACAtrB,GAAAgR,SAAAsa,cAAAhuB,EACA+tB,EAAAE,YAMAR,EAAA,GAAAI,IAIAtQ,IAAAjZ,IACAqpB,EAAA1oB,OACA8H,GAAA/M,IAGAyT,EAAAe,WAAAmZ,EAAA5gB,KASA0gB,GACAM,KAKArrB,GAAAgR,SAAAwa,eACAH,EAAAE,WAAAvrB,GAAAgR,SAAAwa,gBAEAvxB,EAAAgU,WAAAod,KAzHA,GAAAF,GAAA,CA8HA,OAAAnrB,IAAAgR,SAAA,SAAAwZ,GAGAJ,EAAA,MAAA3sB,IACAuE,EACA,EACAwoB,EACAxqB,GAAAM,WAAAwqB,GACAA,EACAppB,EACA8oB,EAAAhZ,aAKA4Y,EAAA,MAAA3sB,IACAuE,EACA,EACAwoB,EACAxqB,GAAAM,WAAAsqB,GACAA,EACAlpB,IAKA0oB,EAAA,MAAA3sB,IACAuE,EACA,EACAwoB,EACAxqB,GAAAM,WAAAuqB,GACAA,EACAjpB,MAGMO,WAKNA,QAAA,SAAAtC,GACA,aAAAA,EAAAG,GAAA8J,OAAAjK,EAAAsC,OAGA4O,IA2DA,OAxDA/Q,IAAAqB,KAAA+oB,EAAA,SAAA3pB,EAAAgqB,GACA,GAAAxK,GAAAwK,EAAA,GACAgB,EAAAhB,EAAA,EAKAtoB,GAAAsoB,EAAA,IAAAxK,EAAAxiB,IAGAguB,GACAxL,EAAAxiB,IACA,WAIA4X,EAAAoW,GAKArB,EAAA,EAAA3pB,GAAA,GAAAwpB,QAGAG,EAAA,MAAAF,MAOAjK,EAAAxiB,IAAAgtB,EAAA,GAAA3a,MAKAiB,EAAA0Z,EAAA,eAEA,MADA1Z,GAAA0Z,EAAA,WAAA9uB,OAAAoV,EAAAxO,OAAA5G,KAAAgN,WACAhN,MAMAoV,EAAA0Z,EAAA,WAAAxK,EAAAkK,WAIAhoB,UAAA4O,GAGA+B,GACAA,EAAAlZ,KAAAmX,KAIAA,GAIA2a,KAAA,SAAAC,GACA,GAGAza,GAAAvI,UAAA7I,OAGAW,EAAAyQ,EAGA0a,EAAAjU,MAAAlX,GACAorB,EAAArf,GAAA5S,KAAA+O,WAGAmjB,EAAA9rB,GAAAgR,WAGA+a,EAAA,SAAAtrB,GACA,gBAAAsB,GACA6pB,EAAAnrB,GAAA9E,KACAkwB,EAAAprB,GAAAkI,UAAA7I,OAAA,EAAA0M,GAAA5S,KAAA+O,WAAA5G,IACAmP,GACA4a,EAAAra,YAAAma,EAAAC,IAMA,IAAA3a,GAAA,IACApP,EAAA6pB,EAAAG,EAAA1pB,KAAA2pB,EAAAtrB,IAAAuB,QAAA8pB,EAAA7pB,QAGA,YAAA6pB,EAAAzW,SACArV,GAAAM,WAAAurB,EAAAprB,IAAAorB,EAAAprB,GAAA6B,OAEA,MAAAwpB,GAAAxpB,MAKA,MAAA7B,KACAqB,EAAA+pB,EAAAprB,GAAAsrB,EAAAtrB,GAAAqrB,EAAA7pB,OAGA,OAAA6pB,GAAA3pB,YAOA,IAAA6pB,IAAA,wDAEAhsB,IAAAgR,SAAAsa,cAAA,SAAAhW,EAAA2W,GAIAhyB,EAAAiyB,SAAAjyB,EAAAiyB,QAAAC,MAAA7W,GAAA0W,GAAAnrB,KAAAyU,EAAAjS,OACApJ,EAAAiyB,QAAAC,KAAA,8BAAA7W,EAAA8W,QAAA9W,EAAA2W,UAOAjsB,GAAAqsB,eAAA,SAAA/W,GACArb,EAAAgU,WAAA,WACA,KAAAqH,KAQA,IAAAgX,IAAAtsB,GAAAgR,UAEAhR,IAAAqI,GAAA3F,MAAA,SAAA2F,GAYA,MAVAikB,IACAhqB,KAAA+F,GAKAgiB,MAAA,SAAA/U,GACAtV,GAAAqsB,eAAA/W,KAGA3Z,MAGAqE,GAAA8J,QAGA0N,SAAA,EAIA+U,UAAA,EAGAC,UAAA,SAAAC,GACAA,EACAzsB,GAAAusB,YAEAvsB,GAAA0C,OAAA,IAKAA,MAAA,SAAAgqB,IAGAA,KAAA,IAAA1sB,GAAAusB,UAAAvsB,GAAAwX,WAKAxX,GAAAwX,SAAA,EAGAkV,KAAA,KAAA1sB,GAAAusB,UAAA,GAKAD,GAAA7a,YAAAtW,IAAA6E,SAIAA,GAAA0C,MAAAJ,KAAAgqB,GAAAhqB,KAaA,aAAAnH,GAAAwxB,YACA,YAAAxxB,GAAAwxB,aAAAxxB,GAAAmnB,gBAAAsK,SAGA3yB,EAAAgU,WAAAjO,GAAA0C,QAKAvH,GAAAsnB,iBAAA,mBAAAjgB,GAGAvI,EAAAwoB,iBAAA,OAAAjgB,GAQA,IAAAoH,IAAA,SAAA1D,EAAAmC,EAAAjF,EAAArB,EAAA8qB,EAAAC,EAAAC,GACA,GAAAtsB,GAAA,EACAwW,EAAA/Q,EAAApG,OACAktB,EAAA,MAAA5pB,CAGA,eAAApD,GAAAD,KAAAqD,GAAA,CACAypB,GAAA,CACA,KAAApsB,IAAA2C,GACAwG,GAAA1D,EAAAmC,EAAA5H,EAAA2C,EAAA3C,IAAA,EAAAqsB,EAAAC,OAIE,IAAAxqB,SAAAR,IACF8qB,GAAA,EAEA7sB,GAAAM,WAAAyB,KACAgrB,GAAA,GAGAC,IAGAD,GACA1kB,EAAAzO,KAAAsM,EAAAnE,GACAsG,EAAA,OAIA2kB,EAAA3kB,EACAA,EAAA,SAAA7H,EAAA4C,EAAArB,GACA,MAAAirB,GAAApzB,KAAAoG,GAAAQ,GAAAuB,MAKAsG,GACA,KAAU5H,EAAAwW,EAASxW,IACnB4H,EACAnC,EAAAzF,GAAA2C,EAAA2pB,EACAhrB,EACAA,EAAAnI,KAAAsM,EAAAzF,KAAA4H,EAAAnC,EAAAzF,GAAA2C,IAMA,OAAAypB,GACA3mB,EAIA8mB,EACA3kB,EAAAzO,KAAAsM,GAGA+Q,EAAA5O,EAAAnC,EAAA,GAAA9C,GAAA0pB,GAEAG,GAAA,SAAAC,GAQA,WAAAA,EAAAxsB,UAAA,IAAAwsB,EAAAxsB,YAAAwsB,EAAAxsB,SAUAiC,GAAAE,IAAA,EAEAF,EAAAnH,WAEA6e,MAAA,SAAA6S,GAGA,GAAAnrB,GAAAmrB,EAAAvxB,KAAAiH,QA4BA,OAzBAb,KACAA,KAKAkrB,GAAAC,KAIAA,EAAAxsB,SACAwsB,EAAAvxB,KAAAiH,SAAAb,EAMA4T,OAAAwX,eAAAD,EAAAvxB,KAAAiH,SACAb,QACAqrB,cAAA,MAMArrB,GAEAnE,IAAA,SAAAsvB,EAAAnqB,EAAAhB,GACA,GAAA6B,GACAyW,EAAA1e,KAAA0e,MAAA6S,EAIA,oBAAAnqB,GACAsX,EAAAra,GAAAuQ,UAAAxN,IAAAhB,MAMA,KAAA6B,IAAAb,GACAsX,EAAAra,GAAAuQ,UAAA3M,IAAAb,EAAAa,EAGA,OAAAyW,IAEA7U,IAAA,SAAA0nB,EAAA9pB,GACA,MAAAb,UAAAa,EACAzH,KAAA0e,MAAA6S,GAGAA,EAAAvxB,KAAAiH,UAAAsqB,EAAAvxB,KAAAiH,SAAA5C,GAAAuQ,UAAAnN,KAEAwG,OAAA,SAAAsjB,EAAA9pB,EAAArB,GAaA,MAAAQ,UAAAa,GACAA,GAAA,gBAAAA,IAAAb,SAAAR,EAEApG,KAAA6J,IAAA0nB,EAAA9pB,IASAzH,KAAAiC,IAAAsvB,EAAA9pB,EAAArB,GAIAQ,SAAAR,IAAAqB,IAEAiI,OAAA,SAAA6hB,EAAA9pB,GACA,GAAA3C,GACA4Z,EAAA6S,EAAAvxB,KAAAiH,QAEA,IAAAL,SAAA8X,EAAA,CAIA,GAAA9X,SAAAa,EAAA,CAGApD,GAAAwQ,QAAApN,GAIAA,IAAA6H,IAAAjL,GAAAuQ,YAEAnN,EAAApD,GAAAuQ,UAAAnN,GAIAA,MAAAiX,IACAjX,GACAA,EAAA9B,MAAAC,SAGAd,EAAA2C,EAAAtD,MAEA,MAAAW,WACA4Z,GAAAjX,EAAA3C,KAKA8B,SAAAa,GAAApD,GAAAiQ,cAAAoK,MAMA6S,EAAAxsB,SACAwsB,EAAAvxB,KAAAiH,SAAAL,aAEA2qB,GAAAvxB,KAAAiH,YAIA+G,QAAA,SAAAujB,GACA,GAAA7S,GAAA6S,EAAAvxB,KAAAiH,QACA,OAAAL,UAAA8X,IAAAra,GAAAiQ,cAAAoK,IAGA,IAAA9U,IAAA,GAAA5C,GAEAe,GAAA,GAAAf,GAcAK,GAAA,gCACAO,GAAA,QAkDAvD,IAAA8J,QACAH,QAAA,SAAAnJ,GACA,MAAAkD,IAAAiG,QAAAnJ,IAAA+E,GAAAoE,QAAAnJ,IAGAuC,KAAA,SAAAvC,EAAA6C,EAAAN,GACA,MAAAW,IAAAkG,OAAApJ,EAAA6C,EAAAN,IAGAsqB,WAAA,SAAA7sB,EAAA6C,GACAK,GAAA2H,OAAA7K,EAAA6C,IAKAiqB,MAAA,SAAA9sB,EAAA6C,EAAAN,GACA,MAAAwC,IAAAqE,OAAApJ,EAAA6C,EAAAN,IAGAwqB,YAAA,SAAA/sB,EAAA6C,GACAkC,GAAA8F,OAAA7K,EAAA6C,MAIArD,GAAAqI,GAAAyB,QACA/G,KAAA,SAAAK,EAAArB,GACA,GAAAtB,GAAA4C,EAAAN,EACAvC,EAAA7E,KAAA,GACA4S,EAAA/N,KAAA6f,UAGA,IAAA9d,SAAAa,EAAA,CACA,GAAAzH,KAAAmE,SACAiD,EAAAW,GAAA8B,IAAAhF,GAEA,IAAAA,EAAAE,WAAA6E,GAAAC,IAAAhF,EAAA,kBAEA,IADAC,EAAA8N,EAAAzO,OACAW,KAIA8N,EAAA9N,KACA4C,EAAAkL,EAAA9N,GAAA4C,KACA,IAAAA,EAAA1C,QAAA,WACA0C,EAAArD,GAAAuQ,UAAAlN,EAAAmJ,MAAA,IACArJ,EAAA3C,EAAA6C,EAAAN,EAAAM,KAIAkC,IAAA3H,IAAA4C,EAAA,mBAIA,MAAAuC,GAIA,sBAAAK,GACAzH,KAAA0F,KAAA,WACAqC,GAAA9F,IAAAjC,KAAAyH,KAIAwG,GAAAjO,KAAA,SAAAoG,GACA,GAAAgB,EAOA,IAAAvC,GAAA+B,SAAAR,EAAA,CAKA,GADAgB,EAAAW,GAAA8B,IAAAhF,EAAA4C,GACAb,SAAAQ,EACA,MAAAA,EAMA,IADAA,EAAAI,EAAA3C,EAAA4C,GACAb,SAAAQ,EACA,MAAAA,OAQApH,MAAA0F,KAAA,WAGAqC,GAAA9F,IAAAjC,KAAAyH,EAAArB,MAEG,KAAAA,EAAA4G,UAAA7I,OAAA,YAGHutB,WAAA,SAAAjqB,GACA,MAAAzH,MAAA0F,KAAA,WACAqC,GAAA2H,OAAA1P,KAAAyH,QAMApD,GAAA8J,QACA4F,MAAA,SAAAlP,EAAAT,EAAAgD,GACA,GAAA2M,EAEA,IAAAlP,EAYA,MAXAT,OAAA,cACA2P,EAAAnK,GAAAC,IAAAhF,EAAAT,GAGAgD,KACA2M,GAAA1P,GAAAwQ,QAAAzN,GACA2M,EAAAnK,GAAAqE,OAAApJ,EAAAT,EAAAC,GAAAmY,UAAApV,IAEA2M,EAAAhI,KAAA3E,IAGA2M,OAIA8d,QAAA,SAAAhtB,EAAAT,GACAA,KAAA,IAEA,IAAA2P,GAAA1P,GAAA0P,MAAAlP,EAAAT,GACA0tB,EAAA/d,EAAA5P,OACAuI,EAAAqH,EAAA4E,QACArF,EAAAjP,GAAA2P,YAAAnP,EAAAT,GACAqc,EAAA,WACApc,GAAAwtB,QAAAhtB,EAAAT,GAIA,gBAAAsI,IACAA,EAAAqH,EAAA4E,QACAmZ,KAGAplB,IAIA,OAAAtI,GACA2P,EAAAuD,QAAA,oBAIAhE,GAAA2C,KACAvJ,EAAAzO,KAAA4G,EAAA4b,EAAAnN,KAGAwe,GAAAxe,GACAA,EAAAY,MAAAC,QAKAH,YAAA,SAAAnP,EAAAT,GACA,GAAAqD,GAAArD,EAAA,YACA,OAAAwF,IAAAC,IAAAhF,EAAA4C,IAAAmC,GAAAqE,OAAApJ,EAAA4C,GACAyM,MAAA7P,GAAAypB,UAAA,eAAAhsB,IAAA,WACA8H,GAAA8F,OAAA7K,GAAAT,EAAA,QAAAqD,WAMApD,GAAAqI,GAAAyB,QACA4F,MAAA,SAAA3P,EAAAgD,GACA,GAAA2qB,GAAA,CAQA,OANA,gBAAA3tB,KACAgD,EAAAhD,EACAA,EAAA,KACA2tB,KAGA/kB,UAAA7I,OAAA4tB,EACA1tB,GAAA0P,MAAA/T,KAAA,GAAAoE,GAGAwC,SAAAQ,EACApH,KACAA,KAAA0F,KAAA,WACA,GAAAqO,GAAA1P,GAAA0P,MAAA/T,KAAAoE,EAAAgD,EAGA/C,IAAA2P,YAAAhU,KAAAoE,GAEA,OAAAA,GAAA,eAAA2P,EAAA,IACA1P,GAAAwtB,QAAA7xB,KAAAoE,MAIAytB,QAAA,SAAAztB,GACA,MAAApE,MAAA0F,KAAA,WACArB,GAAAwtB,QAAA7xB,KAAAoE,MAGA4tB,WAAA,SAAA5tB,GACA,MAAApE,MAAA+T,MAAA3P,GAAA,UAKAoC,QAAA,SAAApC,EAAAF,GACA,GAAA4G,GACAmnB,EAAA,EACAC,EAAA7tB,GAAAgR,WACA7Q,EAAAxE,KACA8E,EAAA9E,KAAAmE,OACAkC,EAAA,aACA4rB,GACAC,EAAApc,YAAAtR,OAUA,KANA,gBAAAJ,KACAF,EAAAE,EACAA,EAAAwC,QAEAxC,KAAA,KAEAU,KACAgG,EAAAlB,GAAAC,IAAArF,EAAAM,GAAAV,EAAA,cACA0G,KAAAoJ,QACA+d,IACAnnB,EAAAoJ,MAAApS,IAAAuE,GAIA,OADAA,KACA6rB,EAAA1rB,QAAAtC,KAGA,IAAAiuB,IAAA,sCAAAC,OAEAvpB,GAAA,GAAAgc,QAAA,iBAAAsN,GAAA,mBAGA3gB,IAAA,+BAEA1H,GAAA,SAAAjF,EAAAma,GAOA,MAHAna,GAAAma,GAAAna,EAGA,SAAAA,EAAAzF,MAAAiK,SACA,KAAAxE,EAAAzF,MAAAiK,SAMAhF,GAAA2G,SAAAnG,EAAAsE,cAAAtE,IAEA,SAAAR,GAAAmE,IAAA3D,EAAA,YAGAwtB,GAAA,SAAAxtB,EAAAW,EAAAmJ,EAAAD,GACA,GAAAxE,GAAAxC,EACA4qB,IAGA,KAAA5qB,IAAAlC,GACA8sB,EAAA5qB,GAAA7C,EAAAzF,MAAAsI,GACA7C,EAAAzF,MAAAsI,GAAAlC,EAAAkC,EAGAwC,GAAAyE,EAAA5B,MAAAlI,EAAA6J,MAGA,KAAAhH,IAAAlC,GACAX,EAAAzF,MAAAsI,GAAA4qB,EAAA5qB,EAGA,OAAAwC,IAqEAZ,KAyEAjF,IAAAqI,GAAAyB,QACA1E,KAAA,WACA,MAAAD,GAAAxJ,MAAA,IAEAuyB,KAAA,WACA,MAAA/oB,GAAAxJ,OAEAqT,OAAA,SAAAqG,GACA,uBAAAA,GACAA,EAAA1Z,KAAAyJ,OAAAzJ,KAAAuyB,OAGAvyB,KAAA0F,KAAA,WACAoE,GAAA9J,MACAqE,GAAArE,MAAAyJ,OAEApF,GAAArE,MAAAuyB,WAKA,IAAAlkB,IAAA,wBAEA/C,GAAA,iCAEAY,GAAA,4BAKAX,IAGAinB,QAAA,8CAKAC,OAAA,wBACAC,KAAA,6CACAC,IAAA,uCACAC,IAAA,gDAEApnB,UAAA,SAIAD,IAAAsnB,SAAAtnB,GAAAinB,OAEAjnB,GAAAunB,MAAAvnB,GAAAwnB,MAAAxnB,GAAAynB,SAAAznB,GAAA0nB,QAAA1nB,GAAAknB,MACAlnB,GAAA2nB,GAAA3nB,GAAAqnB;AA0CA,GAAAvnB,IAAA,aA4FA,WACA,GAAAH,GAAA1L,GAAA2L,yBACAgoB,EAAAjoB,EAAAxL,YAAAF,GAAAoE,cAAA,QACA0jB,EAAA9nB,GAAAoE,cAAA,QAMA0jB,GAAApJ,aAAA,gBACAoJ,EAAApJ,aAAA,qBACAoJ,EAAApJ,aAAA,YAEAiV,EAAAzzB,YAAA4nB,GAIArY,GAAAC,WAAAikB,EAAAC,WAAA,GAAAA,WAAA,GAAAznB,UAAA2C,QAIA6kB,EAAA1nB,UAAA,yBACAwD,GAAAokB,iBAAAF,EAAAC,WAAA,GAAAznB,UAAA4C,eAEA,IAAAoY,IAAAnnB,GAAAmnB,gBAKA2M,GAAA,OACAC,GAAA,iDACAC,GAAA,qBAmFAnvB,IAAAwI,OAEA1J,UAEArB,IAAA,SAAA+C,EAAA2H,EAAA0S,EAAA9X,EAAAqF,GAEA,GAAAgnB,GAAAC,EAAA5oB,EACAiD,EAAA4lB,EAAAC,EACAvE,EAAAwE,EAAAzvB,EAAA0vB,EAAAC,EACAC,EAAApqB,GAAAC,IAAAhF,EAGA,IAAAmvB,EAuCA,IAlCA9U,YACAuU,EAAAvU,EACAA,EAAAuU,EAAAvU,QACAzS,EAAAgnB,EAAAhnB,UAKAA,GACApI,GAAAkf,KAAAgE,gBAAAZ,GAAAla,GAIAyS,EAAAjS,OACAiS,EAAAjS,KAAA5I,GAAA4I,SAIAc,EAAAimB,EAAAjmB,UACAA,EAAAimB,EAAAjmB,YAEA2lB,EAAAM,EAAA9lB,UACAwlB,EAAAM,EAAA9lB,OAAA,SAAAvM,GAIA,yBAAA0C,QAAAwI,MAAAonB,YAAAtyB,EAAAyC,KACAC,GAAAwI,MAAAqnB,SAAAnnB,MAAAlI,EAAAmI,WAAApG,SAKA4F,MAAA,IAAA7G,MAAAC,MAAA,IACA+tB,EAAAnnB,EAAArI,OACAwvB,KACA7oB,EAAA0oB,GAAA1qB,KAAA0D,EAAAmnB,QACAvvB,EAAA2vB,EAAAjpB,EAAA,GACAgpB,GAAAhpB,EAAA,QAAA0O,MAAA,KAAA+B,OAGAnX,IAKAirB,EAAAhrB,GAAAwI,MAAAwiB,QAAAjrB,OAGAA,GAAAqI,EAAA4iB,EAAA8E,aAAA9E,EAAA+E,WAAAhwB,EAGAirB,EAAAhrB,GAAAwI,MAAAwiB,QAAAjrB,OAGAwvB,EAAAvvB,GAAA8J,QACA/J,OACA2vB,WACA3sB,OACA8X,UACAjS,KAAAiS,EAAAjS,KACAR,WACAkZ,aAAAlZ,GAAApI,GAAAgkB,KAAA1iB,MAAAggB,aAAAzgB,KAAAuH,GACA4nB,UAAAP,EAAApd,KAAA,MACI+c,IAGJI,EAAA9lB,EAAA3J,MACAyvB,EAAA9lB,EAAA3J,MACAyvB,EAAAS,cAAA,EAGAjF,EAAAkF,OACAlF,EAAAkF,MAAAt2B,KAAA4G,EAAAuC,EAAA0sB,EAAAJ,MAAA,GAEA7uB,EAAAiiB,kBACAjiB,EAAAiiB,iBAAA1iB,EAAAsvB,IAKArE,EAAAvtB,MACAutB,EAAAvtB,IAAA7D,KAAA4G,EAAA+uB,GAEAA,EAAA1U,QAAAjS,OACA2mB,EAAA1U,QAAAjS,KAAAiS,EAAAjS,OAKAR,EACAonB,EAAArY,OAAAqY,EAAAS,gBAAA,EAAAV,GAEAC,EAAA9nB,KAAA6nB,GAIAvvB,GAAAwI,MAAA1J,OAAAiB,IAAA,IAMAsL,OAAA,SAAA7K,EAAA2H,EAAA0S,EAAAzS,EAAA+nB,GAEA,GAAAvpB,GAAAwpB,EAAA3pB,EACAiD,EAAA4lB,EAAAC,EACAvE,EAAAwE,EAAAzvB,EAAA0vB,EAAAC,EACAC,EAAApqB,GAAAoE,QAAAnJ,IAAA+E,GAAAC,IAAAhF,EAEA,IAAAmvB,IAAAjmB,EAAAimB,EAAAjmB,QAAA,CAOA,IAFAvB,MAAA,IAAA7G,MAAAC,MAAA,IACA+tB,EAAAnnB,EAAArI,OACAwvB,KAMA,GALA7oB,EAAA0oB,GAAA1qB,KAAA0D,EAAAmnB,QACAvvB,EAAA2vB,EAAAjpB,EAAA,GACAgpB,GAAAhpB,EAAA,QAAA0O,MAAA,KAAA+B,OAGAnX,EAAA,CAeA,IARAirB,EAAAhrB,GAAAwI,MAAAwiB,QAAAjrB,OACAA,GAAAqI,EAAA4iB,EAAA8E,aAAA9E,EAAA+E,WAAAhwB,EACAyvB,EAAA9lB,EAAA3J,OACA0G,IAAA,IACA,GAAA+Z,QAAA,UAAAiP,EAAApd,KAAA,4BAGA+d,EAAAxpB,EAAA4oB,EAAA1vB,OACA8G,KACA2oB,EAAAC,EAAA5oB,IAEAupB,GAAAT,IAAAH,EAAAG,UACA7U,KAAAjS,OAAA2mB,EAAA3mB,MACAnC,MAAA5F,KAAA0uB,EAAAS,YACA5nB,OAAAmnB,EAAAnnB,WACA,OAAAA,IAAAmnB,EAAAnnB,YACAonB,EAAArY,OAAAvQ,EAAA,GAEA2oB,EAAAnnB,UACAonB,EAAAS,gBAEAjF,EAAA3f,QACA2f,EAAA3f,OAAAzR,KAAA4G,EAAA+uB,GAOAa,KAAAZ,EAAA1vB,SACAkrB,EAAAqF,UACArF,EAAAqF,SAAAz2B,KAAA4G,EAAAivB,EAAAE,EAAA9lB,WAAA,GAEA7J,GAAAswB,YAAA9vB,EAAAT,EAAA4vB,EAAA9lB,cAGAH,GAAA3J,QA1CA,KAAAA,IAAA2J,GACA1J,GAAAwI,MAAA6C,OAAA7K,EAAAT,EAAAoI,EAAAmnB,GAAAzU,EAAAzS,GAAA,EA8CApI,IAAAiQ,cAAAvG,IACAnE,GAAA8F,OAAA7K,EAAA,mBAIAqvB,SAAA,SAAAU,GAGA,GAEA9vB,GAAAmG,EAAAf,EAAAigB,EAAAyJ,EAAAiB,EAFAhoB,EAAAxI,GAAAwI,MAAAioB,IAAAF,GAGAlmB,EAAA,GAAAsN,OAAAhP,UAAA7I,QACA0vB,GAAAjqB,GAAAC,IAAA7J,KAAA,eAAoD6M,EAAAzI,UACpDirB,EAAAhrB,GAAAwI,MAAAwiB,QAAAxiB,EAAAzI,SAKA,KAFAsK,EAAA,GAAA7B,EAEA/H,EAAA,EAAcA,EAAAkI,UAAA7I,OAAsBW,IACpC4J,EAAA5J,GAAAkI,UAAAlI,EAMA,IAHA+H,EAAAkoB,eAAA/0B,MAGAqvB,EAAA2F,aAAA3F,EAAA2F,YAAA/2B,KAAA+B,KAAA6M,MAAA,GASA,IAJAgoB,EAAAxwB,GAAAwI,MAAAgnB,SAAA51B,KAAA+B,KAAA6M,EAAAgnB,GAGA/uB,EAAA,GACAqlB,EAAA0K,EAAA/vB,QAAA+H,EAAAooB,wBAIA,IAHApoB,EAAAqoB,cAAA/K,EAAAtlB,KAEAoG,EAAA,GACA2oB,EAAAzJ,EAAA0J,SAAA5oB,QACA4B,EAAAsoB,iCAIAtoB,EAAAuoB,aAAAvoB,EAAAuoB,WAAAlwB,KAAA0uB,EAAAS,aAEAxnB,EAAA+mB,YACA/mB,EAAAzF,KAAAwsB,EAAAxsB,KAEA8C,IAAA7F,GAAAwI,MAAAwiB,QAAAuE,EAAAG,eAA+D7lB,QAC/D0lB,EAAA1U,SAAAnS,MAAAod,EAAAtlB,KAAA6J,GAEA9H,SAAAsD,IACA2C,EAAAoI,OAAA/K,MAAA,IACA2C,EAAAwoB,iBACAxoB,EAAAyoB,mBAYA,OAJAjG,GAAAkG,cACAlG,EAAAkG,aAAAt3B,KAAA+B,KAAA6M,GAGAA,EAAAoI,SAGA4e,SAAA,SAAAhnB,EAAAgnB,GACA,GAAA/uB,GAAA8uB,EAAAnL,EAAA+M,EAAAC,EACAZ,KACAP,EAAAT,EAAAS,cACAjvB,EAAAwH,EAAAoL,MAGA,IAAAqc,GAIAjvB,EAAAN,YAOA,UAAA8H,EAAAzI,MAAAyI,EAAAoe,QAAA,GAEA,KAAU5lB,IAAArF,KAAcqF,IAAAtB,YAAA/D,KAIxB,OAAAqF,EAAAN,WAAA,UAAA8H,EAAAzI,MAAAiB,EAAAwa,YAAA,IAGA,IAFA2V,KACAC,KACA3wB,EAAA,EAAiBA,EAAAwvB,EAAmBxvB,IACpC8uB,EAAAC,EAAA/uB,GAGA2jB,EAAAmL,EAAAnnB,SAAA,IAEA7F,SAAA6uB,EAAAhN,KACAgN,EAAAhN,GAAAmL,EAAAjO,aACAthB,GAAAokB,EAAAzoB,MAAA2J,MAAAtE,IAAA,EACAhB,GAAAkf,KAAAkF,EAAAzoB,KAAA,MAAAqF,IAAAlB,QAEAsxB,EAAAhN,IACA+M,EAAAzpB,KAAA6nB,EAGA4B,GAAArxB,QACA0wB,EAAA9oB,MAA0BlH,KAAAQ,EAAAwuB,SAAA2B,IAY1B,MALAnwB,GAAArF,KACAs0B,EAAAT,EAAA1vB,QACA0wB,EAAA9oB,MAAuBlH,KAAAQ,EAAAwuB,WAAAhjB,MAAAyjB,KAGvBO,GAGAa,QAAA,SAAAhuB,EAAAiuB,GACA3b,OAAAwX,eAAAntB,GAAAuxB,MAAA/1B,UAAA6H,GACAmuB,YAAA,EACApE,cAAA,EAEA5nB,IAAAxF,GAAAM,WAAAgxB,GACA,WACA,GAAA31B,KAAA81B,cACA,MAAAH,GAAA31B,KAAA81B,gBAGA,WACA,GAAA91B,KAAA81B,cACA,MAAA91B,MAAA81B,cAAApuB,IAIAzF,IAAA,SAAAmE,GACA4T,OAAAwX,eAAAxxB,KAAA0H,GACAmuB,YAAA,EACApE,cAAA,EACAsE,UAAA,EACA3vB,cAMA0uB,IAAA,SAAAgB,GACA,MAAAA,GAAAzxB,GAAA4C,SACA6uB,EACA,GAAAzxB,IAAAuxB,MAAAE,IAGAzG,SACA2G,MAGAC,UAAA,GAEAtL,OAGA9oB,QAAA,WACA,GAAA7B,OAAAqM,KAAArM,KAAA2qB,MAEA,MADA3qB,MAAA2qB,SACA,GAGAwJ,aAAA,WAEA+B,MACAr0B,QAAA,WACA,GAAA7B,OAAAqM,KAAArM,KAAAk2B,KAEA,MADAl2B,MAAAk2B,QACA,GAGA/B,aAAA,YAEAgC,OAGAt0B,QAAA,WACA,gBAAA7B,KAAAoE,MAAApE,KAAAm2B,OAAA9xB,GAAA+E,SAAApJ,KAAA,SAEA,MADAA,MAAAm2B,SACA,GAKA3qB,SAAA,SAAAqB,GACA,MAAAxI,IAAA+E,SAAAyD,EAAAoL,OAAA,OAIAme,cACAb,aAAA,SAAA1oB,GAIAjG,SAAAiG,EAAAoI,QAAApI,EAAAipB,gBACAjpB,EAAAipB,cAAAO,YAAAxpB,EAAAoI,YAOA5Q,GAAAswB,YAAA,SAAA9vB,EAAAT,EAAA8J,GAGArJ,EAAAiC,qBACAjC,EAAAiC,oBAAA1C,EAAA8J,IAIA7J,GAAAuxB,MAAA,SAAAnoB,EAAA0F,GAGA,MAAAnT,gBAAAqE,IAAAuxB,OAKAnoB,KAAArJ,MACApE,KAAA81B,cAAAroB,EACAzN,KAAAoE,KAAAqJ,EAAArJ,KAIApE,KAAAs2B,mBAAA7oB,EAAA8oB,kBACA3vB,SAAA6G,EAAA8oB,kBAGA9oB,EAAA4oB,eAAA,EACAlqB,EACAC,EAKApM,KAAAiY,OAAAxK,EAAAwK,QAAA,IAAAxK,EAAAwK,OAAAlT,SACA0I,EAAAwK,OAAAlU,WACA0J,EAAAwK,OAEAjY,KAAAk1B,cAAAznB,EAAAynB,cACAl1B,KAAAw2B,cAAA/oB,EAAA+oB,eAIAx2B,KAAAoE,KAAAqJ,EAIA0F,GACA9O,GAAA8J,OAAAnO,KAAAmT,GAIAnT,KAAAy2B,UAAAhpB,KAAAgpB,WAAApyB,GAAAmO,WAGAxS,KAAAqE,GAAA4C,UAAA,IA1CA,GAAA5C,IAAAuxB,MAAAnoB,EAAA0F,IA+CA9O,GAAAuxB,MAAA/1B,WACAmb,YAAA3W,GAAAuxB,MACAU,mBAAAlqB,EACA6oB,qBAAA7oB,EACA+oB,8BAAA/oB,EACAsqB,aAAA,EAEArB,eAAA,WACA,GAAA1zB,GAAA3B,KAAA81B,aAEA91B,MAAAs2B,mBAAAnqB,EAEAxK,IAAA3B,KAAA02B,aACA/0B,EAAA0zB,kBAGAC,gBAAA,WACA,GAAA3zB,GAAA3B,KAAA81B,aAEA91B,MAAAi1B,qBAAA9oB,EAEAxK,IAAA3B,KAAA02B,aACA/0B,EAAA2zB,mBAGAqB,yBAAA,WACA,GAAAh1B,GAAA3B,KAAA81B,aAEA91B,MAAAm1B,8BAAAhpB,EAEAxK,IAAA3B,KAAA02B,aACA/0B,EAAAg1B,2BAGA32B,KAAAs1B,oBAKAjxB,GAAAqB,MACAkxB,QAAA,EACAC,SAAA,EACAC,YAAA,EACAC,gBAAA,EACAC,SAAA,EACAC,QAAA,EACAC,YAAA,EACAC,SAAA,EACAC,OAAA,EACAC,OAAA,EACAC,UAAA,EACAC,MAAA,EACAC,MAAA,EACAC,UAAA,EACAhwB,KAAA,EACAiwB,SAAA,EACAzM,QAAA,EACA0M,SAAA,EACAC,SAAA,EACAC,SAAA,EACAC,SAAA,EACAC,SAAA,EACAC,WAAA,EACAC,aAAA,EACAC,SAAA,EACAC,SAAA,EACAC,eAAA,EACAC,WAAA,EACAC,SAAA,EAEA3lB,MAAA,SAAA9F,GACA,GAAAoe,GAAApe,EAAAoe,MAGA,cAAApe,EAAA8F,OAAA2gB,GAAApuB,KAAA2H,EAAAzI,MACA,MAAAyI,EAAA4qB,SAAA5qB,EAAA4qB,SAAA5qB,EAAA6qB,SAIA7qB,EAAA8F,OAAA/L,SAAAqkB,GAAAsI,GAAAruB,KAAA2H,EAAAzI,MACA,EAAA6mB,EACA,EAGA,EAAAA,EACA,EAGA,EAAAA,EACA,EAGA,EAGApe,EAAA8F,QAECtO,GAAAwI,MAAA6oB,SAUDrxB,GAAAqB,MACA6yB,WAAA,YACAC,WAAA,WACAC,aAAA,cACAC,aAAA,cACC,SAAA9kB,EAAAkhB,GACDzwB,GAAAwI,MAAAwiB,QAAAzb,IACAugB,aAAAW,EACAV,SAAAU,EAEA5mB,OAAA,SAAArB,GACA,GAAA3C,GACA+N,EAAAjY,KACA24B,EAAA9rB,EAAA2pB,cACA5C,EAAA/mB,EAAA+mB,SASA,OALA+E,SAAA1gB,GAAA5T,GAAA2G,SAAAiN,EAAA0gB,MACA9rB,EAAAzI,KAAAwvB,EAAAG,SACA7pB,EAAA0pB,EAAA1U,QAAAnS,MAAA/M,KAAAgN,WACAH,EAAAzI,KAAA0wB,GAEA5qB,MAKA7F,GAAAqI,GAAAyB,QAEAzM,GAAA,SAAA8K,EAAAC,EAAArF,EAAAsF,GACA,MAAAhL,GAAA1B,KAAAwM,EAAAC,EAAArF,EAAAsF,IAEAC,IAAA,SAAAH,EAAAC,EAAArF,EAAAsF,GACA,MAAAhL,GAAA1B,KAAAwM,EAAAC,EAAArF,EAAAsF,EAAA,IAEAI,IAAA,SAAAN,EAAAC,EAAAC,GACA,GAAAknB,GAAAxvB,CACA,IAAAoI,KAAA6oB,gBAAA7oB,EAAAonB,UAWA,MARAA,GAAApnB,EAAAonB,UACAvvB,GAAAmI,EAAAuoB,gBAAAjoB,IACA8mB,EAAAS,UACAT,EAAAG,SAAA,IAAAH,EAAAS,UACAT,EAAAG,SACAH,EAAAnnB,SACAmnB,EAAA1U,SAEAlf,IAEA,oBAAAwM,GAAA,CAGA,IAAApI,IAAAoI,GACAxM,KAAA8M,IAAA1I,EAAAqI,EAAAD,EAAApI,GAEA,OAAApE,MAWA,MATAyM,MAAA,qBAAAA,KAGAC,EAAAD,EACAA,EAAA7F,QAEA8F,KAAA,IACAA,EAAAN,GAEApM,KAAA0F,KAAA,WACArB,GAAAwI,MAAA6C,OAAA1P,KAAAwM,EAAAE,EAAAD,OAMA,IAKAmsB,IAAA,8FAOAC,GAAA,wBAGA1pB,GAAA,oCACA7B,GAAA,cACAmC,GAAA,0CA4LApL,IAAA8J,QACAzC,cAAA,SAAA2D,GACA,MAAAA,GAAA1H,QAAAixB,GAAA,cAGArpB,MAAA,SAAA1K,EAAAi0B,EAAAC,GACA,GAAAj0B,GAAA2F,EAAAuuB,EAAAC,EACA1pB,EAAA1K,EAAAuuB,WAAA,GACA8F,EAAA70B,GAAA2G,SAAAnG,EAAAsE,cAAAtE,EAGA,MAAAoK,GAAAokB,gBAAA,IAAAxuB,EAAAE,UAAA,KAAAF,EAAAE,UACAV,GAAAgoB,SAAAxnB,IAMA,IAHAo0B,EAAAlvB,EAAAwF,GACAypB,EAAAjvB,EAAAlF,GAEAC,EAAA,EAAA2F,EAAAuuB,EAAA70B,OAAuCW,EAAA2F,EAAO3F,IAC9CsJ,EAAA4qB,EAAAl0B,GAAAm0B,EAAAn0B,GAKA,IAAAg0B,EACA,GAAAC,EAIA,IAHAC,KAAAjvB,EAAAlF,GACAo0B,KAAAlvB,EAAAwF,GAEAzK,EAAA,EAAA2F,EAAAuuB,EAAA70B,OAAwCW,EAAA2F,EAAO3F,IAC/C0I,EAAAwrB,EAAAl0B,GAAAm0B,EAAAn0B,QAGA0I,GAAA3I,EAAA0K,EAWA,OANA0pB,GAAAlvB,EAAAwF,EAAA,UACA0pB,EAAA90B,OAAA,GACAmG,EAAA2uB,GAAAC,GAAAnvB,EAAAlF,EAAA,WAIA0K,GAGAK,UAAA,SAAArF,GAKA,IAJA,GAAAnD,GAAAvC,EAAAT,EACAirB,EAAAhrB,GAAAwI,MAAAwiB,QACAvqB,EAAA,EAES8B,UAAA/B,EAAA0F,EAAAzF,IAAqCA,IAC9C,GAAAwsB,GAAAzsB,GAAA,CACA,GAAAuC,EAAAvC,EAAA+E,GAAA3C,SAAA,CACA,GAAAG,EAAA2G,OACA,IAAA3J,IAAAgD,GAAA2G,OACAshB,EAAAjrB,GACAC,GAAAwI,MAAA6C,OAAA7K,EAAAT,GAIAC,GAAAswB,YAAA9vB,EAAAT,EAAAgD,EAAA8G,OAOArJ,GAAA+E,GAAA3C,SAAAL,OAEA/B,EAAAkD,GAAAd,WAIApC,EAAAkD,GAAAd,SAAAL,YAOAvC,GAAAqI,GAAAyB,QACAgrB,OAAA,SAAA1sB,GACA,MAAAiD,GAAA1P,KAAAyM,GAAA,IAGAiD,OAAA,SAAAjD,GACA,MAAAiD,GAAA1P,KAAAyM,IAGA5I,KAAA,SAAAuC,GACA,MAAA6H,IAAAjO,KAAA,SAAAoG,GACA,MAAAQ,UAAAR,EACA/B,GAAAR,KAAA7D,MACAA,KAAAkU,QAAAxO,KAAA,WACA,IAAA1F,KAAA+E,UAAA,KAAA/E,KAAA+E,UAAA,IAAA/E,KAAA+E,WACA/E,KAAA8L,YAAA1F,MAGG,KAAAA,EAAA4G,UAAA7I,SAGHi1B,OAAA,WACA,MAAA5qB,GAAAxO,KAAAgN,UAAA,SAAAnI,GACA,OAAA7E,KAAA+E,UAAA,KAAA/E,KAAA+E,UAAA,IAAA/E,KAAA+E,SAAA,CACA,GAAAkT,GAAA/K,EAAAlN,KAAA6E,EACAoT,GAAAvY,YAAAmF,OAKAw0B,QAAA,WACA,MAAA7qB,GAAAxO,KAAAgN,UAAA,SAAAnI,GACA,OAAA7E,KAAA+E,UAAA,KAAA/E,KAAA+E,UAAA,IAAA/E,KAAA+E,SAAA,CACA,GAAAkT,GAAA/K,EAAAlN,KAAA6E,EACAoT,GAAAqhB,aAAAz0B,EAAAoT,EAAApM,gBAKA0tB,OAAA,WACA,MAAA/qB,GAAAxO,KAAAgN,UAAA,SAAAnI,GACA7E,KAAA+D,YACA/D,KAAA+D,WAAAu1B,aAAAz0B,EAAA7E,SAKAw5B,MAAA,WACA,MAAAhrB,GAAAxO,KAAAgN,UAAA,SAAAnI,GACA7E,KAAA+D,YACA/D,KAAA+D,WAAAu1B,aAAAz0B,EAAA7E,KAAAyf,gBAKAvL,MAAA,WAIA,IAHA,GAAArP,GACAC,EAAA,EAES,OAAAD,EAAA7E,KAAA8E,IAA8BA,IACvC,IAAAD,EAAAE,WAGAV,GAAAuL,UAAA7F,EAAAlF,GAAA,IAGAA,EAAAiH,YAAA,GAIA,OAAA9L,OAGAuP,MAAA,SAAAupB,EAAAC,GAIA,MAHAD,GAAA,MAAAA,KACAC,EAAA,MAAAA,EAAAD,EAAAC,EAEA/4B,KAAAsP,IAAA,WACA,MAAAjL,IAAAkL,MAAAvP,KAAA84B,EAAAC,MAIA1pB,KAAA,SAAAjJ,GACA,MAAA6H,IAAAjO,KAAA,SAAAoG,GACA,GAAAvB,GAAA7E,KAAA,OACA8E,EAAA,EACA2F,EAAAzK,KAAAmE,MAEA,IAAAyC,SAAAR,GAAA,IAAAvB,EAAAE,SACA,MAAAF,GAAA4G,SAIA,oBAAArF,KAAAyyB,GAAA3zB,KAAAkB,KACAmF,IAAAD,GAAAxC,KAAA1C,KAAA,WAAAyB,eAAA,CAEAzB,EAAA/B,GAAAqH,cAAAtF,EAEA,KACA,KAAYtB,EAAA2F,EAAO3F,IACnBD,EAAA7E,KAAA8E,OAGA,IAAAD,EAAAE,WACAV,GAAAuL,UAAA7F,EAAAlF,GAAA,IACAA,EAAA4G,UAAArF,EAIAvB,GAAA,EAGK,MAAAlD,KAGLkD,GACA7E,KAAAkU,QAAAklB,OAAAhzB,IAEG,KAAAA,EAAA4G,UAAA7I,SAGHs1B,YAAA,WACA,GAAA5uB,KAGA,OAAA2D,GAAAxO,KAAAgN,UAAA,SAAAnI,GACA,GAAAklB,GAAA/pB,KAAA+D,UAEAM,IAAA4H,QAAAjM,KAAA6K,GAAA,IACAxG,GAAAuL,UAAA7F,EAAA/J,OACA+pB,GACAA,EAAA2P,aAAA70B,EAAA7E,QAKG6K,MAIHxG,GAAAqB,MACAi0B,SAAA,SACAC,UAAA,UACAN,aAAA,SACAO,YAAA,QACAC,WAAA,eACC,SAAApyB,EAAAqyB,GACD11B,GAAAqI,GAAAhF,GAAA,SAAA+E,GAOA,IANA,GAAAlC,GACAL,KACA8vB,EAAA31B,GAAAoI,GACA4O,EAAA2e,EAAA71B,OAAA,EACAW,EAAA,EAESA,GAAAuW,EAAWvW,IACpByF,EAAAzF,IAAAuW,EAAArb,UAAAuP,OAAA,GACAlL,GAAA21B,EAAAl1B,IAAAi1B,GAAAxvB,GAIAwB,GAAAgB,MAAA7C,EAAAK,EAAAV,MAGA,OAAA7J,MAAAmb,UAAAjR,KAGA,IAAAmG,IAAA,UAEAD,GAAA,GAAAyU,QAAA,KAAAsN,GAAA,uBAEAliB,GAAA,SAAApL,GAKA,GAAA0yB,GAAA1yB,EAAAsE,cAAA0Q,WAMA,OAJA0d,MAAA0C,SACA1C,EAAAj5B,GAGAi5B,EAAA2C,iBAAAr1B,KAKA,WAIA,QAAAs1B,KAGA,GAAAhH,EAAA,CAIAA,EAAA/zB,MAAAg7B,QACA,4GAIAjH,EAAA1nB,UAAA,GACAkb,GAAAjnB,YAAA26B,EAEA,IAAAC,GAAAh8B,EAAA47B,iBAAA/G,EACAoH,GAAA,OAAAD,EAAA/6B,IAGAi7B,EAAA,QAAAF,EAAAG,WACAC,EAAA,QAAAJ,EAAAz3B,MAIAswB,EAAA/zB,MAAAu7B,YAAA,MACAC,EAAA,QAAAN,EAAAK,YAEAhU,GAAA3iB,YAAAq2B,GAIAlH,EAAA,MAGA,GAAAoH,GAAAG,EAAAE,EAAAJ,EACAH,EAAA76B,GAAAoE,cAAA,OACAuvB,EAAA3zB,GAAAoE,cAAA,MAGAuvB,GAAA/zB,QAMA+zB,EAAA/zB,MAAAy7B,eAAA,cACA1H,EAAAC,WAAA,GAAAh0B,MAAAy7B,eAAA,GACA5rB,GAAA6rB,gBAAA,gBAAA3H,EAAA/zB,MAAAy7B,eAEAR,EAAAj7B,MAAAg7B,QAAA,4FAEAC,EAAA36B,YAAAyzB,GAEA9uB,GAAA8J,OAAAc,IACA8rB,cAAA,WAEA,MADAZ,KACAI,GAEA1oB,kBAAA,WAEA,MADAsoB,KACAO,GAEAvqB,iBAAA,WAEA,MADAgqB,KACAS,GAEAI,mBAAA,WAEA,MADAb,KACAK,QAyEA,IAKAS,IAAA,4BACAC,IAAY77B,SAAA,WAAA87B,WAAA,SAAA9xB,QAAA,SACZ+xB,IACAC,cAAA,IACAC,WAAA,OAGAxqB,IAAA,qBACAJ,GAAAlR,GAAAoE,cAAA,OAAAxE,KAoIAiF,IAAA8J,QAIA2G,UACAjC,SACAhJ,IAAA,SAAAhF,EAAAiL,GACA,GAAAA,EAAA,CAGA,GAAA5F,GAAA2F,EAAAhL,EAAA,UACA,YAAAqF,EAAA,IAAAA,MAOAvB,WACA4yB,yBAAA,EACAC,aAAA,EACAC,aAAA,EACAC,UAAA,EACAC,YAAA,EACAL,YAAA,EACAM,YAAA,EACA/oB,SAAA,EACAgpB,OAAA,EACAC,SAAA,EACAC,QAAA,EACAC,QAAA,EACAC,MAAA,GAKAC,UACAC,MAAA,YAIA/8B,MAAA,SAAAyF,EAAA6C,EAAAtB,EAAAgL,GAGA,GAAAvM,GAAA,IAAAA,EAAAE,UAAA,IAAAF,EAAAE,UAAAF,EAAAzF,MAAA,CAKA,GAAA8K,GAAA9F,EAAAkP,EACA8oB,EAAA/3B,GAAAuQ,UAAAlN,GACAtI,EAAAyF,EAAAzF,KASA,OAPAsI,GAAArD,GAAA63B,SAAAE,KACA/3B,GAAA63B,SAAAE,GAAA3rB,EAAA2rB,OAGA9oB,EAAAjP,GAAAyQ,SAAApN,IAAArD,GAAAyQ,SAAAsnB,GAGAx1B,SAAAR,EAoCAkN,GAAA,OAAAA,IACA1M,UAAAsD,EAAAoJ,EAAAzJ,IAAAhF,GAAA,EAAAuM,IAEAlH,EAIA9K,EAAAsI,IA1CAtD,QAAAgC,GAGA,WAAAhC,IAAA8F,EAAArB,GAAAC,KAAA1C,KAAA8D,EAAA,KACA9D,EAAA4B,EAAAnD,EAAA6C,EAAAwC,GAGA9F,EAAA,UAIA,MAAAgC,WAKA,WAAAhC,IACAgC,GAAA8D,KAAA,KAAA7F,GAAAsE,UAAAyzB,GAAA,UAIAntB,GAAA6rB,iBAAA,KAAA10B,GAAA,IAAAsB,EAAA1C,QAAA,gBACA5F,EAAAsI,GAAA,WAIA4L,GAAA,OAAAA,IACA1M,UAAAR,EAAAkN,EAAArR,IAAA4C,EAAAuB,EAAAgL,MAEAhS,EAAAsI,GAAAtB,IAlBA,UAmCAoC,IAAA,SAAA3D,EAAA6C,EAAA0J,EAAAE,GACA,GAAAC,GAAA2J,EAAA5H,EACA8oB,EAAA/3B,GAAAuQ,UAAAlN,EAyBA,OAtBAA,GAAArD,GAAA63B,SAAAE,KACA/3B,GAAA63B,SAAAE,GAAA3rB,EAAA2rB,OAGA9oB,EAAAjP,GAAAyQ,SAAApN,IAAArD,GAAAyQ,SAAAsnB,GAGA9oB,GAAA,OAAAA,KACA/B,EAAA+B,EAAAzJ,IAAAhF,GAAA,EAAAuM,IAIAxK,SAAA2K,IACAA,EAAA1B,EAAAhL,EAAA6C,EAAA4J,IAIA,WAAAC,GAAA7J,IAAA0zB,MACA7pB,EAAA6pB,GAAA1zB,IAIA,KAAA0J,MACA8J,EAAApJ,WAAAP,GACAH,KAAA,GAAAirB,SAAAnhB,MAAA,EAAA3J,GAEAA,KAIAlN,GAAAqB,MAAA,2BAAAZ,EAAA4C,GACArD,GAAAyQ,SAAApN,IACAmC,IAAA,SAAAhF,EAAAiL,EAAAsB,GACA,GAAAtB,EAIA,OAAAmrB,GAAA/1B,KAAAb,GAAAmE,IAAA3D,EAAA,aAQAA,EAAA8M,iBAAAxN,QAAAU,EAAA+M,wBAAA/O,MAIA4O,EAAA5M,EAAA6C,EAAA0J,GAHAihB,GAAAxtB,EAAAq2B,GAAA,WACA,MAAAzpB,GAAA5M,EAAA6C,EAAA0J,MAMAnP,IAAA,SAAA4C,EAAAuB,EAAAgL,GACA,GAAAH,GACAK,EAAAF,GAAAnB,GAAApL,GACAmM,EAAAI,GAAAD,EACAtM,EACA6C,EACA0J,EACA,eAAA/M,GAAAmE,IAAA3D,EAAA,eAAAyM,GACAA,EAWA,OAPAN,KAAAC,EAAApI,GAAAC,KAAA1C,KACA,QAAA6K,EAAA,YAEApM,EAAAzF,MAAAsI,GAAAtB,EACAA,EAAA/B,GAAAmE,IAAA3D,EAAA6C,IAGAqJ,EAAAlM,EAAAuB,EAAA4K,OAKA3M,GAAAyQ,SAAA2lB,WAAAnqB,EAAArB,GAAA+rB,mBACA,SAAAn2B,EAAAiL,GACA,GAAAA,EACA,OAAAgC,WAAAjC,EAAAhL,EAAA,gBACAA,EAAA+M,wBAAAtS,KACA+yB,GAAAxtB,GAAkB41B,WAAA,GAAgB,WAClC,MAAA51B,GAAA+M,wBAAAtS,QAEA,OAMA+E,GAAAqB,MACA42B,OAAA,GACAC,QAAA,GACAC,OAAA,SACC,SAAA3lB,EAAA4lB,GACDp4B,GAAAyQ,SAAA+B,EAAA4lB,IACA1nB,OAAA,SAAA3O,GAOA,IANA,GAAAtB,GAAA,EACA43B,KAGAC,EAAA,gBAAAv2B,KAAAoT,MAAA,MAAApT,GAEUtB,EAAA,EAAOA,IACjB43B,EAAA7lB,EAAArF,GAAA1M,GAAA23B,GACAE,EAAA73B,IAAA63B,EAAA73B,EAAA,IAAA63B,EAAA,EAGA,OAAAD,KAIArsB,GAAAnL,KAAA2R,KACAxS,GAAAyQ,SAAA+B,EAAA4lB,GAAAx6B,IAAA8O,KAIA1M,GAAAqI,GAAAyB,QACA3F,IAAA,SAAAd,EAAAtB,GACA,MAAA6H,IAAAjO,KAAA,SAAA6E,EAAA6C,EAAAtB,GACA,GAAAkL,GAAAgK,EACAhM,KACAxK,EAAA,CAEA,IAAAT,GAAAwQ,QAAAnN,GAAA,CAIA,IAHA4J,EAAArB,GAAApL,GACAyW,EAAA5T,EAAAvD,OAEWW,EAAAwW,EAASxW,IACpBwK,EAAA5H,EAAA5C,IAAAT,GAAAmE,IAAA3D,EAAA6C,EAAA5C,IAAA,EAAAwM,EAGA,OAAAhC,GAGA,MAAA1I,UAAAR,EACA/B,GAAAjF,MAAAyF,EAAA6C,EAAAtB,GACA/B,GAAAmE,IAAA3D,EAAA6C,IACGA,EAAAtB,EAAA4G,UAAA7I,OAAA,MAQHE,GAAA0N,QAEAA,EAAAlS,WACAmb,YAAAjJ,EACApS,KAAA,SAAAkF,EAAAW,EAAAyC,EAAAe,EAAAgJ,EAAAtJ,GACA1I,KAAA6E,OACA7E,KAAAiI,OACAjI,KAAAgS,UAAA3N,GAAA2N,OAAAxG,SACAxL,KAAAwF,UACAxF,KAAA+I,MAAA/I,KAAAwS,IAAAxS,KAAAqF,MACArF,KAAAgJ,MACAhJ,KAAA0I,SAAArE,GAAAsE,UAAAV,GAAA,UAEA5C,IAAA,WACA,GAAAiO,GAAAvB,EAAA6qB,UAAA58B,KAAAiI,KAEA,OAAAqL,MAAAzJ,IACAyJ,EAAAzJ,IAAA7J,MACA+R,EAAA6qB,UAAApxB,SAAA3B,IAAA7J,OAEA4V,IAAA,SAAAF,GACA,GAAAmnB,GACAvpB,EAAAvB,EAAA6qB,UAAA58B,KAAAiI,KAoBA,OAlBAjI,MAAAwF,QAAAiQ,SACAzV,KAAA88B,IAAAD,EAAAx4B,GAAA2N,OAAAhS,KAAAgS,QACA0D,EAAA1V,KAAAwF,QAAAiQ,SAAAC,EAAA,IAAA1V,KAAAwF,QAAAiQ,UAGAzV,KAAA88B,IAAAD,EAAAnnB,EAEA1V,KAAAwS,KAAAxS,KAAAgJ,IAAAhJ,KAAA+I,OAAA8zB,EAAA78B,KAAA+I,MAEA/I,KAAAwF,QAAAu3B,MACA/8B,KAAAwF,QAAAu3B,KAAA9+B,KAAA+B,KAAA6E,KAAA7E,KAAAwS,IAAAxS,MAGAsT,KAAArR,IACAqR,EAAArR,IAAAjC,MAEA+R,EAAA6qB,UAAApxB,SAAAvJ,IAAAjC,MAEAA,OAIA+R,EAAAlS,UAAAF,KAAAE,UAAAkS,EAAAlS,UAEAkS,EAAA6qB,WACApxB,UACA3B,IAAA,SAAA1B,GACA,GAAA8M,EAIA,YAAA9M,EAAAtD,KAAAE,UACA,MAAAoD,EAAAtD,KAAAsD,EAAAF,OAAA,MAAAE,EAAAtD,KAAAzF,MAAA+I,EAAAF,MACAE,EAAAtD,KAAAsD,EAAAF,OAOAgN,EAAA5Q,GAAAmE,IAAAL,EAAAtD,KAAAsD,EAAAF,KAAA,IAGAgN,GAAA,SAAAA,IAAA,IAEAhT,IAAA,SAAAkG,GAKA9D,GAAA8N,GAAA4qB,KAAA50B,EAAAF,MACA5D,GAAA8N,GAAA4qB,KAAA50B,EAAAF,MAAAE,GACI,IAAAA,EAAAtD,KAAAE,UACJ,MAAAoD,EAAAtD,KAAAzF,MAAAiF,GAAA63B,SAAA/zB,EAAAF,SACA5D,GAAAyQ,SAAA3M,EAAAF,MAGAE,EAAAtD,KAAAsD,EAAAF,MAAAE,EAAAqK,IAFAnO,GAAAjF,MAAA+I,EAAAtD,KAAAsD,EAAAF,KAAAE,EAAAqK,IAAArK,EAAAO,SAUAqJ,EAAA6qB,UAAAI,UAAAjrB,EAAA6qB,UAAAK,YACAh7B,IAAA,SAAAkG,GACAA,EAAAtD,KAAAE,UAAAoD,EAAAtD,KAAAd,aACAoE,EAAAtD,KAAAsD,EAAAF,MAAAE,EAAAqK,OAKAnO,GAAA2N,QACAkrB,OAAA,SAAA9+B,GACA,MAAAA,IAEA++B,MAAA,SAAA/+B,GACA,SAAA0C,KAAAs8B,IAAAh/B,EAAA0C,KAAAu8B,IAAA,GAEA7xB,SAAA,SAGAnH,GAAA8N,GAAAJ,EAAAlS,UAAAF,KAGA0E,GAAA8N,GAAA4qB,OAKA,IACAxqB,IAAAL,GACAmC,GAAA,yBACAipB,GAAA,aAuXAj5B,IAAA2O,UAAA3O,GAAA8J,OAAA6E,GAEAC,UACAsqB,KAAA,SAAAt1B,EAAA7B,GACA,GAAA+B,GAAAnI,KAAA8S,YAAA7K,EAAA7B,EAEA,OADA4B,GAAAG,EAAAtD,KAAAoD,EAAAY,GAAAC,KAAA1C,GAAA+B,GACAA,KAIAq1B,QAAA,SAAArqB,EAAAxE,GACAtK,GAAAM,WAAAwO,IACAxE,EAAAwE,EACAA,GAAA,MAEAA,IAAAxN,MAAAC,GAOA,KAJA,GAAAqC,GACA0B,EAAA,EACAxF,EAAAgP,EAAAhP,OAESwF,EAAAxF,EAAgBwF,IACzB1B,EAAAkL,EAAAxJ,GACAqJ,EAAAC,SAAAhL,GAAA+K,EAAAC,SAAAhL,OACA+K,EAAAC,SAAAhL,GAAAqP,QAAA3I,IAIAwG,YAAAjC,GAEAuqB,UAAA,SAAA9uB,EAAA0qB,GACAA,EACArmB,EAAAmC,WAAAmC,QAAA3I,GAEAqE,EAAAmC,WAAApJ,KAAA4C,MAKAtK,GAAAq5B,MAAA,SAAAA,EAAA1rB,EAAAtF,GACA,GAAAixB,GAAAD,GAAA,gBAAAA,GAAAr5B,GAAA8J,UAAiEuvB,IACjEnnB,SAAA7J,OAAAsF,GACA3N,GAAAM,WAAA+4B,MACAjoB,SAAAioB,EACA1rB,OAAAtF,GAAAsF,OAAA3N,GAAAM,WAAAqN,MAoCA,OAhCA3N,IAAA8N,GAAArF,KAAAtN,GAAAqU,OACA8pB,EAAAloB,SAAA,EAGA,gBAAAkoB,GAAAloB,WACAkoB,EAAAloB,WAAApR,IAAA8N,GAAAyrB,OACAD,EAAAloB,SAAApR,GAAA8N,GAAAyrB,OAAAD,EAAAloB,UAGAkoB,EAAAloB,SAAApR,GAAA8N,GAAAyrB,OAAApyB,UAMA,MAAAmyB,EAAA5pB,OAAA4pB,EAAA5pB,SAAA,IACA4pB,EAAA5pB,MAAA,MAIA4pB,EAAArL,IAAAqL,EAAApnB,SAEAonB,EAAApnB,SAAA,WACAlS,GAAAM,WAAAg5B,EAAArL,MACAqL,EAAArL,IAAAr0B,KAAA+B,MAGA29B,EAAA5pB,OACA1P,GAAAwtB,QAAA7xB,KAAA29B,EAAA5pB,QAIA4pB,GAGAt5B,GAAAqI,GAAAyB,QACA0vB,OAAA,SAAAH,EAAAI,EAAA9rB,EAAArD,GAGA,MAAA3O,MAAAmF,OAAA2E,IAAAtB,IAAA,aAAAiB,OAGAT,MAAA+0B,SAAoBlrB,QAAAirB,GAAcJ,EAAA1rB,EAAArD,IAElCovB,QAAA,SAAA91B,EAAAy1B,EAAA1rB,EAAArD,GACA,GAAAuF,GAAA7P,GAAAiQ,cAAArM,GACA+1B,EAAA35B,GAAAq5B,QAAA1rB,EAAArD,GACAsvB,EAAA,WAGA,GAAAtqB,GAAAX,EAAAhT,KAAAqE,GAAA8J,UAAiDlG,GAAA+1B,IAGjD9pB,GAAAtK,GAAAC,IAAA7J,KAAA,YACA2T,EAAAsC,MAAA,GAKA,OAFAgoB,GAAAC,OAAAD,EAEA/pB,GAAA8pB,EAAAjqB,SAAA,EACA/T,KAAA0F,KAAAu4B,GACAj+B,KAAA+T,MAAAiqB,EAAAjqB,MAAAkqB,IAEAhoB,KAAA,SAAA7R,EAAA4tB,EAAA9b,GACA,GAAAioB,GAAA,SAAA7qB,GACA,GAAA2C,GAAA3C,EAAA2C,WACA3C,GAAA2C,KACAA,EAAAC,GAYA,OATA,gBAAA9R,KACA8R,EAAA8b,EACAA,EAAA5tB,EACAA,EAAAwC,QAEAorB,GAAA5tB,KAAA,GACApE,KAAA+T,MAAA3P,GAAA,SAGApE,KAAA0F,KAAA,WACA,GAAAmsB,IAAA,EACAloB,EAAA,MAAAvF,KAAA,aACAg6B,EAAA/5B,GAAA+5B,OACAh3B,EAAAwC,GAAAC,IAAA7J,KAEA,IAAA2J,EACAvC,EAAAuC,IAAAvC,EAAAuC,GAAAsM,MACAkoB,EAAA/2B,EAAAuC,QAGA,KAAAA,IAAAvC,GACAA,EAAAuC,IAAAvC,EAAAuC,GAAAsM,MAAAqnB,GAAAp4B,KAAAyE,IACAw0B,EAAA/2B,EAAAuC,GAKA,KAAAA,EAAAy0B,EAAAj6B,OAA+BwF,KAC/By0B,EAAAz0B,GAAA9E,OAAA7E,MACA,MAAAoE,GAAAg6B,EAAAz0B,GAAAoK,QAAA3P,IAEAg6B,EAAAz0B,GAAAgK,KAAAsC,KAAAC,GACA2b,GAAA,EACAuM,EAAA5iB,OAAA7R,EAAA,KAOAkoB,GAAA3b,GACA7R,GAAAwtB,QAAA7xB,KAAAoE,MAIA85B,OAAA,SAAA95B,GAIA,MAHAA,MAAA,IACAA,KAAA,MAEApE,KAAA0F,KAAA,WACA,GAAAiE,GACAvC,EAAAwC,GAAAC,IAAA7J,MACA+T,EAAA3M,EAAAhD,EAAA,SACAkP,EAAAlM,EAAAhD,EAAA,cACAg6B,EAAA/5B,GAAA+5B,OACAj6B,EAAA4P,IAAA5P,OAAA,CAaA,KAVAiD,EAAA82B,QAAA,EAGA75B,GAAA0P,MAAA/T,KAAAoE,MAEAkP,KAAA2C,MACA3C,EAAA2C,KAAAhY,KAAA+B,MAAA,GAIA2J,EAAAy0B,EAAAj6B,OAA+BwF,KAC/By0B,EAAAz0B,GAAA9E,OAAA7E,MAAAo+B,EAAAz0B,GAAAoK,QAAA3P,IACAg6B,EAAAz0B,GAAAgK,KAAAsC,MAAA,GACAmoB,EAAA5iB,OAAA7R,EAAA,GAKA,KAAAA,EAAA,EAAmBA,EAAAxF,EAAgBwF,IACnCoK,EAAApK,IAAAoK,EAAApK,GAAAu0B,QACAnqB,EAAApK,GAAAu0B,OAAAjgC,KAAA+B,YAKAoH,GAAA82B,YAKA75B,GAAAqB,MAAA,iCAAAZ,EAAA4C,GACA,GAAA22B,GAAAh6B,GAAAqI,GAAAhF,EACArD,IAAAqI,GAAAhF,GAAA,SAAAg2B,EAAA1rB,EAAArD,GACA,aAAA+uB,GAAA,iBAAAA,GACAW,EAAAtxB,MAAA/M,KAAAgN,WACAhN,KAAA+9B,QAAAtrB,EAAA/K,GAAA,GAAAg2B,EAAA1rB,EAAArD,MAKAtK,GAAAqB,MACA44B,UAAA7rB,EAAA,QACA8rB,QAAA9rB,EAAA,QACA+rB,YAAA/rB,EAAA,UACAgsB,QAAU5rB,QAAA,QACV6rB,SAAW7rB,QAAA,QACX8rB,YAAc9rB,QAAA,WACb,SAAAnL,EAAAyL,GACD9O,GAAAqI,GAAAhF,GAAA,SAAAg2B,EAAA1rB,EAAArD,GACA,MAAA3O,MAAA+9B,QAAA5qB,EAAAuqB,EAAA1rB,EAAArD,MAIAtK,GAAA+5B,UACA/5B,GAAA8N,GAAAC,KAAA,WACA,GAAAiE,GACAvR,EAAA,EACAs5B,EAAA/5B,GAAA+5B,MAIA,KAFA7rB,GAAAlO,GAAAmO,MAEQ1N,EAAAs5B,EAAAj6B,OAAmBW,IAC3BuR,EAAA+nB,EAAAt5B,GAGAuR,KAAA+nB,EAAAt5B,KAAAuR,GACA+nB,EAAA5iB,OAAA1W,IAAA,EAIAs5B,GAAAj6B,QACAE,GAAA8N,GAAA8D,OAEA1D,GAAA3L,QAGAvC,GAAA8N,GAAAkE,MAAA,SAAAA,GACAhS,GAAA+5B,OAAAryB,KAAAsK,GACAA,IACAhS,GAAA8N,GAAApJ,QAEA1E,GAAA+5B,OAAA3a,OAIApf,GAAA8N,GAAAysB,SAAA,GACAv6B,GAAA8N,GAAApJ,MAAA,WACAmJ,KACAA,GAAA5T,EAAAsE,sBACAtE,EAAAsE,sBAAAqP,GACA3T,EAAAugC,YAAAx6B,GAAA8N,GAAAC,KAAA/N,GAAA8N,GAAAysB,YAIAv6B,GAAA8N,GAAA8D,KAAA,WACA3X,EAAAwgC,qBACAxgC,EAAAwgC,qBAAA5sB,IAEA5T,EAAAygC,cAAA7sB,IAGAA,GAAA,MAGA7N,GAAA8N,GAAAyrB,QACAoB,KAAA,IACAC,KAAA,IAGAzzB,SAAA,KAMAnH,GAAAqI,GAAAwyB,MAAA,SAAAC,EAAA/6B,GAIA,MAHA+6B,GAAA96B,GAAA8N,GAAA9N,GAAA8N,GAAAyrB,OAAAuB,QACA/6B,KAAA,KAEApE,KAAA+T,MAAA3P,EAAA,SAAAqc,EAAAnN,GACA,GAAA8rB,GAAA9gC,EAAAgU,WAAAmO,EAAA0e,EACA7rB,GAAA2C,KAAA,WACA3X,EAAA+gC,aAAAD,OAMA,WACA,GAAA9X,GAAA9nB,GAAAoE,cAAA,SACA4a,EAAAhf,GAAAoE,cAAA,UACA+5B,EAAAnf,EAAA9e,YAAAF,GAAAoE,cAAA,UAEA0jB,GAAAljB,KAAA,WAIA6K,GAAAqwB,QAAA,KAAAhY,EAAAlhB,MAIA6I,GAAAswB,YAAA5B,EAAAjmB,SAIA4P,EAAA9nB,GAAAoE,cAAA,SACA0jB,EAAAlhB,MAAA,IACAkhB,EAAAljB,KAAA,QACA6K,GAAAuwB,WAAA,MAAAlY,EAAAlhB,QAIA,IAAAq5B,IACAtgB,GAAA9a,GAAAgkB,KAAAlJ,UAEA9a,IAAAqI,GAAAyB,QACAma,KAAA,SAAA5gB,EAAAtB,GACA,MAAA6H,IAAAjO,KAAAqE,GAAAikB,KAAA5gB,EAAAtB,EAAA4G,UAAA7I,OAAA,IAGAu7B,WAAA,SAAAh4B,GACA,MAAA1H,MAAA0F,KAAA,WACArB,GAAAq7B,WAAA1/B,KAAA0H,QAKArD,GAAA8J,QACAma,KAAA,SAAAzjB,EAAA6C,EAAAtB,GACA,GAAA8D,GAAAoJ,EACAqsB,EAAA96B,EAAAE,QAGA,QAAA46B,GAAA,IAAAA,GAAA,IAAAA,EAKA,yBAAA96B,GAAAiD,aACAzD,GAAA4D,KAAApD,EAAA6C,EAAAtB,IAKA,IAAAu5B,GAAAt7B,GAAAgoB,SAAAxnB,KACAyO,EAAAjP,GAAAu7B,UAAAl4B,EAAAG,iBACAxD,GAAAgkB,KAAA1iB,MAAA+f,KAAAxgB,KAAAwC,GAAA+3B,GAAA74B,SAGAA,SAAAR,EACA,OAAAA,MACA/B,IAAAq7B,WAAA76B,EAAA6C,GAIA4L,GAAA,OAAAA,IACA1M,UAAAsD,EAAAoJ,EAAArR,IAAA4C,EAAAuB,EAAAsB,IACAwC,GAGArF,EAAAqZ,aAAAxW,EAAAtB,EAAA,IACAA,GAGAkN,GAAA,OAAAA,IAAA,QAAApJ,EAAAoJ,EAAAzJ,IAAAhF,EAAA6C,IACAwC,GAGAA,EAAA7F,GAAAkf,KAAA+E,KAAAzjB,EAAA6C,GAGA,MAAAwC,EAAAtD,OAAAsD,KAGA01B,WACAx7B,MACAnC,IAAA,SAAA4C,EAAAuB,GACA,IAAA6I,GAAAuwB,YAAA,UAAAp5B,GACA/B,GAAA+E,SAAAvE,EAAA,UACA,GAAA0M,GAAA1M,EAAAuB,KAKA,OAJAvB,GAAAqZ,aAAA,OAAA9X,GACAmL,IACA1M,EAAAuB,MAAAmL,GAEAnL,MAMAs5B,WAAA,SAAA76B,EAAAuB,GACA,GAAAsB,GACA5C,EAAA,EAIA+6B,EAAAz5B,KAAAT,MAAAC,GAEA,IAAAi6B,GAAA,IAAAh7B,EAAAE,SACA,KAAA2C,EAAAm4B,EAAA/6B,MACAD,EAAA0I,gBAAA7F,MAOA+3B,IACAx9B,IAAA,SAAA4C,EAAAuB,EAAAsB,GAQA,MAPAtB,MAAA,EAGA/B,GAAAq7B,WAAA76B,EAAA6C,GAEA7C,EAAAqZ,aAAAxW,KAEAA,IAIArD,GAAAqB,KAAArB,GAAAgkB,KAAA1iB,MAAA+f,KAAA0M,OAAAzsB,MAAA,iBAAAb,EAAA4C,GACA,GAAAo4B,GAAA3gB,GAAAzX,IAAArD,GAAAkf,KAAA+E,IAEAnJ,IAAAzX,GAAA,SAAA7C,EAAA6C,EAAAkc,GACA,GAAA1Z,GAAAgE,EACA6xB,EAAAr4B,EAAAG,aAYA,OAVA+b,KAGA1V,EAAAiR,GAAA4gB,GACA5gB,GAAA4gB,GAAA71B,EACAA,EAAA,MAAA41B,EAAAj7B,EAAA6C,EAAAkc,GACAmc,EACA,KACA5gB,GAAA4gB,GAAA7xB,GAEAhE,IAOA,IAAA81B,IAAA,sCACAC,GAAA,eAEA57B,IAAAqI,GAAAyB,QACAlG,KAAA,SAAAP,EAAAtB,GACA,MAAA6H,IAAAjO,KAAAqE,GAAA4D,KAAAP,EAAAtB,EAAA4G,UAAA7I,OAAA,IAGA+7B,WAAA,SAAAx4B,GACA,MAAA1H,MAAA0F,KAAA,iBACA1F,MAAAqE,GAAA87B,QAAAz4B,YAKArD,GAAA8J,QACAlG,KAAA,SAAApD,EAAA6C,EAAAtB,GACA,GAAA8D,GAAAoJ,EACAqsB,EAAA96B,EAAAE,QAGA,QAAA46B,GAAA,IAAAA,GAAA,IAAAA,EAWA,MAPA,KAAAA,GAAAt7B,GAAAgoB,SAAAxnB,KAGA6C,EAAArD,GAAA87B,QAAAz4B,MACA4L,EAAAjP,GAAAu4B,UAAAl1B,IAGAd,SAAAR,EACAkN,GAAA,OAAAA,IACA1M,UAAAsD,EAAAoJ,EAAArR,IAAA4C,EAAAuB,EAAAsB,IACAwC,EAGArF,EAAA6C,GAAAtB,EAGAkN,GAAA,OAAAA,IAAA,QAAApJ,EAAAoJ,EAAAzJ,IAAAhF,EAAA6C,IACAwC,EAGArF,EAAA6C,IAGAk1B,WACA9R,UACAjhB,IAAA,SAAAhF,GAOA,GAAAu7B,GAAA/7B,GAAAkf,KAAA+E,KAAAzjB,EAAA,WAEA,OAAAu7B,GACAC,SAAAD,EAAA,IAIAJ,GAAA96B,KAAAL,EAAAuE,WACA62B,GAAA/6B,KAAAL,EAAAuE,WACAvE,EAAAgmB,KAEA,GAGA,KAKAsV,SACAG,IAAA,UACAC,MAAA,eAYAtxB,GAAAswB,cACAl7B,GAAAu4B,UAAAllB,UACA7N,IAAA,SAAAhF,GAIA,GAAAklB,GAAAllB,EAAAd,UAIA,OAHAgmB,MAAAhmB,YACAgmB,EAAAhmB,WAAAgnB,cAEA,MAEA9oB,IAAA,SAAA4C,GAIA,GAAAklB,GAAAllB,EAAAd,UACAgmB,KACAA,EAAAgB,cAEAhB,EAAAhmB,YACAgmB,EAAAhmB,WAAAgnB,kBAOA1mB,GAAAqB,MACA,WACA,WACA,YACA,cACA,cACA,UACA,UACA,SACA,cACA,mBACA,WACArB,GAAA87B,QAAAngC,KAAA6H,eAAA7H,OAkBAqE,GAAAqI,GAAAyB,QACAqyB,SAAA,SAAAp6B,GACA,GAAAq6B,GAAA57B,EAAAQ,EAAAq7B,EAAAC,EAAA11B,EAAA21B,EACA97B,EAAA,CAEA,IAAAT,GAAAM,WAAAyB,GACA,MAAApG,MAAA0F,KAAA,SAAAuF,GACA5G,GAAArE,MAAAwgC,SAAAp6B,EAAAnI,KAAA+B,KAAAiL,EAAA0L,EAAA3W,SAIA,oBAAAoG,MAGA,IAFAq6B,EAAAr6B,EAAAT,MAAAC,QAEAf,EAAA7E,KAAA8E,MAIA,GAHA47B,EAAA/pB,EAAA9R,GACAQ,EAAA,IAAAR,EAAAE,UAAA,IAAAyR,EAAAkqB,GAAA,IAEA,CAEA,IADAz1B,EAAA,EACA01B,EAAAF,EAAAx1B,MACA5F,EAAAL,QAAA,IAAA27B,EAAA,SACAt7B,GAAAs7B,EAAA,IAKAC,GAAApqB,EAAAnR,GACAq7B,IAAAE,GACA/7B,EAAAqZ,aAAA,QAAA0iB,GAMA,MAAA5gC,OAGA6gC,YAAA,SAAAz6B,GACA,GAAAq6B,GAAA57B,EAAAQ,EAAAq7B,EAAAC,EAAA11B,EAAA21B,EACA97B,EAAA,CAEA,IAAAT,GAAAM,WAAAyB,GACA,MAAApG,MAAA0F,KAAA,SAAAuF,GACA5G,GAAArE,MAAA6gC,YAAAz6B,EAAAnI,KAAA+B,KAAAiL,EAAA0L,EAAA3W,SAIA,KAAAgN,UAAA7I,OACA,MAAAnE,MAAAsoB,KAAA,WAGA,oBAAAliB,MAGA,IAFAq6B,EAAAr6B,EAAAT,MAAAC,QAEAf,EAAA7E,KAAA8E,MAMA,GALA47B,EAAA/pB,EAAA9R,GAGAQ,EAAA,IAAAR,EAAAE,UAAA,IAAAyR,EAAAkqB,GAAA,IAEA,CAEA,IADAz1B,EAAA,EACA01B,EAAAF,EAAAx1B,MAGA,KAAA5F,EAAAL,QAAA,IAAA27B,EAAA,SACAt7B,IAAAsC,QAAA,IAAAg5B,EAAA,QAKAC,GAAApqB,EAAAnR,GACAq7B,IAAAE,GACA/7B,EAAAqZ,aAAA,QAAA0iB,GAMA,MAAA5gC,OAGA8gC,YAAA,SAAA16B,EAAA26B,GACA,GAAA38B,SAAAgC,EAEA,wBAAA26B,IAAA,WAAA38B,EACA28B,EAAA/gC,KAAAwgC,SAAAp6B,GAAApG,KAAA6gC,YAAAz6B,GAGA/B,GAAAM,WAAAyB,GACApG,KAAA0F,KAAA,SAAAZ,GACAT,GAAArE,MAAA8gC,YACA16B,EAAAnI,KAAA+B,KAAA8E,EAAA6R,EAAA3W,MAAA+gC,GACAA,KAKA/gC,KAAA0F,KAAA,WACA,GAAAshB,GAAAliB,EAAA/E,EAAAihC,CAEA,eAAA58B,EAOA,IAJAU,EAAA,EACA/E,EAAAsE,GAAArE,MACAghC,EAAA56B,EAAAT,MAAAC,QAEAohB,EAAAga,EAAAl8B,MAGA/E,EAAAkhC,SAAAja,GACAjnB,EAAA8gC,YAAA7Z,GAEAjnB,EAAAygC,SAAAxZ,OAKIpgB,UAAAR,GAAA,YAAAhC,IACJ4iB,EAAArQ,EAAA3W,MACAgnB,GAGApd,GAAA3H,IAAAjC,KAAA,gBAAAgnB,GAOAhnB,KAAAke,cACAle,KAAAke,aAAA,QACA8I,GAAA5gB,KAAA,EACA,GACAwD,GAAAC,IAAA7J,KAAA,0BAOAihC,SAAA,SAAAx0B,GACA,GAAAua,GAAAniB,EACAC,EAAA,CAGA,KADAkiB,EAAA,IAAAva,EAAA,IACA5H,EAAA7E,KAAA8E,MACA,OAAAD,EAAAE,WACA,IAAAyR,EAAAG,EAAA9R,IAAA,KAAAG,QAAAgiB,IAAA,EACA,QAIA,YAOA,IAAAka,IAAA,KAEA78B,IAAAqI,GAAAyB,QACAoD,IAAA,SAAAnL,GACA,GAAAkN,GAAApJ,EAAAvF,EACAE,EAAA7E,KAAA,EAEA,KAAAgN,UAAA7I,OA4BA,MAFAQ,GAAAN,GAAAM,WAAAyB,GAEApG,KAAA0F,KAAA,SAAAZ,GACA,GAAAyM,EAEA,KAAAvR,KAAA+E,WAKAwM,EADA5M,EACAyB,EAAAnI,KAAA+B,KAAA8E,EAAAT,GAAArE,MAAAuR,OAEAnL,EAIA,MAAAmL,EACAA,EAAA,GAEI,gBAAAA,GACJA,GAAA,GAEIlN,GAAAwQ,QAAAtD,KACJA,EAAAlN,GAAAiL,IAAAiC,EAAA,SAAAnL,GACA,aAAAA,EAAA,GAAAA,EAAA,MAIAkN,EAAAjP,GAAA88B,SAAAnhC,KAAAoE,OAAAC,GAAA88B,SAAAnhC,KAAAoJ,SAAAvB,eAGAyL,GAAA,OAAAA,IAAA1M,SAAA0M,EAAArR,IAAAjC,KAAAuR,EAAA,WACAvR,KAAAoG,MAAAmL,KAzDA,IAAA1M,EAIA,MAHAyO,GAAAjP,GAAA88B,SAAAt8B,EAAAT,OACAC,GAAA88B,SAAAt8B,EAAAuE,SAAAvB,eAEAyL,GACA,OAAAA,IACA1M,UAAAsD,EAAAoJ,EAAAzJ,IAAAhF,EAAA,UAEAqF,GAGAA,EAAArF,EAAAuB,MAGA,gBAAA8D,GACAA,EAAAvC,QAAAu5B,GAAA,IAIA,MAAAh3B,EAAA,GAAAA,OA4CA7F,GAAA8J,QACAgzB,UACA3O,QACA3oB,IAAA,SAAAhF,GAEA,GAAA0M,GAAAlN,GAAAkf,KAAA+E,KAAAzjB,EAAA,QACA,cAAA0M,EACAA,EAMAiF,EAAAnS,GAAAR,KAAAgB,MAGA2Z,QACA3U,IAAA,SAAAhF,GACA,GAAAuB,GAAAosB,EAAA1tB,EACAU,EAAAX,EAAAW,QACAmE,EAAA9E,EAAAkmB,cACApe,EAAA,eAAA9H,EAAAT,KACAsF,EAAAiD,EAAA,QACAuE,EAAAvE,EAAAhD,EAAA,EAAAnE,EAAArB,MAUA,KAPAW,EADA6E,EAAA,EACAuH,EAGAvE,EAAAhD,EAAA,EAIW7E,EAAAoM,EAASpM,IAKpB,GAJA0tB,EAAAhtB,EAAAV,IAIA0tB,EAAA9a,UAAA5S,IAAA6E,KAGA6oB,EAAA3S,YACA2S,EAAAzuB,WAAA8b,WACAxb,GAAA+E,SAAAopB,EAAAzuB,WAAA,cAMA,GAHAqC,EAAA/B,GAAAmuB,GAAAjhB,MAGA5E,EACA,MAAAvG,EAIAsD,GAAAqC,KAAA3F,GAIA,MAAAsD,IAGAzH,IAAA,SAAA4C,EAAAuB,GAMA,IALA,GAAAg7B,GAAA5O,EACAhtB,EAAAX,EAAAW,QACAkE,EAAArF,GAAAmY,UAAApW,GACAtB,EAAAU,EAAArB,OAEAW,KACA0tB,EAAAhtB,EAAAV,IAIA0tB,EAAA9a,SACArT,GAAA4H,QAAA5H,GAAA88B,SAAA3O,OAAA3oB,IAAA2oB,GAAA9oB,IAAA,KAEA03B,GAAA,EAUA,OAHAA,KACAv8B,EAAAkmB,eAAA,GAEArhB,OAOArF,GAAAqB,MAAA,+BACArB,GAAA88B,SAAAnhC,OACAiC,IAAA,SAAA4C,EAAAuB,GACA,GAAA/B,GAAAwQ,QAAAzO,GACA,MAAAvB,GAAAyJ,QAAAjK,GAAA4H,QAAA5H,GAAAQ,GAAA0M,MAAAnL,IAAA,IAIA6I,GAAAqwB,UACAj7B,GAAA88B,SAAAnhC,MAAA6J,IAAA,SAAAhF,GACA,cAAAA,EAAAiD,aAAA,cAAAjD,EAAAuB,SAWA,IAAAi7B,IAAA,iCAEAh9B,IAAA8J,OAAA9J,GAAAwI,OAEAhL,QAAA,SAAAgL,EAAAzF,EAAAvC,EAAAy8B,GAEA,GAAAx8B,GAAAO,EAAAyF,EAAAy2B,EAAAC,EAAAtzB,EAAAmhB,EACAoS,GAAA58B,GAAArF,IACA4E,EAAAgW,GAAAnc,KAAA4O,EAAA,QAAAA,EAAAzI,KAAAyI,EACAinB,EAAA1Z,GAAAnc,KAAA4O,EAAA,aAAAA,EAAAwnB,UAAA7a,MAAA,OAKA,IAHAnU,EAAAyF,EAAAjG,KAAArF,GAGA,IAAAqF,EAAAE,UAAA,IAAAF,EAAAE,WAKAs8B,GAAAn8B,KAAAd,EAAAC,GAAAwI,MAAAonB,aAIA7vB,EAAAY,QAAA,UAGA8uB,EAAA1vB,EAAAoV,MAAA,KACApV,EAAA0vB,EAAAnb,QACAmb,EAAAvY,QAEAimB,EAAAp9B,EAAAY,QAAA,aAAAZ,EAGAyI,IAAAxI,GAAA4C,SACA4F,EACA,GAAAxI,IAAAuxB,MAAAxxB,EAAA,gBAAAyI,OAGAA,EAAA60B,UAAAJ,EAAA,IACAz0B,EAAAwnB,UAAAP,EAAApd,KAAA,KACA7J,EAAAuoB,WAAAvoB,EAAAwnB,UACA,GAAAxP,QAAA,UAAAiP,EAAApd,KAAA,4BACA,KAGA7J,EAAAoI,OAAArO,OACAiG,EAAAoL,SACApL,EAAAoL,OAAApT,GAIAuC,EAAA,MAAAA,GACAyF,GACAxI,GAAAmY,UAAApV,GAAAyF,IAGAwiB,EAAAhrB,GAAAwI,MAAAwiB,QAAAjrB,OACAk9B,IAAAjS,EAAAxtB,SAAAwtB,EAAAxtB,QAAAkL,MAAAlI,EAAAuC,MAAA,IAMA,IAAAk6B,IAAAjS,EAAA4G,WAAA5xB,GAAAC,SAAAO,GAAA,CAMA,IAJA08B,EAAAlS,EAAA8E,cAAA/vB,EACAi9B,GAAAn8B,KAAAq8B,EAAAn9B,KACAiB,IAAAtB,YAEUsB,EAAKA,IAAAtB,WACf09B,EAAA11B,KAAA1G,GACAyF,EAAAzF,CAIAyF,MAAAjG,EAAAsE,eAAA3J,KACAiiC,EAAA11B,KAAAjB,EAAA+O,aAAA/O,EAAA62B,cAAArjC,GAMA,IADAwG,EAAA,GACAO,EAAAo8B,EAAA38B,QAAA+H,EAAAooB,wBAEApoB,EAAAzI,KAAAU,EAAA,EACAy8B,EACAlS,EAAA+E,UAAAhwB,EAGA8J,GAAAtE,GAAAC,IAAAxE,EAAA,eAAiDwH,EAAAzI,OACjDwF,GAAAC,IAAAxE,EAAA,UACA6I,GACAA,EAAAnB,MAAA1H,EAAA+B,GAIA8G,EAAAszB,GAAAn8B,EAAAm8B,GACAtzB,KAAAnB,OAAAukB,GAAAjsB,KACAwH,EAAAoI,OAAA/G,EAAAnB,MAAA1H,EAAA+B,GACAyF,EAAAoI,UAAA,GACApI,EAAAwoB,iBAoCA,OAhCAxoB,GAAAzI,OAGAk9B,GAAAz0B,EAAAypB,sBAEAjH,EAAA7jB,UACA6jB,EAAA7jB,SAAAuB,MAAA00B,EAAAhe,MAAArc,MAAA,IACAkqB,GAAAzsB,IAIA28B,GAAAn9B,GAAAM,WAAAE,EAAAT,MAAAC,GAAAC,SAAAO,KAGAiG,EAAAjG,EAAA28B,GAEA12B,IACAjG,EAAA28B,GAAA,MAIAn9B,GAAAwI,MAAAonB,UAAA7vB,EACAS,EAAAT,KACAC,GAAAwI,MAAAonB,UAAArtB,OAEAkE,IACAjG,EAAA28B,GAAA12B,IAMA+B,EAAAoI,SAKA2sB,SAAA,SAAAx9B,EAAAS,EAAAgI,GACA,GAAAlL,GAAA0C,GAAA8J,OACA,GAAA9J,IAAAuxB,MACA/oB,GAEAzI,OACAsyB,aAAA,GAIAryB,IAAAwI,MAAAhL,QAAAF,EAAA,KAAAkD,MAKAR,GAAAqI,GAAAyB,QAEAtM,QAAA,SAAAuC,EAAAgD,GACA,MAAApH,MAAA0F,KAAA,WACArB,GAAAwI,MAAAhL,QAAAuC,EAAAgD,EAAApH,SAGA6hC,eAAA,SAAAz9B,EAAAgD,GACA,GAAAvC,GAAA7E,KAAA,EACA,IAAA6E,EACA,MAAAR,IAAAwI,MAAAhL,QAAAuC,EAAAgD,EAAAvC,GAAA,MAMAR,GAAAqB,KAAA,wLAEA8T,MAAA,KACA,SAAA1U,EAAA4C,GAGArD,GAAAqI,GAAAhF,GAAA,SAAAN,EAAAsF,GACA,MAAAM,WAAA7I,OAAA,EACAnE,KAAA0B,GAAAgG,EAAA,KAAAN,EAAAsF,GACA1M,KAAA6B,QAAA6F,MAIArD,GAAAqI,GAAAyB,QACA2zB,MAAA,SAAAC,EAAAC,GACA,MAAAhiC,MAAAu4B,WAAAwJ,GAAAvJ,WAAAwJ,GAAAD,MAOA9yB,GAAAgzB,QAAA,aAAA3jC,GAWA2Q,GAAAgzB,SACA59B,GAAAqB,MAAeilB,MAAA,UAAAuL,KAAA,YAAqC,SAAAtiB,EAAAkhB,GAGpD,GAAA5V,GAAA,SAAArS,GACAxI,GAAAwI,MAAA+0B,SAAA9M,EAAAjoB,EAAAoL,OAAA5T,GAAAwI,MAAAioB,IAAAjoB,IAGAxI,IAAAwI,MAAAwiB,QAAAyF,IACAP,MAAA,WACA,GAAA7wB,GAAA1D,KAAAmJ,eAAAnJ,KACAkiC,EAAAt4B,GAAAqE,OAAAvK,EAAAoxB,EAEAoN,IACAx+B,EAAAojB,iBAAAlT,EAAAsL,GAAA,GAEAtV,GAAAqE,OAAAvK,EAAAoxB,GAAAoN,GAAA,OAEAxN,SAAA,WACA,GAAAhxB,GAAA1D,KAAAmJ,eAAAnJ,KACAkiC,EAAAt4B,GAAAqE,OAAAvK,EAAAoxB,GAAA,CAEAoN,GAKAt4B,GAAAqE,OAAAvK,EAAAoxB,EAAAoN,IAJAx+B,EAAAoD,oBAAA8M,EAAAsL,GAAA,GACAtV,GAAA8F,OAAAhM,EAAAoxB,OASA,IAAArK,IAAAnsB,EAAAmsB,SAEA0X,GAAA99B,GAAAmO,MAEA4vB,GAAA,IAKA/9B,IAAAg+B,SAAA,SAAAj7B,GACA,GAAAwZ,EACA,KAAAxZ,GAAA,gBAAAA,GACA,WAKA,KACAwZ,GAAA,GAAAtiB,GAAAgkC,WAAAC,gBAAAn7B,EAAA,YACE,MAAAzF,GACFif,EAAAha,OAMA,MAHAga,OAAAzW,qBAAA,eAAAhG,QACAE,GAAAsV,MAAA,gBAAAvS,GAEAwZ,EAIA,IACA7J,IAAA,QACAyrB,GAAA,SACAC,GAAA,wCACAC,GAAA,oCA0CAr+B,IAAAs+B,MAAA,SAAAtjB,EAAAvI,GACA,GAAAD,GACAjX,KACAkC,EAAA,SAAA2F,EAAAm7B,GAGA,GAAAx8B,GAAA/B,GAAAM,WAAAi+B,GACAA,IACAA,CAEAhjC,KAAAuE,QAAA0+B,mBAAAp7B,GAAA,IACAo7B,mBAAA,MAAAz8B,EAAA,GAAAA,GAIA,IAAA/B,GAAAwQ,QAAAwK,MAAAtE,SAAA1W,GAAAsX,cAAA0D,GAGAhb,GAAAqB,KAAA2Z,EAAA,WACAvd,EAAA9B,KAAA0H,KAAA1H,KAAAoG,aAOA,KAAAyQ,IAAAwI,GACAzI,EAAAC,EAAAwI,EAAAxI,GAAAC,EAAAhV,EAKA,OAAAlC,GAAA8W,KAAA,MAGArS,GAAAqI,GAAAyB,QACA20B,UAAA,WACA,MAAAz+B,IAAAs+B,MAAA3iC,KAAA+iC,mBAEAA,eAAA,WACA,MAAA/iC,MAAAsP,IAAA,WAGA,GAAA9K,GAAAH,GAAA4D,KAAAjI,KAAA,WACA,OAAAwE,GAAAH,GAAAmY,UAAAhY,GAAAxE,OAEAmF,OAAA,WACA,GAAAf,GAAApE,KAAAoE,IAGA,OAAApE,MAAA0H,OAAArD,GAAArE,MAAAysB,GAAA,cACAiW,GAAAx9B,KAAAlF,KAAAoJ,YAAAq5B,GAAAv9B,KAAAd,KACApE,KAAAsO,UAAAD,GAAAnJ,KAAAd,MAEAkL,IAAA,SAAAxK,EAAAD,GACA,GAAA0M,GAAAlN,GAAArE,MAAAuR,KAEA,cAAAA,EACA,KAGAlN,GAAAwQ,QAAAtD,GACAlN,GAAAiL,IAAAiC,EAAA,SAAAA,GACA,OAAa7J,KAAA7C,EAAA6C,KAAAtB,MAAAmL,EAAA5J,QAAA66B,GAAA,YAIF96B,KAAA7C,EAAA6C,KAAAtB,MAAAmL,EAAA5J,QAAA66B,GAAA,WACR34B,QAKH,IACAm5B,IAAA,OACAC,GAAA,OACAC,GAAA,gBACAC,GAAA,6BAGAC,GAAA,4DACAC,GAAA,iBACAC,GAAA,QAWAnuB,MAOA4C,MAGAwrB,GAAA,KAAA30B,OAAA,KAGA40B,GAAAhkC,GAAAoE,cAAA,IACA4/B,IAAA3Y,KAAAJ,GAAAI,KAgPAxmB,GAAA8J,QAGAs1B,OAAA,EAGAC,gBACAC,QAEAvrB,cACAwrB,IAAAnZ,GAAAI,KACAzmB,KAAA,MACAy/B,QAAAT,GAAAl+B,KAAAulB,GAAAqZ,UACA3gC,QAAA,EACA4gC,aAAA,EACAC,OAAA,EACAC,YAAA,mDAcAC,SACA3G,IAAAgG,GACA1/B,KAAA,aACAwL,KAAA,YACAuR,IAAA,4BACAujB,KAAA,qCAGAzrB,UACAkI,IAAA,UACAvR,KAAA,SACA80B,KAAA,YAGA7qB,gBACAsH,IAAA,cACA/c,KAAA,eACAsgC,KAAA,gBAKArrB,YAGAsrB,SAAAhe,OAGAie,aAAA,EAGAC,YAAAh9B,KAAAC,MAGAg9B,WAAAlgC,GAAAg+B,UAOAlqB,aACAyrB,KAAA,EACA55B,SAAA,IAOAw6B,UAAA,SAAAvsB,EAAAwsB,GACA,MAAAA,GAGAzsB,MAAAC,EAAA5T,GAAA+T,cAAAqsB,GAGAzsB,GAAA3T,GAAA+T,aAAAH,IAGAysB,cAAA1tB,EAAA7B,IACAwvB,cAAA3tB,EAAAe,IAGA6sB,KAAA,SAAAhB,EAAAp+B,GAmUA,QAAAiB,GAAAo+B,EAAAC,EAAAxsB,EAAAysB,GACA,GAAA9rB,GAAA+rB,EAAArrB,EAAAX,EAAAisB,EACAC,EAAAJ,CAGAj+B,KAIAA,GAAA,EAGAs+B,GACA7mC,EAAA+gC,aAAA8F,GAKAC,EAAAx+B,OAGAy+B,EAAAN,GAAA,GAGAvtB,EAAAwZ,WAAA6T,EAAA,MAGA5rB,EAAA4rB,GAAA,KAAAA,EAAA,WAAAA,EAGAvsB,IACAU,EAAAX,GAAAzY,EAAA4X,EAAAc,IAIAU,EAAAD,GAAAnZ,EAAAoZ,EAAAxB,EAAAyB,GAGAA,GAGArZ,EAAA0lC,aACAL,EAAAztB,EAAAqB,kBAAA,iBACAosB,IACA5gC,GAAAq/B,aAAA6B,GAAAN,GAEAA,EAAAztB,EAAAqB,kBAAA,QACAosB,IACA5gC,GAAAs/B,KAAA4B,GAAAN,IAKA,MAAAJ,GAAA,SAAAjlC,EAAAwE,KACA8gC,EAAA,YAGK,MAAAL,EACLK,EAAA,eAIAA,EAAAlsB,EAAAU,MACAsrB,EAAAhsB,EAAA5R,KACAuS,EAAAX,EAAAW,MACAV,GAAAU,KAKAA,EAAAurB,GACAL,GAAAK,IACAA,EAAA,QACAL,EAAA,IACAA,EAAA,KAMArtB,EAAAqtB,SACArtB,EAAA0tB,YAAAJ,GAAAI,GAAA,GAGAjsB,EACA7D,EAAAU,YAAA0vB,GAAAR,EAAAE,EAAA1tB,IAEApC,EAAAe,WAAAqvB,GAAAhuB,EAAA0tB,EAAAvrB,IAIAnC,EAAAiuB,cACAA,EAAA7+B,OAEA8+B,GACAC,EAAA9jC,QAAAoX,EAAA,2BACAzB,EAAA5X,EAAAqZ,EAAA+rB,EAAArrB,IAIAisB,EAAApX,SAAAgX,GAAAhuB,EAAA0tB,IAEAQ,IACAC,EAAA9jC,QAAA,gBAAA2V,EAAA5X,MAGAyE,GAAAo/B,QACAp/B,GAAAwI,MAAAhL,QAAA,cA3aA,gBAAA+hC,KACAp+B,EAAAo+B,EACAA,EAAAh9B,QAIApB,OAEA,IAAA4/B,GAGAG,EAGAF,EACAQ,EAGAV,EAGAW,EAGAj/B,EAGA6+B,EAGA5gC,EAGAihC,EAGAnmC,EAAAyE,GAAAmgC,aAA2Bh/B,GAG3BggC,EAAA5lC,EAAAoK,SAAApK,EAGA+lC,EAAA/lC,EAAAoK,UACAw7B,EAAAzgC,UAAAygC,EAAAzqB,QACA1W,GAAAmhC,GACAnhC,GAAAwI,MAGAuI,EAAA/Q,GAAAgR,WACAuwB,EAAAvhC,GAAAypB,UAAA,eAGA2X,EAAA7lC,EAAA6lC,eAGAO,KACAC,KAGAC,EAAA,WAGA1uB,GACAwZ,WAAA,EAGAnY,kBAAA,SAAApR,GACA,GAAA9B,EACA,IAAAkB,EAAA,CACA,IAAAg/B,EAEA,IADAA,KACAlgC,EAAAw9B,GAAAr6B,KAAAu8B,IACAQ,EAAAlgC,EAAA,GAAAkC,eAAAlC,EAAA,EAGAA,GAAAkgC,EAAAp+B,EAAAI,eAEA,aAAAlC,EAAA,KAAAA,GAIAwgC,sBAAA,WACA,MAAAt/B,GAAAw+B,EAAA,MAIAe,iBAAA,SAAA1+B,EAAAtB,GAMA,MALA,OAAAS,IACAa,EAAAu+B,EAAAv+B,EAAAG,eACAo+B,EAAAv+B,EAAAG,gBAAAH,EACAs+B,EAAAt+B,GAAAtB,GAEApG,MAIAqmC,iBAAA,SAAAjiC,GAIA,MAHA,OAAAyC,IACAjH,EAAAgZ,SAAAxU,GAEApE,MAIAylC,WAAA,SAAAn2B,GACA,GAAA7L,EACA,IAAA6L,EACA,GAAAzI,EAGA2Q,EAAApD,OAAA9E,EAAAkI,EAAAqtB,aAIA,KAAAphC,IAAA6L,GACAm2B,EAAAhiC,IAAAgiC,EAAAhiC,GAAA6L,EAAA7L,GAIA,OAAAzD,OAIAsmC,MAAA,SAAApB,GACA,GAAAqB,GAAArB,GAAAgB,CAKA,OAJAd,IACAA,EAAAkB,MAAAC,GAEA9/B,EAAA,EAAA8/B,GACAvmC,MAoBA,IAfAoV,EAAA5O,QAAAgR,GAKA5X,EAAAgkC,SAAAhkC,EAAAgkC,KAAAnZ,GAAAI,MAAA,IACAljB,QAAA27B,GAAA7Y,GAAAqZ,SAAA,MAGAlkC,EAAAwE,KAAAoB,EAAAe,QAAAf,EAAApB,MAAAxE,EAAA2G,QAAA3G,EAAAwE,KAGAxE,EAAAyX,WAAAzX,EAAAwX,UAAA,KAAAvP,cAAAlC,MAAAC,MAAA,IAGA,MAAAhG,EAAA4mC,YAAA,CACAV,EAAAtmC,GAAAoE,cAAA,IAKA,KACAkiC,EAAAjb,KAAAjrB,EAAAgkC,IAIAkC,EAAAjb,KAAAib,EAAAjb,KACAjrB,EAAA4mC,YAAAhD,GAAAM,SAAA,KAAAN,GAAAiD,MACAX,EAAAhC,SAAA,KAAAgC,EAAAW,KACI,MAAA9kC,GAIJ/B,EAAA4mC,aAAA,GAaA,GARA5mC,EAAAwH,MAAAxH,EAAAmkC,aAAA,gBAAAnkC,GAAAwH,OACAxH,EAAAwH,KAAA/C,GAAAs+B,MAAA/iC,EAAAwH,KAAAxH,EAAAkX,cAIAS,EAAApC,GAAAvV,EAAA4F,EAAAgS,GAGA3Q,EACA,MAAA2Q,EAKAkuB,GAAArhC,GAAAwI,OAAAjN,EAAAuD,OAGAuiC,GAAA,IAAArhC,GAAAo/B,UACAp/B,GAAAwI,MAAAhL,QAAA,aAIAjC,EAAAwE,KAAAxE,EAAAwE,KAAAwM,cAGAhR,EAAA8mC,YAAArD,GAAAn+B,KAAAtF,EAAAwE,MAKAmhC,EAAA3lC,EAAAgkC,IAAAj8B,QAAAs7B,GAAA,IAGArjC,EAAA8mC,WAuBG9mC,EAAAwH,MAAAxH,EAAAmkC,aACH,KAAAnkC,EAAAqkC,aAAA,IAAAj/B,QAAA,uCACApF,EAAAwH,KAAAxH,EAAAwH,KAAAO,QAAAq7B,GAAA,OAtBA+C,EAAAnmC,EAAAgkC,IAAA/yB,MAAA00B,EAAAphC,QAGAvE,EAAAwH,OACAm+B,IAAAnD,GAAAl9B,KAAAqgC,GAAA,SAAA3lC,EAAAwH,WAGAxH,GAAAwH,MAIAxH,EAAA8e,SAAA,IACA6mB,IAAA59B,QAAAu7B,GAAA,MACA6C,GAAA3D,GAAAl9B,KAAAqgC,GAAA,cAAApD,MAAA4D,GAIAnmC,EAAAgkC,IAAA2B,EAAAQ,GASAnmC,EAAA0lC,aACAjhC,GAAAq/B,aAAA6B,IACA/tB,EAAA4uB,iBAAA,oBAAA/hC,GAAAq/B,aAAA6B,IAEAlhC,GAAAs/B,KAAA4B,IACA/tB,EAAA4uB,iBAAA,gBAAA/hC,GAAAs/B,KAAA4B,MAKA3lC,EAAAwH,MAAAxH,EAAA8mC,YAAA9mC,EAAAqkC,eAAA,GAAAz+B,EAAAy+B,cACAzsB,EAAA4uB,iBAAA,eAAAxmC,EAAAqkC,aAIAzsB,EAAA4uB,iBACA,SACAxmC,EAAAyX,UAAA,IAAAzX,EAAAskC,QAAAtkC,EAAAyX,UAAA,IACAzX,EAAAskC,QAAAtkC,EAAAyX,UAAA,KACA,MAAAzX,EAAAyX,UAAA,QAAAksB,GAAA,WAAsD,IACtD3jC,EAAAskC,QAAA,KAIA,KAAAp/B,IAAAlF,GAAAmlC,QACAvtB,EAAA4uB,iBAAAthC,EAAAlF,EAAAmlC,QAAAjgC,GAIA,IAAAlF,EAAA+mC,aACA/mC,EAAA+mC,WAAA1oC,KAAAunC,EAAAhuB,EAAA5X,MAAA,GAAAiH,GAGA,MAAA2Q,GAAA8uB,OAeA,IAXAJ,EAAA,QAGAN,EAAA9jC,IAAAlC,EAAA2W,UACAiB,EAAA/Q,KAAA7G,EAAAolC,SACAxtB,EAAA9Q,KAAA9G,EAAA+Z,OAGAyrB,EAAA7tB,EAAAQ,GAAAnY,EAAA4F,EAAAgS,GAKG,CASH,GARAA,EAAAwZ,WAAA,EAGA0U,GACAC,EAAA9jC,QAAA,YAAA2V,EAAA5X,IAIAiH,EACA,MAAA2Q,EAIA5X,GAAAokC,OAAApkC,EAAAw/B,QAAA,IACA+F,EAAA7mC,EAAAgU,WAAA,WACAkF,EAAA8uB,MAAA,YACK1mC,EAAAw/B,SAGL,KACAv4B,GAAA,EACAu+B,EAAAwB,KAAAZ,EAAAv/B,GACI,MAAA9E,GAGJ,GAAAkF,EACA,KAAAlF,EAIA8E,IAAA,EAAA9E,QAhCA8E,IAAA,iBAqJA,OAAA+Q,IAGAqvB,QAAA,SAAAjD,EAAAx8B,EAAAuH,GACA,MAAAtK,IAAAwF,IAAA+5B,EAAAx8B,EAAAuH,EAAA,SAGAm4B,UAAA,SAAAlD,EAAAj1B,GACA,MAAAtK,IAAAwF,IAAA+5B,EAAAh9B,OAAA+H,EAAA,aAIAtK,GAAAqB,MAAA,uBAAAZ,EAAAyB,GACAlC,GAAAkC,GAAA,SAAAq9B,EAAAx8B,EAAAuH,EAAAvK,GAUA,MAPAC,IAAAM,WAAAyC,KACAhD,KAAAuK,EACAA,EAAAvH,EACAA,EAAAR,QAIAvC,GAAAugC,KAAAvgC,GAAA8J,QACAy1B,MACAx/B,KAAAmC,EACA6Q,SAAAhT,EACAgD,OACA49B,QAAAr2B,GACGtK,GAAAsX,cAAAioB,WAKHv/B,GAAAmL,SAAA,SAAAo0B,GACA,MAAAv/B,IAAAugC,MACAhB,MAGAx/B,KAAA,MACAgT,SAAA,SACAsH,OAAA,EACAslB,OAAA,EACA7gC,QAAA,EACAsW,QAAA,KAKApV,GAAAqI,GAAAyB,QACA44B,QAAA,SAAA13B,GACA,GAAAtE,EAyBA,OAvBA/K,MAAA,KACAqE,GAAAM,WAAA0K,KACAA,IAAApR,KAAA+B,KAAA,KAIA+K,EAAA1G,GAAAgL,EAAArP,KAAA,GAAAmJ,eAAAiG,GAAA,GAAAG,OAAA,GAEAvP,KAAA,GAAA+D,YACAgH,EAAAuuB,aAAAt5B,KAAA,IAGA+K,EAAAuE,IAAA,WAGA,IAFA,GAAAzK,GAAA7E,KAEA6E,EAAAmiC,mBACAniC,IAAAmiC,iBAGA,OAAAniC,KACIu0B,OAAAp5B,OAGJA,MAGAinC,UAAA,SAAA53B,GACA,MAAAhL,IAAAM,WAAA0K,GACArP,KAAA0F,KAAA,SAAAZ,GACAT,GAAArE,MAAAinC,UAAA53B,EAAApR,KAAA+B,KAAA8E,MAIA9E,KAAA0F,KAAA,WACA,GAAA3F,GAAAsE,GAAArE,MACA0Y,EAAA3Y,EAAA2Y,UAEAA,GAAAvU,OACAuU,EAAAquB,QAAA13B,GAGAtP,EAAAq5B,OAAA/pB,MAKAtE,KAAA,SAAAsE,GACA,GAAA1K,GAAAN,GAAAM,WAAA0K,EAEA,OAAArP,MAAA0F,KAAA,SAAAZ,GACAT,GAAArE,MAAA+mC,QAAApiC,EAAA0K,EAAApR,KAAA+B,KAAA8E,GAAAuK,MAIA63B,OAAA,SAAAz6B,GAIA,MAHAzM,MAAA+pB,OAAAtd,GAAA/H,IAAA,QAAAgB,KAAA;AACArB,GAAArE,MAAAy5B,YAAAz5B,KAAA4L,cAEA5L,QAKAqE,GAAAgkB,KAAA1D,QAAA9Q,OAAA,SAAAhP,GACA,OAAAR,GAAAgkB,KAAA1D,QAAAwiB,QAAAtiC,IAEAR,GAAAgkB,KAAA1D,QAAAwiB,QAAA,SAAAtiC,GACA,SAAAA,EAAAuiC,aAAAviC,EAAAwiC,cAAAxiC,EAAA8M,iBAAAxN,SAMAE,GAAA+T,aAAAkvB,IAAA,WACA,IACA,UAAAhpC,GAAAipC,eACE,MAAA5lC,KAGF,IAAA6lC,KAGAC,EAAA,IAIAC,KAAA,KAEAC,GAAAtjC,GAAA+T,aAAAkvB,KAEAr4B,IAAA24B,OAAAD,IAAA,mBAAAA,IACA14B,GAAA21B,KAAA+C,QAEAtjC,GAAAsgC,cAAA,SAAAn/B,GACA,GAAAmJ,GAAAk5B,CAGA,IAAA54B,GAAA24B,MAAAD,KAAAniC,EAAAghC,YACA,OACAI,KAAA,SAAA7B,EAAAxuB,GACA,GAAAzR,GACAwiC,EAAA9hC,EAAA8hC,KAWA,IATAA,EAAAQ,KACAtiC,EAAApB,KACAoB,EAAAo+B,IACAp+B,EAAAw+B,MACAx+B,EAAAuiC,SACAviC,EAAAimB,UAIAjmB,EAAAwiC,UACA,IAAAljC,IAAAU,GAAAwiC,UACAV,EAAAxiC,GAAAU,EAAAwiC,UAAAljC,EAKAU,GAAAoT,UAAA0uB,EAAAjB,kBACAiB,EAAAjB,iBAAA7gC,EAAAoT,UAQApT,EAAAghC,aAAAzB,EAAA,sBACAA,EAAA,qCAIA,KAAAjgC,IAAAigC,GACAuC,EAAAlB,iBAAAthC,EAAAigC,EAAAjgC,GAIA6J,GAAA,SAAAvK,GACA,kBACAuK,IACAA,EAAAk5B,EAAAP,EAAAW,OACAX,EAAAY,QAAAZ,EAAAa,QAAAb,EAAAc,mBAAA,KAEA,UAAAhkC,EACAkjC,EAAAhB,QACQ,UAAAliC,EAKR,gBAAAkjC,GAAAzC,OACAtuB,EAAA,WAEAA,EAGA+wB,EAAAzC,OACAyC,EAAApC,YAIA3uB,EACAixB,GAAAF,EAAAzC,SAAAyC,EAAAzC,OACAyC,EAAApC,WAKA,UAAAoC,EAAAe,cAAA,SACA,gBAAAf,GAAAgB,cACWC,OAAAjB,EAAAtuB,WACAnV,KAAAyjC,EAAAgB,cACXhB,EAAAnB,4BAQAmB,EAAAW,OAAAt5B,IACAk5B,EAAAP,EAAAY,QAAAv5B,EAAA,SAKA/H,SAAA0gC,EAAAa,QACAb,EAAAa,QAAAN,EAEAP,EAAAc,mBAAA,WAGA,IAAAd,EAAAtW,YAMA1yB,EAAAgU,WAAA,WACA3D,GACAk5B,OAQAl5B,IAAA,QAEA,KAGA24B,EAAAV,KAAAphC,EAAAkhC,YAAAlhC,EAAA4B,MAAA,MACK,MAAAzF,GAGL,GAAAgN,EACA,KAAAhN,KAKA2kC,MAAA,WACA33B,GACAA,QAWAtK,GAAAqgC,cAAA,SAAA9kC,GACAA,EAAA4mC,cACA5mC,EAAA8Y,SAAA/U,QAAA,KAKAU,GAAAmgC,WACAN,SACAvgC,OAAA,6FAGA+U,UACA/U,OAAA,2BAEAmV,YACA0vB,cAAA,SAAA3kC,GAEA,MADAQ,IAAAgY,WAAAxY,GACAA,MAMAQ,GAAAqgC,cAAA,kBAAA9kC,GACAgH,SAAAhH,EAAA8e,QACA9e,EAAA8e,OAAA,GAEA9e,EAAA4mC,cACA5mC,EAAAwE,KAAA,SAKAC,GAAAsgC,cAAA,kBAAA/kC,GAGA,GAAAA,EAAA4mC,YAAA,CACA,GAAA7iC,GAAAgL,CACA,QACAi4B,KAAA,SAAA/gC,EAAA0Q,GACA5S,EAAAU,GAAA,YAAA4D,MACAwgC,QAAA7oC,EAAA8oC,cACAj7B,IAAA7N,EAAAgkC,MACKliC,GACL,aACAiN,EAAA,SAAAg6B,GACAhlC,EAAA+L,SACAf,EAAA,KACAg6B,GACApyB,EAAA,UAAAoyB,EAAAvkC,KAAA,QAAAukC,EAAAvkC,QAMA5E,GAAAsE,KAAApE,YAAAiE,EAAA,KAEA2iC,MAAA,WACA33B,GACAA,QAUA,IAAAi6B,OACAC,GAAA,mBAGAxkC,IAAAmgC,WACAsE,MAAA,WACAC,cAAA,WACA,GAAAp6B,GAAAi6B,GAAAnlB,OAAApf,GAAA4C,QAAA,IAAAk7B,IAEA,OADAniC,MAAA2O,IAAA,EACAA,KAKAtK,GAAAqgC,cAAA,sBAAA9kC,EAAAopC,EAAAxxB,GAEA,GAAAyxB,GAAAC,EAAAC,EACAC,EAAAxpC,EAAAkpC,SAAA,IAAAD,GAAA3jC,KAAAtF,EAAAgkC,KACA,MACA,gBAAAhkC,GAAAwH,MAEA,KADAxH,EAAAqkC,aAAA,IACAj/B,QAAA,sCACA6jC,GAAA3jC,KAAAtF,EAAAwH,OAAA,OAIA,IAAAgiC,GAAA,UAAAxpC,EAAAyX,UAAA,GA8DA,MA3DA4xB,GAAArpC,EAAAmpC,cAAA1kC,GAAAM,WAAA/E,EAAAmpC,eACAnpC,EAAAmpC,gBACAnpC,EAAAmpC,cAGAK,EACAxpC,EAAAwpC,GAAAxpC,EAAAwpC,GAAAzhC,QAAAkhC,GAAA,KAAAI,GACGrpC,EAAAkpC,SAAA,IACHlpC,EAAAgkC,MAAAxB,GAAAl9B,KAAAtF,EAAAgkC,KAAA,SAAAhkC,EAAAkpC,MAAA,IAAAG,GAIArpC,EAAAkZ,WAAA,0BAIA,MAHAqwB,IACA9kC,GAAAsV,MAAAsvB,EAAA,mBAEAE,EAAA,IAIAvpC,EAAAyX,UAAA,UAGA6xB,EAAA5qC,EAAA2qC,GACA3qC,EAAA2qC,GAAA,WACAE,EAAAn8B,WAIAwK,EAAApD,OAAA,WAGAxN,SAAAsiC,EACA7kC,GAAA/F,GAAA4hC,WAAA+I,GAIA3qC,EAAA2qC,GAAAC,EAIAtpC,EAAAqpC,KAGArpC,EAAAmpC,cAAAC,EAAAD,cAGAH,GAAA78B,KAAAk9B,IAIAE,GAAA9kC,GAAAM,WAAAukC,IACAA,EAAAC,EAAA,IAGAA,EAAAD,EAAAtiC,SAIA,WAYAqI,GAAAo6B,mBAAA,WACA,GAAA9/B,GAAA/J,GAAA8pC,eAAAD,mBAAA,IAAA9/B,IAEA,OADAA,GAAAkC,UAAA,6BACA,IAAAlC,EAAAqC,WAAAzH,UAQAE,GAAA0oB,UAAA,SAAA3lB,EAAA4C,EAAAu/B,GACA,mBAAAniC,GACA,QAEA,kBAAA4C,KACAu/B,EAAAv/B,EACAA,GAAA,EAGA,IAAAuW,GAAAipB,EAAA7+B,CAwBA,OAtBAX,KAIAiF,GAAAo6B,oBACAr/B,EAAAxK,GAAA8pC,eAAAD,mBAAA,IAKA9oB,EAAAvW,EAAApG,cAAA,QACA2c,EAAAsK,KAAArrB,GAAAirB,SAAAI,KACA7gB,EAAAlG,KAAApE,YAAA6gB,IAEAvW,EAAAxK,IAIAgqC,EAAA3c,GAAA/jB,KAAA1B,GACAuD,GAAA4+B,MAGAC,GACAx/B,EAAApG,cAAA4lC,EAAA,MAGAA,EAAA9+B,GAAAtD,GAAA4C,EAAAW,GAEAA,KAAAxG,QACAE,GAAAsG,GAAA+E,SAGArL,GAAAgG,SAAAm/B,EAAA59B,cAOAvH,GAAAqI,GAAAspB,KAAA,SAAA4N,EAAA6F,EAAA96B,GACA,GAAAlC,GAAArI,EAAA4U,EACAjZ,EAAAC,KACA8M,EAAA82B,EAAA5+B,QAAA,IAsDA,OApDA8H,IAAA,IACAL,EAAA+J,EAAAotB,EAAA/yB,MAAA/D,IACA82B,IAAA/yB,MAAA,EAAA/D,IAIAzI,GAAAM,WAAA8kC,IAGA96B,EAAA86B,EACAA,EAAA7iC,QAGE6iC,GAAA,gBAAAA,KACFrlC,EAAA,QAIArE,EAAAoE,OAAA,GACAE,GAAAugC,MACAhB,MAKAx/B,QAAA,MACAgT,SAAA,OACAhQ,KAAAqiC,IACGhjC,KAAA,SAAA6hC,GAGHtvB,EAAAhM,UAEAjN,EAAAsP,KAAA5C,EAIApI,GAAA,SAAA+0B,OAAA/0B,GAAA0oB,UAAAub,IAAA/kB,KAAA9W,GAGA67B,KAKGl0B,OAAAzF,GAAA,SAAA6I,EAAAqtB,GACH9kC,EAAA2F,KAAA,WACAiJ,EAAA5B,MAAA/M,KAAAgZ,IAAAxB,EAAA8wB,aAAAzD,EAAArtB,QAKAxX,MAOAqE,GAAAqB,MACA,YACA,WACA,eACA,YACA,cACA,YACA,SAAAZ,EAAAV,GACAC,GAAAqI,GAAAtI,GAAA,SAAAsI,GACA,MAAA1M,MAAA0B,GAAA0C,EAAAsI,MAOArI,GAAAgkB,KAAA1D,QAAA+kB,SAAA,SAAA7kC,GACA,MAAAR,IAAAO,KAAAP,GAAA+5B,OAAA,SAAA1xB,GACA,MAAA7H,KAAA6H,EAAA7H,OACEV,QAaFE,GAAAslC,QACAC,UAAA,SAAA/kC,EAAAW,EAAAV,GACA,GAAA+kC,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACA9qC,EAAAgF,GAAAmE,IAAA3D,EAAA,YACAulC,EAAA/lC,GAAAQ,GACAsO,IAGA,YAAA9T,IACAwF,EAAAzF,MAAAC,SAAA,YAGA4qC,EAAAG,EAAAT,SACAI,EAAA1lC,GAAAmE,IAAA3D,EAAA,OACAqlC,EAAA7lC,GAAAmE,IAAA3D,EAAA,QACAslC,GAAA,aAAA9qC,GAAA,UAAAA,KACA0qC,EAAAG,GAAAllC,QAAA,WAIAmlC,GACAN,EAAAO,EAAA/qC,WACA2qC,EAAAH,EAAAtqC,IACAuqC,EAAAD,EAAAvqC,OAGA0qC,EAAAl4B,WAAAi4B,IAAA,EACAD,EAAAh4B,WAAAo4B,IAAA,GAGA7lC,GAAAM,WAAAa,KAGAA,IAAAvH,KAAA4G,EAAAC,EAAAT,GAAA8J,UAAqD87B,KAGrD,MAAAzkC,EAAAjG,MACA4T,EAAA5T,IAAAiG,EAAAjG,IAAA0qC,EAAA1qC,IAAAyqC,GAEA,MAAAxkC,EAAAlG,OACA6T,EAAA7T,KAAAkG,EAAAlG,KAAA2qC,EAAA3qC,KAAAwqC,GAGA,SAAAtkC,GACAA,EAAA6kC,MAAApsC,KAAA4G,EAAAsO,GAGAi3B,EAAA5hC,IAAA2K,KAKA9O,GAAAqI,GAAAyB,QACAw7B,OAAA,SAAAnkC,GAGA,GAAAwH,UAAA7I,OACA,MAAAyC,UAAApB,EACAxF,KACAA,KAAA0F,KAAA,SAAAZ,GACAT,GAAAslC,OAAAC,UAAA5pC,KAAAwF,EAAAV,IAIA,IAAAkf,GAAAsmB,EAAAC,EAAA7mC,EACAmB,EAAA7E,KAAA,EAEA,IAAA6E,EAOA,MAAAA,GAAA8M,iBAAAxN,QAIAomC,EAAA1lC,EAAA+M,wBAGA24B,EAAA1nC,OAAA0nC,EAAAznC,QACAY,EAAAmB,EAAAsE,cACAmhC,EAAA1wB,GAAAlW,GACAsgB,EAAAtgB,EAAAijB,iBAGApnB,IAAAgrC,EAAAhrC,IAAA+qC,EAAAE,YAAAxmB,EAAAymB,UACAnrC,KAAAirC,EAAAjrC,KAAAgrC,EAAAI,YAAA1mB,EAAA2mB,aAKAJ,IAlBWhrC,IAAA,EAAAD,KAAA,IAqBXD,SAAA,WACA,GAAAW,KAAA,IAIA,GAAA4qC,GAAAjB,EACA9kC,EAAA7E,KAAA,GACA6qC,GAAmBtrC,IAAA,EAAAD,KAAA,EA4BnB,OAxBA,UAAA+E,GAAAmE,IAAA3D,EAAA,YAGA8kC,EAAA9kC,EAAA+M,yBAKAg5B,EAAA5qC,KAAA4qC,eAGAjB,EAAA3pC,KAAA2pC,SACAtlC,GAAA+E,SAAAwhC,EAAA,aACAC,EAAAD,EAAAjB,UAIAkB,GACAtrC,IAAAsrC,EAAAtrC,IAAA8E,GAAAmE,IAAAoiC,EAAA,wBACAtrC,KAAAurC,EAAAvrC,KAAA+E,GAAAmE,IAAAoiC,EAAA,4BAMArrC,IAAAoqC,EAAApqC,IAAAsrC,EAAAtrC,IAAA8E,GAAAmE,IAAA3D,EAAA,gBACAvF,KAAAqqC,EAAArqC,KAAAurC,EAAAvrC,KAAA+E,GAAAmE,IAAA3D,EAAA,oBAcA+lC,aAAA,WACA,MAAA5qC,MAAAsP,IAAA,WAGA,IAFA,GAAAs7B,GAAA5qC,KAAA4qC,aAEAA,GAAA,WAAAvmC,GAAAmE,IAAAoiC,EAAA,aACAA,gBAGA,OAAAA,IAAAjkB,QAMAtiB,GAAAqB,MAAcu3B,WAAA,cAAAD,UAAA,eAAsD,SAAAz2B,EAAA0B,GACpE,GAAA1I,GAAA,gBAAA0I,CAEA5D,IAAAqI,GAAAnG,GAAA,SAAAgL,GACA,MAAAtD,IAAAjO,KAAA,SAAA6E,EAAA0B,EAAAgL,GACA,GAAA+4B,GAAA1wB,GAAA/U,EAEA,OAAA+B,UAAA2K,EACA+4B,IAAAriC,GAAApD,EAAA0B,QAGA+jC,EACAA,EAAAQ,SACAvrC,EAAA+qC,EAAAI,YAAAn5B,EACAhS,EAAAgS,EAAA+4B,EAAAE,aAIA3lC,EAAA0B,GAAAgL,IAEGhL,EAAAgL,EAAAvE,UAAA7I,WAUHE,GAAAqB,MAAA,uBAAAZ,EAAAmD,GACA5D,GAAAyQ,SAAA7M,GAAAqI,EAAArB,GAAA8rB,cACA,SAAAl2B,EAAAiL,GACA,GAAAA,EAIA,MAHAA,GAAAD,EAAAhL,EAAAoD,GAGAmI,GAAAlL,KAAA4K,GACAzL,GAAAQ,GAAAxF,WAAA4I,GAAA,KACA6H,MAQAzL,GAAAqB,MAAcqlC,OAAA,SAAAC,MAAA,SAAmC,SAAAtjC,EAAAtD,GACjDC,GAAAqB,MAAe62B,QAAA,QAAA70B,EAAAyF,QAAA/I,EAAA6mC,GAAA,QAAAvjC,GACf,SAAAwjC,EAAAC,GAGA9mC,GAAAqI,GAAAy+B,GAAA,SAAA7O,EAAAl2B,GACA,GAAA8qB,GAAAlkB,UAAA7I,SAAA+mC,GAAA,iBAAA5O,IACAlrB,EAAA85B,IAAA5O,KAAA,GAAAl2B,KAAA,oBAEA,OAAA6H,IAAAjO,KAAA,SAAA6E,EAAAT,EAAAgC,GACA,GAAA1C,EAEA,OAAAW,IAAAC,SAAAO,GAGA,IAAAsmC,EAAAnmC,QAAA,SACAH,EAAA,QAAA6C,GACA7C,EAAArF,SAAAmnB,gBAAA,SAAAjf,GAIA,IAAA7C,EAAAE,UACArB,EAAAmB,EAAA8hB,gBAIA7lB,KAAAoQ,IACArM,EAAA0E,KAAA,SAAA7B,GAAAhE,EAAA,SAAAgE,GACA7C,EAAA0E,KAAA,SAAA7B,GAAAhE,EAAA,SAAAgE,GACAhE,EAAA,SAAAgE,KAIAd,SAAAR,EAGA/B,GAAAmE,IAAA3D,EAAAT,EAAAgN,GAGA/M,GAAAjF,MAAAyF,EAAAT,EAAAgC,EAAAgL,IACIhN,EAAA8sB,EAAAoL,EAAA11B,OAAAsqB,QAMJ7sB,GAAAqI,GAAAyB,QAEA9L,KAAA,SAAAmK,EAAApF,EAAAsF,GACA,MAAA1M,MAAA0B,GAAA8K,EAAA,KAAApF,EAAAsF,IAEA0+B,OAAA,SAAA5+B,EAAAE,GACA,MAAA1M,MAAA8M,IAAAN,EAAA,KAAAE,IAGA2+B,SAAA,SAAA5+B,EAAAD,EAAApF,EAAAsF,GACA,MAAA1M,MAAA0B,GAAA8K,EAAAC,EAAArF,EAAAsF,IAEA4+B,WAAA,SAAA7+B,EAAAD,EAAAE,GAGA,WAAAM,UAAA7I,OACAnE,KAAA8M,IAAAL,EAAA,MACAzM,KAAA8M,IAAAN,EAAAC,GAAA,KAAAC,MAIArI,GAAAknC,UAAAjkC,KAAAC,MAmBAtE,KAAAC,EAAA,WACA,MAAAmB,KACE0I,MAAAlP,EAAAoF,KAAA2D,SAAA1D,IAAApF,EAAAD,QAAAqF,GAMF,IAGAsoC,IAAAltC,EAAA+F,OAGAonC,GAAAntC,EAAAD,CAyBA,OAvBAgG,IAAAqnC,WAAA,SAAAxzB,GASA,MARA5Z,GAAAD,IAAAgG,KACA/F,EAAAD,EAAAotC,IAGAvzB,GAAA5Z,EAAA+F,cACA/F,EAAA+F,OAAAmnC,IAGAnnC,IAMAd,IACAjF,EAAA+F,OAAA/F,EAAAD,EAAAgG,IAOAA,MJsSM,SAASvG,EAAQD,EAASH,IKhxUhC,SAAAyF,EAAAC,GACAA,EAAAvF,IAGCmC,KAAA,SAAAnC,GAA4B,YA4F7B,SAAA8tC,MA8aA,QAAAC,GAAAtqC,EAAAC,GAEAvB,KAAAsB,KAAA,EACAtB,KAAAuB,KAAA,EAgeA,QAAAsqC,GAAAngB,EAAAogB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,EAAAC,GAEAryB,OAAAwX,eAAAxxB,KAAA,MAAsCoG,MAAAkmC,MAEtCtsC,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAA0H,KAAA,GACA1H,KAAA0sC,WAAA,GAEA1sC,KAAA0rB,MAAA9kB,SAAA8kB,IAAAmgB,EAAAc,cACA3sC,KAAA4sC,WAEA5sC,KAAA8rC,QAAAllC,SAAAklC,IAAAD,EAAAgB,gBAEA7sC,KAAA+rC,MAAAnlC,SAAAmlC,IAAAe,GACA9sC,KAAAgsC,MAAAplC,SAAAolC,IAAAc,GAEA9sC,KAAAisC,UAAArlC,SAAAqlC,IAAAc,GACA/sC,KAAAksC,UAAAtlC,SAAAslC,IAAAc,GAEAhtC,KAAAosC,WAAAxlC,SAAAwlC,IAAA,EAEApsC,KAAAmsC,OAAAvlC,SAAAulC,IAAAc,GACAjtC,KAAAoE,KAAAwC,SAAAxC,IAAA8oC,GAEAltC,KAAA2pC,OAAA,GAAAiC,GAAA,KACA5rC,KAAAmtC,OAAA,GAAAvB,GAAA,KAEA5rC,KAAAotC,iBAAA,EACAptC,KAAAqtC,kBAAA,EACArtC,KAAAstC,OAAA,EACAttC,KAAAutC,gBAAA,EAOAvtC,KAAAqsC,SAAAzlC,SAAAylC,IAAAmB,GAEAxtC,KAAAwa,QAAA,EACAxa,KAAAytC,SAAA,KA4OA,QAAAnB,KAA4B,MAAAra,MAU5B,QAAAyb,GAAApsC,EAAAC,EAAAC,EAAA6B,GAEArD,KAAAsB,KAAA,EACAtB,KAAAuB,KAAA,EACAvB,KAAAwB,KAAA,EACAxB,KAAAqD,EAAAuD,SAAAvD,IAAA,EAonBA,QAAAsqC,GAAA9qC,EAAAC,EAAA0C,GAEAxF,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAA6C,QACA7C,KAAA8C,SAEA9C,KAAA4tC,QAAA,GAAAF,GAAA,IAAA7qC,EAAAC,GACA9C,KAAA6tC,aAAA,EAEA7tC,KAAA8tC,SAAA,GAAAJ,GAAA,IAAA7qC,EAAAC,GAEA0C,QAEAoB,SAAApB,EAAA0mC,YAAA1mC,EAAA0mC,UAAAa,IAEA/sC,KAAA+tC,QAAA,GAAAlC,GAAAjlC,cAAApB,EAAAumC,MAAAvmC,EAAAwmC,MAAAxmC,EAAAymC,UAAAzmC,EAAA0mC,UAAA1mC,EAAA2mC,OAAA3mC,EAAApB,KAAAoB,EAAA4mC,WAAA5mC,EAAA6mC,UAEArsC,KAAAguC,YAAApnC,SAAApB,EAAAwoC,aAAAxoC,EAAAwoC,YACAhuC,KAAAiuC,cAAArnC,SAAApB,EAAAyoC,eAAAzoC,EAAAyoC,cACAjuC,KAAAkuC,aAAAtnC,SAAApB,EAAA0oC,aAAA1oC,EAAA0oC,aAAA,KA2DA,QAAAC,GAAAtrC,EAAAC,EAAA0C,GAEAmoC,EAAA1vC,KAAA+B,KAAA6C,EAAAC,EAAA0C,GAEAxF,KAAAouC,eAAA,EACApuC,KAAAquC,kBAAA,EAgBA,QAAAC,GAAAhtC,EAAAC,EAAAC,EAAA6B,GAEArD,KAAAuuC,GAAAjtC,GAAA,EACAtB,KAAAwuC,GAAAjtC,GAAA,EACAvB,KAAAyuC,GAAAjtC,GAAA,EACAxB,KAAA0uC,GAAA9nC,SAAAvD,IAAA,EAukBA,QAAAsrC,GAAArtC,EAAAC,EAAAC,GAEAxB,KAAAsB,KAAA,EACAtB,KAAAuB,KAAA,EACAvB,KAAAwB,KAAA,EA6vBA,QAAAotC,KAEA5uC,KAAAwE,SAAA,GAAAqqC,eAEA,QACA,QACA,QACA,UAIA7hC,UAAA7I,OAAA,GAEAosB,QAAA5W,MAAA,iFA87BA,QAAAm1B,GAAAC,EAAAjD,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,EAAAC,GAEA0C,EAAAnoC,SAAAmoC,OACAjD,EAAAllC,SAAAklC,IAAAkD,GAEAnD,EAAA5tC,KAAA+B,KAAA+uC,EAAAjD,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,EAAAC,GAEArsC,KAAAstC,OAAA,EA+EA,QAAA2B,KAEAjvC,KAAAkvC,OACAlvC,KAAAsP,OAaA,QAAA6/B,GAAAC,EAAAC,EAAAC,GAEA,GAAAC,GAAAH,EAAA,EAEA,IAAAG,GAAA,GAAAA,EAAA,QAAAH,EAIA,IAAAziB,GAAA0iB,EAAAC,EACAE,EAAAC,GAAA9iB,EASA,IAPA/lB,SAAA4oC,IAEAA,EAAA,GAAAX,cAAAliB,GACA8iB,GAAA9iB,GAAA6iB,GAIA,IAAAH,EAAA,CAEAE,EAAAt0B,QAAAu0B,EAAA,EAEA,QAAA1qC,GAAA,EAAA6kC,EAAA,EAA+B7kC,IAAAuqC,IAAevqC,EAE9C6kC,GAAA2F,EACAF,EAAAtqC,GAAAmW,QAAAu0B,EAAA7F,GAMA,MAAA6F,GAMA,QAAAE,GAAAvvC,EAAAwsB,GAEA,GAAA6iB,GAAAG,GAAAhjB,EAEA/lB,UAAA4oC,IAEAA,EAAA,GAAAI,YAAAjjB,GACAgjB,GAAAhjB,GAAA6iB,EAIA,QAAA1qC,GAAA,EAAkBA,IAAA6nB,IAAS7nB,EAC3B0qC,EAAA1qC,GAAA3E,EAAA0vC,kBAEA,OAAAL,GAWA,QAAAM,GAAAC,EAAA/pC,GAA+B+pC,EAAAC,UAAAhwC,KAAAiwC,KAAAjqC,GAC/B,QAAAkqC,GAAAH,EAAA/pC,GAA+B+pC,EAAAI,UAAAnwC,KAAAiwC,KAAAjqC,GAI/B,QAAAoqC,GAAAL,EAAA/pC,GAEAY,SAAAZ,EAAA1E,EAAAyuC,EAAAM,WAAArwC,KAAAiwC,KAAAjqC,GACA+pC,EAAAO,UAAAtwC,KAAAiwC,KAAAjqC,EAAA1E,EAAA0E,EAAAzE,GAIA,QAAAgvC,GAAAR,EAAA/pC,GAEAY,SAAAZ,EAAA1E,EACAyuC,EAAAS,UAAAxwC,KAAAiwC,KAAAjqC,EAAA1E,EAAA0E,EAAAzE,EAAAyE,EAAAxE,GACAoF,SAAAZ,EAAAwpC,EACAO,EAAAS,UAAAxwC,KAAAiwC,KAAAjqC,EAAAwpC,EAAAxpC,EAAAyqC,EAAAzqC,EAAAsZ,GAEAywB,EAAAW,WAAA1wC,KAAAiwC,KAAAjqC,GAIA,QAAA2qC,GAAAZ,EAAA/pC,GAEAY,SAAAZ,EAAA1E,EAAAyuC,EAAAa,WAAA5wC,KAAAiwC,KAAAjqC,GACA+pC,EAAAc,UAAA7wC,KAAAiwC,KAAAjqC,EAAA1E,EAAA0E,EAAAzE,EAAAyE,EAAAxE,EAAAwE,EAAA3C,GAMA,QAAAytC,GAAAf,EAAA/pC,GAEA+pC,EAAAgB,iBAAA/wC,KAAAiwC,MAAA,EAAAjqC,EAAAxB,UAAAwB,GAIA,QAAAgrC,GAAAjB,EAAA/pC,GAEA+pC,EAAAkB,iBAAAjxC,KAAAiwC,MAAA,EAAAjqC,EAAAxB,UAAAwB,GAIA,QAAAkrC,GAAAnB,EAAA/pC,GAEA+pC,EAAAoB,iBAAAnxC,KAAAiwC,MAAA,EAAAjqC,EAAAxB,UAAAwB,GAMA,QAAAorC,GAAArB,EAAA/pC,EAAA7F,GAEA,GAAAuI,GAAAvI,EAAA0vC,kBACAE,GAAAI,UAAAnwC,KAAAiwC,KAAAvnC,GACAvI,EAAAkxC,aAAArrC,GAAAsrC,GAAA5oC,GAIA,QAAA6oC,GAAAxB,EAAA/pC,EAAA7F,GAEA,GAAAuI,GAAAvI,EAAA0vC,kBACAE,GAAAI,UAAAnwC,KAAAiwC,KAAAvnC,GACAvI,EAAAqxC,eAAAxrC,GAAAyrC,GAAA/oC,GAMA,QAAAgpC,GAAA3B,EAAA/pC,GAAgC+pC,EAAA4B,WAAA3xC,KAAAiwC,KAAAjqC,GAChC,QAAA4rC,GAAA7B,EAAA/pC,GAAgC+pC,EAAA8B,WAAA7xC,KAAAiwC,KAAAjqC,GAChC,QAAA8rC,GAAA/B,EAAA/pC,GAAgC+pC,EAAAgC,WAAA/xC,KAAAiwC,KAAAjqC,GAIhC,QAAAgsC,GAAA5tC,GAEA,OAAAA,GAEA,gBAAA0rC,EACA,kBAAAM,EACA,kBAAAG,EACA,kBAAAI,EAEA,kBAAAG,EACA,kBAAAE,EACA,kBAAAE,EAEA,kBAAAE,EACA,kBAAAG,EAEA,4BAAArB,EACA,6BAAAwB,EACA,6BAAAE,EACA,6BAAAE,IAQA,QAAAG,GAAAlC,EAAA/pC,GAAgC+pC,EAAAmC,WAAAlyC,KAAAiwC,KAAAjqC,GAChC,QAAAmsC,GAAApC,EAAA/pC,GAAgC+pC,EAAAqC,WAAApyC,KAAAiwC,KAAAjqC,GAIhC,QAAAqsC,GAAAtC,EAAA/pC,GAEA+pC,EAAAM,WAAArwC,KAAAiwC,KAAAd,EAAAnpC,EAAAhG,KAAAsyC,KAAA,IAIA,QAAAC,GAAAxC,EAAA/pC,GAEA+pC,EAAAW,WAAA1wC,KAAAiwC,KAAAd,EAAAnpC,EAAAhG,KAAAsyC,KAAA,IAIA,QAAAE,GAAAzC,EAAA/pC,GAEA+pC,EAAAa,WAAA5wC,KAAAiwC,KAAAd,EAAAnpC,EAAAhG,KAAAsyC,KAAA,IAMA,QAAAG,GAAA1C,EAAA/pC,GAEA+pC,EAAAgB,iBAAA/wC,KAAAiwC,MAAA,EAAAd,EAAAnpC,EAAAhG,KAAAsyC,KAAA,IAIA,QAAAI,GAAA3C,EAAA/pC,GAEA+pC,EAAAkB,iBAAAjxC,KAAAiwC,MAAA,EAAAd,EAAAnpC,EAAAhG,KAAAsyC,KAAA,IAIA,QAAAK,GAAA5C,EAAA/pC,GAEA+pC,EAAAoB,iBAAAnxC,KAAAiwC,MAAA,EAAAd,EAAAnpC,EAAAhG,KAAAsyC,KAAA,KAMA,QAAAM,GAAA7C,EAAA/pC,EAAA7F,GAEA,GAAAwsB,GAAA3mB,EAAA7B,OACA0uC,EAAAnD,EAAAvvC,EAAAwsB,EAEAojB,GAAAqC,WAAApyC,KAAAiwC,KAAA4C,EAEA,QAAA/tC,GAAA,EAAkBA,IAAA6nB,IAAS7nB,EAE3B3E,EAAAkxC,aAAArrC,EAAAlB,IAAAwsC,GAAAuB,EAAA/tC,IAMA,QAAAguC,GAAA/C,EAAA/pC,EAAA7F,GAEA,GAAAwsB,GAAA3mB,EAAA7B,OACA0uC,EAAAnD,EAAAvvC,EAAAwsB,EAEAojB,GAAAqC,WAAApyC,KAAAiwC,KAAA4C,EAEA,QAAA/tC,GAAA,EAAkBA,IAAA6nB,IAAS7nB,EAE3B3E,EAAAqxC,eAAAxrC,EAAAlB,IAAA2sC,GAAAoB,EAAA/tC,IAQA,QAAAiuC,GAAA3uC,GAEA,OAAAA,GAEA,gBAAA6tC,EACA,kBAAAI,EACA,kBAAAE,EACA,kBAAAC,EAEA,kBAAAC,EACA,kBAAAC,EACA,kBAAAC,EAEA,kBAAAC,EACA,kBAAAE,EAEA,4BAAAX,EACA,6BAAAT,EACA,6BAAAE,EACA,6BAAAE,IAQA,QAAAkB,GAAAj1C,EAAAk1C,EAAAhD,GAEAjwC,KAAAjC,KACAiC,KAAAiwC,OACAjwC,KAAAkzC,SAAAlB,EAAAiB,EAAA7uC,MAMA,QAAA+uC,GAAAp1C,EAAAk1C,EAAAhD,GAEAjwC,KAAAjC,KACAiC,KAAAiwC,OACAjwC,KAAAsyC,KAAAW,EAAAX,KACAtyC,KAAAkzC,SAAAH,EAAAE,EAAA7uC,MAMA,QAAAgvC,GAAAr1C,GAEAiC,KAAAjC,KAEAkxC,EAAAhxC,KAAA+B,MAmCA,QAAAqzC,GAAAhZ,EAAAiZ,GAEAjZ,EAAA6U,IAAAnjC,KAAAunC,GACAjZ,EAAA/qB,IAAAgkC,EAAAv1C,IAAAu1C,EAIA,QAAAC,GAAAN,EAAAhD,EAAA5V,GAEA,GAAAmZ,GAAAP,EAAAvrC,KACA+rC,EAAAD,EAAArvC,MAKA,KAFAuvC,GAAAC,UAAA,IAEU,CAEV,GAAAhuC,GAAA+tC,GAAA5qC,KAAA0qC,GACAI,EAAAF,GAAAC,UAEA51C,EAAA4H,EAAA,GACAkuC,EAAA,MAAAluC,EAAA,GACAmuC,EAAAnuC,EAAA,EAIA,IAFAkuC,IAAA91C,GAAA,GAEA6I,SAAAktC,GACA,MAAAA,GAAAF,EAAA,IAAAH,EAAA,CAGAJ,EAAAhZ,EAAAzzB,SAAAktC,EACA,GAAAd,GAAAj1C,EAAAk1C,EAAAhD,GACA,GAAAkD,GAAAp1C,EAAAk1C,EAAAhD,GAEA,OAKA,GAAA3gC,GAAA+qB,EAAA/qB,IACAmR,EAAAnR,EAAAvR,EAEA6I,UAAA6Z,IAEAA,EAAA,GAAA2yB,GAAAr1C,GACAs1C,EAAAhZ,EAAA5Z,IAIA4Z,EAAA5Z,GAUA,QAAAszB,GAAAhE,EAAAiE,EAAA7zC,GAEA8uC,EAAAhxC,KAAA+B,MAEAA,KAAAG,UAIA,QAFAwsB,GAAAojB,EAAAkE,oBAAAD,EAAAjE,EAAAmE,iBAEApvC,EAAA,EAAkBA,IAAA6nB,IAAS7nB,EAAA,CAE3B,GAAAqvC,GAAApE,EAAAqE,iBAAAJ,EAAAlvC,GACA0uC,EAAAW,EAAAzsC,KACAuoC,EAAAF,EAAAsE,mBAAAL,EAAAR,EAEAD,GAAAY,EAAAlE,EAAAjwC,OAscA,QAAAO,GAAAivC,EAAAiB,EAAAnxB,GAEA,MAAA1Y,UAAA6pC,GAAA7pC,SAAA0Y,EAGAtf,KAAAiC,IAAAutC,GAIAxvC,KAAAs0C,OAAA9E,EAAAiB,EAAAnxB,GAm4BA,QAAAi1B,GAAAxzC,EAAAmQ,GAEAlR,KAAAe,IAAA6F,SAAA7F,IAAA,GAAA6qC,KAAA4I,aACAx0C,KAAAkR,IAAAtK,SAAAsK,IAAA,GAAA06B,KAAA4I,aA2OA,QAAAC,GAAAt0C,EAAAu0C,GAUA,QAAA/0C,KAEA,GAAAg1C,GAAA,GAAA9F,gBACA,SACA,SACA,SACA,UAGA+F,EAAA,GAAAC,cACA,MACA,OAKAC,GAAA/E,EAAAgF,eACAC,EAAAjF,EAAAgF,eAEAhF,EAAAkF,WAAAlF,EAAAmF,aAAAJ,GACA/E,EAAAoF,WAAApF,EAAAmF,aAAAP,EAAA5E,EAAAqF,aAEArF,EAAAkF,WAAAlF,EAAAsF,qBAAAL,GACAjF,EAAAoF,WAAApF,EAAAsF,qBAAAT,EAAA7E,EAAAqF,aAIAE,EAAAvF,EAAAwF,gBACAC,EAAAzF,EAAAwF,gBAEA77B,EAAA+7B,YAAA1F,EAAA2F,WAAAJ,GACAvF,EAAA4F,WAAA5F,EAAA2F,WAAA,EAAA3F,EAAA6F,IAAA,QAAA7F,EAAA6F,IAAA7F,EAAA8F,cAAA,MACA9F,EAAA+F,cAAA/F,EAAA2F,WAAA3F,EAAAgG,eAAAhG,EAAAiG,eACAjG,EAAA+F,cAAA/F,EAAA2F,WAAA3F,EAAAkG,eAAAlG,EAAAiG,eACAjG,EAAA+F,cAAA/F,EAAA2F,WAAA3F,EAAAmG,mBAAAnG,EAAAoG,SACApG,EAAA+F,cAAA/F,EAAA2F,WAAA3F,EAAAqG,mBAAArG,EAAAoG,SAEAz8B,EAAA+7B,YAAA1F,EAAA2F,WAAAF,GACAzF,EAAA4F,WAAA5F,EAAA2F,WAAA,EAAA3F,EAAAsG,KAAA,QAAAtG,EAAAsG,KAAAtG,EAAA8F,cAAA,MACA9F,EAAA+F,cAAA/F,EAAA2F,WAAA3F,EAAAgG,eAAAhG,EAAAiG,eACAjG,EAAA+F,cAAA/F,EAAA2F,WAAA3F,EAAAkG,eAAAlG,EAAAiG,eACAjG,EAAA+F,cAAA/F,EAAA2F,WAAA3F,EAAAmG,mBAAAnG,EAAAoG,SACApG,EAAA+F,cAAA/F,EAAA2F,WAAA3F,EAAAqG,mBAAArG,EAAAoG,SAEAG,GAEAC,cAEA,+BAEA,+BACA,sBACA,0BAEA,kCAEA,2BACA,qBAEA,oBACA,6BAEA,gBAEA,YAEA,uBAEA,2BAEA,iEACA,6DACA,6DACA,6DACA,6DACA,6DACA,6DACA,6DACA,6DAEA,2CACA,2CACA,2CACA,2CAEA,uEACA,uEAEA,IAEA,uFAEA,KAEA7/B,KAAA,MAEA8/B,gBAEA,+BAEA,yBACA,yBACA,sBAEA,oBACA,6BAEA,gBAIA,2BAEA,6CAIA,kCAEA,wCAIA,WAEA,wCACA,sCACA,0BACA,6BAEA,IAEA,KAEA9/B,KAAA,OAIAs9B,EAAAyC,EAAAH,GAEA5xB,GACAgyB,OAAA3G,EAAA4G,kBAAA3C,EAAA,YACA4C,GAAA7G,EAAA4G,kBAAA3C,EAAA,OAGA6C,GACAC,WAAA/G,EAAAsE,mBAAAL,EAAA,cACA1kC,IAAAygC,EAAAsE,mBAAAL,EAAA,OACA+C,aAAAhH,EAAAsE,mBAAAL,EAAA,gBACAnhC,QAAAk9B,EAAAsE,mBAAAL,EAAA,WACAgD,MAAAjH,EAAAsE,mBAAAL,EAAA,SACA3rC,MAAA0nC,EAAAsE,mBAAAL,EAAA,SACAiD,SAAAlH,EAAAsE,mBAAAL,EAAA,YACAkD,eAAAnH,EAAAsE,mBAAAL,EAAA,mBA6LA,QAAAyC,GAAAH,GAEA,GAAAtC,GAAAjE,EAAA0G,gBAEAD,EAAAzG,EAAAoH,aAAApH,EAAAqH,iBACAb,EAAAxG,EAAAoH,aAAApH,EAAAsH,eAEAxgC,EAAA,aAAA1W,EAAAm3C,eAAA,WAaA,OAXAvH,GAAAwH,aAAAf,EAAA3/B,EAAAy/B,EAAAE,gBACAzG,EAAAwH,aAAAhB,EAAA1/B,EAAAy/B,EAAAC,cAEAxG,EAAAyH,cAAAhB,GACAzG,EAAAyH,cAAAjB,GAEAxG,EAAA0H,aAAAzD,EAAAwC,GACAzG,EAAA0H,aAAAzD,EAAAuC,GAEAxG,EAAA2H,YAAA1D,GAEAA,EAlXA,GAGAc,GAAAE,EACAsB,EAAAtC,EAAAtvB,EAAAmyB,EAEAvB,EAAAE,EANAzF,EAAA5vC,EAAA6J,QACA0P,EAAAvZ,EAAAuZ,KA2KA1Z,MAAA2C,OAAA,SAAAzB,EAAAE,EAAA0sC,GAEA,OAAA4G,EAAAvwC,OAAA,CAEA,GAAAwzC,GAAA,GAAAhJ,GAEAiJ,EAAA9J,EAAAzqC,EAAAyqC,EAAAtsC,EACAq2C,EAAA,GAAA/J,EAAAtsC,EACAs2C,EAAA,GAAAhK,EAAAzqC,EAEAivC,EAAA,GAAAxE,EAAAzqC,EACAgF,EAAA,GAAAujC,GAAA0G,EAAAsF,EAAAtF,GAEA4E,EAAA,GAAAvI,GAAA,OACAoJ,EAAA,GAAAnM,GAAA,KAEAoM,EAAA,GAAAzD,EAEAyD,GAAAj3C,IAAAkB,IAAA6rC,EAAAxsC,EAAAwsC,EAAAvsC,GACAy2C,EAAA9mC,IAAAjP,IAAA6rC,EAAAxsC,GAAAwsC,EAAAtsC,EAAA,IAAAssC,EAAAvsC,GAAAusC,EAAAzqC,EAAA,KAEAuD,SAAAotC,GAEAr0C,IAIAowC,EAAAkI,WAAAjE,GAEAt6B,EAAAw+B,iBACAx+B,EAAAy+B,gBAAAzzB,EAAAgyB,QACAh9B,EAAAy+B,gBAAAzzB,EAAAkyB,IACAl9B,EAAA0+B,0BAKArI,EAAAI,UAAA0G,EAAAE,aAAA,GACAhH,EAAAI,UAAA0G,EAAAvnC,IAAA,GAEAygC,EAAAkF,WAAAlF,EAAAmF,aAAAJ,GACA/E,EAAAsI,oBAAA3zB,EAAAgyB,OAAA,EAAA3G,EAAAuI,OAAA,QACAvI,EAAAsI,oBAAA3zB,EAAAkyB,GAAA,EAAA7G,EAAAuI,OAAA,QAEAvI,EAAAkF,WAAAlF,EAAAsF,qBAAAL,GAEAt7B,EAAA4U,QAAAyhB,EAAAwI,WACA7+B,EAAA8+B,eAAA,EAEA,QAAA1zC,GAAA,EAAA2F,EAAAiqC,EAAAvwC,OAAsCW,EAAA2F,EAAO3F,IAAA,CAE7CwtC,EAAA,GAAAxE,EAAAzqC,EACAgF,EAAApG,IAAAqwC,EAAAsF,EAAAtF,EAIA,IAAAmG,GAAA/D,EAAA5vC,EAkBA,IAhBA6yC,EAAA11C,IAAAw2C,EAAAC,YAAAl0C,SAAA,IAAAi0C,EAAAC,YAAAl0C,SAAA,IAAAi0C,EAAAC,YAAAl0C,SAAA,KAEAmzC,EAAAgB,aAAAv3C,EAAAw3C,oBACAjB,EAAAkB,gBAAAz3C,EAAA03C,kBAIA5B,EAAAz7B,KAAAk8B,GAIAI,EAAAz2C,EAAAwsC,EAAAxsC,EAAA41C,EAAA51C,EAAAu2C,IAAA,EACAE,EAAAx2C,EAAAusC,EAAAvsC,EAAA21C,EAAA31C,EAAAu2C,IAAA,EAIAE,EAAAe,cAAAhB,MAAA,GAIAr+B,EAAAs/B,cAAAjJ,EAAAkJ,UACAv/B,EAAA+7B,YAAA1F,EAAA2F,WAAA,MACAh8B,EAAAs/B,cAAAjJ,EAAAmJ,UACAx/B,EAAA+7B,YAAA1F,EAAA2F,WAAAJ,GACAvF,EAAAoJ,eAAApJ,EAAA2F,WAAA,EAAA3F,EAAA6F,IAAAmC,EAAAz2C,EAAAy2C,EAAAx2C,EAAA,SAKAwuC,EAAAI,UAAA0G,EAAAC,WAAA,GACA/G,EAAAO,UAAAuG,EAAAxuC,QAAA/G,EAAA+G,EAAA9G,GACAwuC,EAAAS,UAAAqG,EAAAK,iBAAA51C,EAAA41C,EAAA31C,EAAA21C,EAAA11C,GAEAkY,EAAA4U,QAAAyhB,EAAAqJ,OACA1/B,EAAA2/B,OAAAtJ,EAAAuJ,YAEAvJ,EAAAwJ,aAAAxJ,EAAAyJ,UAAA,EAAAzJ,EAAA0J,eAAA,GAKA//B,EAAAs/B,cAAAjJ,EAAAkJ,UACAv/B,EAAA+7B,YAAA1F,EAAA2F,WAAAF,GACAzF,EAAAoJ,eAAApJ,EAAA2F,WAAA,EAAA3F,EAAAsG,KAAA0B,EAAAz2C,EAAAy2C,EAAAx2C,EAAA,SAKAwuC,EAAAI,UAAA0G,EAAAC,WAAA,GACAp9B,EAAA4U,QAAAyhB,EAAAuJ,YAEA5/B,EAAAs/B,cAAAjJ,EAAAmJ,UACAx/B,EAAA+7B,YAAA1F,EAAA2F,WAAAJ,GACAvF,EAAAwJ,aAAAxJ,EAAAyJ,UAAA,EAAAzJ,EAAA0J,eAAA,GAKAhB,EAAAiB,eAAAj+B,KAAAy7B,GAEAuB,EAAAkB,qBAEAlB,EAAAkB,qBAAAlB,GAIAA,EAAAmB,mBAMA7J,EAAAI,UAAA0G,EAAAC,WAAA,GACAp9B,EAAA2/B,OAAAtJ,EAAAqJ,MAEA,QAAAnuC,GAAA,EAAA4uC,EAAApB,EAAAqB,WAAA31C,OAAmD8G,EAAA4uC,EAAQ5uC,IAAA,CAE3D,GAAA8uC,GAAAtB,EAAAqB,WAAA7uC,EAEA8uC,GAAAlnC,QAAA,MAAAknC,EAAA1xC,MAAA,OAEA6uC,EAAA51C,EAAAy4C,EAAAz4C,EACA41C,EAAA31C,EAAAw4C,EAAAx4C,EACA21C,EAAA11C,EAAAu4C,EAAAv4C,EAEA8wC,EAAAyH,EAAAzH,KAAAyH,EAAA1xC,MAAAylC,EAAAzqC,EAEAgF,EAAA/G,EAAAgxC,EAAAsF,EACAvvC,EAAA9G,EAAA+wC,EAEAvC,EAAAS,UAAAqG,EAAAK,iBAAA51C,EAAA41C,EAAA31C,EAAA21C,EAAA11C,GACAuuC,EAAAO,UAAAuG,EAAAxuC,QAAA/G,EAAA+G,EAAA9G,GACAwuC,EAAAC,UAAA6G,EAAAI,SAAA8C,EAAA9C,UAEAlH,EAAAC,UAAA6G,EAAAhkC,QAAAknC,EAAAlnC,SACAk9B,EAAAS,UAAAqG,EAAAG,MAAA+C,EAAA/C,MAAAxH,EAAAuK,EAAA/C,MAAAvG,EAAAsJ,EAAA/C,MAAA13B,GAEA5F,EAAAsgC,YAAAD,EAAAE,SAAAF,EAAAG,cAAAH,EAAAI,SAAAJ,EAAAK,UACAj6C,EAAAkxC,aAAA0I,EAAAhM,QAAA,GAEAgC,EAAAwJ,aAAAxJ,EAAAyJ,UAAA,EAAAzJ,EAAA0J,eAAA,MAYA//B,EAAA2/B,OAAAtJ,EAAAwI,WACA7+B,EAAA2/B,OAAAtJ,EAAAuJ,YACA5/B,EAAA8+B,eAAA,GAEAr4C,EAAAk6C,iBAmCA,QAAAC,GAAAn6C,EAAAo6C,GAgBA,QAAA56C,KAEA,GAAAg1C,GAAA,GAAA9F,gBACA,WACA,WACA,WACA,YAGA+F,EAAA,GAAAC,cACA,MACA,OAGAC,GAAA/E,EAAAgF,eACAC,EAAAjF,EAAAgF,eAEAhF,EAAAkF,WAAAlF,EAAAmF,aAAAJ,GACA/E,EAAAoF,WAAApF,EAAAmF,aAAAP,EAAA5E,EAAAqF,aAEArF,EAAAkF,WAAAlF,EAAAsF,qBAAAL,GACAjF,EAAAoF,WAAApF,EAAAsF,qBAAAT,EAAA7E,EAAAqF,aAEApB,EAAAyC,IAEA/xB,GACArlB,SAAA0wC,EAAA4G,kBAAA3C,EAAA,YACA4C,GAAA7G,EAAA4G,kBAAA3C,EAAA,OAGA6C,GACA2D,SAAAzK,EAAAsE,mBAAAL,EAAA,YACAyG,QAAA1K,EAAAsE,mBAAAL,EAAA,WAEAiD,SAAAlH,EAAAsE,mBAAAL,EAAA,YACA3rC,MAAA0nC,EAAAsE,mBAAAL,EAAA,SAEAgD,MAAAjH,EAAAsE,mBAAAL,EAAA,SACA1kC,IAAAygC,EAAAsE,mBAAAL,EAAA,OACAnhC,QAAAk9B,EAAAsE,mBAAAL,EAAA,WAEA0G,gBAAA3K,EAAAsE,mBAAAL,EAAA,mBACA8E,iBAAA/I,EAAAsE,mBAAAL,EAAA,oBAEA2G,QAAA5K,EAAAsE,mBAAAL,EAAA,WACA4G,WAAA7K,EAAAsE,mBAAAL,EAAA,cACA6G,QAAA9K,EAAAsE,mBAAAL,EAAA,WACA8G,OAAA/K,EAAAsE,mBAAAL,EAAA,UACA+G,SAAAhL,EAAAsE,mBAAAL,EAAA,YAEAgH,UAAAjL,EAAAsE,mBAAAL,EAAA,aAGA,IAAAiH,GAAAz7C,SAAA07C,gBAAA,wCACAD,GAAAp4C,MAAA,EACAo4C,EAAAn4C,OAAA,CAEA,IAAAkH,GAAAixC,EAAAE,WAAA,KACAnxC,GAAAoxC,UAAA,QACApxC,EAAAqxC,SAAA,SAEAtN,EAAA,GAAAlC,GAAAoP,GACAlN,EAAAuN,aAAA,EAoKA,QAAA7E,KAEA,GAAAzC,GAAAjE,EAAA0G,gBAEAF,EAAAxG,EAAAoH,aAAApH,EAAAsH,eACAb,EAAAzG,EAAAoH,aAAApH,EAAAqH,gBAkGA,OAhGArH,GAAAwH,aAAAhB,GAEA,aAAAp2C,EAAAm3C,eAAA,UAEA,gCACA,iCACA,0BACA,sBACA,yBACA,wBAEA,2BACA,qBAEA,oBAEA,gBAEA,iCAEA,2CAEA,wBACA,iGACA,iGAEA,sBAEA,gEACA,uCACA,oDAEA,+BAEA,KAEA5gC,KAAA,OAEAq5B,EAAAwH,aAAAf,GAEA,aAAAr2C,EAAAm3C,eAAA,UAEA,sBACA,yBACA,yBAEA,uBACA,yBACA,4BACA,yBACA,wBACA,2BAEA,oBAEA,gBAEA,wCAEA,wCAEA,mEAEA,uBAEA,iDACA,yBAEA,wBAEA,oDAEA,WAEA,+BACA,wEACA,kDAEA,IAEA,mFAEA,IAEA,KAEA5gC,KAAA,OAEAq5B,EAAAyH,cAAAjB,GACAxG,EAAAyH,cAAAhB,GAEAzG,EAAA0H,aAAAzD,EAAAuC,GACAxG,EAAA0H,aAAAzD,EAAAwC,GAEAzG,EAAA2H,YAAA1D,GAEAA,EAIA,QAAAuH,GAAAl8B,EAAAC,GAEA,MAAAD,GAAAm8B,cAAAl8B,EAAAk8B,YAEAn8B,EAAAm8B,YAAAl8B,EAAAk8B,YAEIn8B,EAAA7d,IAAA8d,EAAA9d,EAEJ8d,EAAA9d,EAAA6d,EAAA7d,EAIA8d,EAAAvhB,GAAAshB,EAAAthB,GAvWA,GAGA+2C,GAAAE,EACAhB,EAAAtvB,EAAAmyB,EAEA9I,EANAgC,EAAA5vC,EAAA6J,QACA0P,EAAAvZ,EAAAuZ,MASA+hC,EAAA,GAAA9M,GACA+M,EAAA,GAAApN,GACAqN,EAAA,GAAAhN,EAoEA3uC,MAAA2C,OAAA,SAAAzB,EAAAE,GAEA,OAAAm5C,EAAAp2C,OAAA,CAIAyC,SAAAotC,GAEAr0C,IAIAowC,EAAAkI,WAAAjE,GAEAt6B,EAAAw+B,iBACAx+B,EAAAy+B,gBAAAzzB,EAAArlB,UACAqa,EAAAy+B,gBAAAzzB,EAAAkyB,IACAl9B,EAAA0+B,0BAEA1+B,EAAA4U,QAAAyhB,EAAAwI,WACA7+B,EAAA2/B,OAAAtJ,EAAAqJ,OAEArJ,EAAAkF,WAAAlF,EAAAmF,aAAAJ,GACA/E,EAAAsI,oBAAA3zB,EAAArlB,SAAA,EAAA0wC,EAAAuI,OAAA,QACAvI,EAAAsI,oBAAA3zB,EAAAkyB,GAAA,EAAA7G,EAAAuI,OAAA,QAEAvI,EAAAkF,WAAAlF,EAAAsF,qBAAAL,GAEAjF,EAAAoB,iBAAA0F,EAAAiC,kBAAA,EAAA13C,EAAA03C,iBAAAt0C,UAEAkV,EAAAs/B,cAAAjJ,EAAAkJ,UACAlJ,EAAAI,UAAA0G,EAAAvnC,IAAA,EAEA,IAAAssC,GAAA,EACAC,EAAA,EACAC,EAAA56C,EAAA46C,GAEAA,IAEA/L,EAAAS,UAAAqG,EAAAkE,SAAAe,EAAA9E,MAAAxH,EAAAsM,EAAA9E,MAAAvG,EAAAqL,EAAA9E,MAAA13B,GAEAw8B,KAAAC,OAEAhM,EAAAC,UAAA6G,EAAAgE,QAAAiB,EAAAE,MACAjM,EAAAC,UAAA6G,EAAAiE,OAAAgB,EAAAG,KAEAlM,EAAAI,UAAA0G,EAAA8D,QAAA,GACAiB,EAAA,EACAC,EAAA,GAEKC,KAAAI,YAELnM,EAAAC,UAAA6G,EAAA+D,WAAAkB,EAAAK,SAEApM,EAAAI,UAAA0G,EAAA8D,QAAA,GACAiB,EAAA,EACAC,EAAA,KAMA9L,EAAAI,UAAA0G,EAAA8D,QAAA,GACAiB,EAAA,EACAC,EAAA,EAOA,QAAA/2C,GAAA,EAAA2F,EAAA8vC,EAAAp2C,OAAuCW,EAAA2F,EAAO3F,IAAA,CAE9C,GAAAi1C,GAAAQ,EAAAz1C,EAEAi1C,GAAAW,gBAAA0B,iBAAAh7C,EAAAw3C,mBAAAmB,EAAArB,aACAqB,EAAAv4C,GAAAu4C,EAAAW,gBAAAl2C,SAAA,IAIA+1C,EAAAh/B,KAAAggC,EAMA,QAFAlzC,MAEAvD,EAAA,EAAA2F,EAAA8vC,EAAAp2C,OAAuCW,EAAA2F,EAAO3F,IAAA,CAE9C,GAAAi1C,GAAAQ,EAAAz1C,GACAu3C,EAAAtC,EAAAsC,QAEA,IAAAA,EAAAlV,WAAA,GAEA4I,EAAAC,UAAA6G,EAAAmE,UAAAqB,EAAArB,WACAjL,EAAAoB,iBAAA0F,EAAA6D,iBAAA,EAAAX,EAAAW,gBAAAl2C,UAEAu1C,EAAArB,YAAA4D,UAAAb,EAAAC,EAAAC,GAEAtzC,EAAA,GAAAszC,EAAAr6C,EACA+G,EAAA,GAAAszC,EAAAp6C,CAEA,IAAAo5C,GAAA,CAEAz5C,GAAA46C,KAAAO,EAAAP,MAEAnB,EAAAkB,GAIAD,IAAAjB,IAEA5K,EAAAI,UAAA0G,EAAA8D,WACAiB,EAAAjB,GAIA,OAAA0B,EAAA/sC,KAEAygC,EAAAO,UAAAuG,EAAA2D,SAAA6B,EAAA/sC,IAAAq6B,OAAAroC,EAAA+6C,EAAA/sC,IAAAq6B,OAAApoC,GACAwuC,EAAAO,UAAAuG,EAAA4D,QAAA4B,EAAA/sC,IAAA69B,OAAA7rC,EAAA+6C,EAAA/sC,IAAA69B,OAAA5rC,KAIAwuC,EAAAO,UAAAuG,EAAA2D,SAAA,KACAzK,EAAAO,UAAAuG,EAAA4D,QAAA,MAIA1K,EAAAC,UAAA6G,EAAAhkC,QAAAwpC,EAAAxpC,SACAk9B,EAAAS,UAAAqG,EAAAG,MAAAqF,EAAArF,MAAAxH,EAAA6M,EAAArF,MAAAvG,EAAA4L,EAAArF,MAAA13B,GAEAywB,EAAAC,UAAA6G,EAAAI,SAAAoF,EAAApF,UACAlH,EAAAM,WAAAwG,EAAAxuC,SAEAqR,EAAAsgC,YAAAqC,EAAApC,SAAAoC,EAAAnC,cAAAmC,EAAAlC,SAAAkC,EAAAjC,UACA1gC,EAAA6iC,aAAAF,EAAAG,WACA9iC,EAAA8+B,cAAA6D,EAAAI,YAEAJ,EAAA/sC,IAEAnP,EAAAkxC,aAAAgL,EAAA/sC,IAAA,GAIAnP,EAAAkxC,aAAAtD,EAAA,GAIAgC,EAAAwJ,aAAAxJ,EAAAyJ,UAAA,EAAAzJ,EAAA0J,eAAA,IAMA//B,EAAA2/B,OAAAtJ,EAAAwI,WAEAp4C,EAAAk6C,iBAwIA,QAAAqC,KAEA1iC,OAAAwX,eAAAxxB,KAAA,MAAsCoG,MAAAu2C,MAEtC38C,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAA0H,KAAA,GACA1H,KAAAoE,KAAA,WAEApE,KAAA87C,KAAA,EACA97C,KAAA48C,QAAA,EAEA58C,KAAAi6C,SAAA4C,GACA78C,KAAA88C,KAAAC,GACA/8C,KAAAg9C,QAAAC,GACAj9C,KAAAk9C,aAAAC,GAEAn9C,KAAA6S,QAAA,EACA7S,KAAAo9C,aAAA,EAEAp9C,KAAAm6C,SAAAkD,GACAr9C,KAAAo6C,SAAAkD,GACAt9C,KAAAk6C,cAAAqD,GACAv9C,KAAAw9C,cAAA,KACAx9C,KAAAy9C,cAAA,KACAz9C,KAAA09C,mBAAA,KAEA19C,KAAA29C,UAAAC,GACA59C,KAAAw8C,WAAA,EACAx8C,KAAAy8C,YAAA,EAEAz8C,KAAA69C,eAAA,KACA79C,KAAA89C,kBAAA,EACA99C,KAAA+9C,aAAA,EAEA/9C,KAAAg+C,YAAA,EAEAh+C,KAAAi+C,UAAA,KAEAj+C,KAAAk+C,eAAA,EACAl+C,KAAAm+C,oBAAA,EACAn+C,KAAAo+C,mBAAA,EAEAp+C,KAAAg7C,UAAA,EACAh7C,KAAAq+C,oBAAA,EAEAr+C,KAAAs+C,SAAA,EAEAt+C,KAAAmnC,SAAA,EAEAnnC,KAAAu+C,cAAA,EA4RA,QAAA5B,KAA6B,MAAA6B,MAuB7B,QAAAC,GAAAC,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAAoE,KAAA,iBAEApE,KAAA2+C,WACA3+C,KAAA62C,YAEA72C,KAAAu2C,aAAA,gGACAv2C,KAAAw2C,eAAA,iEAEAx2C,KAAA4+C,UAAA,EAEA5+C,KAAA6+C,WAAA,EACA7+C,KAAA8+C,mBAAA,EAEA9+C,KAAA87C,KAAA,EACA97C,KAAA48C,QAAA,EACA58C,KAAA++C,UAAA,EAEA/+C,KAAAg/C,UAAA,EACAh/C,KAAAi/C,cAAA,EACAj/C,KAAAk/C,cAAA,EAEAl/C,KAAAm/C,YACAC,aAAA,EACAC,WAAA,EACAC,aAAA,EACAC,kBAAA,GAKAv/C,KAAAw/C,wBACAxI,OAAA,OACAJ,IAAA,KACA6I,KAAA,MAGAz/C,KAAA0/C,oBAAA94C,OAEAA,SAAA83C,IAEA93C,SAAA83C,EAAAh6B,YAEA6L,QAAA5W,MAAA,2FAIA3Z,KAAA2/C,UAAAjB,IA0EA,QAAAkB,GAAAlB,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAAoE,KAAA,oBAEApE,KAAA6/C,aAAAC,GAEA9/C,KAAAg/C,UAAA,EACAh/C,KAAAi/C,cAAA,EAEAj/C,KAAAsP,IAAA,KAEAtP,KAAA+/C,SAAA,KAEA//C,KAAAggD,gBAAA,KACAhgD,KAAAigD,kBAAA,EACAjgD,KAAAkgD,iBAAA,EAEAlgD,KAAA6+C,WAAA,EACA7+C,KAAA8+C,mBAAA,EAEA9+C,KAAA87C,KAAA,EACA97C,KAAA48C,QAAA,EAEA58C,KAAA2/C,UAAAjB,GAsCA,QAAAyB,IAAAp/C,EAAAmQ,GAEAlR,KAAAe,IAAA6F,SAAA7F,IAAA,GAAA4tC,KAAA6F,oBACAx0C,KAAAkR,IAAAtK,SAAAsK,IAAA,GAAAy9B,KAAA6F,oBA0dA,QAAA4L,IAAAC,EAAAC,GAEAtgD,KAAAqgD,OAAAz5C,SAAAy5C,IAAA,GAAA1R,GACA3uC,KAAAsgD,OAAA15C,SAAA05C,IAAA,EA8KA,QAAAC,MAEAvgD,KAAAwE,SAAA,GAAAqqC,eAEA,MACA,MACA,QAIA7hC,UAAA7I,OAAA,GAEAosB,QAAA5W,MAAA,iFAwSA,QAAA5a,IAAAyhD,EAAAC,GAEAzgD,KAAAwgD,OAAA55C,SAAA45C,IAAA,GAAA7R,GAAA,OACA3uC,KAAAygD,SAAA75C,SAAA65C,IAAA,EAwOA,QAAAC,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEAhhD,KAAAihD,QAEAr6C,SAAA+5C,IAAA,GAAA5hD,IACA6H,SAAAg6C,IAAA,GAAA7hD,IACA6H,SAAAi6C,IAAA,GAAA9hD,IACA6H,SAAAk6C,IAAA,GAAA/hD,IACA6H,SAAAm6C,IAAA,GAAAhiD,IACA6H,SAAAo6C,IAAA,GAAAjiD,KA4LA,QAAAmiD,IAAAC,EAAAC,EAAAC,EAAAC,GAqSA,QAAAC,GAAA97C,EAAA42C,EAAAmF,EAAAC,GAEA,GAAAC,GAAAj8C,EAAAi8C,SAEAzsC,EAAA,KAEA0sC,EAAAC,EACAC,EAAAp8C,EAAAq8C,mBASA,IAPAN,IAEAG,EAAAI,EACAF,EAAAp8C,EAAAu8C,wBAIAH,EA6BA5sC,EAAA4sC,MA7BA,CAEA,GAAAI,IAAA,CAEA5F,GAAA4C,eAEAyC,KAAAQ,iBAEAD,EAAAP,EAAAS,iBAAAT,EAAAS,gBAAA9iD,UAAAqiD,EAAAS,gBAAA9iD,SAAA8E,OAAA,EAEMu9C,KAAAU,aAENH,EAAAP,EAAAzC,cAAAyC,EAAAzC,aAAA96C,OAAA,GAMA,IAAAk+C,GAAA58C,EAAA68C,eAAAjG,EAAA2C,SAEAuD,EAAA,CAEAN,KAAAM,GAAAC,GACAH,IAAAE,GAAAE,GAEAxtC,EAAA0sC,EAAAY,GAQA,GAAApB,EAAAuB,sBACArG,EAAA0B,eAAA,GACA,IAAA1B,EAAAwB,eAAA15C,OAAA,CAKA,GAAAw+C,GAAA1tC,EAAAs3B,KAAAqW,EAAAvG,EAAA9P,KAEAsW,EAAAC,EAAAH,EAEA/7C,UAAAi8C,IAEAA,KACAC,EAAAH,GAAAE,EAIA,IAAAE,GAAAF,EAAAD,EAEAh8C,UAAAm8C,IAEAA,EAAA9tC,EAAA1F,QACAszC,EAAAD,GAAAG,GAIA9tC,EAAA8tC,EAIA9tC,EAAAkyB,QAAAkV,EAAAlV,QACAlyB,EAAA4pC,UAAAxC,EAAAwC,SAEA,IAAA/B,GAAAT,EAAAS,IA6BA,OA3BAkG,GAAAC,mBAAAnG,GAAAoG,KAEApG,EAAAC,IAIAiG,EAAAG,qBAEArG,IAAAC,GAAAD,EAAAsG,GACAtG,IAAAsG,KAAAtG,EAAAC,KAIA9nC,EAAA6nC,OAEA7nC,EAAA8oC,YAAA1B,EAAA0B,YACA9oC,EAAA4oC,eAAAxB,EAAAwB,eAEA5oC,EAAA6pC,mBAAAzC,EAAAyC,mBACA7pC,EAAA2pC,UAAAvC,EAAAuC,UAEA4C,GAAA56C,SAAAqO,EAAA4hC,SAAAwM,UAEApuC,EAAA4hC,SAAAwM,SAAAj9C,MAAAqV,KAAAgmC,GAIAxsC,EAIA,QAAAquC,GAAA79C,EAAArE,EAAAmiD,GAEA,GAAA99C,EAAA0hC,WAAA,GAEA,GAAAA,GAAA,KAAA1hC,EAAA+9C,OAAAC,KAAAriD,EAAAoiD,OAAAC,KAEA,IAAAtc,IAAA1hC,EAAAi+C,QAAAj+C,EAAAk+C,QAAAl+C,EAAAm+C,WAEAn+C,EAAAvD,aAAAuD,EAAAo+C,iBAAA,GAAAC,EAAAC,iBAAAt+C,MAAA,IAEA,GAAA42C,GAAA52C,EAAA42C,QAEAA,GAAAlV,WAAA,IAEA1hC,EAAAi1C,gBAAA0B,iBAAAmH,EAAA3K,mBAAAnzC,EAAAizC,aACAsL,EAAAj4C,KAAAtG,IAUA,OAFAynB,GAAAznB,EAAAynB,SAEApoB,EAAA,EAAA2F,EAAAyiB,EAAA/oB,OAAwCW,EAAA2F,EAAO3F,IAE/Cw+C,EAAAp2B,EAAApoB,GAAA1D,EAAAmiD,IAlbA,GAAAU,GAAA9C,EAAAn3C,QACAk6C,EAAA/C,EAAAznC,MACAoqC,EAAA,GAAApD,IACAyD,EAAA,GAAAvV,GAEAwV,EAAAhD,EAAAiD,QAEAC,EAAA,GAAA1Y,GACA2Y,EAAA,GAAA3Y,GAAA0V,EAAAkD,eAAAlD,EAAAkD,gBAEAC,EAAA,GAAA9V,GACA+V,EAAA,GAAA/V,GAEAqV,KAEAxB,EAAA,EACAC,EAAA,EAEAkC,GAAAnC,EAAAC,GAAA,EAEAb,EAAA,GAAA5lC,OAAA2oC,GACA5C,EAAA,GAAA/lC,OAAA2oC,GAEA7B,KAEA8B,GACA,GAAAjW,GAAA,UAAAA,IAAA,UAAAA,GAAA,OACA,GAAAA,GAAA,WAAAA,GAAA,UAAAA,GAAA,SAGAkW,GACA,GAAAlW,GAAA,UAAAA,GAAA,UAAAA,GAAA,OACA,GAAAA,GAAA,UAAAA,GAAA,UAAAA,GAAA,SAGAmW,GACA,GAAApX,GAAA,GAAAA,GAAA,GAAAA,GACA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,IAKAqX,EAAA,GAAAnF,EACAmF,GAAAlF,aAAAmF,GACAD,EAAAhG,UAAA,CAKA,QAHAkG,GAAAC,GAAA,aACAC,EAAAC,GAAA71C,MAAA01C,EAAApO,UAEA/xC,EAAA,EAAkBA,IAAA6/C,IAAiC7/C,EAAA,CAEnD,GAAAm9C,GAAA,KAAAn9C,EAAA09C,GACAH,EAAA,KAAAv9C,EAAA29C,GAEA4C,EAAAN,EAAAx1C,OACA81C,GAAApG,aAAAgD,EACAoD,EAAArG,SAAAqD,EAEAT,EAAA98C,GAAAugD,CAEA,IAAAC,GAAA,GAAA7G,IACAE,SACA4G,cAAA,IAEA1O,SAAAsO,EACA5O,aAAA0O,EAAA1O,aACAC,eAAAyO,EAAAzO,eACAyI,aAAAgD,EACAjD,SAAAqD,EACAtD,UAAA,GAGAgD,GAAAj9C,GAAAwgD,EAMA,GAAAtC,GAAAhjD,IAEAA,MAAAY,SAAA,EAEAZ,KAAAwlD,YAAA,EACAxlD,KAAAs7C,aAAA,EAEAt7C,KAAAoE,KAAAqhD,GAEAzlD,KAAAmjD,oBAAA,EACAnjD,KAAAijD,mBAAA,EAEAjjD,KAAA2C,OAAA,SAAAzB,EAAAE,GAEA,GAAA4hD,EAAApiD,WAAA,IACAoiD,EAAAwC,cAAA,GAAAxC,EAAA1H,eAAA,IAEA,IAAA8I,EAAAjgD,OAAA,CAGA+/C,EAAAwB,WAAA,SACAxB,EAAA51B,QAAA21B,EAAA7K,OACA8K,EAAA3H,cAAA,GACA2H,EAAAyB,gBAAA,EAMA,QAFAC,GAAApE,EAEA18C,EAAA,EAAA+gD,EAAAzB,EAAAjgD,OAA8CW,EAAA+gD,EAAQ/gD,IAAA,CAEtD,GAAAghD,GAAA1B,EAAAt/C,GACAihD,EAAAD,EAAAC,MAEA,IAAAn/C,SAAAm/C,EAAA,CAOA,GAAAxC,GAAAwC,EAAA3kD,MAKA,IAHAkjD,EAAA7oC,KAAAsqC,EAAAC,SACA1B,EAAAvjD,IAAAwjD,GAEAuB,KAAAtE,aAAA,CAEAoE,EAAA,EACApE,GAAA,CAEA,IAAAyE,GAAA3B,EAAAhjD,EACA4kD,EAAA5B,EAAA/iD,CAgBAujD,GAAA,GAAA7iD,IAAA,EAAAgkD,EAAAC,EAAAD,EAAAC,GAEApB,EAAA,GAAA7iD,IAAA,EAAAikD,EAAAD,EAAAC,GAEApB,EAAA,GAAA7iD,IAAA,EAAAgkD,EAAAC,EAAAD,EAAAC,GAEApB,EAAA,GAAA7iD,IAAAgkD,EAAAC,EAAAD,EAAAC,GAEApB,EAAA,GAAA7iD,IAAA,EAAAgkD,EAAA,EAAAA,EAAAC,GAEApB,EAAA,GAAA7iD,IAAAgkD,EAAA,EAAAA,EAAAC,GAEA5B,EAAAhjD,GAAA,EACAgjD,EAAA/iD,GAAA,MAIAqkD,GAAA,EACApE,GAAA,CAIA,WAAAuE,EAAAz2C,IAAA,CAEA,GAAA62C,IAAiBja,UAAAka,GAAAna,UAAAma,GAAAja,OAAAc,GAEjB8Y,GAAAz2C,IAAA,GAAAq+B,GAAA2W,EAAAhjD,EAAAgjD,EAAA/iD,EAAA4kD,GAEA5C,EAAAvgD,yBAIA+iD,KAAAM,mBAEAN,EAAA5jD,OAAA2jD,EAIA,IAAAnlD,GAAAolD,EAAAz2C,IACAg3C,EAAAP,EAAAQ,MAEA7B,GAAA8B,sBAAAV,EAAApN,aACA6K,EAAAlkD,SAAAoc,KAAAipC,GAEAvD,EAAAsF,gBAAA9lD,GACAwgD,EAAAuF,OAKA,QAAAC,GAAA,EAAuBA,EAAAf,EAAkBe,IAAA,CAEzC,GAAAnF,EAAA,CAEAiD,EAAAhpC,KAAA8nC,EAAAlkD,UACAolD,EAAA3iD,IAAA8iD,EAAA+B,IACApD,EAAAqD,GAAAnrC,KAAAopC,EAAA8B,IACApD,EAAA9hD,OAAAgjD,EAEA,IAAAoC,GAAA/B,EAAA6B,EACAzC,GAAApW,SAAA+Y,OAIApC,GAAA+B,sBAAAV,EAAA7tC,OAAAygC,aACA6K,EAAA9hD,OAAAgjD,EAIAlB,GAAAuD,oBACAvD,EAAA3K,mBAAAmO,WAAAxD,EAAA7K,aAIA4N,EAAArkD,IACA,UACA,UACA,UACA,SAGAqkD,EAAAU,SAAAzD,EAAAzK,kBACAwN,EAAAU,SAAAzD,EAAA3K,oBAIAuL,EAAA/H,iBAAAmH,EAAAzK,iBAAAyK,EAAA3K,oBACAkL,EAAAmD,cAAA9C,GAIAH,EAAA7/C,OAAA,EAEAm/C,EAAApiD,EAAAE,EAAAmiD,EAKA,QAAAt4C,GAAA,EAAA4uC,EAAAmK,EAAA7/C,OAA8C8G,EAAA4uC,EAAQ5uC,IAAA,CAEtD,GAAAxF,GAAAu+C,EAAA/4C,GACAy2C,EAAAL,EAAAl/C,OAAAsD,GACA42C,EAAA52C,EAAA42C,QAEA,IAAAA,KAAA6K,gBAKA,OAHA7pC,GAAAqkC,EAAArkC,OACA8pC,EAAA9K,EAAA8K,UAEAC,EAAA,EAAAC,EAAAhqC,EAAAlZ,OAA2CijD,EAAAC,EAAQD,IAAA,CAEnD,GAAAE,GAAAjqC,EAAA+pC,GACAG,EAAAJ,EAAAG,EAAAE,cAEA,IAAAD,EAAApgB,WAAA,GAEA,GAAAke,GAAA9D,EAAA97C,EAAA8hD,EAAA/F,EAAAkD,EACAvD,GAAAsG,mBAAAlE,EAAA,KAAA7B,EAAA2D,EAAA5/C,EAAA6hD,QAMO,CAEP,GAAAjC,GAAA9D,EAAA97C,EAAA42C,EAAAmF,EAAAkD,EACAvD,GAAAsG,mBAAAlE,EAAA,KAAA7B,EAAA2D,EAAA5/C,EAAA,aA9JA8qB,SAAAC,KAAA,wBAAAs1B,EAAA,kBAyKA,GAAAJ,GAAAvE,EAAAuG,gBACAC,EAAAxG,EAAAyG,eACAzG,GAAA7gD,cAAAolD,EAAAiC,GAEA3E,EAAA1H,aAAA,IA+JA,QAAAuM,IAAAC,EAAAC,GAEA/nD,KAAA8nD,OAAAlhD,SAAAkhD,IAAA,GAAAnZ,GACA3uC,KAAA+nD,UAAAnhD,SAAAmhD,IAAA,GAAApZ,GAuhBA,QAAAqZ,IAAA1mD,EAAAC,EAAAC,EAAAq6B,GAEA77B,KAAAuuC,GAAAjtC,GAAA,EACAtB,KAAAwuC,GAAAjtC,GAAA,EACAvB,KAAAyuC,GAAAjtC,GAAA,EACAxB,KAAAioD,OAAApsB,GAAAmsB,GAAAE,aAkUA,QAAAC,MAEAnoD,KAAAyjD,KAAA,EAgDA,QAAA2E,MAmBA,QAAAC,KAEAC,EAAAC,aAAAtR,GAAA,GAIA,QAAAuR,KAEAvR,EAAAwR,kBAAAH,EAAA1hD,QAAA,GAzBAoT,OAAAwX,eAAAxxB,KAAA,MAAsCoG,MAAAsiD,OAEtC1oD,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAA0H,KAAA,GACA1H,KAAAoE,KAAA,WAEApE,KAAA+pB,OAAA,KACA/pB,KAAAktB,YAEAltB,KAAA4mD,GAAAwB,GAAAO,UAAAp5C,OAEA,IAAAlQ,GAAA,GAAAsvC,GACAsI,EAAA,GAAA+Q,IACAM,EAAA,GAAAha,GACAjmC,EAAA,GAAAsmC,GAAA,MAcAsI,GAAA2R,SAAAP,GACAC,EAAAM,SAAAJ,GAEAxuC,OAAA6uC,iBAAA7oD,MACAX,UACAw2B,YAAA,EACAzvB,MAAA/G,GAEA43C,UACAphB,YAAA,EACAzvB,MAAA6wC,GAEAqR,YACAzyB,YAAA,EACAzvB,MAAAkiD,GAEAjgD,OACAwtB,YAAA,EACAzvB,MAAAiC,GAEAqyC,iBACAt0C,MAAA,GAAAwoC,IAEAka,cACA1iD,MAAA,GAAAm6C,OAIAvgD,KAAAumD,OAAA,GAAA3X,GACA5uC,KAAA04C,YAAA,GAAA9J,GAEA5uC,KAAA+oD,iBAAAX,GAAAY,wBACAhpD,KAAAipD,wBAAA,EAEAjpD,KAAAwjD,OAAA,GAAA2E,IACAnoD,KAAAmnC,SAAA,EAEAnnC,KAAAkC,YAAA,EACAlC,KAAAkpD,eAAA,EAEAlpD,KAAA6jD,eAAA,EACA7jD,KAAAw7C,YAAA,EAEAx7C,KAAAmpD,YAEAnpD,KAAAopD,eAAA,aACAppD,KAAAqpD,cAAA,aA4nBA,QAAAX,MAA6B,MAAAY,MAM7B,QAAAC,IAAAxgD,EAAAC,GAEAhJ,KAAA+I,MAAAnC,SAAAmC,IAAA,GAAA4lC,GACA3uC,KAAAgJ,IAAApC,SAAAoC,IAAA,GAAA2lC,GA6HA,QAAA6a,IAAAnqC,EAAAC,EAAAnhB,GAEA6B,KAAAqf,EAAAzY,SAAAyY,IAAA,GAAAsvB,GACA3uC,KAAAsf,EAAA1Y,SAAA0Y,IAAA,GAAAqvB,GACA3uC,KAAA7B,EAAAyI,SAAAzI,IAAA,GAAAwwC,GA4PA,QAAA8a,IAAApqC,EAAAC,EAAAnhB,EAAAqiD,EAAAxJ,EAAAwQ,GAEAxnD,KAAAqf,IACArf,KAAAsf,IACAtf,KAAA7B,IAEA6B,KAAAwgD,YAAAkJ,UAAAlJ,EAAA,GAAA7R,GACA3uC,KAAA2pD,cAAA3tC,MAAAnH,QAAA2rC,QAEAxgD,KAAAg3C,WAAA4S,QAAA5S,EAAA,GAAAz2C,GACAP,KAAAk9C,aAAAlhC,MAAAnH,QAAAmiC,QAEAh3C,KAAAwnD,cAAA5gD,SAAA4gD,IAAA,EA4EA,QAAAqC,IAAAnL,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAAoE,KAAA,oBAEApE,KAAAg3C,MAAA,GAAAz2C,GAAA,UAEAP,KAAAsP,IAAA,KAEAtP,KAAA8pD,MAAA,KACA9pD,KAAA+pD,eAAA,EAEA/pD,KAAAgqD,YAAA,KAEAhqD,KAAA+/C,SAAA,KAEA//C,KAAAiqD,OAAA,KACAjqD,KAAAkqD,QAAAC,GACAnqD,KAAAoqD,aAAA,EACApqD,KAAAqqD,gBAAA,IAEArqD,KAAA6+C,WAAA,EACA7+C,KAAA8+C,mBAAA,EACA9+C,KAAAsqD,iBAAA,QACAtqD,KAAAuqD,kBAAA,QAEAvqD,KAAAg/C,UAAA,EACAh/C,KAAAi/C,cAAA,EAEAj/C,KAAA48C,QAAA,EAEA58C,KAAA2/C,UAAAjB,GA6CA,QAAA8L,IAAApb,EAAAqb,EAAAC,GAEA,GAAA1uC,MAAAnH,QAAAu6B,GAEA,SAAA3f,WAAA,wDAIAzvB,MAAAusC,KAAAC,GAAAC,eAEAzsC,KAAAovC,QACApvC,KAAAyqD;AACAzqD,KAAAiyB,MAAArrB,SAAAwoC,IAAAjrC,OAAAsmD,EAAA,EACAzqD,KAAA0qD,gBAAA,EAEA1qD,KAAA2qD,SAAA,EACA3qD,KAAA4qD,aAAsBjhB,OAAA,EAAA1X,OAAA,GAEtBjyB,KAAAwa,QAAA,EA+SA,QAAAqwC,IAAAzb,EAAAqb,GAEA,UAAAD,IAAA,GAAAM,WAAA1b,GAAAqb,GAIA,QAAAM,IAAA3b,EAAAqb,GAEA,UAAAD,IAAA,GAAAQ,YAAA5b,GAAAqb,GAIA,QAAAQ,IAAA7b,EAAAqb,GAEA,UAAAD,IAAA,GAAAU,mBAAA9b,GAAAqb,GAIA,QAAAU,IAAA/b,EAAAqb,GAEA,UAAAD,IAAA,GAAAY,YAAAhc,GAAAqb,GAIA,QAAAY,IAAAjc,EAAAqb,GAEA,UAAAD,IAAA,GAAA3V,aAAAzF,GAAAqb,GAIA,QAAAa,IAAAlc,EAAAqb,GAEA,UAAAD,IAAA,GAAA5a,YAAAR,GAAAqb,GAIA,QAAAc,IAAAnc,EAAAqb,GAEA,UAAAD,IAAA,GAAAgB,aAAApc,GAAAqb,GAIA,QAAAgB,IAAArc,EAAAqb,GAEA,UAAAD,IAAA,GAAA3b,cAAAO,GAAAqb,GAIA,QAAAiB,IAAAtc,EAAAqb,GAEA,UAAAD,IAAA,GAAAmB,cAAAvc,GAAAqb,GAMA,QAAAmB,IAAAxc,EAAAqb,GAGA,MADAl6B,SAAAC,KAAA,8GACA,GAAAg6B,IAAApb,EAAAqb,GAAAoB,YAAA,GAaA,QAAAC,MAEA9xC,OAAAwX,eAAAxxB,KAAA,MAAsCoG,MAAA2lD,OAEtC/rD,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAA0H,KAAA,GACA1H,KAAAoE,KAAA,WAEApE,KAAA20C,YACA30C,KAAAgsD,UACAhsD,KAAA40C,SACA50C,KAAAisD,mBAEAjsD,KAAAi/C,gBACAj/C,KAAAk/C,gBAEAl/C,KAAAksD,eACAlsD,KAAAmsD,eAEAnsD,KAAAosD,iBAEApsD,KAAAqsD,YAAA,KACArsD,KAAAssD,eAAA,KAIAtsD,KAAAusD,oBAAA,EACAvsD,KAAAwsD,oBAAA,EACAxsD,KAAAysD,eAAA,EACAzsD,KAAA0sD,mBAAA,EACA1sD,KAAA2sD,kBAAA,EACA3sD,KAAA4sD,yBAAA,EACA5sD,KAAA6sD,kBAAA,EAssCA,QAAAd,MAA6B,MAAAe,MAM7B,QAAAC,MAEA/yC,OAAAwX,eAAAxxB,KAAA,MAAsCoG,MAAA2lD,OAEtC/rD,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAA0H,KAAA,GACA1H,KAAAoE,KAAA,iBAEApE,KAAAgtD,WACAhtD,KAAA20C,YACA30C,KAAAitD,WACAjtD,KAAAgsD,UACAhsD,KAAAktD,OACAltD,KAAAmtD,QAEAntD,KAAAqd,UAEArd,KAAAi/C,gBAEAj/C,KAAAksD,eACAlsD,KAAAmsD,eAIAnsD,KAAAqsD,YAAA,KACArsD,KAAAssD,eAAA,KAIAtsD,KAAAwsD,oBAAA,EACAxsD,KAAA0sD,mBAAA,EACA1sD,KAAA2sD,kBAAA,EACA3sD,KAAAysD,eAAA,EACAzsD,KAAA6sD,kBAAA,EA8PA,QAAAO,MAEApzC,OAAAwX,eAAAxxB,KAAA,MAAsCoG,MAAA2lD,OAEtC/rD,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAA0H,KAAA,GACA1H,KAAAoE,KAAA,iBAEApE,KAAA2J,MAAA,KACA3J,KAAA0kB,cAEA1kB,KAAAmiD,mBAEAniD,KAAAqd,UAEArd,KAAAqsD,YAAA,KACArsD,KAAAssD,eAAA,KAEAtsD,KAAAqtD,WAAoBtkD,MAAA,EAAAkpB,MAAAuiB,KAs/BpB,QAAA8Y,IAAA5L,EAAArF,GAEA+L,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,OAEApE,KAAA0hD,SAAA96C,SAAA86C,IAAA,GAAA0L,IACAptD,KAAAq8C,SAAAz1C,SAAAy1C,IAAA,GAAAwN,KAA8E7S,MAAA,SAAAl2C,KAAA8a,WAE9E5b,KAAAutD,SAAAC,GAEAxtD,KAAAytD,qBAwUA,QAAAC,IAAA7qD,EAAAC,EAAAssB,EAAAu+B,EAAAC,EAAAC,GAyDA,QAAAC,GAAAzqD,EAAA0qD,EAAAC,GAEA,GAAArZ,GAAA,CAOA,OAJAA,KAAAtxC,EAAA,IAAA0qD,EAAA,KACApZ,IAAAtxC,EAAA,IAAA2qD,EAAA,KACArZ,IAAAqZ,EAAA,IAAAD,EAAA,KAMA,QAAAE,GAAA5qD,EAAA0qD,EAAAC,GAEA,GAAArkD,GAAA,CAOA,OAJAA,IAAAtG,EAAA0qD,EAAA,EACApkD,GAAAtG,EAAA2qD,EAAA,EACArkD,GAAAqkD,EAAAD,EAAA,EAEA,EAAApkD,EAIA,QAAAukD,GAAAC,EAAAnoD,EAAA3C,EAAA+qD,EAAAC,EAAAxrD,EAAAC,EAAAssB,EAAAk/B,EAAAC,EAAA/G,GAmBA,OAjBAgH,GAAA3rD,EAAAyrD,EACAG,EAAA3rD,EAAAyrD,EAEAG,EAAA7rD,EAAA,EACA8rD,EAAA7rD,EAAA,EACA8rD,EAAAx/B,EAAA,EAEAy/B,EAAAP,EAAA,EACAQ,EAAAP,EAAA,EAEAQ,EAAA,EACAC,EAAA,EAEAC,EAAA,GAAAtgB,GAIAugB,EAAA,EAAoBA,EAAAJ,EAAaI,IAIjC,OAFA3tD,GAAA2tD,EAAAT,EAAAE,EAEAQ,EAAA,EAAqBA,EAAAN,EAAaM,IAAA,CAElC,GAAA7tD,GAAA6tD,EAAAX,EAAAE,CAGAO,GAAAd,GAAA7sD,EAAA8sD,EACAa,EAAAjpD,GAAAzE,EAAA8sD,EACAY,EAAA5rD,GAAAurD,EAGAja,EAAAya,GAAAH,EAAA3tD,EACAqzC,EAAAya,EAAA,GAAAH,EAAA1tD,EACAozC,EAAAya,EAAA,GAAAH,EAAAztD,EAGAytD,EAAAd,GAAA,EACAc,EAAAjpD,GAAA,EACAipD,EAAA5rD,GAAA+rB,EAAA,OAGA69B,EAAAmC,GAAAH,EAAA3tD,EACA2rD,EAAAmC,EAAA,GAAAH,EAAA1tD,EACA0rD,EAAAmC,EAAA,GAAAH,EAAAztD,EAGA0rD,EAAAmC,GAAAF,EAAAb,EACApB,EAAAmC,EAAA,KAAAH,EAAAX,EAGAa,GAAA,EACAC,GAAA,EACAN,GAAA,EAUA,IAAAG,EAAA,EAAgBA,EAAAX,EAAYW,IAE5B,IAAAC,EAAA,EAAiBA,EAAAb,EAAYa,IAAA,CAG7B,GAAA9vC,GAAAiwC,EAAAH,EAAAN,EAAAK,EACA5vC,EAAAgwC,EAAAH,EAAAN,GAAAK,EAAA,GACA/wD,EAAAmxD,GAAAH,EAAA,GAAAN,GAAAK,EAAA,GACAlB,EAAAsB,GAAAH,EAAA,GAAAN,EAAAK,CAGAlC,GAAAuC,GAAAlwC,EACA2tC,EAAAuC,EAAA,GAAAjwC,EACA0tC,EAAAuC,EAAA,GAAAvB,EAGAhB,EAAAuC,EAAA,GAAAjwC,EACA0tC,EAAAuC,EAAA,GAAApxD,EACA6uD,EAAAuC,EAAA,GAAAvB,EAGAuB,GAAA,EACAP,GAAA,EAOAhM,EAAAwM,SAAAC,EAAAT,EAAAxH,GAGAiI,GAAAT,EAGAM,GAAAP,EApLA3B,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,oBAEApE,KAAA0+C,YACA77C,QACAC,SACAssB,QACAu+B,gBACAC,iBACAC,gBAGA,IAAA7K,GAAAhjD,IAGA2tD,GAAA7sD,KAAA4uD,MAAA/B,IAAA,EACAC,EAAA9sD,KAAA4uD,MAAA9B,IAAA,EACAC,EAAA/sD,KAAA4uD,MAAA7B,IAAA,CAGA,IAAA8B,GAAA7B,EAAAH,EAAAC,EAAAC,GACA+B,EAAA3B,EAAAN,EAAAC,EAAAC,GAGAb,EAAA,IAAA4C,EAAA,MAAApE,YAAA3W,aAAA+a,GACAjb,EAAA,GAAA9F,cAAA,EAAA8gB,GACA1C,EAAA,GAAApe,cAAA,EAAA8gB,GACAzC,EAAA,GAAAre,cAAA,EAAA8gB,GAGAP,EAAA,EACAC,EAAA,EACAE,EAAA,EACAD,EAAA,EAGAG,EAAA,CAGAvB,GAAA,kBAAA9+B,EAAAtsB,EAAAD,EAAAgrD,EAAAD,EAAA,GACAM,EAAA,iBAAA9+B,EAAAtsB,GAAAD,EAAAgrD,EAAAD,EAAA,GACAM,EAAA,gBAAArrD,EAAAusB,EAAAtsB,EAAA6qD,EAAAE,EAAA,GACAK,EAAA,iBAAArrD,EAAAusB,GAAAtsB,EAAA6qD,EAAAE,EAAA,GACAK,EAAA,iBAAArrD,EAAAC,EAAAssB,EAAAu+B,EAAAC,EAAA,GACAM,EAAA,kBAAArrD,EAAAC,GAAAssB,EAAAu+B,EAAAC,EAAA,GAGA5tD,KAAA6vD,SAAA,GAAArF,IAAAwC,EAAA,IACAhtD,KAAA8vD,aAAA,cAAAtF,IAAA7V,EAAA,IACA30C,KAAA8vD,aAAA,YAAAtF,IAAAyC,EAAA,IACAjtD,KAAA8vD,aAAA,QAAAtF,IAAA0C,EAAA,IA+IA,QAAA6C,IAAAltD,EAAAC,EAAA6qD,EAAAC,GAEAR,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,sBAEApE,KAAA0+C,YACA77C,QACAC,SACA6qD,gBACAC,iBAsBA,QAnBAoC,GAAAntD,EAAA,EACAotD,EAAAntD,EAAA,EAEAwrD,EAAAxtD,KAAA4uD,MAAA/B,IAAA,EACAY,EAAAztD,KAAA4uD,MAAA9B,IAAA,EAEAiB,EAAAP,EAAA,EACAQ,EAAAP,EAAA,EAEA2B,EAAArtD,EAAAyrD,EACA6B,EAAArtD,EAAAyrD,EAEA5Z,EAAA,GAAA9F,cAAAggB,EAAAC,EAAA,GACA7B,EAAA,GAAApe,cAAAggB,EAAAC,EAAA,GACA5B,EAAA,GAAAre,cAAAggB,EAAAC,EAAA,GAEAnlB,EAAA,EACAymB,EAAA,EAEAlB,EAAA,EAAmBA,EAAAJ,EAAaI,IAIhC,OAFA3tD,GAAA2tD,EAAAiB,EAAAF,EAEAd,EAAA,EAAoBA,EAAAN,EAAaM,IAAA,CAEjC,GAAA7tD,GAAA6tD,EAAAe,EAAAF,CAEArb,GAAAhL,GAAAroC,EACAqzC,EAAAhL,EAAA,IAAApoC,EAEA0rD,EAAAtjB,EAAA,KAEAujB,EAAAkD,GAAAjB,EAAAb,EACApB,EAAAkD,EAAA,KAAAlB,EAAAX,EAEA5kB,GAAA,EACAymB,GAAA,EAMAzmB,EAAA,CAIA,QAFAqjB,GAAA,IAAArY,EAAAxwC,OAAA,QAAAqnD,YAAA3W,aAAAyZ,EAAAC,EAAA,GAEAW,EAAA,EAAmBA,EAAAX,EAAYW,IAE/B,OAAAC,GAAA,EAAoBA,EAAAb,EAAYa,IAAA,CAEhC,GAAA9vC,GAAA8vC,EAAAN,EAAAK,EACA5vC,EAAA6vC,EAAAN,GAAAK,EAAA,GACA/wD,EAAAgxD,EAAA,EAAAN,GAAAK,EAAA,GACAlB,EAAAmB,EAAA,EAAAN,EAAAK,CAEAlC,GAAArjB,GAAAtqB,EACA2tC,EAAArjB,EAAA,GAAArqB,EACA0tC,EAAArjB,EAAA,GAAAqkB,EAEAhB,EAAArjB,EAAA,GAAArqB,EACA0tC,EAAArjB,EAAA,GAAAxrC,EACA6uD,EAAArjB,EAAA,GAAAqkB,EAEArkB,GAAA,EAMA3pC,KAAA6vD,SAAA,GAAArF,IAAAwC,EAAA,IACAhtD,KAAA8vD,aAAA,cAAAtF,IAAA7V,EAAA,IACA30C,KAAA8vD,aAAA,YAAAtF,IAAAyC,EAAA,IACAjtD,KAAA8vD,aAAA,QAAAtF,IAAA0C,EAAA,IAaA,QAAAmD,MAEAjI,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,SAEApE,KAAA44C,mBAAA,GAAAhK,GACA5uC,KAAA84C,iBAAA,GAAAlK,GAiEA,QAAAvtC,IAAAivD,EAAAvtD,EAAAi5C,EAAAC,GAEAoU,GAAApyD,KAAA+B,MAEAA,KAAAoE,KAAA,oBAEApE,KAAAswD,IAAA1pD,SAAA0pD,IAAA,GACAtwD,KAAAi8B,KAAA,EAEAj8B,KAAAg8C,KAAAp1C,SAAAo1C,IAAA,GACAh8C,KAAAi8C,IAAAr1C,SAAAq1C,IAAA,IACAj8C,KAAA2qB,MAAA,GAEA3qB,KAAA+C,OAAA6D,SAAA7D,IAAA,EACA/C,KAAAu3B,KAAA,KAEAv3B,KAAAuwD,UAAA,GACAvwD,KAAAwwD,WAAA,EAEAxwD,KAAAgD,yBAuMA,QAAAytD,IAAAnxD,EAAAoxD,EAAAnxD,EAAAoxD,EAAA3U,EAAAC,GAEAoU,GAAApyD,KAAA+B,MAEAA,KAAAoE,KAAA,qBAEApE,KAAAi8B,KAAA,EACAj8B,KAAAu3B,KAAA,KAEAv3B,KAAAV,OACAU,KAAA0wD,QACA1wD,KAAAT,MACAS,KAAA2wD,SAEA3wD,KAAAg8C,KAAAp1C,SAAAo1C,IAAA,GACAh8C,KAAAi8C,IAAAr1C,SAAAq1C,IAAA,IAEAj8C,KAAAgD,yBAwGA,QAAA4tD,IAAA7gB,EAAAoP,EAAA0R,GAIA,QAAA3xD,GAAAkH,GAEA0qD,EAAA1qD,EAMA,QAAAypD,GAAAlmD,GAEAA,EAAAylC,gBAAAoc,cAAArM,EAAAt1C,IAAA,2BAEAzF,EAAA2rC,EAAAghB,aACAze,EAAA,IAIAluC,EAAA2rC,EAAA0J,eACAnH,EAAA,GAMA,QAAA3vC,GAAAoG,EAAAkpB,GAEA8d,EAAAwJ,aAAAuX,EAAA7+B,EAAA7tB,EAAA2E,EAAAupC,GAEAue,EAAAG,QACAH,EAAAlc,UAAA1iB,EAEA6+B,IAAA/gB,EAAAyJ,YAAAqX,EAAAjc,OAAA3iB,EAAA,GAIA,QAAAg/B,GAAAvP,EAAA34C,EAAAkpB,GAEA,GAAAi/B,GAAA/R,EAAAt1C,IAAA,yBAEA,eAAAqnD,MAEA3gC,SAAA5W,MAAA,mIAKAu3C,EAAAC,2BAAAL,EAAA7+B,EAAA7tB,EAAA2E,EAAAupC,EAAAoP,EAAA0P,mBAEAP,EAAAG,QACAH,EAAAlc,UAAA1iB,EAAAyvB,EAAA0P,uBAEAN,IAAA/gB,EAAAyJ,YAAAqX,EAAAjc,OAAA8M,EAAA0P,kBAAAn/B,EAAA,KArDA,GAAA6+B,GAQA1sD,EAAAkuC,CAiDA,QAEApzC,UACA2wD,WACAltD,SACAsuD,mBAUA,QAAAI,IAAAthB,EAAAoP,EAAA0R,GAIA,QAAA3xD,GAAAkH,GAEA0qD,EAAA1qD,EAIA,QAAAzD,GAAAoG,EAAAkpB,GAEA8d,EAAAuhB,WAAAR,EAAA/nD,EAAAkpB,GAEA4+B,EAAAG,QACAH,EAAAlc,UAAA1iB,EAEA6+B,IAAA/gB,EAAAyJ,YAAAqX,EAAAjc,OAAA3iB,EAAA,GAIA,QAAAg/B,GAAAvP,GAEA,GAAAwP,GAAA/R,EAAAt1C,IAAA,yBAEA,WAAAqnD,EAGA,WADA3gC,SAAA5W,MAAA,iIAKA,IAAAta,GAAAqiD,EAAAh9B,WAAArlB,SAEA4yB,EAAA,CAEA5yB,MAAAkyD,8BAEAt/B,EAAA5yB,EAAA+H,KAAA6qB,MAEAi/B,EAAAM,yBAAAV,EAAA,EAAA7+B,EAAAyvB,EAAA0P,qBAIAn/B,EAAA5yB,EAAA4yB,MAEAi/B,EAAAM,yBAAAV,EAAA,EAAA7+B,EAAAyvB,EAAA0P,oBAIAP,EAAAG,QACAH,EAAAlc,UAAA1iB,EAAAyvB,EAAA0P,kBAEAN,IAAA/gB,EAAAyJ,YAAAqX,EAAAjc,OAAA8M,EAAA0P,kBAAAn/B,EAAA,GAnDA,GAAA6+B,EAuDA,QACA5xD,UACAyD,SACAsuD,mBASA,QAAAQ,MAEA,GAAA7U,KAEA,QAEA/yC,IAAA,SAAAi8C,GAEA,GAAAl/C,SAAAg2C,EAAAkJ,EAAA/nD,IAEA,MAAA6+C,GAAAkJ,EAAA/nD,GAIA,IAAA84C,EAEA,QAAAiP,EAAA1hD,MAEA,uBACAyyC,GACAkR,UAAA,GAAApZ,GACAqI,MAAA,GAAAz2C,GAEAwlD,QAAA,EACA2L,WAAA,EACAC,aAAA,EACAC,cAAA,GAAAhmB,GAEA,MAEA,iBACAiL,GACAx3C,SAAA,GAAAsvC,GACAoZ,UAAA,GAAApZ,GACAqI,MAAA,GAAAz2C,GACAsxD,SAAA,EACAC,QAAA,EACAC,YAAA,EACAC,MAAA,EAEAjM,QAAA,EACA2L,WAAA,EACAC,aAAA,EACAC,cAAA,GAAAhmB,GAEA,MAEA,kBACAiL,GACAx3C,SAAA,GAAAsvC,GACAqI,MAAA,GAAAz2C,GACAsxD,SAAA,EACAG,MAAA,EAEAjM,QAAA,EACA2L,WAAA,EACAC,aAAA,EACAC,cAAA,GAAAhmB,GAEA,MAEA,uBACAiL,GACAkR,UAAA,GAAApZ,GACAsjB,SAAA,GAAA1xD,GACA2xD,YAAA,GAAA3xD,IAQA,MAFAq8C,GAAAkJ,EAAA/nD,IAAA84C,EAEAA,IAYA,QAAAsb,IAAA71C,GAIA,OAFA81C,GAAA91C,EAAA9C,MAAA,MAEA1U,EAAA,EAAkBA,EAAAstD,EAAAjuD,OAAkBW,IAEpCstD,EAAAttD,KAAA,OAAAstD,EAAAttD,EAIA,OAAAstD,GAAA17C,KAAA,MAIA,QAAA27C,IAAAtiB,EAAA3rC,EAAAkY,GAEA,GAAAg6B,GAAAvG,EAAAoH,aAAA/yC,EAoBA,OAlBA2rC,GAAAwH,aAAAjB,EAAAh6B,GACAyzB,EAAAyH,cAAAlB,GAEAvG,EAAAuiB,mBAAAhc,EAAAvG,EAAAwiB,mBAAA,GAEAhiC,QAAA5W,MAAA,+CAIA,KAAAo2B,EAAAyiB,iBAAAlc,IAEA/lB,QAAAC,KAAA,2CAAApsB,IAAA2rC,EAAAsH,cAAA,oBAAAtH,EAAAyiB,iBAAAlc,GAAA6b,GAAA71C,IAOAg6B,EAUA,QAAAmc,IAAApmB,GAEA,OAAAA,GAEA,IAAAmB,IACA,4BACA,KAAAklB,IACA,0BACA,KAAAC,IACA,0BACA,KAAAC,IACA,+BACA,KAAAC,IACA,gCACA,KAAAC,IACA,iCACA,KAAAC,IACA,kDACA,SACA,SAAAzvD,OAAA,yBAAA+oC,IAMA,QAAA2mB,IAAAC,EAAA5mB,GAEA,GAAA6mB,GAAAT,GAAApmB,EACA,eAAA4mB,EAAA,2BAAmDC,EAAA,cAAAA,EAAA,SAInD,QAAAC,IAAAF,EAAA5mB,GAEA,GAAA6mB,GAAAT,GAAApmB,EACA,eAAA4mB,EAAA,mCAAmDC,EAAA,GAAAA,EAAA,SAInD,QAAAE,IAAAH,EAAAI,GAEA,GAAAC,EAEA,QAAAD,GAEA,IAAAE,IACAD,EAAA,QACA,MAEA,KAAAE,IACAF,EAAA,UACA,MAEA,KAAAG,IACAH,EAAA,YACA,MAEA,KAAAI,IACAJ,EAAA,iBACA,MAEA,SACA,SAAAhwD,OAAA,4BAAA+vD,GAIA,cAAAJ,EAAA,2BAAmDK,EAAA,0BAInD,QAAAK,IAAAxU,EAAAT,EAAAkV,GAEAzU,OAEA,IAAA0U,IACA1U,EAAAC,aAAAV,EAAAoV,cAAApV,EAAAqV,SAAArV,EAAAsV,WAAAtV,EAAAuV,YAAA,sDACA9U,EAAAE,WAAAX,EAAAwV,yBAAAN,EAAA/pD,IAAA,6DACAs1C,EAAA,aAAAyU,EAAA/pD,IAAA,qEACAs1C,EAAAI,kBAAAb,EAAAuL,SAAA2J,EAAA/pD,IAAA,6EAGA,OAAAgqD,GAAA1uD,OAAAgvD,IAAAz9C,KAAA,MAIA,QAAA09C,IAAAzV,GAEA,GAAAkV,KAEA,QAAAnsD,KAAAi3C,GAAA,CAEA,GAAAv4C,GAAAu4C,EAAAj3C,EAEAtB,MAAA,GAEAytD,EAAA9nD,KAAA,WAAArE,EAAA,IAAAtB,GAIA,MAAAytD,GAAAn9C,KAAA,MAIA,QAAA29C,IAAAtkB,EAAAiE,EAAAsgB,GAMA,OAJA5vC,MAEAiI,EAAAojB,EAAAkE,oBAAAD,EAAAjE,EAAAwkB,mBAEAzvD,EAAA,EAAkBA,EAAA6nB,EAAO7nB,IAAA,CAEzB,GAAAqvC,GAAApE,EAAAykB,gBAAAxgB,EAAAlvC,GACA4C,EAAAysC,EAAAzsC,IAIAgd,GAAAhd,GAAAqoC,EAAA4G,kBAAA3C,EAAAtsC,GAIA,MAAAgd,GAIA,QAAAyvC,IAAA73C,GAEA,WAAAA,EAIA,QAAAm4C,IAAAn4C,EAAAoiC,GAEA,MAAApiC,GACA3U,QAAA,kBAAA+2C,EAAAgW,cACA/sD,QAAA,mBAAA+2C,EAAAiW,eACAhtD,QAAA,oBAAA+2C,EAAAkW,gBACAjtD,QAAA,mBAAA+2C,EAAAmW,eAIA,QAAAC,IAAAx4C,GAIA,QAAA3U,GAAAhC,EAAAovD,GAEA,GAAAptD,GAAAqtD,GAAAD,EAEA,IAAAnuD,SAAAe,EAEA,SAAArE,OAAA,6BAAAyxD,EAAA,IAIA,OAAAD,IAAAntD,GAZA,GAAA4hB,GAAA,yBAgBA,OAAAjN,GAAA3U,QAAA4hB,EAAA5hB,GAIA,QAAAstD,IAAA34C,GAIA,QAAA3U,GAAAhC,EAAAoD,EAAAC,EAAAksD,GAIA,OAFAC,GAAA,GAEArwD,EAAAu7B,SAAAt3B,GAAmCjE,EAAAu7B,SAAAr3B,GAAqBlE,IAExDqwD,GAAAD,EAAAvtD,QAAA,gBAAA7C,EAAA,KAIA,OAAAqwD,GAZA,GAAA5rC,GAAA,qEAgBA,OAAAjN,GAAA3U,QAAA4hB,EAAA5hB,GAIA,QAAAytD,IAAAj1D,EAAAsD,EAAA44C,EAAAqC,GAEA,GAAA3O,GAAA5vC,EAAA6J,QAEAm1C,EAAA9C,EAAA8C,WACAR,EAAAtC,EAAAsC,QAEApI,EAAA8F,EAAAgZ,cAAA9e,aACAC,EAAA6F,EAAAgZ,cAAA7e,eAEA8e,EAAA,sBAEA5W,GAAA6W,gBAAA9P,GAEA6P,EAAA,qBAEG5W,EAAA6W,gBAAAC,KAEHF,EAAA,0BAIA,IAAAG,GAAA,mBACAC,EAAA,yBACAC,EAAA,0BAEA,IAAAjX,EAAAuL,OAAA,CAEA,OAAA5N,EAAA4N,OAAAne,SAEA,IAAAkD,IACA,IAAA4mB,IACAH,EAAA,kBACA,MAEA,KAAAI,IACA,IAAAC,IACAL,EAAA,qBACA,MAEA,KAAAM,IACA,IAAAC,IACAP,EAAA,qBACA,MAEA,KAAAQ,IACAR,EAAA,qBAKA,OAAApZ,EAAA4N,OAAAne,SAEA,IAAA8pB,IACA,IAAAI,IACAN,EAAA,yBAKA,OAAArZ,EAAA6N,SAEA,IAAAC,IACAwL,EAAA,0BACA,MAEA,KAAAO,IACAP,EAAA,qBACA,MAEA,KAAAQ,IACAR,EAAA,uBAOA,GAcAS,GAAAC,EAdAC,EAAAn2D,EAAAo2D,YAAA,EAAAp2D,EAAAo2D,YAAA,EAMAC,EAAA7C,GAAAxU,EAAAT,EAAAv+C,EAAAg/C,YAEAsX,EAAArC,GAAAzV,GAIA3K,EAAAjE,EAAA0G,eAIA4F,GAAAqa,qBAEAN,GAEAK,EAEA,MAEAtxD,OAAAgvD,IAAAz9C,KAAA,MAEA2/C,GAEAG,EACAC,EAEA,MAEAtxD,OAAAgvD,IAAAz9C,KAAA,QAIA0/C,GAEA,aAAA1X,EAAAT,UAAA,UACA,aAAAS,EAAAT,UAAA,QAEA,uBAAA5B,EAAAgZ,cAAA3tD,KAEA+uD,EAEA/X,EAAAiY,uBAAA,6BAEA,wBAAAL,EAEA,qBAAA5X,EAAAkY,SAEAlY,EAAApvC,IAAA,qBACAovC,EAAAuL,OAAA,wBACAvL,EAAAuL,OAAA,WAAAyL,EAAA,GACAhX,EAAAmY,SAAA,0BACAnY,EAAAoL,MAAA,uBACApL,EAAAoY,YAAA,6BACApY,EAAAqV,QAAA,yBACArV,EAAAsV,UAAA,2BACAtV,EAAAsB,iBAAAtB,EAAAiY,uBAAA,iCACAjY,EAAAsL,YAAA,6BACAtL,EAAAqY,aAAA,8BACArY,EAAAsY,aAAA,8BACAtY,EAAAqB,SAAA,0BACArB,EAAAxB,aAAA,uBAEAwB,EAAAuV,YAAA,yBAEAvV,EAAAM,SAAA,0BACAN,EAAAuY,iBAAA,0BAEAvY,EAAAO,aAAA,8BACAP,EAAAQ,cAAAR,EAAAuV,eAAA,gCACAvV,EAAAwY,YAAA,0BACAxY,EAAAyY,UAAA,wBAEA,+BAAAzY,EAAA0Y,kBAEA1Y,EAAA2Y,iBAAA,2BACA3Y,EAAA2Y,iBAAA,WAAA/B,EAAA,GAEA5W,EAAA4Y,gBAAA,iCAEA5Y,EAAAwV,uBAAA,6BACAxV,EAAAwV,wBAAA/zD,EAAAg/C,WAAAt1C,IAAA,mDAEA,4BACA,gCACA,iCACA,2BACA,6BACA,+BAEA,2BACA,yBACA,qBAEA,mBAEA,0BAEA,SAEA,0BAEA,iCACA,iCACA,iCACA,iCAEA,4BAEA,mCACA,mCACA,mCACA,mCAEA,UAEA,mCACA,mCACA,mCACA,mCAEA,WAEA,SAEA,sBAEA,8BACA,+BAEA,SAEA,MAEA1E,OAAAgvD,IAAAz9C,KAAA,MAEA2/C,GAEAG,EAEA,aAAA9X,EAAAT,UAAA,UACA,aAAAS,EAAAT,UAAA,QAEA,uBAAA5B,EAAAgZ,cAAA3tD,KAEA+uD,EAEA/X,EAAA1D,UAAA,qBAAA0D,EAAA1D,UAAA,GAEA,wBAAAsb,EAEA5X,EAAA6Y,QAAA7Y,EAAA5C,IAAA,qBACA4C,EAAA6Y,QAAA7Y,EAAA8Y,OAAA,sBAEA9Y,EAAApvC,IAAA,qBACAovC,EAAAuL,OAAA,wBACAvL,EAAAuL,OAAA,WAAAwL,EAAA,GACA/W,EAAAuL,OAAA,WAAAyL,EAAA,GACAhX,EAAAuL,OAAA,WAAA0L,EAAA,GACAjX,EAAAmY,SAAA,0BACAnY,EAAAoL,MAAA,uBACApL,EAAAoY,YAAA,6BACApY,EAAAqV,QAAA,yBACArV,EAAAsV,UAAA,2BACAtV,EAAAsL,YAAA,6BACAtL,EAAAqY,aAAA,8BACArY,EAAAsY,aAAA,8BACAtY,EAAAqB,SAAA,0BACArB,EAAAxB,aAAA,uBAEAwB,EAAAuV,YAAA,yBAEAvV,EAAAwY,YAAA,0BACAxY,EAAAyY,UAAA,wBAEA,+BAAAzY,EAAA0Y,kBACA,kCAAA1Y,EAAA0Y,kBAAA1Y,EAAA+Y,qBAEA/Y,EAAA2Y,iBAAA,2BACA3Y,EAAA2Y,iBAAA,WAAA/B,EAAA,GAEA5W,EAAAL,mBAAA,iCAEAK,EAAAgZ,wBAAA,uCAEAhZ,EAAAwV,uBAAA,6BACAxV,EAAAwV,wBAAA/zD,EAAAg/C,WAAAt1C,IAAA,mDAEA60C,EAAAuL,QAAA9pD,EAAAg/C,WAAAt1C,IAAA,uDAEA,2BACA,+BAEA60C,EAAA2U,cAAAsE,GAAA,0BACAjZ,EAAA2U,cAAAsE,GAAA3C,GAAA,6BACAtW,EAAA2U,cAAAsE,GAAAvE,GAAA,cAAA1U,EAAA2U,aAAA,GAEA3U,EAAAkZ,gBAAAlZ,EAAAmZ,aAAAnZ,EAAAoZ,gBAAApZ,EAAAqZ,oBAAA/C,GAAA,2BACAtW,EAAAmZ,YAAA7E,GAAA,mBAAAtU,EAAAmZ,aAAA,GACAnZ,EAAAoZ,eAAA9E,GAAA,sBAAAtU,EAAAoZ,gBAAA,GACApZ,EAAAqZ,oBAAA/E,GAAA,2BAAAtU,EAAAqZ,qBAAA,GACArZ,EAAAkZ,eAAAzE,GAAA,sBAAAzU,EAAAkZ,gBAAA,GAEAlZ,EAAAmB,aAAA,yBAAAxD,EAAAwD,aAAA,GAEA,MAEA16C,OAAAgvD,IAAAz9C,KAAA,OAIA6/B,EAAAue,GAAAve,EAAAmI,GACAnI,EAAAke,GAAAle,EAAAmI,GAEAlI,EAAAse,GAAAte,EAAAkI,GACAlI,EAAAie,GAAAje,EAAAkI,GAEArC,EAAA2b,mBAEAzhB,EAAA0e,GAAA1e,GACAC,EAAAye,GAAAze,GAIA,IAAAyhB,GAAA7B,EAAA7f,EACA2hB,EAAA7B,EAAA7f,EAKA2hB,EAAA9F,GAAAtiB,IAAAsH,cAAA4gB,GACAG,EAAA/F,GAAAtiB,IAAAqH,gBAAA8gB,EAEAnoB,GAAA0H,aAAAzD,EAAAmkB,GACApoB,EAAA0H,aAAAzD,EAAAokB,GAIAxxD,SAAAy1C,EAAAqD,oBAEA3P,EAAAsoB,mBAAArkB,EAAA,EAAAqI,EAAAqD,qBAEGhB,EAAAO,gBAAA,GAGHlP,EAAAsoB,mBAAArkB,EAAA,cAIAjE,EAAA2H,YAAA1D,EAEA,IAAAskB,GAAAvoB,EAAAwoB,kBAAAvkB,GACAwkB,EAAAzoB,EAAAyiB,iBAAA2F,GACAM,EAAA1oB,EAAAyiB,iBAAA4F,GAEAM,GAAA,EACAC,GAAA,CAKA5oB,GAAAkE,oBAAAD,EAAAjE,EAAA6oB,gBAAA,GAEAF,GAAA,EAEAnoC,QAAA5W,MAAA,qCAAAo2B,EAAA8oB,WAAA,qBAAA9oB,EAAAkE,oBAAAD,EAAAjE,EAAA+oB,iBAAA,uBAAAR,EAAAE,EAAAC,IAEG,KAAAH,EAEH/nC,QAAAC,KAAA,6CAAA8nC,GAEG,KAAAE,GAAA,KAAAC,IAEHE,GAAA,GAIAA,IAEA34D,KAAA+4D,aAEAL,WACArc,WAEAic,aAEA/hB,cAEAyiB,IAAAR,EACA3hD,OAAAu/C,GAIA5f,gBAEAwiB,IAAAP,EACA5hD,OAAAw/C,KAUAtmB,EAAAkpB,aAAAd,GACApoB,EAAAkpB,aAAAb,EAIA,IAAAc,EAEAl5D,MAAAm5D,YAAA,WASA,MAPAvyD,UAAAsyD,IAEAA,EACA,GAAAnlB,GAAAhE,EAAAiE,EAAA7zC,IAIA+4D,EAMA,IAAAE,EAyDA,OAvDAp5D,MAAAq5D,cAAA,WAQA,MANAzyD,UAAAwyD,IAEAA,EAAA/E,GAAAtkB,EAAAiE,IAIAolB,GAMAp5D,KAAAs5D,QAAA,WAEAvpB,EAAAwpB,cAAAvlB,GACAh0C,KAAAg0C,QAAAptC,QAMAoT,OAAA6uC,iBAAA7oD,MAEA62C,UACAhtC,IAAA,WAGA,MADA0mB,SAAAC,KAAA,wDACAxwB,KAAAm5D,gBAKAz0C,YACA7a,IAAA,WAGA,MADA0mB,SAAAC,KAAA,4DACAxwB,KAAAq5D,oBAUAr5D,KAAAjC,GAAAy7D,KACAx5D,KAAAyD,OACAzD,KAAAy5D,UAAA,EACAz5D,KAAAg0C,UACAh0C,KAAAu2C,aAAA4hB,EACAn4D,KAAAw2C,eAAA4hB,EAEAp4D,KAQA,QAAA05D,IAAAv5D,EAAAmhD,GA+BA,QAAAqY,GAAAl0D,GAEA,GAAA67C,EAAAsY,qBAAAn0D,KAAAo0D,UAAAp0D,EAAAo0D,SAAA5C,iBAEA,WAWA,IAAA6C,GAAAxY,EAAAyY,kBACAC,EAAAl5D,KAAA4uD,OAAAoK,EAAA,OAEAlD,EAAAoD,CAcA,OAZApzD,UAAAnB,QAAA68C,gBAEAsU,EAAA91D,KAAAC,IAAA0E,EAAAo0D,SAAAI,MAAA91D,OAAAyyD,GAEAA,EAAAnxD,EAAAo0D,SAAAI,MAAA91D,QAEAosB,QAAAC,KAAA,mCAAA/qB,EAAAo0D,SAAAI,MAAA91D,OAAA,4BAAAyyD,EAAA,mCAMAA,EAMA,QAAAsD,GAAA5qD,EAAA6qD,GAEA,GAAA9tB,EAwBA,OAtBA/8B,GAIIA,KAAA8qD,UAEJ/tB,EAAA/8B,EAAA+8B,SAEI/8B,KAAA+qD,sBAEJ9pC,QAAAC,KAAA,6HACA6b,EAAA/8B,EAAAy+B,QAAA1B,UATAA,EAAAmB,GAcAnB,IAAAmB,IAAA2sB,IAEA9tB,EAAA0mB,IAIA1mB,EA7FA,GAAAiuB,MAEAC,GACA3a,kBAAA,QACA4a,mBAAA,SACA3Q,kBAAA,QACA4Q,oBAAA,UACAC,kBAAA,QACAC,qBAAA,WACAC,qBAAA,WACAC,kBAAA,QACAC,mBAAA,SACAC,eAAA,UAGAC,GACA,gGACA,6GACA,8BACA,4DACA,oEACA,4DACA,yDACA,gEACA,2EACA,+FAwEAh7D,MAAAi7D,cAAA,SAAA5e,EAAAO,EAAAd,EAAAof,EAAAC,EAAA11D,GAEA,GAAA21D,GAAAb,EAAAle,EAAAj4C,MAKAwyD,EAAA+C,EAAAl0D,GACAw4C,EAAA99C,EAAAm3C,cAEA,QAAA+E,EAAA4B,YAEAA,EAAAqD,EAAA+Z,gBAAAhf,EAAA4B,WAEAA,IAAA5B,EAAA4B,WAEA1tB,QAAAC,KAAA,oCAAA6rB,EAAA4B,UAAA,uBAAAA,EAAA,YAMA,IAAAqd,GAAAn7D,EAAAo7D,yBAEA7c,GAEA0c,WAEAnd,YACA0Y,uBAAArV,EAAAka,eACA5D,eAAAsC,EAAAoB,IAAAvtB,QAAA,KAAA5tC,EAAAs7D,aACAnsD,MAAA+sC,EAAA/sC,IACAuoD,YAAAqC,EAAA7d,EAAA/sC,IAAAnP,EAAAu7D,YACAzR,SAAA5N,EAAA4N,OACA0R,WAAAtf,EAAA4N,QAAA5N,EAAA4N,OAAAne,QACAgsB,eAAAoC,EAAA7d,EAAA4N,OAAA9pD,EAAAu7D,YACA5H,eAAAzX,EAAA4N,SAAA5N,EAAA4N,OAAAne,UAAA+pB,IAAAxZ,EAAA4N,OAAAne,UAAAgqB,IACAe,WAAAxa,EAAAwa,SACA/M,QAAAzN,EAAAyN,MACAgN,cAAAza,EAAAya,YACAiB,oBAAAmC,EAAA7d,EAAAya,YAAA32D,EAAAu7D,YACA3H,UAAA1X,EAAA0X,QACAC,YAAA3X,EAAA2X,UACAhU,kBAAA3D,EAAA2D,gBACA+W,eAAA1a,EAAA0a,aACAC,eAAA3a,EAAA2a,aACAhN,cAAA3N,EAAA2N,YACAjK,WAAA1D,EAAA0D,SAEAmK,QAAA7N,EAAA6N,QAEAhN,aAAAb,EAAAa,aAEApB,QACAyb,OAAAlb,EAAAP,IACA0b,OAAA1b,KAAAI,UAEA+X,YAAA5X,EAAAW,UAAA4e,GAEAtE,gBAAAjb,EAAAib,gBACApD,uBAAA5S,EAAA4S,uBAEAlV,SAAA3C,EAAA2C,SACA4X,WACAK,iBAAA3V,EAAAsY,qBAAAn0D,KAAAo0D,UAAAp0D,EAAAo0D,SAAA5C,iBAEAhY,aAAA5C,EAAA4C,aACAC,aAAA7C,EAAA6C,aACA2c,gBAAA17D,EAAA07D,gBACAC,gBAAA37D,EAAA27D,gBAEApH,aAAA9X,EAAAmf,YAAA53D,OACAywD,eAAAhY,EAAAof,MAAA73D,OACAwwD,cAAA/X,EAAAqf,KAAA93D,OACA0wD,cAAAjY,EAAAsf,KAAA/3D,OAEAizD,kBAAA8D,EACAzD,oBAAA0D,EAEA9D,iBAAAl3D,EAAAQ,UAAAC,SAAA6E,EAAAyjD,eAAAtM,EAAAyH,QAAAlgD,OAAA,EACAoxD,cAAAp1D,EAAAQ,UAAAyD,KAEAivD,YAAAlzD,EAAAkzD,YACAqE,wBAAAv3D,EAAAu3D,wBAEArZ,mBAAAhC,EAAAgC,mBAEArD,UAAAqB,EAAArB,UACAkc,YAAA7a,EAAAS,OAAAoG,GACAiU,UAAA9a,EAAAS,OAAAsG,GAEAvD,aAAAj5C,SAAAy1C,EAAAwD,cAAAxD,EAAAwD,aAIA,OAAAnB,IAIA1+C,KAAAm8D,eAAA,SAAA9f,EAAAqC,GAEA,GAAAtP,KAaA,IAXAsP,EAAA0c,SAEAhsB,EAAArjC,KAAA2yC,EAAA0c,WAIAhsB,EAAArjC,KAAAswC,EAAA7F,gBACApH,EAAArjC,KAAAswC,EAAA9F,eAIA3vC,SAAAy1C,EAAAsC,QAEA,OAAAj3C,KAAA20C,GAAAsC,QAEAvP,EAAArjC,KAAArE,GACA0nC,EAAArjC,KAAAswC,EAAAsC,QAAAj3C,GAMA,QAAA5C,GAAA,EAAmBA,EAAAk2D,EAAA72D,OAA2BW,IAE9CsqC,EAAArjC,KAAA2yC,EAAAsc,EAAAl2D,IAIA,OAAAsqC,GAAA14B,QAIA1W,KAAAo8D,eAAA,SAAA/f,EAAAqC,EAAAj7C,GAKA,OAHAuwC,GAGA51C,EAAA,EAAAi+D,EAAA/B,EAAAn2D,OAAyC/F,EAAAi+D,EAAQj+D,IAAA,CAEjD,GAAAk+D,GAAAhC,EAAAl8D,EAEA,IAAAk+D,EAAA74D,SAAA,CAEAuwC,EAAAsoB,IACAtoB,EAAAylB,SAEA,QAaA,MAPA7yD,UAAAotC,IAEAA,EAAA,GAAAohB,IAAAj1D,EAAAsD,EAAA44C,EAAAqC,GACA4b,EAAAvuD,KAAAioC,IAIAA,GAIAh0C,KAAAu8D,eAAA,SAAAvoB,GAEA,SAAAA,EAAAylB,UAAA,CAGA,GAAA30D,GAAAw1D,EAAAt1D,QAAAgvC,EACAsmB,GAAAx1D,GAAAw1D,IAAAn2D,OAAA,GACAm2D,EAAA72C,MAGAuwB,EAAAslB,YAOAt5D,KAAAs6D,WAQA,QAAAkC,IAAAzsB,EAAA/6B,EAAAm/B,GAIA,QAAAsoB,GAAA5vD,GAEA,GAAA60C,GAAA70C,EAAAoL,OACAykD,EAAAC,EAAAjb,EAAA3jD,GAEA,QAAA2+D,EAAA/yD,OAEAizD,EAAAF,EAAA/yD,OAIAkzD,EAAAH,EAAAh4C,YAEAg9B,EAAA56C,oBAAA,UAAA21D,SAEAE,GAAAjb,EAAA3jD,GAIA,IAAA++D,GAAA9nD,EAAAnL,IAAA63C,EAEAob,GAAAje,WAEA+d,EAAAE,EAAAje,WAIA7pC,EAAA+nD,OAAArb,EAEA,IAAAsb,GAAAhoD,EAAAnL,IAAA6yD,EAEAM,GAAAne,WAEA+d,EAAAI,EAAAne,WAIA7pC,EAAA+nD,OAAAL,GAIAvoB,EAAAnmB,OAAA2uC,aAIA,QAAAM,GAAAC,GAEA,MAAAA,GAAA3L,6BAEAv8C,EAAAnL,IAAAqzD,EAAA91D,MAAA+1D,cAIAnoD,EAAAnL,IAAAqzD,GAAAC,cAIA,QAAAP,GAAAM,GAEA,GAAAE,GAAAH,EAAAC,EAEAt2D,UAAAw2D,IAEArtB,EAAAstB,aAAAD,GACAE,EAAAJ,IAMA,QAAAL,GAAAn4C,GAEA,OAAAhd,KAAAgd,GAEAk4C,EAAAl4C,EAAAhd,IAMA,QAAA41D,GAAAJ,GAEAA,EAAA3L,6BAEAv8C,EAAA+nD,OAAAG,EAAA91D,MAIA4N,EAAA+nD,OAAAG,GA1FA,GAAAP,KAgGA,QAEA9yD,IAAA,SAAApE,GAEA,GAAAi8C,GAAAj8C,EAAAi8C,QAEA,IAAA96C,SAAA+1D,EAAAjb,EAAA3jD,IAEA,MAAA4+D,GAAAjb,EAAA3jD,GAIA2jD,GAAA56B,iBAAA,UAAA21C,EAEA,IAAAC,EAsBA,OApBAhb,GAAAQ,iBAEAwa,EAAAhb,EAEKA,EAAAU,aAELx7C,SAAA86C,EAAA6b,kBAEA7b,EAAA6b,iBAAA,GAAAnQ,KAAAoQ,cAAA/3D,IAIAi3D,EAAAhb,EAAA6b,iBAIAZ,EAAAjb,EAAA3jD,IAAA2+D,EAEAvoB,EAAAnmB,OAAA2uC,aAEAD,IAYA,QAAAe,IAAA1tB,EAAA/6B,EAAAm/B,GAMA,QAAAhyC,GAAAsD,GAIA,GAAAi8C,GAAAib,EAAA9yD,IAAApE,EAEAA,GAAAi8C,SAAAU,YAEAV,EAAAgc,iBAAAj4D,EAIA,IAAAkE,GAAA+3C,EAAA/3C,MACA+a,EAAAg9B,EAAAh9B,UAEA,QAAA/a,GAEAg0D,EAAAh0D,EAAAomC,EAAAsF,qBAIA,QAAA3tC,KAAAgd,GAEAi5C,EAAAj5C,EAAAhd,GAAAqoC,EAAAmF,aAMA,IAAAiN,GAAAT,EAAAS,eAEA,QAAAz6C,KAAAy6C,GAIA,OAFA/S,GAAA+S,EAAAz6C,GAEA5C,EAAA,EAAA2F,EAAA2kC,EAAAjrC,OAAsCW,EAAA2F,EAAO3F,IAE7C64D,EAAAvuB,EAAAtqC,GAAAirC,EAAAmF,aAMA,OAAAwM,GAIA,QAAAic,GAAAT,EAAAU,GAEA,GAAAx2D,GAAA81D,EAAA,6BAAAA,EAAA91D,KAAA81D,EAEAW,EAAA7oD,EAAAnL,IAAAzC,EAEAR,UAAAi3D,EAAAV,cAEApoB,EAAA8oB,EAAAz2D,EAAAw2D,GAEIC,EAAArjD,UAAApT,EAAAoT,SAEJsjD,EAAAD,EAAAz2D,EAAAw2D,GAMA,QAAA7oB,GAAA8oB,EAAAz2D,EAAAw2D,GAEAC,EAAAV,cAAAptB,EAAAgF,eACAhF,EAAAkF,WAAA2oB,EAAAC,EAAAV,cAEA,IAAAY,GAAA32D,EAAAujD,QAAA5a,EAAAiuB,aAAAjuB,EAAAqF,WAEArF,GAAAoF,WAAAyoB,EAAAx2D,EAAAgoC,MAAA2uB,GAEAF,EAAArjD,QAAApT,EAAAoT,QAIA,QAAAsjD,GAAAD,EAAAz2D,EAAAw2D,GAEA7tB,EAAAkF,WAAA2oB,EAAAC,EAAAV,eAEA/1D,EAAAujD,WAAA,EAEA5a,EAAAoF,WAAAyoB,EAAAx2D,EAAAgoC,MAAAW,EAAAqF,aAEIhuC,EAAAwjD,YAAA34B,SAAA,EAIJ8d,EAAAkuB,cAAAL,EAAA,EAAAx2D,EAAAgoC,OAEI,IAAAhoC,EAAAwjD,YAAA34B,MAEJ1B,QAAA5W,MAAA,4KAIAo2B,EAAAkuB,cAAAL,EAAAx2D,EAAAwjD,YAAAjhB,OAAAviC,EAAAgoC,MAAA8uB,kBACA92D,EAAAgoC,MAAA+uB,SAAA/2D,EAAAwjD,YAAAjhB,OAAAviC,EAAAwjD,YAAAjhB,OAAAviC,EAAAwjD,YAAA34B,QAEA7qB,EAAAwjD,YAAA34B,MAAA,GAIA4rC,EAAArjD,QAAApT,EAAAoT,QAIA,QAAAyiD,GAAAC,GAEA,MAAAA,GAAA3L,6BAEAv8C,EAAAnL,IAAAqzD,EAAA91D,MAAA+1D,cAIAnoD,EAAAnL,IAAAqzD,GAAAC,cAIA,QAAAiB,GAAA1c,GAEA,GAAAob,GAAA9nD,EAAAnL,IAAA63C,EAEA,IAAA96C,SAAAk2D,EAAAje,UAEA,MAAAie,GAAAje,SAIA,IAAAmO,MAEArjD,EAAA+3C,EAAA/3C,MACA+a,EAAAg9B,EAAAh9B,WACArlB,EAAAqlB,EAAArlB,QAIA,WAAAsK,EAKA,OAFAylC,GAAAzlC,EAAAylC,MAEAtqC,EAAA,EAAA2F,EAAA2kC,EAAAjrC,OAAsCW,EAAA2F,EAAO3F,GAAA,GAE7C,GAAAua,GAAA+vB,EAAAtqC,EAAA,GACAwa,EAAA8vB,EAAAtqC,EAAA,GACA3G,EAAAixC,EAAAtqC,EAAA,EAEAkoD,GAAAjhD,KAAAsT,EAAAC,IAAAnhB,IAAAkhB,OAQA,QAFA+vB,GAAA1qB,EAAArlB,SAAA+vC,MAEAtqC,EAAA,EAAA2F,EAAA2kC,EAAAjrC,OAAA,IAAkDW,EAAA2F,EAAO3F,GAAA,GAEzD,GAAAua,GAAAva,EAAA,EACAwa,EAAAxa,EAAA,EACA3G,EAAA2G,EAAA,CAEAkoD,GAAAjhD,KAAAsT,EAAAC,IAAAnhB,IAAAkhB,GAQA,GAAAg/C,GAAAh/D,EAAA4yB,MAAA,MAAAu5B,YAAA3W,YACAqoB,EAAA,GAAA1S,IAAA,GAAA6T,GAAArR,GAAA,EAMA,OAJA2Q,GAAAT,EAAAntB,EAAAsF,sBAEAynB,EAAAje,UAAAqe,EAEAA,EAvLA,GAAAP,GAAA,GAAAH,IAAAzsB,EAAA/6B,EAAAm/B,EA2LA,QAEA8oB,qBACAmB,wBAEAj8D,UAUA,QAAAm8D,IAAAra,EAAA9E,EAAAzlC,EAAA1E,EAAAssC,EAAAid,EAAApqB,GAOA,QAAAqqB,GAAA9yC,EAAA+yC,GAEA,GAAA/yC,EAAA7oB,MAAA47D,GAAA/yC,EAAA5oB,OAAA27D,EAAA,CAKA,GAAAp2D,GAAAo2D,EAAA39D,KAAAoQ,IAAAwa,EAAA7oB,MAAA6oB,EAAA5oB,QAEAm4C,EAAAz7C,SAAA07C,gBAAA,wCACAD,GAAAp4C,MAAA/B,KAAA4uD,MAAAhkC,EAAA7oB,MAAAwF,GACA4yC,EAAAn4C,OAAAhC,KAAA4uD,MAAAhkC,EAAA5oB,OAAAuF,EAEA,IAAA2B,GAAAixC,EAAAE,WAAA,KAKA,OAJAnxC,GAAA00D,UAAAhzC,EAAA,IAAAA,EAAA7oB,MAAA6oB,EAAA5oB,OAAA,IAAAm4C,EAAAp4C,MAAAo4C,EAAAn4C,QAEAytB,QAAAC,KAAA,0CAAA9E,EAAA7oB,MAAA,IAAA6oB,EAAA5oB,OAAA,iBAAAm4C,EAAAp4C,MAAA,IAAAo4C,EAAAn4C,OAAA4oB,GAEAuvB,EAIA,MAAAvvB,GAIA,QAAAizC,GAAAjzC,GAEA,MAAA8gB,IAAAmyB,aAAAjzC,EAAA7oB,QAAA2pC,GAAAmyB,aAAAjzC,EAAA5oB,QAIA,QAAA87D,GAAAlzC,GAEA,GAAAA,YAAAmzC,mBAAAnzC,YAAAozC,mBAAA,CAEA,GAAA7jB,GAAAz7C,SAAA07C,gBAAA,wCACAD,GAAAp4C,MAAA2pC,GAAAuyB,kBAAArzC,EAAA7oB,OACAo4C,EAAAn4C,OAAA0pC,GAAAuyB,kBAAArzC,EAAA5oB,OAEA,IAAAkH,GAAAixC,EAAAE,WAAA,KAKA,OAJAnxC,GAAA00D,UAAAhzC,EAAA,IAAAuvB,EAAAp4C,MAAAo4C,EAAAn4C,QAEAytB,QAAAC,KAAA,mDAAA9E,EAAA7oB,MAAA,IAAA6oB,EAAA5oB,OAAA,iBAAAm4C,EAAAp4C,MAAA,IAAAo4C,EAAAn4C,OAAA4oB,GAEAuvB,EAIA,MAAAvvB,GAIA,QAAAszC,GAAAjxB,GAEA,MAAAA,GAAAhC,QAAAe,IAAAiB,EAAA/B,QAAAc,IACAiB,EAAA7B,YAAAka,IAAArY,EAAA7B,YAAAa,GAQA,QAAAkyB,GAAAC,GAEA,MAAAA,KAAA9Y,IAAA8Y,IAAAC,IAAAD,IAAAE,GAEAnb,EAAA9N,QAIA8N,EAAAob,OAMA,QAAAC,GAAAzyD,GAEA,GAAAkhC,GAAAlhC,EAAAoL,MAEA81B,GAAAjnC,oBAAA,UAAAw4D,GAEAC,EAAAxxB,GAEAyxB,EAAAC,WAKA,QAAAC,GAAA7yD,GAEA,GAAA8yD,GAAA9yD,EAAAoL,MAEA0nD,GAAA74D,oBAAA,UAAA44D,GAEAE,EAAAD,GAEAH,EAAAC,WAMA,QAAAF,GAAAxxB,GAEA,GAAA8xB,GAAA7qD,EAAAnL,IAAAkkC,EAEA,IAAAA,EAAAriB,OAAAm0C,EAAAC,0BAIA7b,EAAA8b,cAAAF,EAAAC,+BAEI,CAIJ,GAAAl5D,SAAAi5D,EAAAG,YAAA,MAEA/b,GAAA8b,cAAAF,EAAAI,gBAKAjrD,EAAA+nD,OAAAhvB,GAIA,QAAA6xB,GAAAD,GAEA,GAAAO,GAAAlrD,EAAAnL,IAAA81D,GACAE,EAAA7qD,EAAAnL,IAAA81D,EAAA5xB,QAEA,IAAA4xB,EAAA,CAcA,GAZA/4D,SAAAi5D,EAAAI,gBAEAhc,EAAA8b,cAAAF,EAAAI,gBAIAN,EAAAzxB,cAEAyxB,EAAAzxB,aAAAiyB,UAIAR,KAAAS,wBAEA,OAAAt7D,GAAA,EAAoBA,EAAA,EAAOA,IAE3Bm/C,EAAAoc,kBAAAH,EAAAI,mBAAAx7D,IACAo7D,EAAAK,oBAAAtc,EAAAuc,mBAAAN,EAAAK,mBAAAz7D,QAMAm/C,GAAAoc,kBAAAH,EAAAI,oBACAJ,EAAAK,oBAAAtc,EAAAuc,mBAAAN,EAAAK,mBAIAvrD,GAAA+nD,OAAA4C,EAAA5xB,SACA/4B,EAAA+nD,OAAA4C,IAQA,QAAAtuB,GAAAtD,EAAA0yB,GAEA,GAAAZ,GAAA7qD,EAAAnL,IAAAkkC,EAEA,IAAAA,EAAAvzB,QAAA,GAAAqlD,EAAAa,YAAA3yB,EAAAvzB,QAAA,CAEA,GAAAkR,GAAAqiB,EAAAriB,KAEA,IAAA9kB,SAAA8kB,EAEA6E,QAAAC,KAAA,wEAAAud,OAEK,IAAAriB,EAAAnV,YAAA,EAOL,WADAoqD,GAAAd,EAAA9xB,EAAA0yB,EAJAlwC,SAAAC,KAAA,yEAAAud,IAWAr0B,EAAAs/B,cAAAiL,EAAAhL,SAAAwnB,GACA/mD,EAAA+7B,YAAAwO,EAAAvO,WAAAmqB,EAAAI,gBAIA,QAAAzuB,GAAAzD,EAAA0yB,GAEA,GAAAZ,GAAA7qD,EAAAnL,IAAAkkC,EAEA,QAAAA,EAAAriB,MAAAvnB,OAEA,GAAA4pC,EAAAvzB,QAAA,GAAAqlD,EAAAa,YAAA3yB,EAAAvzB,QAAA,CAEAqlD,EAAAC,4BAEA/xB,EAAAjnB,iBAAA,UAAAw4C,GAEAO,EAAAC,0BAAA7b,EAAA1O,gBAEAiqB,EAAAC,YAIA/lD,EAAAs/B,cAAAiL,EAAAhL,SAAAwnB,GACA/mD,EAAA+7B,YAAAwO,EAAA2c,iBAAAf,EAAAC,2BAEA7b,EAAA4c,YAAA5c,EAAA6c,oBAAA/yB,EAAAT,MAOA,QALAyzB,GAAAhzB,KAAAizB,oBACAC,EAAAlzB,EAAAriB,MAAA,IAAAqiB,EAAAriB,MAAA,GAAAu1C,cAEAC,KAEAp8D,EAAA,EAAqBA,EAAA,EAAOA,IAE5Bi8D,GAAAE,EAMAC,EAAAp8D,GAAAm8D,EAAAlzB,EAAAriB,MAAA5mB,GAAA4mB,MAAAqiB,EAAAriB,MAAA5mB,GAJAo8D,EAAAp8D,GAAA05D,EAAAzwB,EAAAriB,MAAA5mB,GAAAw8C,EAAA6f,eAUA,IAAAz1C,GAAAw1C,EAAA,GACAE,EAAAzC,EAAAjzC,GACA21C,EAAA9C,EAAAxwB,EAAA5B,QACAm1B,EAAA/C,EAAAxwB,EAAA3pC,KAEAm9D,GAAAtd,EAAA2c,iBAAA7yB,EAAAqzB,EAEA,QAAAt8D,GAAA,EAAqBA,EAAA,EAAOA,IAE5B,GAAAi8D,EAgBA,OAFAS,GAAA50B,EAAAs0B,EAAAp8D,GAAA8nC,QAEA3hC,EAAA,EAAA4uC,EAAAjN,EAAAzoC,OAA4C8G,EAAA4uC,EAAQ5uC,IAEpDu2D,EAAA50B,EAAA3hC,GAEA8iC,EAAA5B,SAAAc,IAAAc,EAAA5B,SAAAs1B,GAEA/nD,EAAAgoD,8BAAA18D,QAAAq8D,IAAA,EAEA3nD,EAAAioD,qBAAA1d,EAAA2d,4BAAA98D,EAAAmG,EAAAo2D,EAAAG,EAAA3+D,MAAA2+D,EAAA1+D,OAAA,EAAA0+D,EAAAp6D,MAIAmpB,QAAAC,KAAA,mGAMA9W,EAAAi8B,WAAAsO,EAAA2d,4BAAA98D,EAAAmG,EAAAo2D,EAAAG,EAAA3+D,MAAA2+D,EAAA1+D,OAAA,EAAAu+D,EAAAC,EAAAE,EAAAp6D,UAhCA65D,GAEAvnD,EAAAi8B,WAAAsO,EAAA2d,4BAAA98D,EAAA,EAAAu8D,EAAAH,EAAAp8D,GAAAjC,MAAAq+D,EAAAp8D,GAAAhC,OAAA,EAAAu+D,EAAAC,EAAAJ,EAAAp8D,GAAAsC,MAIAsS,EAAAi8B,WAAAsO,EAAA2d,4BAAA98D,EAAA,EAAAu8D,IAAAC,EAAAJ,EAAAp8D,GAoCAipC,GAAAX,iBAAAg0B,GAEAnd,EAAA4d,eAAA5d,EAAA2c,kBAIAf,EAAAa,UAAA3yB,EAAAvzB,QAEAuzB,EAAAN,UAAAM,EAAAN,SAAAM,OAIAr0B,GAAAs/B,cAAAiL,EAAAhL,SAAAwnB,GACA/mD,EAAA+7B,YAAAwO,EAAA2c,iBAAAf,EAAAC,2BAQA,QAAAgC,GAAA/zB,EAAA0yB,GAEA/mD,EAAAs/B,cAAAiL,EAAAhL,SAAAwnB,GACA/mD,EAAA+7B,YAAAwO,EAAA2c,iBAAA5rD,EAAAnL,IAAAkkC,GAAAkyB,gBAIA,QAAAsB,GAAAQ,EAAAh0B,EAAAqzB,GAEA,GAAAlQ,EAkCA,IAhCAkQ,GAEAnd,EAAAnO,cAAAisB,EAAA9d,EAAAlO,eAAAwoB,EAAAxwB,EAAAhC,QACAkY,EAAAnO,cAAAisB,EAAA9d,EAAAhO,eAAAsoB,EAAAxwB,EAAA/B,QAEAiY,EAAAnO,cAAAisB,EAAA9d,EAAA/N,mBAAAqoB,EAAAxwB,EAAA9B,YACAgY,EAAAnO,cAAAisB,EAAA9d,EAAA7N,mBAAAmoB,EAAAxwB,EAAA7B,cAIA+X,EAAAnO,cAAAisB,EAAA9d,EAAAlO,eAAAkO,EAAAjO,eACAiO,EAAAnO,cAAAisB,EAAA9d,EAAAhO,eAAAgO,EAAAjO,eAEAjI,EAAAhC,QAAAe,IAAAiB,EAAA/B,QAAAc,IAEAvc,QAAAC,KAAA,gIAAAud,GAIAkW,EAAAnO,cAAAisB,EAAA9d,EAAA/N,mBAAA+oB,EAAAlxB,EAAA9B,YACAgY,EAAAnO,cAAAisB,EAAA9d,EAAA7N,mBAAA6oB,EAAAlxB,EAAA7B,YAEA6B,EAAA7B,YAAAka,IAAArY,EAAA7B,YAAAa,IAEAxc,QAAAC,KAAA,kIAAAud,IAMAmjB,EAAA/R,EAAAt1C,IAAA,kCAEA,CAEA,GAAAkkC,EAAA3pC,OAAA49D,IAAA,OAAA7iB,EAAAt1C,IAAA,kCACA,IAAAkkC,EAAA3pC,OAAA69D,IAAA,OAAA9iB,EAAAt1C,IAAA,yCAEAkkC,EAAA3B,WAAA,GAAAp3B,EAAAnL,IAAAkkC,GAAAm0B,uBAEAje,EAAAke,cAAAJ,EAAA7Q,EAAAkR,2BAAAthE,KAAAC,IAAAgtC,EAAA3B,WAAAkV,EAAA+gB,qBACArtD,EAAAnL,IAAAkkC,GAAAm0B,oBAAAn0B,EAAA3B,aAQA,QAAAu0B,GAAAd,EAAA9xB,EAAA0yB,GAEA75D,SAAAi5D,EAAAG,cAEAH,EAAAG,aAAA,EAEAjyB,EAAAjnB,iBAAA,UAAAw4C,GAEAO,EAAAI,eAAAhc,EAAA1O,gBAEAiqB,EAAAC,YAIA/lD,EAAAs/B,cAAAiL,EAAAhL,SAAAwnB,GACA/mD,EAAA+7B,YAAAwO,EAAAvO,WAAAmqB,EAAAI,gBAEAhc,EAAA4c,YAAA5c,EAAA6c,oBAAA/yB,EAAAT,OACA2W,EAAA4c,YAAA5c,EAAAqe,+BAAAv0B,EAAAV,kBACA4W,EAAA4c,YAAA5c,EAAAse,iBAAAx0B,EAAAR,gBAEA,IAAA7hB,GAAA8yC,EAAAzwB,EAAAriB,MAAA41B,EAAAkD,eAEAwa,GAAAjxB,IAAA4wB,EAAAjzC,MAAA,IAEAA,EAAAkzC,EAAAlzC,GAIA,IAAA01C,GAAAzC,EAAAjzC,GACA21C,EAAA9C,EAAAxwB,EAAA5B,QACAm1B,EAAA/C,EAAAxwB,EAAA3pC,KAEAm9D,GAAAtd,EAAAvO,WAAA3H,EAAAqzB,EAEA,IAAAI,GAAA50B,EAAAmB,EAAAnB,OAEA,IAAAmB,KAAAy0B,eAAA,CAIA,GAAAC,GAAAxe,EAAAye,eAEA,IAAA30B,EAAA3pC,OAAA49D,GAAA,CAEA,IAAAW,EAAA,SAAAr/D,OAAA,iDACAm/D,GAAAxe,EAAA2e,uBAEKD,KAGLF,EAAAxe,EAAA4e,kBAMA90B,GAAA5B,SAAA22B,KAEAL,EAAAxe,EAAA8e,eAIArpD,EAAAi8B,WAAAsO,EAAAvO,WAAA,EAAA+sB,EAAA/2C,EAAA7oB,MAAA6oB,EAAA5oB,OAAA,EAAAu+D,EAAAC,EAAA,UAEI,IAAAvzB,KAAAkzB,cAMJ,GAAAr0B,EAAAzoC,OAAA,GAAAi9D,EAAA,CAEA,OAAAt8D,GAAA,EAAA+gD,EAAAjZ,EAAAzoC,OAA0CW,EAAA+gD,EAAQ/gD,IAElD08D,EAAA50B,EAAA9nC,GACA4U,EAAAi8B,WAAAsO,EAAAvO,WAAA5wC,EAAAu8D,EAAAG,EAAA3+D,MAAA2+D,EAAA1+D,OAAA,EAAAu+D,EAAAC,EAAAE,EAAAp6D,KAIA2mC,GAAAX,iBAAA,MAIA1zB,GAAAi8B,WAAAsO,EAAAvO,WAAA,EAAA2rB,EAAA31C,EAAA7oB,MAAA6oB,EAAA5oB,OAAA,EAAAu+D,EAAAC,EAAA51C,EAAAtkB,UAII,IAAA2mC,KAAAizB,oBAEJ,OAAAl8D,GAAA,EAAA+gD,EAAAjZ,EAAAzoC,OAAyCW,EAAA+gD,EAAQ/gD,IAEjD08D,EAAA50B,EAAA9nC,GAEAipC,EAAA5B,SAAAc,IAAAc,EAAA5B,SAAAs1B,GAEA/nD,EAAAgoD,8BAAA18D,QAAAq8D,IAAA,EAEA3nD,EAAAioD,qBAAA1d,EAAAvO,WAAA5wC,EAAAu8D,EAAAG,EAAA3+D,MAAA2+D,EAAA1+D,OAAA,EAAA0+D,EAAAp6D,MAIAmpB,QAAAC,KAAA,kGAMA9W,EAAAi8B,WAAAsO,EAAAvO,WAAA5wC,EAAAu8D,EAAAG,EAAA3+D,MAAA2+D,EAAA1+D,OAAA,EAAAu+D,EAAAC,EAAAE,EAAAp6D,UAcA,IAAAwlC,EAAAzoC,OAAA,GAAAi9D,EAAA,CAEA,OAAAt8D,GAAA,EAAA+gD,EAAAjZ,EAAAzoC,OAA0CW,EAAA+gD,EAAQ/gD,IAElD08D,EAAA50B,EAAA9nC,GACA4U,EAAAi8B,WAAAsO,EAAAvO,WAAA5wC,EAAAu8D,IAAAC,EAAAE,EAIAzzB,GAAAX,iBAAA,MAIA1zB,GAAAi8B,WAAAsO,EAAAvO,WAAA,EAAA2rB,IAAAC,EAAA51C,EAMAqiB,GAAAX,iBAAAg0B,GAAAnd,EAAA4d,eAAA5d,EAAAvO,YAEAmqB,EAAAa,UAAA3yB,EAAAvzB,QAEAuzB,EAAAN,UAAAM,EAAAN,SAAAM,GAOA,QAAAi1B,GAAAC,EAAAtD,EAAAuD,EAAAC,GAEA,GAAA9B,GAAA9C,EAAAoB,EAAA5xB,QAAA5B,QACAm1B,EAAA/C,EAAAoB,EAAA5xB,QAAA3pC,KACAsV,GAAAi8B,WAAAwtB,EAAA,EAAA9B,EAAA1B,EAAA98D,MAAA88D,EAAA78D,OAAA,EAAAu+D,EAAAC,EAAA,MACArd,EAAAmf,gBAAAnf,EAAAof,YAAAJ,GACAhf,EAAAqf,qBAAArf,EAAAof,YAAAH,EAAAC,EAAAnuD,EAAAnL,IAAA81D,EAAA5xB,SAAAkyB,eAAA,GACAhc,EAAAmf,gBAAAnf,EAAAof,YAAA,MAKA,QAAAE,GAAAC,EAAA7D,GAEA1b,EAAAwf,iBAAAxf,EAAAyf,aAAAF,GAEA7D,EAAA3xB,cAAA2xB,EAAA1xB,eAEAgW,EAAA0f,oBAAA1f,EAAAyf,aAAAzf,EAAA4e,kBAAAlD,EAAA98D,MAAA88D,EAAA78D,QACAmhD,EAAA2f,wBAAA3f,EAAAof,YAAApf,EAAA4f,iBAAA5f,EAAAyf,aAAAF,IAEI7D,EAAA3xB,aAAA2xB,EAAA1xB,eAEJgW,EAAA0f,oBAAA1f,EAAAyf,aAAAzf,EAAA8e,cAAApD,EAAA98D,MAAA88D,EAAA78D,QACAmhD,EAAA2f,wBAAA3f,EAAAof,YAAApf,EAAA6f,yBAAA7f,EAAAyf,aAAAF,IAKAvf,EAAA0f,oBAAA1f,EAAAyf,aAAAzf,EAAA8f,MAAApE,EAAA98D,MAAA88D,EAAA78D,QAIAmhD,EAAAwf,iBAAAxf,EAAAyf,aAAA,MAKA,QAAAM,GAAAf,EAAAtD,GAEA,GAAAsE,GAAAtE,KAAAS,uBACA,IAAA6D,EAAA,SAAA3gE,OAAA,2DAIA,IAFA2gD,EAAAmf,gBAAAnf,EAAAof,YAAAJ,IAEAtD,EAAAzxB,eAAAyxB,EAAAzxB,aAAAs0B,eAEA,SAAAl/D,OAAA,sEAKA0R,GAAAnL,IAAA81D,EAAAzxB,cAAA+xB,gBACAN,EAAAzxB,aAAAxiB,MAAA7oB,QAAA88D,EAAA98D,OACA88D,EAAAzxB,aAAAxiB,MAAA5oB,SAAA68D,EAAA78D,SACA68D,EAAAzxB,aAAAxiB,MAAA7oB,MAAA88D,EAAA98D,MACA88D,EAAAzxB,aAAAxiB,MAAA5oB,OAAA68D,EAAA78D,OACA68D,EAAAzxB,aAAAoN,aAAA,GAGAjK,EAAAsuB,EAAAzxB,aAAA,EAEA,IAAAg2B,GAAAlvD,EAAAnL,IAAA81D,EAAAzxB,cAAA+xB,cAEA,IAAAN,EAAAzxB,aAAA/B,SAAAg4B,GAEAlgB,EAAAqf,qBAAArf,EAAAof,YAAApf,EAAA4f,iBAAA5f,EAAAvO,WAAAwuB,EAAA,OAEI,IAAAvE,EAAAzxB,aAAA/B,SAAA22B,GAMJ,SAAAx/D,OAAA,8BAJA2gD,GAAAqf,qBAAArf,EAAAof,YAAApf,EAAA6f,yBAAA7f,EAAAvO,WAAAwuB,EAAA,IAWA,QAAAE,GAAAzE,GAEA,GAAAO,GAAAlrD,EAAAnL,IAAA81D,GAEAsE,EAAAtE,KAAAS,uBAEA,IAAAT,EAAAzxB,aAAA,CAEA,GAAA+1B,EAAA,SAAA3gE,OAAA,2DAEA0gE,GAAA9D,EAAAI,mBAAAX,OAIA,IAAAsE,EAAA,CAEA/D,EAAAK,qBAEA,QAAAz7D,GAAA,EAAqBA,EAAA,EAAOA,IAE5Bm/C,EAAAmf,gBAAAnf,EAAAof,YAAAnD,EAAAI,mBAAAx7D;AACAo7D,EAAAK,mBAAAz7D,GAAAm/C,EAAAogB,qBACAd,EAAArD,EAAAK,mBAAAz7D,GAAA66D,OAMA1b,GAAAmf,gBAAAnf,EAAAof,YAAAnD,EAAAI,oBACAJ,EAAAK,mBAAAtc,EAAAogB,qBACAd,EAAArD,EAAAK,mBAAAZ,EAMA1b,GAAAmf,gBAAAnf,EAAAof,YAAA,MAKA,QAAAiB,GAAA3E,GAEA,GAAAO,GAAAlrD,EAAAnL,IAAA81D,GACAE,EAAA7qD,EAAAnL,IAAA81D,EAAA5xB,QAEA4xB,GAAA74C,iBAAA,UAAA44C,GAEAG,EAAAI,eAAAhc,EAAA1O,gBAEAiqB,EAAAC,UAEA,IAAAwE,GAAAtE,KAAAS,wBACAmE,EAAA5F,EAAAgB,EAIA,IAAAsE,EAAA,CAEA/D,EAAAI,qBAEA,QAAAx7D,GAAA,EAAoBA,EAAA,EAAOA,IAE3Bo7D,EAAAI,mBAAAx7D,GAAAm/C,EAAAugB,wBAMAtE,GAAAI,mBAAArc,EAAAugB,mBAMA,IAAAP,EAAA,CAEAvqD,EAAA+7B,YAAAwO,EAAA2c,iBAAAf,EAAAI,gBACAsB,EAAAtd,EAAA2c,iBAAAjB,EAAA5xB,QAAAw2B,EAEA,QAAAz/D,GAAA,EAAoBA,EAAA,EAAOA,IAE3Bk+D,EAAA9C,EAAAI,mBAAAx7D,GAAA66D,EAAA1b,EAAAwgB,kBAAAxgB,EAAA2d,4BAAA98D,EAIA66D,GAAA5xB,QAAAX,iBAAAm3B,GAAAtgB,EAAA4d,eAAA5d,EAAA2c,kBACAlnD,EAAA+7B,YAAAwO,EAAA2c,iBAAA,UAIAlnD,GAAA+7B,YAAAwO,EAAAvO,WAAAmqB,EAAAI,gBACAsB,EAAAtd,EAAAvO,WAAAiqB,EAAA5xB,QAAAw2B,GACAvB,EAAA9C,EAAAI,mBAAAX,EAAA1b,EAAAwgB,kBAAAxgB,EAAAvO,YAEAiqB,EAAA5xB,QAAAX,iBAAAm3B,GAAAtgB,EAAA4d,eAAA5d,EAAAvO,YACAh8B,EAAA+7B,YAAAwO,EAAAvO,WAAA,KAMAiqB,GAAA3xB,aAEAo2B,EAAAzE,GAMA,QAAA+E,GAAA/E,GAEA,GAAA5xB,GAAA4xB,EAAA5xB,OAEA,IAAAA,EAAAX,iBAAAuxB,EAAAgB,IACA5xB,EAAA7B,YAAAka,IACArY,EAAA7B,YAAAa,GAAA,CAEA,GAAA90B,GAAA0nD,KAAAS,wBAAAnc,EAAA2c,iBAAA3c,EAAAvO,WACAivB,EAAA3vD,EAAAnL,IAAAkkC,GAAAkyB,cAEAvmD,GAAA+7B,YAAAx9B,EAAA0sD,GACA1gB,EAAA4d,eAAA5pD,GACAyB,EAAA+7B,YAAAx9B,EAAA,OApuBA,GAAAunD,GAAArrB,EAAAnmB,OACA20C,EAAA,mBAAAiC,yBAAA3gB,YAAA2gB,uBAyuBA5kE,MAAAqxC,eACArxC,KAAAwxC,iBACAxxC,KAAA8hE,wBACA9hE,KAAAskE,oBACAtkE,KAAA0kE,2BAQA,QAAAG,MAEA,GAAA7vD,KAEA,QAEAnL,IAAA,SAAApE,GAEA,GAAA8mC,GAAA9mC,EAAA8mC,KACAj9B,EAAA0F,EAAAu3B,EASA,OAPA3lC,UAAA0I,IAEAA,KACA0F,EAAAu3B,GAAAj9B,GAIAA,GAIAytD,OAAA,SAAAt3D,SAEAuP,GAAAvP,EAAA8mC,OAIAma,MAAA,WAEA1xC,OAYA,QAAA8vD,IAAA/0B,EAAAoP,EAAAof,GAEA,QAAAwG,KAEA,GAAA72C,IAAA,EAEA8oB,EAAA,GAAAtJ,GACAs3B,EAAA,KACAC,EAAA,GAAAv3B,EAEA,QAEAw3B,QAAA,SAAAC,GAEAH,IAAAG,GAAAj3C,IAEA6hB,EAAAo1B,mBACAH,EAAAG,IAMAC,UAAA,SAAA72C,GAEAL,EAAAK,GAIA82C,SAAA,SAAA71B,EAAAiB,EAAAnxB,EAAAD,GAEA23B,EAAA/0C,IAAAutC,EAAAiB,EAAAnxB,EAAAD,GAEA4lD,EAAAK,OAAAtuB,MAAA,IAEAjH,EAAA2V,WAAAlW,EAAAiB,EAAAnxB,EAAAD,GACA4lD,EAAAxpD,KAAAu7B,KAMAprB,MAAA,WAEAsC,GAAA,EAEA82C,EAAA,KACAC,EAAAhjE,IAAA,WAQA,QAAAsjE,KAEA,GAAAr3C,IAAA,EAEAs3C,EAAA,KACAC,EAAA,KACAC,EAAA,IAEA,QAEAC,QAAA,SAAAnpB,GAEAA,EAEAnD,EAAAtJ,EAAAuJ,YAIAhrB,EAAAyhB,EAAAuJ,aAMA4rB,QAAA,SAAAU,GAEAJ,IAAAI,GAAA13C,IAEA6hB,EAAA61B,aACAJ,EAAAI,IAMAC,QAAA,SAAAloB,GAEA,GAAA8nB,IAAA9nB,EAAA,CAEA,GAAAA,EAEA,OAAAA,GAEA,IAAAmoB,IAEA/1B,EAAA4N,UAAA5N,EAAAg2B,MACA,MAEA,KAAAC,IAEAj2B,EAAA4N,UAAA5N,EAAAk2B,OACA,MAEA,KAAAC,IAEAn2B,EAAA4N,UAAA5N,EAAAo2B,KACA,MAEA,KAAAvoB,IAEA7N,EAAA4N,UAAA5N,EAAAq2B,OACA,MAEA,KAAAC,IAEAt2B,EAAA4N,UAAA5N,EAAAu2B,MACA,MAEA,KAAAC,IAEAx2B,EAAA4N,UAAA5N,EAAAy2B,OACA,MAEA,KAAAC,IAEA12B,EAAA4N,UAAA5N,EAAA22B,QACA,MAEA,KAAAC,IAEA52B,EAAA4N,UAAA5N,EAAA62B,SACA,MAEA,SAEA72B,EAAA4N,UAAA5N,EAAAq2B,YAMAr2B,GAAA4N,UAAA5N,EAAAq2B,OAIAX,GAAA9nB,IAMAynB,UAAA,SAAA72C,GAEAL,EAAAK,GAIA82C,SAAA,SAAAj2C,GAEAs2C,IAAAt2C,IAEA2gB,EAAA82B,WAAAz3C,GACAs2C,EAAAt2C,IAMAxD,MAAA,WAEAsC,GAAA,EAEAs3C,EAAA,KACAC,EAAA,KACAC,EAAA,OAQA,QAAAoB,KAEA,GAAA54C,IAAA,EAEA64C,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,IAEA,QAEA3B,QAAA,SAAA4B,GAEAA,EAEAluB,EAAAtJ,EAAAy3B,cAIAl5C,EAAAyhB,EAAAy3B,eAMAtC,QAAA,SAAAuC,GAEAV,IAAAU,GAAAv5C,IAEA6hB,EAAA03B,eACAV,EAAAU,IAMA5B,QAAA,SAAA6B,EAAAC,EAAAF,GAEAT,IAAAU,GACAT,IAAAU,GACAT,IAAAO,IAEA13B,EAAA23B,cAAAC,EAAAF,GAEAT,EAAAU,EACAT,EAAAU,EACAT,EAAAO,IAMAG,MAAA,SAAAC,EAAAC,EAAAC,GAEAZ,IAAAU,GACAT,IAAAU,GACAT,IAAAU,IAEAh4B,EAAAi4B,UAAAH,EAAAC,EAAAC,GAEAZ,EAAAU,EACAT,EAAAU,EACAT,EAAAU,IAMA3C,UAAA,SAAA72C,GAEAL,EAAAK,GAIA82C,SAAA,SAAA4C,GAEAX,IAAAW,IAEAl4B,EAAAm4B,aAAAD,GACAX,EAAAW,IAMAr8C,MAAA,WAEAsC,GAAA,EAEA64C,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,OAkDA,QAAA/xB,GAAAnxC,EAAA6T,EAAAga,GAEA,GAAA7qB,GAAA,GAAA4jD,YAAA,GACAjd,EAAAgC,EAAAwF,eAEAxF,GAAA0F,YAAArxC,EAAA2pC,GACAgC,EAAA+F,cAAA1xC,EAAA2rC,EAAAqG,mBAAArG,EAAAoG,SACApG,EAAA+F,cAAA1xC,EAAA2rC,EAAAmG,mBAAAnG,EAAAoG,QAEA,QAAArxC,GAAA,EAAmBA,EAAAmtB,EAAWntB,IAE9BirC,EAAA4F,WAAA19B,EAAAnT,EAAA,EAAAirC,EAAAsG,KAAA,MAAAtG,EAAAsG,KAAAtG,EAAA8F,cAAAzuC,EAIA,OAAA2mC,GAUA,QAAApuC,KAEA+lD,EAAA,SACAmhB,EAAA,GACAqB,EAAA,GAEA7uB,EAAAtJ,EAAAuJ,YACA6uB,EAAAvqB,IAEAwqB,GAAA,GACAC,EAAAC,IACAjvB,EAAAtJ,EAAAwI,WAEAc,EAAAtJ,EAAAqJ,OACAY,EAAA6C,IAIA,QAAA3E,KAEA,OAAApzC,GAAA,EAAA2F,EAAA89D,EAAApkE,OAA6CW,EAAA2F,EAAO3F,IAEpDyjE,EAAAzjE,GAAA,EAMA,QAAAqzC,GAAA+kB,GAWA,GATAqL,EAAArL,GAAA,EAEA,IAAAsL,EAAAtL,KAEAntB,EAAA04B,wBAAAvL,GACAsL,EAAAtL,GAAA,GAIA,IAAAwL,EAAAxL,GAAA,CAEA,GAAAhM,GAAA/R,EAAAt1C,IAAA,yBAEAqnD,GAAAyX,yBAAAzL,EAAA,GACAwL,EAAAxL,GAAA,GAMA,QAAA0L,GAAA1L,EAAA2L,EAAA3X,GAEAqX,EAAArL,GAAA,EAEA,IAAAsL,EAAAtL,KAEAntB,EAAA04B,wBAAAvL,GACAsL,EAAAtL,GAAA,GAIAwL,EAAAxL,KAAA2L,IAEA3X,EAAAyX,yBAAAzL,EAAA2L,GACAH,EAAAxL,GAAA2L,GAMA,QAAAzwB,KAEA,OAAAtzC,GAAA,EAAA2F,EAAA+9D,EAAArkE,OAAiDW,IAAA2F,IAAS3F,EAE1D0jE,EAAA1jE,KAAAyjE,EAAAzjE,KAEAirC,EAAA+4B,yBAAAhkE,GACA0jE,EAAA1jE,GAAA,GAQA,QAAAu0C,GAAAt7C,GAEAujD,EAAAvjD,MAAA,IAEAgyC,EAAAsJ,OAAAt7C,GACAujD,EAAAvjD,IAAA,GAMA,QAAAuwB,GAAAvwB,GAEAujD,EAAAvjD,MAAA,IAEAgyC,EAAAzhB,QAAAvwB,GACAujD,EAAAvjD,IAAA,GAMA,QAAA2jE,KAEA,UAAAqH,IAEAA,KAEA5pB,EAAAt1C,IAAA,mCACAs1C,EAAAt1C,IAAA,kCACAs1C,EAAAt1C,IAAA,kCAIA,OAFAm/D,GAAAj5B,EAAAk5B,aAAAl5B,EAAAm5B,4BAEApkE,EAAA,EAAqBA,EAAAkkE,EAAA7kE,OAAoBW,IAEzCikE,EAAAh9D,KAAAi9D,EAAAlkE,GAQA,OAAAikE,GAIA,QAAA/uB,GAAAC,EAAAC,EAAAC,EAAAC,EAAAsD,EAAAF,EAAAC,EAAAY,GAEApE,IAAAkvB,GAEA9vB,EAAAtJ,EAAAqJ,OAIA9qB,EAAAyhB,EAAAqJ,OAIAa,IAAAmvB,GAAA/qB,IAAAgrB,KAEApvB,IAAAqvB,GAEAjrB,GAEAtO,EAAAw5B,sBAAAx5B,EAAAy5B,SAAAz5B,EAAAy5B,UACAz5B,EAAA05B,kBAAA15B,EAAA25B,IAAA35B,EAAA25B,IAAA35B,EAAA25B,IAAA35B,EAAA25B,OAIA35B,EAAAmK,cAAAnK,EAAAy5B,UACAz5B,EAAA45B,UAAA55B,EAAA65B,UAAA75B,EAAA25B,MAIKzvB,IAAA4vB,GAELxrB,GAEAtO,EAAAw5B,sBAAAx5B,EAAAy5B,SAAAz5B,EAAAy5B,UACAz5B,EAAA05B,kBAAA15B,EAAA+5B,KAAA/5B,EAAA+5B,KAAA/5B,EAAAg6B,oBAAAh6B,EAAAi6B,uBAIAj6B,EAAAmK,cAAAnK,EAAAy5B,UACAz5B,EAAA45B,UAAA55B,EAAA+5B,KAAA/5B,EAAAg6B,sBAIK9vB,IAAAgwB,GAEL5rB,GAEAtO,EAAAw5B,sBAAAx5B,EAAAy5B,SAAAz5B,EAAAy5B,UACAz5B,EAAA05B,kBAAA15B,EAAA+5B,KAAA/5B,EAAAm6B,UAAAn6B,EAAA+5B,KAAA/5B,EAAA65B,aAIA75B,EAAAmK,cAAAnK,EAAAy5B,UACAz5B,EAAA45B,UAAA55B,EAAA+5B,KAAA/5B,EAAAm6B,YAMA7rB,GAEAtO,EAAAw5B,sBAAAx5B,EAAAy5B,SAAAz5B,EAAAy5B,UACAz5B,EAAA05B,kBAAA15B,EAAA25B,IAAA35B,EAAAi6B,oBAAAj6B,EAAA25B,IAAA35B,EAAAi6B,uBAIAj6B,EAAAw5B,sBAAAx5B,EAAAy5B,SAAAz5B,EAAAy5B,UACAz5B,EAAA05B,kBAAA15B,EAAA65B,UAAA75B,EAAAi6B,oBAAAj6B,EAAA25B,IAAA35B,EAAAi6B,sBAMAZ,EAAAnvB,EACAovB,GAAAhrB,GAIApE,IAAAkwB,IAEAzsB,KAAAxD,EACAsD,KAAArD,EACAsD,KAAArD,EAEAF,IAAAkwB,GAAA1sB,IAAA2sB,KAEAt6B,EAAAw5B,sBAAAhL,EAAArkB,GAAAqkB,EAAA7gB,IAEA0sB,EAAAlwB,EACAmwB,GAAA3sB,GAIAvD,IAAAmwB,GAAAlwB,IAAAmwB,GAAA/sB,IAAAgtB,IAAA/sB,IAAAgtB,KAEA16B,EAAA05B,kBAAAlL,EAAApkB,GAAAokB,EAAAnkB,GAAAmkB,EAAA/gB,GAAA+gB,EAAA9gB,IAEA6sB,EAAAnwB,EACAowB,EAAAnwB,EACAowB,GAAAhtB,EACAitB,GAAAhtB,KAMA2sB,EAAA,KACAE,EAAA,KACAC,EAAA,KACAF,GAAA,KACAG,GAAA,KACAC,GAAA,MAQA,QAAAC,GAAA1sB,GAEA2sB,EAAAzF,QAAAlnB,GAIA,QAAAzB,GAAAC,GAEAxO,EAAA23B,QAAAnpB,GAIA,QAAAhE,GAAAiE,GAEAzO,EAAAk3B,QAAAzoB,GAIA,QAAA0rB,GAAAxqB,GAEA3P,EAAA63B,QAAAloB,GAIA,QAAAitB,GAAArD,GAEAt5B,EAAA03B,QAAA4B,GAIA,QAAAsD,GAAAC,GAEA78B,EAAAi3B,QAAA4F,GAIA,QAAAC,GAAArD,EAAAC,EAAAF,GAEAx5B,EAAA43B,QAAA6B,EAAAC,EAAAF,GAIA,QAAAuD,GAAAnD,EAAAC,EAAAC,GAEA95B,EAAA25B,MAAAC,EAAAC,EAAAC,GAMA,QAAAK,GAAAjR,GAEA8T,KAAA9T,IAEAA,EAEApnB,EAAAm7B,UAAAn7B,EAAAo7B,IAIAp7B,EAAAm7B,UAAAn7B,EAAAq7B,KAIAH,GAAA9T,GAMA,QAAAkR,GAAAgD,GAEAA,IAAAC,IAEAjyB,EAAAtJ,EAAAwI,WAEA8yB,IAAAE,KAEAF,IAAA/C,GAEAv4B,EAAAs7B,SAAAt7B,EAAAy7B,MAEMH,IAAAI,GAEN17B,EAAAs7B,SAAAt7B,EAAA27B,OAIA37B,EAAAs7B,SAAAt7B,EAAA47B,kBAQAr9C,EAAAyhB,EAAAwI,WAIAgzB,GAAAF,EAIA,QAAAO,GAAA/oE,GAEAA,IAAAgpE,KAEA97B,EAAA+7B,UAAAjpE,GAEAgpE,GAAAhpE,GAMA,QAAAkpE,GAAA7tB,EAAA8tB,EAAAn5B,GAEAqL,GAEA7E,EAAAtJ,EAAAk8B,qBAEAC,KAAAF,GAAAG,KAAAt5B,IAEA9C,EAAAmO,cAAA8tB,EAAAn5B,GAEAq5B,GAAAF,EACAG,GAAAt5B,IAMAvkB,EAAAyhB,EAAAk8B,qBAMA,QAAAG,KAEA,MAAAC,IAIA,QAAA1mB,GAAA9X,GAEAw+B,GAAAx+B,EAEAA,EAEAwL,EAAAtJ,EAAAu8B,cAIAh+C,EAAAyhB,EAAAu8B,cAQA,QAAAtzB,GAAAuzB,GAEA3lE,SAAA2lE,MAAAx8B,EAAAkJ,SAAAuzB,GAAA,GAEAC,KAAAF,IAEAx8B,EAAAiJ,cAAAuzB,GACAE,GAAAF,GAMA,QAAA92B,GAAAi3B,EAAA/H,GAEA,OAAA8H,IAEAzzB,GAIA,IAAA2zB,GAAAC,GAAAH,GAEA7lE,UAAA+lE,IAEAA,GAAoBvoE,KAAAwC,OAAAmnC,QAAAnnC,QACpBgmE,GAAAH,IAAAE,GAIAA,EAAAvoE,OAAAsoE,GAAAC,EAAA5+B,UAAA42B,IAEA50B,EAAA0F,YAAAi3B,EAAA/H,GAAAkI,GAAAH,IAEAC,EAAAvoE,KAAAsoE,EACAC,EAAA5+B,QAAA42B,GAMA,QAAAhD,KAEA,IAEA5xB,EAAA4xB,qBAAA50D,MAAAgjC,EAAA/iC,WAEI,MAAA2M,GAEJ4W,QAAA5W,UAMA,QAAAg8B,KAEA,IAEA5F,EAAA4F,WAAA5oC,MAAAgjC,EAAA/iC,WAEI,MAAA2M,GAEJ4W,QAAA5W,UAQA,QAAA+rC,GAAAlW,EAAAiB,EAAAnxB,EAAAD,GAEAsrD,EAAAtF,SAAA71B,EAAAiB,EAAAnxB,EAAAD,GAIA,QAAAwnD,GAAAz3C,GAEA4e,EAAAq3B,SAAAj2C,GAIA,QAAA84C,GAAAD,GAEAh6B,EAAAo3B,SAAA4C,GAMA,QAAAr6B,MAEAk/B,GAAAxH,OAAA13B,MAAA,IAEAmC,EAAAnC,UAAAtsC,EAAAssC,EAAArsC,EAAAqsC,EAAApsC,EAAAosC,EAAAvqC,GACAypE,GAAArxD,KAAAmyB,IAMA,QAAAE,MAEAi/B,GAAAzH,OAAAx3B,MAAA,IAEAiC,EAAAjC,WAAAxsC,EAAAwsC,EAAAvsC,EAAAusC,EAAAtsC,EAAAssC,EAAAzqC,GACA0pE,GAAAtxD,KAAAqyB,IAQA,QAAAliB,KAEA,OAAA9mB,GAAA,EAAmBA,EAAA0jE,EAAArkE,OAA8BW,IAEjD,IAAA0jE,EAAA1jE,KAEAirC,EAAA+4B,yBAAAhkE,GACA0jE,EAAA1jE,GAAA,EAMAw8C,MAEAynB,EAAA,KAEA0D,GAAA,KACAG,MAEAxD,EAAA,KAEA6B,GAAA,KACAM,GAAA,KAEAZ,EAAA/+C,QACAoiB,EAAApiB,QACAqiB,EAAAriB,QA7mBA,GAAA++C,GAAA,GAAA5F,GACA/2B,EAAA,GAAAu3B,GACAt3B,EAAA,GAAA64B,GAEAkG,EAAAj9B,EAAAk5B,aAAAl5B,EAAAk9B,oBACA1E,EAAA,GAAAvd,YAAAgiB,GACAxE,EAAA,GAAAxd,YAAAgiB,GACAtE,EAAA,GAAA1d,YAAAgiB,GAEA1rB,KAEAynB,EAAA,KAEAK,EAAA,KACAgB,EAAA,KACAE,EAAA,KACAC,EAAA,KACAF,GAAA,KACAG,GAAA,KACAC,GAAA,KACApB,IAAA,EAEA4B,GAAA,KACAM,GAAA,KAEAM,GAAA,KAEAK,GAAA,KACAC,GAAA,KAEAE,GAAA,KAEAG,GAAAz8B,EAAAk5B,aAAAl5B,EAAAm9B,yBAEAT,GAAA,KACAG,MAEAE,GAAA,GAAAp/B,GACAq/B,GAAA,GAAAr/B,GAqBAm/B,KAsjBA,OArjBAA,IAAA98B,EAAA2F,YAAAH,EAAAxF,EAAA2F,WAAA3F,EAAA2F,WAAA,GACAm3B,GAAA98B,EAAA6wB,kBAAArrB,EAAAxF,EAAA6wB,iBAAA7wB,EAAA6xB,4BAAA,IAsjBAuL,SACAn2B,MAAA2zB,EACAv7C,MAAA4e,EACAi6B,QAAAh6B,GAGAtuC,OACAu4C,iBACAC,kBACAywB,4BACAxwB,0BACAiB,SACA/qB,UACAozC,8BAEA1nB,cAEA0wB,gBACAnuB,eACA/D,gBACA2vB,eACAyC,iBACAC,kBACAE,iBACAC,eAEA5C,eACAC,cAEAuD,eACAG,mBAEAK,iBACAzmB,iBAEA3M,gBACAvD,cACAksB,uBACAhsB,aAEA+P,aACAmhB,aACAqB,eAEAt6B,UACAE,WAEAliB,SAUA,QAAAwhD,IAAAr9B,EAAAoP,EAAAT,GAIA,QAAA2jB,KAEA,GAAAz7D,SAAAymE,EAAA,MAAAA,EAEA,IAAAnc,GAAA/R,EAAAt1C,IAAA,iCAYA,OARAwjE,GAFA,OAAAnc,EAEAnhB,EAAAk5B,aAAA/X,EAAAoc,gCAIA,EAQA,QAAAjS,GAAApd,GAEA,aAAAA,EAAA,CAEA,GAAAlO,EAAAw9B,yBAAAx9B,EAAAsH,cAAAtH,EAAAy9B,YAAAvvB,UAAA,GACAlO,EAAAw9B,yBAAAx9B,EAAAqH,gBAAArH,EAAAy9B,YAAAvvB,UAAA,EAEA,aAIAA,GAAA,UAIA,kBAAAA,GAEAlO,EAAAw9B,yBAAAx9B,EAAAsH,cAAAtH,EAAA09B,cAAAxvB,UAAA,GACAlO,EAAAw9B,yBAAAx9B,EAAAqH,gBAAArH,EAAA09B,cAAAxvB,UAAA,EAEA,UAMA,OAhDA,GAAAovB,GAoDApvB,EAAAr3C,SAAA83C,EAAAT,UAAAS,EAAAT,UAAA,QACAyvB,EAAArS,EAAApd,EAEAyvB,KAAAzvB,IAEA1tB,QAAAC,KAAA,uBAAAytB,EAAA,uBAAAyvB,EAAA,YACAzvB,EAAAyvB,EAIA,IAAAxZ,GAAAxV,EAAAwV,0BAAA,KAAA/U,EAAAt1C,IAAA,kBAEA2iE,EAAAz8B,EAAAk5B,aAAAl5B,EAAAm9B,yBACAS,EAAA59B,EAAAk5B,aAAAl5B,EAAA69B,gCACAppB,EAAAzU,EAAAk5B,aAAAl5B,EAAA89B,kBACA1M,EAAApxB,EAAAk5B,aAAAl5B,EAAA+9B,2BAEAC,EAAAh+B,EAAAk5B,aAAAl5B,EAAAk9B,oBACAlT,EAAAhqB,EAAAk5B,aAAAl5B,EAAAi+B,4BACAC,EAAAl+B,EAAAk5B,aAAAl5B,EAAAm+B,qBACAC,EAAAp+B,EAAAk5B,aAAAl5B,EAAAq+B,8BAEA5S,EAAAmS,EAAA,EACAU,IAAAlvB,EAAAt1C,IAAA,qBACA+vD,EAAA4B,GAAA6S,CAEA,QAEAhM,mBACAhH,kBAEApd,YACAiW,yBAEAsY,cACAmB,oBACAnpB,iBACA2c,iBAEA4M,gBACAhU,oBACAkU,cACAE,sBAEA3S,iBACA6S,wBACAzU,uBAUA,QAAA0U,IAAAv+B,GAEA,GAAAoP,KAEA,QAEAt1C,IAAA,SAAAnC,GAEA,GAAAd,SAAAu4C,EAAAz3C,GAEA,MAAAy3C,GAAAz3C,EAIA,IAAAwpD,EAEA,QAAAxpD,GAEA,0BACAwpD,EAAAnhB,EAAAw+B,aAAA,wBAAAx+B,EAAAw+B,aAAA,4BAAAx+B,EAAAw+B,aAAA,6BACA,MAEA,sCACArd,EAAAnhB,EAAAw+B,aAAA,mCAAAx+B,EAAAw+B,aAAA,uCAAAx+B,EAAAw+B,aAAA,wCACA,MAEA,qCACArd,EAAAnhB,EAAAw+B,aAAA,kCAAAx+B,EAAAw+B,aAAA,sCAAAx+B,EAAAw+B,aAAA,uCACA,MAEA,sCACArd,EAAAnhB,EAAAw+B,aAAA,mCAAAx+B,EAAAw+B,aAAA,wCACA,MAEA,qCACArd,EAAAnhB,EAAAw+B,aAAA,gCACA,MAEA,SACArd,EAAAnhB,EAAAw+B,aAAA7mE,GAYA,MARA,QAAAwpD,GAEA3gC,QAAAC,KAAA,wBAAA9oB,EAAA,6BAIAy3C,EAAAz3C,GAAAwpD,EAEAA,IAYA,QAAAsd,MA8FA,QAAAC,KAEAC,EAAAtoE,QAAAuoE,IAEAD,EAAAtoE,MAAAuoE,EACAD,EAAApzB,YAAAszB,EAAA,GAIA5rB,EAAA6rB,UAAAD,EACA5rB,EAAA8rB,gBAAA,EAIA,QAAAC,GAAA9tB,EAAA7/C,EAAA4tE,EAAAC,GAEA,GAAAC,GAAA,OAAAjuB,IAAA98C,OAAA,EACAgrE,EAAA,IAEA,QAAAD,EAAA,CAIA,GAFAC,EAAAT,EAAAtoE,MAEA6oE,KAAA,UAAAE,EAAA,CAEA,GAAAC,GAAAJ,EAAA,EAAAE,EACAG,EAAAjuE,EAAAw3C,kBAEA02B,GAAAC,gBAAAF,IAEA,OAAAF,KAAAhrE,OAAAirE,KAEAD,EAAA,GAAAtgC,cAAAugC,GAIA,QAAAtqE,GAAA,EAAA0qE,EAAAR,EACAlqE,IAAAoqE,IAAwBpqE,EAAA0qE,GAAA,EAExBC,EAAAh0D,KAAAwlC,EAAAn8C,IACA6zC,aAAA02B,EAAAC,GAEAG,EAAAjvB,OAAAvlC,QAAAk0D,EAAAK,GACAL,EAAAK,EAAA,GAAAC,EAAAhvB,SAMAiuB,EAAAtoE,MAAA+oE,EACAT,EAAApzB,aAAA,EAMA,MAFA0H,GAAA6rB,UAAAK,EAEAC,EApJA,GAAAnsB,GAAAhjD,KAEA2uE,EAAA,KACAC,EAAA,EACAlsB,GAAA,EACAgtB,GAAA,EAEAD,EAAA,GAAA1wE,IACAuwE,EAAA,GAAA/uB,IAEAmuB,GAActoE,MAAA,KAAAk1C,aAAA,EAEdt7C,MAAA0uE,UACA1uE,KAAA6uE,UAAA,EACA7uE,KAAA8uE,gBAAA,EAEA9uE,KAAAL,KAAA,SAAAshD,EAAA0uB,EAAAvuE,GAEA,GAAAR,GACA,IAAAqgD,EAAA98C,QACAwrE,GAGA,IAAAf,GACAlsB,CAOA,OALAA,GAAAitB,EAEAhB,EAAAI,EAAA9tB,EAAA7/C,EAAA,GACAwtE,EAAA3tB,EAAA98C,OAEAvD,GAIAZ,KAAA4vE,aAAA,WAEAF,GAAA,EACAX,EAAA,OAIA/uE,KAAA6vE,WAAA,WAEAH,GAAA,EACAjB,KAIAzuE,KAAA8vE,SAAA,SAAA7uB,EAAAnD,EAAAC,EAAA38C,EAAAsd,EAAAqxD,GAEA,IAAArtB,GACA,OAAAzB,GAAA,IAAAA,EAAA98C,QACAurE,IAAA3xB,EAGA2xB,EAGAX,EAAA,MAIAN,QAGI,CAEJ,GAAAuB,GAAAN,EAAA,EAAAd,EACAqB,EAAA,EAAAD,EAEAb,EAAAzwD,EAAAwxD,eAAA,IAEAxB,GAAAtoE,MAAA+oE,EAEAA,EAAAJ,EAAA9tB,EAAA7/C,EAAA6uE,EAAAF,EAEA,QAAAjrE,GAAA,EAAoBA,IAAAmrE,IAAenrE,EAEnCqqE,EAAArqE,GAAA6pE,EAAA7pE,EAIA4Z,GAAAwxD,cAAAf,EACAnvE,KAAA8uE,gBAAAhxB,EAAA99C,KAAA6uE,UAAA,EACA7uE,KAAA6uE,WAAAmB,IA6EA,QAAA5vE,IAAAs+C,GAqRA,QAAAyxB,KAEA,cAAAC,GAAAC,GAAA,EAIA,QAAAC,GAAA9gC,EAAAiB,EAAAnxB,EAAAD,GAEAkxD,KAAA,IAEA/gC,GAAAnwB,EAAWoxB,GAAApxB,EAAQC,GAAAD,GAInB3F,GAAAgsC,WAAAlW,EAAAiB,EAAAnxB,EAAAD,GAIA,QAAAmxD,KAEA92D,GAAA/Z,OAEA+Z,GAAAk0B,QAAA6iC,GAAAh1D,KAAAi1D,IAAAC,eAAAN,KACA32D,GAAAo0B,SAAA8iC,GAAAn1D,KAAAo1D,IAAAF,eAAAN,KAEAC,EAAAQ,GAAAthC,EAAAshC,GAAArgC,EAAAqgC,GAAAxxD,EAAAyxD,IAIA,QAAA12B,KAEA22B,GAAA,KACAC,GAAA,KAEAC,GAAA,GACAC,IAAA,EAEAz3D,GAAAkS,QA4MA,QAAAwlD,GAAAvkE,GAEAA,EAAAwoB,iBAEAglB,IACAm2B,IAEAx7D,GAAA0xC,QAIA,QAAA2qB,GAAAxkE,GAEA,GAAAwvC,GAAAxvC,EAAAoL,MAEAokC,GAAAv1C,oBAAA,UAAAuqE,GAEAC,EAAAj1B,GAMA,QAAAi1B,GAAAj1B,GAEAk1B,EAAAl1B,GAEArnC,GAAA+nD,OAAA1gB,GAKA,QAAAk1B,GAAAl1B,GAEA,GAAAigB,GAAAtnD,GAAAnL,IAAAwyC,GAAArI,OAEAqI,GAAArI,QAAAptC,OAEAA,SAAA01D,GAEAkV,GAAAjV,eAAAD,GAuTA,QAAAmV,GAAAp1B,EAAArI,EAAA0N,EAAAgwB,GAEA,GAAAxgB,EAEA,IAAAxP,KAAAiwB,4BAEAzgB,EAAA/R,GAAAt1C,IAAA,0BAEA,OAAAqnD,GAGA,WADA3gC,SAAA5W,MAAA,iJAOA/S,UAAA8qE,MAAA,GAEAh4D,GAAAw+B,gBAEA,IAAA05B,GAAAlwB,EAAAh9B,WAEAmtD,EAAA79B,EAAAqlB,gBAEAyY,EAAAz1B,EAAAmD,sBAEA,QAAA93C,KAAAmqE,GAAA,CAEA,GAAAE,GAAAF,EAAAnqE,EAEA,IAAAqqE,GAAA,GAEA,GAAAC,GAAAJ,EAAAlqE,EAEA,IAAAd,SAAAorE,EAAA,CAEA,GAAA5tE,GAAA6/C,GAAA3L,MACAlJ,EAAA4iC,EAAA5iC,MACAsb,EAAAsnB,EAAAtnB,UAEAtb,aAAAP,cAEAzqC,EAAA6/C,GAAA3L,MAEOlJ,YAAAuc,cAEPp7B,QAAAC,KAAA,gDAEO4e,YAAAyF,aAEPzwC,EAAA6/C,GAAAxK,eAEOrK,YAAAgc,YAEPhnD,EAAA6/C,GAAAguB,MAEO7iC,YAAAoc,aAEPpnD,EAAA6/C,GAAA8M,aAEO3hB,YAAAQ,YAEPxrC,EAAA6/C,GAAAiuB,IAEO9iC,YAAA0b,WAEP1mD,EAAA6/C,GAAAkuB,KAEO/iC,YAAA4b,cAEP5mD,EAAA6/C,GAAApO,cAIA,IAAAvD,GAAA0/B,EAAAvnB,SACA2S,EAAAgV,GAAAnV,mBAAA+U,EAEA,IAAAA,EAAAzgB,6BAAA,CAEA,GAAAnqD,GAAA4qE,EAAA5qE,KACAirE,EAAAjrE,EAAAirE,OACA1oC,EAAAqoC,EAAAroC,MAEAviC,MAAAkrE,8BAEA54D,GAAAkvD,0BAAAmJ,EAAA3qE,EAAAyhE,iBAAA3X,GAEAtqD,SAAA86C,EAAA0P,oBAEA1P,EAAA0P,kBAAAhqD,EAAAyhE,iBAAAzhE,EAAA6qB,QAMAvY,GAAAy+B,gBAAA45B,GAIA9tB,GAAAhP,WAAAgP,GAAA/O,aAAAkoB,GACAnZ,GAAA5L,oBAAA05B,EAAAz/B,EAAAluC,EAAAsmD,EAAA2nB,EAAAjrE,EAAAgoC,MAAA8uB,mBAAAwT,EAAAW,EAAA1oC,GAAAviC,EAAAgoC,MAAA8uB,uBAIA8T,GAAAO,4BAEA74D,GAAAkvD,0BAAAmJ,EAAAC,EAAAnJ,iBAAA3X,GAEAtqD,SAAA86C,EAAA0P,oBAEA1P,EAAA0P,kBAAA4gB,EAAAnJ,iBAAAmJ,EAAA//C,QAMAvY,GAAAy+B,gBAAA45B,GAIA9tB,GAAAhP,WAAAgP,GAAA/O,aAAAkoB,GACAnZ,GAAA5L,oBAAA05B,EAAAz/B,EAAAluC,EAAAsmD,EAAA,EAAAgnB,EAAAp/B,EAAA0/B,EAAA5iC,MAAA8uB,uBAIM,IAAAt3D,SAAAkrE,EAAA,CAEN,GAAA1rE,GAAA0rE,EAAApqE,EAEA,IAAAd,SAAAR,EAEA,OAAAA,EAAAjC,QAEA,OACA8/C,GAAAuuB,gBAAAT,EAAA3rE,EACA,MAEA,QACA69C,GAAAwuB,gBAAAV,EAAA3rE,EACA,MAEA,QACA69C,GAAAyuB,gBAAAX,EAAA3rE,EACA,MAEA,SACA69C,GAAA0uB,gBAAAZ,EAAA3rE,MAYAsT,GAAA0+B,0BAMA,QAAAw6B,GAAAvzD,EAAAC,GAEA,MAAAxe,MAAA+xE,IAAAvzD,EAAA,IAAAxe,KAAA+xE,IAAAxzD,EAAA,IAIA,QAAAk8B,GAAAl8B,EAAAC,GAEA,MAAAD,GAAA5Z,OAAA+1C,cAAAl8B,EAAA7Z,OAAA+1C,YAEAn8B,EAAA5Z,OAAA+1C,YAAAl8B,EAAA7Z,OAAA+1C,YAEIn8B,EAAAg9B,SAAArI,SAAA10B,EAAA+8B,SAAArI,SAAA30B,EAAAg9B,SAAArI,UAAA10B,EAAA+8B,SAAArI,QAEJ30B,EAAAg9B,SAAArI,QAAAj2C,GAAAuhB,EAAA+8B,SAAArI,QAAAj2C,GAEIshB,EAAAg9B,SAAAt+C,KAAAuhB,EAAA+8B,SAAAt+C,GAEJshB,EAAAg9B,SAAAt+C,GAAAuhB,EAAA+8B,SAAAt+C,GAEIshB,EAAA7d,IAAA8d,EAAA9d,EAEJ6d,EAAA7d,EAAA8d,EAAA9d,EAIA6d,EAAAthB,GAAAuhB,EAAAvhB,GAMA,QAAA+0E,GAAAzzD,EAAAC,GAEA,MAAAD,GAAA5Z,OAAA+1C,cAAAl8B,EAAA7Z,OAAA+1C,YAEAn8B,EAAA5Z,OAAA+1C,YAAAl8B,EAAA7Z,OAAA+1C,YAEIn8B,EAAA7d,IAAA8d,EAAA9d,EAEJ8d,EAAA9d,EAAA6d,EAAA7d,EAIA6d,EAAAthB,GAAAuhB,EAAAvhB,GAgLA,QAAAg1E,GAAAttE,EAAAi8C,EAAArF,EAAA76C,EAAA8lD,GAEA,GAAAlY,GAAAzlC,CAIA0yC,GAAAe,aAEAhO,EAAA4jC,GACArpE,IAAAspE,KAIA7jC,EAAA8jC,EACAvpE,IAAAwpE,GAMA,IAAAC,GAAAhkC,EAAAzlC,EAEA/C,UAAAwsE,GAEAA,EAAAr1E,GAAA0H,EAAA1H,GACAq1E,EAAA3tE,SACA2tE,EAAA1xB,WACA0xB,EAAA/2B,WACA+2B,EAAA5xE,EAAA6xE,GAAA7xE,EACA4xE,EAAA9rB,UAIA8rB,GACAr1E,GAAA0H,EAAA1H,GACA0H,SACAi8C,WACArF,WACA76C,EAAA6xE,GAAA7xE,EACA8lD,SAIAlY,EAAArjC,KAAAqnE,IAQA,QAAAE,GAAA7tE,GAEA,GAAAi8C,GAAAj8C,EAAAi8C,QAQA,OANA,QAAAA,EAAA4K,gBACA5K,EAAA6xB,wBAEAC,GAAA/3D,KAAAimC,EAAA4K,gBACA3T,aAAAlzC,EAAAizC,aAEA+6B,EAAAD,IAIA,QAAAE,GAAA35B,GAMA,MAJAy5B,IAAAnzB,OAAAp+C,IAAA,OACAuxE,GAAAlzB,OAAA,kBACAkzB,GAAA76B,aAAAoB,EAAArB,aAEA+6B,EAAAD,IAIA,QAAAC,GAAAE,GAEA,IAAA7vB,GAAA8vB,iBAAAD,GAAA,QAEA,IAAA9E,GAAAgF,GAAAhF,SAEA,QAAAA,EAAA,QAEA,IAAA5tB,GAAA6yB,GAAAj2B,eAEAwC,EAAAszB,EAAAtzB,OACA0zB,GAAAJ,EAAArzB,OACAx7C,EAAA,CAEA,GAGA,IAAAm8C,EAAAn8C,GAAAkvE,gBAAA3zB,GAAA0zB,EAAA,iBAEIjvE,IAAA+pE,EAEJ,UAIA,QAAAvrB,GAAA79C,EAAArE,GAEA,GAAAqE,EAAA0hC,WAAA,GAEA,GAAAA,GAAA,KAAA1hC,EAAA+9C,OAAAC,KAAAriD,EAAAoiD,OAAAC,KAEA,IAAAtc,EAEA,GAAA1hC,EAAAwuE,QAEAr3B,EAAA7wC,KAAAtG,OAEK,IAAAA,EAAAyuE,SAELzuE,EAAAo+C,iBAAA,GAAA6vB,EAAAjuE,MAAA,GAEA80C,GAAAxuC,KAAAtG,OAIK,IAAAA,EAAA0uE,YAELr6B,GAAA/tC,KAAAtG,OAEK,IAAAA,EAAA2uE,wBAELN,GAAAO,eAAA,IAEAhB,GAAA7sB,sBAAA/gD,EAAAizC,aACA26B,GAAAx6B,gBAAAsL,KAIA4uB,EAAAttE,EAAA,KAAAA,EAAA42C,SAAAg3B,GAAA7xE,EAAA,UAEK,KAAAiE,EAAAi+C,QAAAj+C,EAAAk+C,QAAAl+C,EAAAm+C,YAELn+C,EAAA68C,eAEA78C,EAAAo0D,SAAA13D,SAIAsD,EAAAo+C,iBAAA,GAAAyvB,EAAA7tE,MAAA,IAEA,GAAA42C,GAAA52C,EAAA42C,QAEA,IAAAA,EAAAlV,WAAA,GAEA2sC,GAAAO,eAAA,IAEAhB,GAAA7sB,sBAAA/gD,EAAAizC,aACA26B,GAAAx6B,gBAAAsL,IAIA,IAAAzC,GAAA0wB,GAAAjwE,OAAAsD,EAEA,IAAA42C,EAAA6K,gBAKA,OAHA7pC,GAAAqkC,EAAArkC,OACA8pC,EAAA9K,EAAA8K,UAEAriD,EAAA,EAAA2F,EAAA4S,EAAAlZ,OAA2CW,EAAA2F,EAAO3F,IAAA,CAElD,GAAAwiD,GAAAjqC,EAAAvY,GACAyiD,EAAAJ,EAAAG,EAAAE,cAEAD,GAAApgB,WAAA,GAEA4rC,EAAAttE,EAAAi8C,EAAA6F,EAAA8rB,GAAA7xE,EAAA8lD,OAQAyrB,GAAAttE,EAAAi8C,EAAArF,EAAAg3B,GAAA7xE,EAAA,OAcA,OAFA0rB,GAAAznB,EAAAynB,SAEApoB,EAAA,EAAA2F,EAAAyiB,EAAA/oB,OAAwCW,EAAA2F,EAAO3F,IAE/Cw+C,EAAAp2B,EAAApoB,GAAA1D,IAMA,QAAAkzE,GAAAC,EAAArzE,EAAAE,EAAAozE,GAEA,OAAA1vE,GAAA,EAAA2F,EAAA8pE,EAAApwE,OAA0CW,EAAA2F,EAAO3F,IAAA,CAEjD,GAAAsuE,GAAAmB,EAAAzvE,GAEAW,EAAA2tE,EAAA3tE,OACAi8C,EAAA0xB,EAAA1xB,SACArF,EAAAz1C,SAAA4tE,EAAApB,EAAA/2B,SAAAm4B,EACAltB,EAAA8rB,EAAA9rB,KAOA,IALA7hD,EAAAi1C,gBAAA0B,iBAAAh7C,EAAAw3C,mBAAAnzC,EAAAizC,aACAjzC,EAAAqjD,aAAAymB,gBAAA9pE,EAAAi1C,iBAEAj1C,EAAA2jD,eAAA0qB,GAAA5yE,EAAAE,EAAAsgD,EAAArF,EAAAiL,GAEA7hD,EAAA2uE,wBAAA,CAEAK,EAAAp4B,EAEA,IAAArI,GAAA0gC,EAAAtzE,EAAAF,EAAA46C,IAAAO,EAAA52C,EAEAyrE,IAAA,GAEAzrE,EAAA9C,OAAA,SAAA8C,GAEAquE,GAAAa,sBAAAlvE,EAAAuuC,EAAAqI,SAMAy3B,IAAArsB,mBAAArmD,EAAAF,EAAA46C,IAAA4F,EAAArF,EAAA52C,EAAA6hD,EAIA7hD,GAAA4jD,cAAAyqB,GAAA5yE,EAAAE,EAAAsgD,EAAArF,EAAAiL,IAOA,QAAAstB,GAAAv4B,EAAAP,EAAAr2C,GAEA,GAAAovE,GAAA7/D,GAAAnL,IAAAwyC,GAEAqC,EAAA8yB,GAAAvW,cACA5e,EAAA+E,GAAAtF,EAAA+3B,GAAAhF,UAAAgF,GAAA/E,gBAAArpE,GAEAhC,EAAA+tE,GAAArV,eAAA9f,EAAAqC,GAEA1K,EAAA6gC,EAAA7gC,QACA8gC,GAAA,CAEA,IAAAluE,SAAAotC,EAGAqI,EAAAv1B,iBAAA,UAAAuqD,OAEI,IAAAr9B,EAAAvwC,SAGJ8tE,EAAAl1B,OAEI,IAAAz1C,SAAA83C,EAAA0c,SAGJ,MAKA0Z,IAAA,EAIA,GAAAA,EAAA,CAEA,GAAAp2B,EAAA0c,SAAA,CAEA,GAAA9kB,GAAA4O,GAAAxG,EAAA0c,SAEAyZ,GAAAxf,eACA3tD,KAAA20C,EAAAj4C,KACAyyC,SAAAuO,GAAA71C,MAAA+mC,EAAAO,UACAN,aAAAD,EAAAC,aACAC,eAAAF,EAAAE,oBAKAq+B,GAAAxf,eACA3tD,KAAA20C,EAAAj4C,KACAyyC,SAAAwF,EAAAxF,SACAN,aAAA8F,EAAA9F,aACAC,eAAA6F,EAAA7F,eAKA6F,GAAAgZ,cAAAwf,EAAAxf,cAEArhB,EAAAw9B,GAAApV,eAAA/f,EAAAqC,EAAAj7C,GAEAoxE,EAAA7gC,UACAqI,EAAArI,UAIA,GAAAtvB,GAAAsvB,EAAAqlB,eAEA,IAAAhd,EAAA4C,aAAA,CAEA5C,EAAA04B,yBAAA,CAEA,QAAAjwE,GAAA,EAAoBA,EAAAgvE,GAAAjY,gBAA2B/2D,IAE/C4f,EAAA,cAAA5f,IAAA,GAEAu3C,EAAA04B,2BAQA,GAAA14B,EAAA6C,aAAA,CAEA7C,EAAA24B,yBAAA,CAEA,QAAAlwE,GAAA,EAAoBA,EAAAgvE,GAAAhY,gBAA2Bh3D,IAE/C4f,EAAA,cAAA5f,IAAA,GAEAu3C,EAAA24B,2BAQA,GAAAn+B,GAAAg+B,EAAAxf,cAAAxe,UAEAwF,EAAA2b,kBACA3b,EAAAqa,sBACAra,EAAA0C,YAAA,IAEA81B,EAAAzd,kBAAAyc,GAAAhF,UACAgG,EAAA/F,gBAAA+E,GAAA/E,gBACAj4B,EAAAgH,eAAAg2B,GAAAnF,SAIAmG,EAAA/4B,MAIA+4B,EAAAI,WAAA7zB,GAAA52B,KAEA6xB,EAAAO,SAIA/F,EAAAq+B,kBAAA9uE,MAAAg7C,GAAA+zB,QACAt+B,EAAAu+B,kBAAAhvE,MAAAg7C,GAAA2a,YACAllB,EAAAw+B,WAAAjvE,MAAAg7C,GAAA6a,KACAplB,EAAAy+B,YAAAlvE,MAAAg7C,GAAA4a,MACAnlB,EAAA0+B,iBAAAnvE,MAAAg7C,GAAA8a,KAEArlB,EAAA2+B,qBAAApvE,MAAAg7C,GAAAo0B,qBACA3+B,EAAA4+B,wBAAArvE,MAAAg7C,GAAAq0B,wBACA5+B,EAAA6+B,cAAAtvE,MAAAg7C,GAAAs0B,cACA7+B,EAAA8+B,iBAAAvvE,MAAAg7C,GAAAu0B,iBACA9+B,EAAA++B,eAAAxvE,MAAAg7C,GAAAw0B,eACA/+B,EAAAg/B,kBAAAzvE,MAAAg7C,GAAAy0B,kBAIA,IAAAC,GAAAjB,EAAA7gC,QAAAmlB,cACA4c,EACAhiC,EAAAiiC,aAAAF,EAAA5mC,IAAA2H,EAEAg+B,GAAAkB,eAIA,QAAAtB,GAAAp4B,GAEAA,EAAAS,OAAAoG,GACAxpC,GAAA4U,QAAA21B,GAAA1L,WACA7+B,GAAA2/B,OAAA4K,GAAA1L,WAEA7+B,GAAA0uD,aAAA/rB,EAAAS,OAAAsG,IAEA/G,EAAAe,eAAA,EACA1jC,GAAAsgC,YAAAqC,EAAApC,SAAAoC,EAAAnC,cAAAmC,EAAAlC,SAAAkC,EAAAjC,SAAAiC,EAAAqB,mBAAArB,EAAAmB,cAAAnB,EAAAoB,cAAApB,EAAAgC,oBACA3kC,GAAAsgC,YAAAmvB,IAEAzvD,GAAAyuD,aAAA9rB,EAAAsB,WACAjkC,GAAA6iC,aAAAF,EAAAG,WACA9iC,GAAA8+B,cAAA6D,EAAAI,YACA/iC,GAAAgxD,cAAAruB,EAAA2B,YACAtkC,GAAAqyD,iBAAA1vB,EAAA6B,cAAA7B,EAAA8B,oBAAA9B,EAAA+B,oBAIA,QAAAs2B,GAAAtzE,EAAA06C,EAAAO,EAAA52C,GAEAwwE,GAAA,CAEA,IAAApB,GAAA7/D,GAAAnL,IAAAwyC,EAEA,IAAA65B,KAEAC,IAAA/0E,IAAA6vE,IAAA,CAEA,GAAAjnD,GACA5oB,IAAA6vE,IACA50B,EAAAt+C,KAAAozE,EAKA0C,IAAA/D,SACAzzB,EAAAwB,eAAAxB,EAAAyB,iBAAAzB,EAAA0B,YACA38C,EAAAyzE,EAAA7qD,GAMAqyB,EAAAf,eAAA,IAEA10C,SAAAiuE,EAAA7gC,QAEAqI,EAAAf,aAAA,EAEKe,EAAAP,KAAA+4B,EAAA/4B,QAELO,EAAAf,aAAA,EAEKe,EAAAO,QAAAi4B,EAAAI,aAAA7zB,GAAA52B,KAEL6xB,EAAAf,aAAA,EAEK10C,SAAAiuE,EAAAzd,mBACLyd,EAAAzd,oBAAAyc,GAAAhF,WACAgG,EAAA/F,kBAAA+E,GAAA/E,kBAEAzyB,EAAAf,aAAA,IAMAe,EAAAf,cAEAs5B,EAAAv4B,EAAAP,EAAAr2C,GACA42C,EAAAf,aAAA,EAIA,IAAA86B,IAAA,EACAC,GAAA,EACAC,GAAA,EAEAtiC,EAAA6gC,EAAA7gC,QACAuiC,EAAAviC,EAAAmlB,cACAqd,EAAA3B,EAAAxf,cAAAxe,QAqBA,IAnBA7C,EAAAj2C,KAAAizE,KAEA/sB,GAAAhM,WAAAjE,WACAg9B,GAAAh9B,EAAAj2C,GAEAq4E,GAAA,EACAC,GAAA,EACAC,GAAA,GAIAj6B,EAAAt+C,KAAAozE,KAEAA,GAAA90B,EAAAt+C,GAEAs4E,GAAA,GAIAD,GAAAh1E,IAAA6vE,GAAA,CA4BA,GA1BAsF,EAAAt0E,IAAAgiD,GAAA7iD,EAAA,oBAEAkgD,GAAA4S,wBAEAqiB,EAAArjC,SAAA+Q,GAAA,gBACA,GAAAnjD,KAAAk4D,IAAA53D,EAAA66C,IAAA,GAAAn7C,KAAA21E,MAKAr1E,IAAA6vE,KAEAA,GAAA7vE,EAMAi1E,GAAA,EACAC,GAAA,GAOAj6B,EAAA2b,kBACA3b,EAAAq6B,qBACAr6B,EAAAs6B,wBACAt6B,EAAA4N,OAAA,CAEA,GAAA2sB,GAAAL,EAAAjnE,IAAAunE,cAEAjwE,UAAAgwE,GAEAA,EAAA1jC,SAAA+Q,GACAovB,GAAA7sB,sBAAAplD,EAAAs3C,eAMA2D,EAAAq6B,qBACAr6B,EAAAy6B,uBACAz6B,EAAA06B,qBACA16B,EAAAs6B,wBACAt6B,EAAA2b,kBACA3b,EAAA2C,WAEAu3B,EAAArjC,SAAA+Q,GAAA,aAAA7iD,EAAAw3C,oBAIA29B,EAAAt0E,IAAAgiD,GAAA6vB,GAAA,uBACAyC,EAAAt0E,IAAAgiD,GAAA6vB,GAAA,yBAQA,GAAAz3B,EAAA2C,SAAA,CAEAu3B,EAAAS,YAAA/yB,GAAAx+C,EAAA,cACA8wE,EAAAS,YAAA/yB,GAAAx+C,EAAA,oBAEA,IAAAo0D,GAAAp0D,EAAAo0D,QAEAA,KAEAvY,GAAAsY,qBAAAC,EAAA5C,kBAEAsf,EAAAt0E,IAAAgiD,GAAA4V,EAAA,eACA0c,EAAAt0E,IAAAgiD,GAAA4V,EAAA,oBACA0c,EAAAt0E,IAAAgiD,GAAA4V,EAAA,sBAIA0c,EAAAS,YAAA/yB,GAAA4V,EAAA,iBAsGA,MA9FAwc,KAEAh6B,EAAAO,QAWAq6B,EAAAT,EAAAF,GAMAx6B,GAAAO,EAAAP,KAEAo7B,EAAAV,EAAA16B,IAIAO,EAAA06B,qBACA16B,EAAAy6B,uBACAz6B,EAAAq6B,qBACAr6B,EAAAs6B,wBACAt6B,EAAA86B,sBAEAC,EAAAZ,EAAAn6B,GAMAA,EAAAg7B,oBAEAC,EAAAd,EAAAn6B,GAEKA,EAAAk7B,sBAELD,EAAAd,EAAAn6B,GACAm7B,EAAAhB,EAAAn6B,IAEKA,EAAAo7B,iBAELC,EAAAlB,EAAAn6B,GAEKA,EAAAy6B,sBAELa,EAAAnB,EAAAn6B,GAEKA,EAAAq6B,oBAELkB,EAAApB,EAAAn6B,GAEKA,EAAAw7B,uBAELC,EAAAtB,EAAAn6B,GAEKA,EAAAs6B,uBAELoB,EAAAvB,EAAAn6B,GAEKA,EAAA86B,oBAEL96B,EAAA2D,kBAEAw2B,EAAAx2B,gBAAA55C,MAAAi2C,EAAA2D,gBACAw2B,EAAAv2B,kBAAA75C,MAAAi2C,EAAA4D,kBACAu2B,EAAAt2B,iBAAA95C,MAAAi2C,EAAA6D,kBAIK7D,EAAA27B,uBAELxB,EAAA3jE,QAAAzM,MAAAi2C,EAAAxpC,SAIAkhC,EAAAkkC,OACAh0B,GAAA4wB,EAAAkB,aAAAS,EAAA1C,KAOAyC,EAAAt0E,IAAAgiD,GAAAx+C,EAAA,mBACA8wE,EAAAt0E,IAAAgiD,GAAAx+C,EAAA,gBACA8wE,EAAArjC,SAAA+Q,GAAA,cAAAx+C,EAAAizC,aAEA1E,EAMA,QAAAojC,GAAAvgC,EAAAwF,GAEAxF,EAAAhkC,QAAAzM,MAAAi2C,EAAAxpC,QAEAgkC,EAAAqhC,QAAA9xE,MAAAi2C,EAAArF,MAEAqF,EAAA87B,UAEAthC,EAAAshC,SAAA/xE,MAAAqV,KAAA4gC,EAAA87B,UAAAxH,eAAAt0B,EAAA+7B,mBAIAvhC,EAAAvnC,IAAAlJ,MAAAi2C,EAAA/sC,IACAunC,EAAAmT,YAAA5jD,MAAAi2C,EAAA2N,YACAnT,EAAAkJ,SAAA35C,MAAAi2C,EAAA0D,SAEA1D,EAAAyN,QAEAjT,EAAAiT,MAAA1jD,MAAAi2C,EAAAyN,MACAjT,EAAAkT,eAAA3jD,MAAAi2C,EAAA0N,eAYA,IAAAsuB,EAwCA,IAtCAh8B,EAAA/sC,IAEA+oE,EAAAh8B,EAAA/sC,IAEI+sC,EAAA2N,YAEJquB,EAAAh8B,EAAA2N,YAEI3N,EAAA2D,gBAEJq4B,EAAAh8B,EAAA2D,gBAEI3D,EAAA2X,UAEJqkB,EAAAh8B,EAAA2X,UAEI3X,EAAA0X,QAEJskB,EAAAh8B,EAAA0X,QAEI1X,EAAA0a,aAEJshB,EAAAh8B,EAAA0a,aAEI1a,EAAA2a,aAEJqhB,EAAAh8B,EAAA2a,aAEI3a,EAAA0D,SAEJs4B,EAAAh8B,EAAA0D,SAEI1D,EAAAya,cAEJuhB,EAAAh8B,EAAAya,aAIAlwD,SAAAyxE,EAAA,CAGAA,EAAAhe,sBAEAge,IAAAtqC,QAIA,IAAApE,GAAA0uC,EAAA1uC,OACAwD,EAAAkrC,EAAAlrC,MAEA0J,GAAAyhC,aAAAlyE,MAAAnE,IAAA0nC,EAAAroC,EAAAqoC,EAAApoC,EAAA4rC,EAAA7rC,EAAA6rC,EAAA5rC,GAIAs1C,EAAAoT,OAAA7jD,MAAAi2C,EAAA4N,OAMApT,EAAA0hC,WAAAnyE,MAAAi2C,EAAA4N,QAAA5N,EAAA4N,OAAAuuB,eAAA,IAEA3hC,EAAAuT,aAAAhkD,MAAAi2C,EAAA+N,aACAvT,EAAAwT,gBAAAjkD,MAAAi2C,EAAAgO,gBAIA,QAAAitB,GAAAzgC,EAAAwF,GAEAxF,EAAAqhC,QAAA9xE,MAAAi2C,EAAArF,MACAH,EAAAhkC,QAAAzM,MAAAi2C,EAAAxpC,QAIA,QAAA2kE,GAAA3gC,EAAAwF,GAEAxF,EAAA4hC,SAAAryE,MAAAi2C,EAAAo8B,SACA5hC,EAAA6hC,UAAAtyE,MAAAi2C,EAAAo8B,SAAAp8B,EAAAs8B,QACA9hC,EAAAxuC,MAAAjC,MAAAi2C,EAAAh0C,MAIA,QAAAqvE,GAAA7gC,EAAAwF,GASA,GAPAxF,EAAAqhC,QAAA9xE,MAAAi2C,EAAArF,MACAH,EAAAhkC,QAAAzM,MAAAi2C,EAAAxpC,QACAgkC,EAAAvE,KAAAlsC,MAAAi2C,EAAA/J,KAAA+9B,GACAx5B,EAAAxuC,MAAAjC,MAAA,GAAAwyE,GAEA/hC,EAAAvnC,IAAAlJ,MAAAi2C,EAAA/sC,IAEA,OAAA+sC,EAAA/sC,IAAA,CAEA,GAAAq6B,GAAA0S,EAAA/sC,IAAAq6B,OACAwD,EAAAkP,EAAA/sC,IAAA69B,MAEA0J,GAAAyhC,aAAAlyE,MAAAnE,IAAA0nC,EAAAroC,EAAAqoC,EAAApoC,EAAA4rC,EAAA7rC,EAAA6rC,EAAA5rC,IAMA,QAAA21E,GAAArgC,EAAAiF,GAEAjF,EAAAkE,SAAA30C,MAAA01C,EAAA9E,MAEA8E,EAAAC,OAEAlF,EAAAgE,QAAAz0C,MAAA01C,EAAAE,KACAnF,EAAAiE,OAAA10C,MAAA01C,EAAAG,KAEIH,EAAAI,YAEJrF,EAAA+D,WAAAx0C,MAAA01C,EAAAK,SAMA,QAAAw7B,GAAA9gC,EAAAwF,GAEAA,EAAAwa,WAEAhgB,EAAAggB,SAAAzwD,MAAAi2C,EAAAwa,SACAhgB,EAAAgiC,kBAAAzyE,MAAAi2C,EAAAw8B,mBAIAx8B,EAAAya,cAEAjgB,EAAAigB,YAAA1wD,MAAAi2C,EAAAya,aAMA,QAAA8gB,GAAA/gC,EAAAwF,GAEAxF,EAAAiiC,SAAA1yE,MAAAi2C,EAAAy8B,SACAjiC,EAAAkiC,UAAA3yE,MAAAtF,KAAAoQ,IAAAmrC,EAAA08B,UAAA,MAEA18B,EAAAwa,WAEAhgB,EAAAggB,SAAAzwD,MAAAi2C,EAAAwa,SACAhgB,EAAAgiC,kBAAAzyE,MAAAi2C,EAAAw8B,mBAIAx8B,EAAAya,cAEAjgB,EAAAigB,YAAA1wD,MAAAi2C,EAAAya,aAIAza,EAAA0X,UAEAld,EAAAkd,QAAA3tD,MAAAi2C,EAAA0X,QACAld,EAAAmiC,UAAA5yE,MAAAi2C,EAAA28B,WAIA38B,EAAA2X,YAEAnd,EAAAmd,UAAA5tD,MAAAi2C,EAAA2X,UACAnd,EAAAoiC,YAAA7yE,MAAAqV,KAAA4gC,EAAA48B,cAIA58B,EAAA2D,kBAEAnJ,EAAAmJ,gBAAA55C,MAAAi2C,EAAA2D,gBACAnJ,EAAAoJ,kBAAA75C,MAAAi2C,EAAA4D,kBACApJ,EAAAqJ,iBAAA95C,MAAAi2C,EAAA6D,kBAMA,QAAA63B,GAAAlhC,EAAAwF,GAEAxF,EAAAqiC,UAAA9yE,MAAAi2C,EAAA68B,UACAriC,EAAAsiC,UAAA/yE,MAAAi2C,EAAA88B,UAEA98B,EAAA0a,eAEAlgB,EAAAkgB,aAAA3wD,MAAAi2C,EAAA0a,cAIA1a,EAAA2a,eAEAngB,EAAAmgB,aAAA5wD,MAAAi2C,EAAA2a,cAIA3a,EAAAwa,WAEAhgB,EAAAggB,SAAAzwD,MAAAi2C,EAAAwa,SACAhgB,EAAAgiC,kBAAAzyE,MAAAi2C,EAAAw8B,mBAIAx8B,EAAAya,cAEAjgB,EAAAigB,YAAA1wD,MAAAi2C,EAAAya,aAIAza,EAAA0X,UAEAld,EAAAkd,QAAA3tD,MAAAi2C,EAAA0X,QACAld,EAAAmiC,UAAA5yE,MAAAi2C,EAAA28B,WAIA38B,EAAA2X,YAEAnd,EAAAmd,UAAA5tD,MAAAi2C,EAAA2X,UACAnd,EAAAoiC,YAAA7yE,MAAAqV,KAAA4gC,EAAA48B,cAIA58B,EAAA2D,kBAEAnJ,EAAAmJ,gBAAA55C,MAAAi2C,EAAA2D,gBACAnJ,EAAAoJ,kBAAA75C,MAAAi2C,EAAA4D,kBACApJ,EAAAqJ,iBAAA95C,MAAAi2C,EAAA6D,kBAIA7D,EAAA4N,SAGApT,EAAAuiC,gBAAAhzE,MAAAi2C,EAAA+8B,iBAMA,QAAAtB,GAAAjhC,EAAAwF,GAEAxF,EAAAwiC,UAAAjzE,MAAAi2C,EAAAg9B,UACAxiC,EAAAyiC,mBAAAlzE,MAAAi2C,EAAAi9B,mBAEAvB,EAAAlhC,EAAAwF,GAMA,QAAA46B,GAAApgC,EAAAzwC,GAEAywC,EAAAq+B,kBAAA55B,YAAAl1C,EAEAywC,EAAAu+B,kBAAA95B,YAAAl1C,EACAywC,EAAAy+B,YAAAh6B,YAAAl1C,EACAywC,EAAAw+B,WAAA/5B,YAAAl1C,EACAywC,EAAA0+B,iBAAAj6B,YAAAl1C,EAMA,QAAAmzE,GAAA38B,GAIA,OAFA48B,GAAA,EAEA10E,EAAA,EAAA2F,EAAAmyC,EAAAz4C,OAAsCW,EAAA2F,EAAO3F,IAAA,CAE7C,GAAAghD,GAAAlJ,EAAA93C,EAEAghD,GAAA5jD,aAEAk/C,GAAAiD,QAAAm1B,KAAA1zB,GAMA1E,GAAAiD,QAAAlgD,OAAAq1E,EAIA,QAAAC,GAAA78B,EAAAx7C,GAEA,GAAAqJ,GAAAivE,EAAA5zB,EAEA9O,EACA2iC,EACA9nB,EACAlxD,EAJA6uC,EAAA,EAAAiB,EAAA,EAAAnxB,EAAA,EAMA+vD,EAAAjuE,EAAAw3C,mBAEAghC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,CAEA,KAAAtvE,EAAA,EAAAivE,EAAA98B,EAAAz4C,OAAmCsG,EAAAivE,EAAQjvE,IAU3C,GARAq7C,EAAAlJ,EAAAnyC,GAEAusC,EAAA8O,EAAA9O,MACA2iC,EAAA7zB,EAAA6zB,UACA9nB,EAAA/L,EAAA+L,SAEAlxD,EAAAmlD,EAAAC,QAAAD,EAAAC,OAAAz2C,IAAAw2C,EAAAC,OAAAz2C,IAAAy+B,QAAA,KAEA+X,EAAAk0B,eAEAxqC,GAAAwH,EAAAxH,EAAAmqC,EACAlpC,GAAAuG,EAAAvG,EAAAkpC,EACAr6D,GAAA03B,EAAA13B,EAAAq6D,MAEK,IAAA7zB,EAAAm0B,mBAAA,CAEL,GAAApjC,GAAAqjC,GAAArwE,IAAAi8C,EAEAjP,GAAAG,MAAAv7B,KAAAqqC,EAAA9O,OAAA25B,eAAA7qB,EAAA6zB,WACA9iC,EAAAkR,UAAAvB,sBAAAV,EAAApN,aACA26B,GAAA7sB,sBAAAV,EAAA7tC,OAAAygC,aACA7B,EAAAkR,UAAAoyB,IAAA9G,IACAx8B,EAAAkR,UAAAqyB,mBAAA/K,GAEAx4B,EAAAkP,OAAAD,EAAA5jD,WAEA4jD,EAAA5jD,aAEA20C,EAAA6a,WAAA5L,EAAAC,OAAAs0B,KACAxjC,EAAA8a,aAAA7L,EAAAC,OAAAzF,OACAzJ,EAAA+a,cAAA9L,EAAAC,OAAAC,SAIA5E,GAAAo0B,qBAAAoE,GAAAj5E,EACAygD,GAAAq0B,wBAAAmE,GAAA9zB,EAAAC,OAAAQ,OACAnF,GAAA2a,YAAA6d,KAAA/iC,MAEK,IAAAiP,EAAAw0B,YAAA,CAEL,GAAAzjC,GAAAqjC,GAAArwE,IAAAi8C,EAEAjP,GAAAx3C,SAAAmnD,sBAAAV,EAAApN,aACA7B,EAAAx3C,SAAAs5C,aAAA02B,GAEAx4B,EAAAG,MAAAv7B,KAAAu7B,GAAA25B,eAAAgJ,GACA9iC,EAAAgb,WAEAhb,EAAAkR,UAAAvB,sBAAAV,EAAApN,aACA26B,GAAA7sB,sBAAAV,EAAA7tC,OAAAygC,aACA7B,EAAAkR,UAAAoyB,IAAA9G,IACAx8B,EAAAkR,UAAAqyB,mBAAA/K,GAEAx4B,EAAAib,QAAAhxD,KAAAs8B,IAAA0oB,EAAAy0B,OACA1jC,EAAAkb,YAAAjxD,KAAAs8B,IAAA0oB,EAAAy0B,OAAA,EAAAz0B,EAAA00B,WACA3jC,EAAAmb,MAAA,IAAAlM,EAAA+L,SAAA,EAAA/L,EAAAkM,MAEAnb,EAAAkP,OAAAD,EAAA5jD,WAEA4jD,EAAA5jD,aAEA20C,EAAA6a,WAAA5L,EAAAC,OAAAs0B,KACAxjC,EAAA8a,aAAA7L,EAAAC,OAAAzF,OACAzJ,EAAA+a,cAAA9L,EAAAC,OAAAC,SAIA5E,GAAAs0B,cAAAoE,GAAAn5E,EACAygD,GAAAu0B,iBAAAmE,GAAAh0B,EAAAC,OAAAQ,OACAnF,GAAA6a,KAAA6d,KAAAjjC,MAEK,IAAAiP,EAAAtE,aAAA,CAEL,GAAA3K,GAAAqjC,GAAArwE,IAAAi8C,EAEAjP,GAAAx3C,SAAAmnD,sBAAAV,EAAApN,aACA7B,EAAAx3C,SAAAs5C,aAAA02B,GAEAx4B,EAAAG,MAAAv7B,KAAAqqC,EAAA9O,OAAA25B,eAAA7qB,EAAA6zB,WACA9iC,EAAAgb,SAAA/L,EAAA+L,SACAhb,EAAAmb,MAAA,IAAAlM,EAAA+L,SAAA,EAAA/L,EAAAkM,MAEAnb,EAAAkP,OAAAD,EAAA5jD,WAEA4jD,EAAA5jD,aAEA20C,EAAA6a,WAAA5L,EAAAC,OAAAs0B,KACAxjC,EAAA8a,aAAA7L,EAAAC,OAAAzF,OACAzJ,EAAA+a,cAAA9L,EAAAC,OAAAC,SAIA5E,GAAAw0B,eAAAiE,GAAAl5E,EAEAiG,SAAAw6C,GAAAy0B,kBAAAgE,KAEAz4B,GAAAy0B,kBAAAgE,GAAA,GAAAjrC,IAMAykC,GAAA7sB,sBAAAV,EAAApN,aAAA+hC,SACAr5B,GAAAy0B,kBAAAgE,GAAAa,WAAAC,YAAAtH,IAEAjyB,GAAA4a,MAAA6d,KAAAhjC,MAEK,IAAAiP,EAAA80B,kBAAA,CAEL,GAAA/jC,GAAAqjC,GAAArwE,IAAAi8C,EAEAjP,GAAAkR,UAAAvB,sBAAAV,EAAApN,aACA7B,EAAAkR,UAAAqyB,mBAAA/K,GACAx4B,EAAAkR,UAAA8yB,YAEAhkC,EAAAob,SAAAx2C,KAAAqqC,EAAA9O,OAAA25B,eAAAgJ,GACA9iC,EAAAqb,YAAAz2C,KAAAqqC,EAAAoM,aAAAye,eAAAgJ,GAEAv4B,GAAA8a,KAAA6d,KAAAljC,EAMAuK,GAAA+zB,QAAA,GAAA3lC,EACA4R,GAAA+zB,QAAA,GAAA1kC,EACA2Q,GAAA+zB,QAAA,GAAA71D,EAEA8hC,GAAA2a,YAAA53D,OAAAy1E,EACAx4B,GAAA6a,KAAA93D,OAAA21E,EACA14B,GAAA4a,MAAA73D,OAAA01E,EACAz4B,GAAA8a,KAAA/3D,OAAA41E,EAEA34B,GAAA52B,KAAAovD,EAAA,IAAAC,EAAA,IAAAC,EAAA,IAAAC,EAAA,IAAA34B,GAAAiD,QAAAlgD,OAeA,QAAA0rC,KAEA,GAAAirC,GAAA7E,EAUA,OARA6E,IAAAx5B,GAAAkrB,aAEAj8C,QAAAC,KAAA,gCAAAsqD,EAAA,+CAAAx5B,GAAAkrB,aAIAyJ,IAAA,EAEA6E,EAiPA,QAAAvc,GAAAngE,GAEA,GAAA8yD,EAEA,IAAA9yD,IAAA28E,GAAA,MAAA92B,IAAA+2B,MACA,IAAA58E,IAAA0uC,GAAA,MAAAmX,IAAAjO,aACA,IAAA53C,IAAA68E,GAAA,MAAAh3B,IAAAi3B,eAEA,IAAA98E,IAAAgoD,GAAA,MAAAnC,IAAA9N,OACA,IAAA/3C,IAAA+gE,GAAA,MAAAlb,IAAAk3B,sBACA,IAAA/8E,IAAAghE,GAAA,MAAAnb,IAAAm3B,qBAEA,IAAAh9E,IAAA2uC,GAAA,MAAAkX,IAAAob,MACA,IAAAjhE,IAAAi9E,GAAA,MAAAp3B,IAAAq3B,qBACA,IAAAl9E,IAAA4uC,GAAA,MAAAiX,IAAAs3B,oBAEA,IAAAn9E,IAAA8uC,GAAA,MAAA+W,IAAApO,aACA,IAAAz3C,IAAAo9E,GAAA,MAAAv3B,IAAAw3B,sBACA,IAAAr9E,IAAAs9E,GAAA,MAAAz3B,IAAA03B,sBACA,IAAAv9E,IAAAw9E,GAAA,MAAA33B,IAAA43B,oBAEA,IAAAz9E,IAAA09E,GAAA,MAAA73B,IAAAkuB,IACA,IAAA/zE,IAAA29E,GAAA,MAAA93B,IAAAguB,KACA,IAAA7zE,IAAA49E,GAAA,MAAA/3B,IAAAxK,cACA,IAAAr7C,IAAA69E,GAAA,MAAAh4B,IAAAiuB,GACA,IAAA9zE,IAAA89E,GAAA,MAAAj4B,IAAA8M,YACA,IAAA3yD,IAAA4jE,GAAA,MAAA/d,IAAA3L,KAEA,IAAAl6C,IAAA6jE,KAEA/Q,EAAA/R,GAAAt1C,IAAA,0BAEA,OAAAqnD,GAAA,MAAAA,GAAAirB,cAIA,IAAA/9E,IAAAg+E,GAAA,MAAAn4B,IAAAo4B,KACA,IAAAj+E,IAAAqjE,GAAA,MAAAxd,IAAArO,GACA,IAAAx3C,IAAA6uC,GAAA,MAAAgX,IAAA5N,IACA,IAAAj4C,IAAAk+E,GAAA,MAAAr4B,IAAAs4B,SACA,IAAAn+E,IAAAo+E,GAAA,MAAAv4B,IAAAw4B,eACA,IAAAr+E,IAAA+lE,GAAA,MAAAlgB,IAAAye,eACA,IAAAtkE,IAAA0kE,GAAA,MAAA7e,IAAA8e,aAEA,IAAA3kE,IAAAm/C,GAAA,MAAA0G,IAAAulB,QACA,IAAAprE,IAAAs+E,GAAA,MAAAz4B,IAAA04B,aACA,IAAAv+E,IAAAw+E,GAAA,MAAA34B,IAAA44B,qBAEA,IAAAz+E,IAAA0+E,GAAA,MAAA74B,IAAA6lB,IACA,IAAA1rE,IAAA2+E,GAAA,MAAA94B,IAAAylB,GACA,IAAAtrE,IAAA4+E,GAAA,MAAA/4B,IAAAimB,SACA,IAAA9rE,IAAA6+E,GAAA,MAAAh5B,IAAA8lB,mBACA,IAAA3rE,IAAAi/C,GAAA,MAAA4G,IAAA2lB,SACA,IAAAxrE,IAAAk/C,GAAA,MAAA2G,IAAA+lB,mBACA,IAAA5rE,IAAA8+E,GAAA,MAAAj5B,IAAAk5B,SACA,IAAA/+E,IAAAg/E,GAAA,MAAAn5B,IAAAo5B,mBAEA,IAAAj/E,IAAAk/E,GAAA,MAAAr5B,IAAAs5B,SACA,IAAAn/E,IAAAo/E,GAAA,MAAAv5B,IAAAw5B,mBACA,IAAAr/E,IAAAs/E,GAAA,MAAAz5B,IAAA05B,kBAEA,KAAAv/E,IAAAw/E,IAAAx/E,IAAAy/E,IACAz/E,IAAA0/E,IAAA1/E,IAAA2/E,MAEA7sB,EAAA/R,GAAAt1C,IAAA,iCAEA,OAAAqnD,GAAA,CAEA,GAAA9yD,IAAAw/E,GAAA,MAAA1sB,GAAA8sB,4BACA,IAAA5/E,IAAAy/E,GAAA,MAAA3sB,GAAA+sB,6BACA,IAAA7/E,IAAA0/E,GAAA,MAAA5sB,GAAAgtB,6BACA,IAAA9/E,IAAA2/E,GAAA,MAAA7sB,GAAAitB,8BAMA,IAAA//E,IAAAggF,IAAAhgF,IAAAigF,IACAjgF,IAAAkgF,IAAAlgF,IAAAmgF,MAEArtB,EAAA/R,GAAAt1C,IAAA,kCAEA,OAAAqnD,GAAA,CAEA,GAAA9yD,IAAAggF,GAAA,MAAAltB,GAAAstB,+BACA,IAAApgF,IAAAigF,GAAA,MAAAntB,GAAAutB,+BACA,IAAArgF,IAAAkgF,GAAA,MAAAptB,GAAAwtB,gCACA,IAAAtgF,IAAAmgF,GAAA,MAAArtB,GAAAytB,iCAMA,GAAAvgF,IAAAwgF,KAEA1tB,EAAA/R,GAAAt1C,IAAA,iCAEA,OAAAqnD,GAAA,MAAAA,GAAA2tB,yBAIA,KAAAzgF,IAAA0gF,IAAA1gF,IAAA2gF,MAEA7tB,EAAA/R,GAAAt1C,IAAA,oBAEA,OAAAqnD,GAAA,CAEA,GAAA9yD,IAAA0gF,GAAA,MAAA5tB,GAAA8tB,OACA,IAAA5gF,IAAA2gF,GAAA,MAAA7tB,GAAA+tB,QAMA,MAAA7gF,KAAA8gF,KAEAhuB,EAAA/R,GAAAt1C,IAAA,uBAEA,OAAAqnD,KAAAiuB,wBAIA,EAtuFA5uD,QAAAyoC,IAAA,sBAAAomB,IAEA1gC,OAEA,IAAA2gC,GAAAz4E,SAAA83C,EAAAzD,OAAAyD,EAAAzD,OAAAz7C,SAAA07C,gBAAA,yCACAokC,EAAA14E,SAAA83C,EAAA10C,QAAA00C,EAAA10C,QAAA,KAEAu1E,EAAA34E,SAAA83C,EAAA8gC,OAAA9gC,EAAA8gC,MACAC,EAAA74E,SAAA83C,EAAAtvB,OAAAsvB,EAAAtvB,MACAswD,EAAA94E,SAAA83C,EAAAupB,SAAAvpB,EAAAupB,QACA0X,EAAA/4E,SAAA83C,EAAAkhC,WAAAlhC,EAAAkhC,UACArP,EAAA3pE,SAAA83C,EAAAL,oBAAAK,EAAAL,mBACAwhC,EAAAj5E,SAAA83C,EAAAohC,uBAAAphC,EAAAohC,sBAEAljC,KAEAs2B,KACAC,IAAA,EACAH,MACAC,IAAA,EAEA8M,GAAA,GAAAlxC,cAAA,GAEA0L,MACAT,KAIA95C,MAAAb,WAAAkgF,EACAr/E,KAAAgK,QAAA,KAIAhK,KAAAggF,WAAA,EACAhgF,KAAAigF,gBAAA,EACAjgF,KAAAkgF,gBAAA,EACAlgF,KAAAmgF,kBAAA,EAIAngF,KAAAq0E,aAAA,EAIAr0E,KAAA69C,kBACA79C,KAAA0iD,sBAAA,EAIA1iD,KAAAu2D,YAAA,EACAv2D,KAAA07D,YAAA,EACA17D,KAAAy7D,aAAA,EAIAz7D,KAAA03D,yBAAA,EAIA13D,KAAAqzD,YAAAE,GACAvzD,KAAAogF,oBAAA,EACApgF,KAAAqgF,sBAAA,EAIArgF,KAAA67D,gBAAA,EACA77D,KAAA87D,gBAAA,CAIA,IAAAgY,IAAA9zE,KAIAgxE,GAAA,KACAZ,GAAA,KACAkQ,GAAA,KACAnP,IAAA,EACAD,GAAA,GACAD,GAAA,KAEAR,GAAA,GAAA/iC,GACA6yC,GAAA,KAEA3P,GAAA,GAAAljC,GAIAuoC,GAAA,EAIAnF,GAAA,GAAAvwE,GAAA,GACAwwE,GAAA,EAEAyP,GAAAnB,EAAAx8E,MACA+1E,GAAAyG,EAAAv8E,OAEAutE,GAAA,EAEAK,GAAA,GAAAhjC,GAAA,IAAA8yC,GAAA5H,IACA6H,IAAA,EAEA5P,GAAA,GAAAnjC,GAAA,IAAA8yC,GAAA5H,IAIA90B,GAAA,GAAApD,IAIAmzB,GAAA,GAAArF,IACA0H,IAAA,EACAC,IAAA,EAEA3C,GAAA,GAAApzB,IAIA+D,GAAA,GAAAvV,GAEAykC,GAAA,GAAA1kC,GAIAyS,IAEA52B,KAAA,GAEA2qD,SAAA,OACApZ,eACAyZ,wBACAC,2BACAxZ,QACAyZ,iBACAC,oBACA3Z,SACA4Z,kBACAC,qBACA3Z,QAEA7X,YAMAq8B,IAEA1vB,MAAA,EACArc,SAAA,EACAC,MAAA,EACA+rC,OAAA,EAIA3gF,MAAAm0C,MAEAxxC,OAAA+9E,GACA1yD,QAEA2uC,WAAA,EACA8C,SAAA,GAGAnF,SAAA,KAOA,IAAArW,GAEA,KAEA,GAAAv/B,KACA86D,MAAAD,EACAnwD,MAAAqwD,EACAxX,QAAAyX,EACAE,UAAAD,EACAthC,mBAAAkyB,EACAuP,sBAAAD,EAKA,IAFA57B,GAAAq7B,GAAAD,EAAAlkC,WAAA,QAAAz2B,KAAA26D,EAAAlkC,WAAA,qBAAAz2B,IAEA,OAAAu/B,GAEA,aAAAo7B,EAAAlkC,WAAA,SAEA,8DAIA,+BAQAv0C,UAAAq9C,GAAAspB,2BAEAtpB,GAAAspB,yBAAA,WAEA,OAAaqT,SAAA,EAAAC,SAAA,EAAA5iC,UAAA,KAMbohC,EAAAv4D,iBAAA,mBAAAsqD,GAAA,GAEG,MAAAz3D,GAEH4W,QAAA5W,MAAA,wBAAAA,GAIA,GAAAwlC,IAAA,GAAAmvB,IAAArqB,GAEA9E,IAAAt1C,IAAA,uBACAs1C,GAAAt1C,IAAA,qBACAs1C,GAAAt1C,IAAA,4BACAs1C,GAAAt1C,IAAA,0BACAs1C,GAAAt1C,IAAA,iCACAs1C,GAAAt1C,IAAA,4BACAs1C,GAAAt1C,IAAA,0BAEAs1C,GAAAt1C,IAAA,4BAEAujD,GAAA0zB,SAAA,WAIA,IAAAx/B,IAAA,GAAA8rB,IAAAnpB,GAAA9E,GAAAT,GAEAhlC,GAAA,GAAAorD,IAAA7gB,GAAA9E,GAAAof,GACAvpD,GAAA,GAAA6vD,IACApF,GAAA,GAAAnB,IAAAra,GAAA9E,GAAAzlC,GAAA1E,GAAAssC,GAAAid,EAAAv+D,KAAAm0C,MACAi+B,GAAA,GAAA3U,IAAAxZ,GAAAjvC,GAAAhV,KAAAm0C,MACAq9B,GAAA,GAAA9X,IAAA15D,KAAAshD,IACA44B,GAAA,GAAAzoB,GAEAzxD,MAAAm0C,KAAAmmB,SAAAkX,GAAAlX,QAEA,IAAAymB,IAAA,GAAA1vB,IAAApN,GAAA9E,GAAAuhC,IACAM,GAAA,GAAApwB,IAAA3M,GAAA9E,GAAAuhC,IAIAO,GAAA,GAAAxwB,KAAA,cACAywB,GAAA,GAAA7/E,IACA8/E,GAAA,GAAA7zB,IACA,GAAAyC,IAAA,KACA,GAAAlG,KAA2BrN,WAAA,EAAAC,YAAA,EAAAX,KAAA,KAE3BslC,GAAAl8B,GAAA,KACAm8B,GAAA,GAAA/zB,IACA,GAAAI,IAAA,OACA,GAAAjP,IACA5H,SAAAuqC,GAAAvqC,SACAN,aAAA6qC,GAAA7qC,aACAC,eAAA4qC,GAAA5qC,eACAsG,KAAAsG,GACA5G,WAAA,EACAC,YAAA,EACAX,KAAA,IA+CA00B,KAEAxwE,KAAAgK,QAAAi6C,GACAjkD,KAAAshD,gBACAthD,KAAAm/C,cACAn/C,KAAAgV,cACAhV,KAAA0Z,QAIA,IAAA/Y,IAAA,GAAAugD,IAAAlhD,KAAAohD,GAAAgxB,GAAA9wB,GAEAthD,MAAAW,YAKA,IAAA2gF,IAAA,GAAAhnC,GAAAt6C,KAAAu6C,IACAgnC,GAAA,GAAA9sC,GAAAz0C,KAAA85C,GAIA95C,MAAAm7C,WAAA,WAEA,MAAA8I,KAIAjkD,KAAAwhF,qBAAA,WAEA,MAAAv9B,IAAAu9B,wBAIAxhF,KAAAyhF,iBAAA,WAEAtiC,GAAAt1C,IAAA,sBAAA63E,eAIA1hF,KAAAqiE,iBAAA,WAEA,MAAA/gB,IAAA+gB,oBAIAriE,KAAAs3C,aAAA,WAEA,MAAAgK,IAAArD,WAIAj+C,KAAA2hF,cAAA;AAEA,MAAAtR,KAIArwE,KAAAiB,cAAA,SAAAmF,GAEAQ,SAAAR,IAEAiqE,GAAAjqE,EAEApG,KAAAQ,QAAAqwE,GAAArvE,EAAAqvE,GAAAxtE,GAAA,KAIArD,KAAA4hF,QAAA,WAEA,OACA/+E,MAAA29E,GACA19E,OAAA81E,KAKA54E,KAAAQ,QAAA,SAAAqC,EAAAC,EAAA++E,GAEArB,GAAA39E,EACA+1E,GAAA91E,EAEAu8E,EAAAx8E,QAAAwtE,GACAgP,EAAAv8E,SAAAutE,GAEAwR,KAAA,IAEAxC,EAAAjgF,MAAAyD,QAAA,KACAw8E,EAAAjgF,MAAA0D,SAAA,MAIA9C,KAAA8hF,YAAA,IAAAj/E,EAAAC,IAIA9C,KAAA8hF,YAAA,SAAAxgF,EAAAC,EAAAsB,EAAAC,GAEA4W,GAAAo0B,SAAA+iC,GAAA5uE,IAAAX,EAAAC,EAAAsB,EAAAC,KAIA9C,KAAA+hF,WAAA,SAAAzgF,EAAAC,EAAAsB,EAAAC,GAEA4W,GAAAk0B,QAAA8iC,GAAAzuE,IAAAX,EAAAC,EAAAsB,EAAAC,KAIA9C,KAAA2lD,eAAA,SAAAq8B,GAEAtoE,GAAAisC,eAAA86B,GAAAuB,IAMAhiF,KAAA0nD,cAAA,WAEA,MAAAopB,KAIA9wE,KAAAM,cAAA,SAAA02C,EAAAwoC,GAEA1O,GAAA7uE,IAAA+0C,GAEA+5B,GAAAnqE,SAAA44E,IAAA,EAEAlP,EAAAQ,GAAAthC,EAAAshC,GAAArgC,EAAAqgC,GAAAxxD,EAAAyxD,KAIA/wE,KAAA4nD,cAAA,WAEA,MAAAmpB,KAIA/wE,KAAAiiF,cAAA,SAAAzC,GAEAzO,GAAAyO,EAEAlP,EAAAQ,GAAAthC,EAAAshC,GAAArgC,EAAAqgC,GAAAxxD,EAAAyxD,KAIA/wE,KAAA0mD,MAAA,SAAA1P,EAAA5nB,EAAA64C,GAEA,GAAAia,GAAA,GAEAt7E,SAAAowC,QAAAkrC,GAAAj+B,GAAAk+B,mBACAv7E,SAAAwoB,QAAA8yD,GAAAj+B,GAAAm+B,mBACAx7E,SAAAqhE,QAAAia,GAAAj+B,GAAAo+B,oBAEAp+B,GAAAyC,MAAAw7B,IAIAliF,KAAA0lD,WAAA,WAEA1lD,KAAA0mD,OAAA,UAIA1mD,KAAA6mE,WAAA,WAEA7mE,KAAA0mD,OAAA,UAIA1mD,KAAAkoE,aAAA,WAEAloE,KAAA0mD,OAAA,UAIA1mD,KAAAsiF,YAAA,SAAA3iB,EAAA3oB,EAAA5nB,EAAA64C,GAEAjoE,KAAAymD,gBAAAkZ,GACA3/D,KAAA0mD,MAAA1P,EAAA5nB,EAAA64C,IAMAjoE,KAAAq6C,eAEAr6C,KAAAmgE,QAAA,WAEA6S,MACAC,IAAA,EACAC,KACAC,IAAA,EAEAkM,EAAAv4E,oBAAA,mBAAAsqE,GAAA,IAsDApxE,KAAA20E,sBAAA,SAAAlvE,EAAAuuC,EAAAqI,GAEA3iC,GAAAw+B,gBAEA,IAAAi1B,GAAAn4D,GAAAnL,IAAApE,EAEAA,GAAA88E,eAAApV,EAAA9tE,WAAA8tE,EAAA9tE,SAAA4kD,GAAAlP,gBACAtvC,EAAA+8E,aAAArV,EAAA3sB,SAAA2sB,EAAA3sB,OAAAyD,GAAAlP,gBACAtvC,EAAAg9E,SAAAtV,EAAAv2B,KAAAu2B,EAAAv2B,GAAAqN,GAAAlP,gBACAtvC,EAAAi9E,YAAAvV,EAAAn2B,QAAAm2B,EAAAn2B,MAAAiN,GAAAlP,eAEA,IAAArwB,GAAAsvB,EAAAqlB,eAYA,IAVA5zD,EAAA88E,eAEAt+B,GAAAhP,WAAAgP,GAAA/O,aAAAi4B,EAAA9tE,UACA4kD,GAAA9O,WAAA8O,GAAA/O,aAAAzvC,EAAAk9E,cAAA1+B,GAAA+Z,cAEAtkD,GAAAy+B,gBAAAzzB,EAAArlB,UACA4kD,GAAA5L,oBAAA3zB,EAAArlB,SAAA,EAAA4kD,GAAA3L,OAAA,QAIA7yC,EAAA+8E,WAAA,CAIA,GAFAv+B,GAAAhP,WAAAgP,GAAA/O,aAAAi4B,EAAA3sB,SAEAnE,EAAAq6B,sBACAr6B,EAAAs6B,wBACAt6B,EAAAW,UAAA4e,GAEA,OAAA92D,GAAA,EAAA2F,EAAA,EAAAhF,EAAAwsB,MAA2CntB,EAAA2F,EAAO3F,GAAA,GAElD,GAAAsqC,GAAA3pC,EAAAm9E,YAEAC,GAAAzzC,EAAAtqC,EAAA,GAAAsqC,EAAAtqC,EAAA,GAAAsqC,EAAAtqC,EAAA,MACAg+E,GAAA1zC,EAAAtqC,EAAA,GAAAsqC,EAAAtqC,EAAA,GAAAsqC,EAAAtqC,EAAA,MACAi+E,GAAA3zC,EAAAtqC,EAAA,GAAAsqC,EAAAtqC,EAAA,GAAAsqC,EAAAtqC,EAAA,KAEAsqC,GAAAtqC,EAAA,GAAA+9E,EACAzzC,EAAAtqC,EAAA,GAAAg+E,EACA1zC,EAAAtqC,EAAA,GAAAi+E,EAEA3zC,EAAAtqC,EAAA,GAAA+9E,EACAzzC,EAAAtqC,EAAA,GAAAg+E,EACA1zC,EAAAtqC,EAAA,GAAAi+E,EAEA3zC,EAAAtqC,EAAA,GAAA+9E,EACAzzC,EAAAtqC,EAAA,GAAAg+E,EACA1zC,EAAAtqC,EAAA,GAAAi+E,EAMA9+B,GAAA9O,WAAA8O,GAAA/O,aAAAzvC,EAAAm9E,YAAA3+B,GAAA+Z,cAEAtkD,GAAAy+B,gBAAAzzB,EAAA87B,QAEAyD,GAAA5L,oBAAA3zB,EAAA87B,OAAA,EAAAyD,GAAA3L,OAAA,OAIA7yC,EAAAg9E,QAAApmC,EAAA/sC,MAEA20C,GAAAhP,WAAAgP,GAAA/O,aAAAi4B,EAAAv2B,IACAqN,GAAA9O,WAAA8O,GAAA/O,aAAAzvC,EAAAu9E,QAAA/+B,GAAA+Z,cAEAtkD,GAAAy+B,gBAAAzzB,EAAAkyB,IAEAqN,GAAA5L,oBAAA3zB,EAAAkyB,GAAA,EAAAqN,GAAA3L,OAAA,QAIA7yC,EAAAi9E,WAAArmC,EAAAa,eAAAC,KAEA8G,GAAAhP,WAAAgP,GAAA/O,aAAAi4B,EAAAn2B,OACAiN,GAAA9O,WAAA8O,GAAA/O,aAAAzvC,EAAAw9E,WAAAh/B,GAAA+Z,cAEAtkD,GAAAy+B,gBAAAzzB,EAAAsyB,OAEAiN,GAAA5L,oBAAA3zB,EAAAsyB,MAAA,EAAAiN,GAAA3L,OAAA,QAIA5+B,GAAA0+B,0BAEA6L,GAAAqN,WAAArN,GAAAzK,UAAA,EAAA/zC,EAAAwsB,OAEAxsB,EAAAwsB,MAAA,GAIAjyB,KAAAynD,mBAAA,SAAArmD,EAAA06C,EAAA4F,EAAArF,EAAA52C,EAAA6hD,GAEAmtB,EAAAp4B,EAEA,IAAArI,GAAA0gC,EAAAtzE,EAAA06C,EAAAO,EAAA52C,GAEAy9E,GAAA,EACAC,EAAAzhC,EAAA3jD,GAAA,IAAAi2C,EAAAj2C,GAAA,IAAAs+C,EAAAwC,SAEAskC,KAAAjS,KAEAA,GAAAiS,EACAD,GAAA,EAMA,IAAAE,GAAA39E,EAAA29E,qBAEA,IAAAx8E,SAAAw8E,EAAA,CAIA,OAFAC,MAEAv+E,EAAA,EAAA2F,EAAA24E,EAAAj/E,OAAsDW,EAAA2F,EAAO3F,IAAA,CAE7D,GAAAw+E,GAAAF,EAAAt+E,EACAu+E,GAAAt3E,MAAAu3E,EAAAx+E,IAIAu+E,EAAA9nE,KAAAq3D,GAEAyQ,EAAAl/E,OAAA,IAEAk/E,EAAAl/E,OAAA,EAMA,QAFAg+C,GAAAT,EAAAS,gBAEAr9C,EAAA,EAAA2F,EAAA44E,EAAAl/E,OAAiDW,EAAA2F,EAAO3F,IAAA,CAExD,GAAAw+E,GAAAD,EAAAv+E,EAGA,IAFAi7E,GAAAj7E,GAAAw+E,EAAA,GAEA,IAAAA,EAAA,IAEA,GAAA35E,GAAA25E,EAAA,EAEAjnC,GAAA4C,gBAAA,GAAAkD,EAAA9iD,UAAAqiD,EAAAoO,aAAA,cAAAhrD,EAAAq9C,EAAA9iD,SAAAsK,IACA0yC,EAAA6C,gBAAA,GAAAiD,EAAA3B,QAAAkB,EAAAoO,aAAA,cAAAhrD,EAAAq9C,EAAA3B,OAAA72C,QAIA0yC,GAAA4C,gBAAA,GAAAyC,EAAAn0C,gBAAA,cAAAzI,GACAu3C,EAAA6C,gBAAA,GAAAwC,EAAAn0C,gBAAA,cAAAzI,GAMA,OAAAA,GAAAu+E,EAAAl/E,OAAA0hD,EAAAk6B,GAAA57E,OAAuEW,EAAA+gD,EAAQ/gD,IAE/Ei7E,GAAAj7E,GAAA,CAIAkvC,GAAAmlB,cAAAjmB,SACA+Q,GAAA,wBAAA87B,IAEAmD,GAAA,EAMA,GAAAv5E,GAAA+3C,EAAA/3C,MACAtK,EAAAqiD,EAAAh9B,WAAArlB,SACAkkF,EAAA,CAEAlnC,GAAAwC,aAAA,IAEAl1C,EAAAyoE,GAAAhU,sBAAA1c,GACA6hC,EAAA,EAIA,IAAApjF,EAEA,QAAAwJ,GAEAxJ,EAAA6gF,GACA7gF,EAAA0vD,SAAAlmD,IAIAxJ,EAAA4gF,GAIAmC,IAEAzR,EAAAp1B,EAAArI,EAAA0N,GAEA,OAAA/3C,GAEAs6C,GAAAhP,WAAAgP,GAAA5O,qBAAA+8B,GAAAnV,mBAAAtzD,IAQA,IAAA65E,GAAA,CAEA,QAAA75E,EAEA65E,EAAA75E,EAAAsoB,MAEIrrB,SAAAvH,IAEJmkF,EAAAnkF,EAAA4yB,MAIA,IAAAwxD,GAAA/hC,EAAA2L,UAAAtkD,MAAAw6E,EACAG,EAAAhiC,EAAA2L,UAAAp7B,MAAAsxD,EAEA9zB,EAAA,OAAAnI,IAAAv+C,MAAAw6E,EAAA,EACAv0B,EAAA,OAAA1H,IAAAr1B,MAAAsxD,EAAA/uC,IAEAmvC,EAAA7iF,KAAAoQ,IAAAuyE,EAAAh0B,GACAm0B,EAAA9iF,KAAAC,IAAAyiF,EAAAC,EAAAC,EAAAj0B,EAAAT,GAAA,EAEA60B,EAAA/iF,KAAAoQ,IAAA,EAAA0yE,EAAAD,EAAA,EAEA,QAAAE,EAAA,CAIA,GAAAp+E,EAAAi+C,OAEA,GAAArH,EAAAwC,aAAA,EAEAnlC,GAAAkyD,aAAAvvB,EAAAyC,mBAAAqxB,KACAhwE,EAAAjB,QAAA+kD,GAAA6/B,WAIA,QAAAr+E,EAAA8nD,UAEA,IAAAC,IACArtD,EAAAjB,QAAA+kD,GAAAzK,UACA,MAEA,KAAAuqC,IACA5jF,EAAAjB,QAAA+kD,GAAA+/B,eACA,MAEA,KAAAC,IACA9jF,EAAAjB,QAAA+kD,GAAAigC,kBAQI,IAAAz+E,EAAAk+C,OAAA,CAEJ,GAAAmoB,GAAAzvB,EAAAuC,SAEAh4C,UAAAklE,MAAA,GAEApyD,GAAAkyD,aAAAE,EAAAqE,KAEA1qE,EAAA0+E,eAEAhkF,EAAAjB,QAAA+kD,GAAA6/B,OAIA3jF,EAAAjB,QAAA+kD,GAAAmgC,gBAII3+E,GAAAm+C,UAEJzjD,EAAAjB,QAAA+kD,GAAAogC,OAIA3iC,MAAAiwB,0BAEAjwB,EAAA0P,kBAAA,GAEAjxD,EAAA8wD,gBAAAvP,EAAAiiC,EAAAE,GAMA1jF,EAAAwC,OAAAghF,EAAAE,KA+NA7jF,KAAA2C,OAAA,SAAAzB,EAAAE,EAAAu+D,EAAA2kB,GAEA,GAAA19E,SAAAxF,KAAAmjF,YAAA,EAGA,WADAh0D,SAAA5W,MAAA,yEAOAu3D,IAAA,GACAC,IAAA,EACAF,GAAA,KAIA/vE,EAAAskD,cAAA,GAAAtkD,EAAA4lD,oBAIA,OAAA1lD,EAAA2oB,QAAA3oB,EAAA0lD,oBAEA1lD,EAAAw3C,mBAAAmO,WAAA3lD,EAAAs3C,aAEAyL,GAAA/H,iBAAAh7C,EAAA03C,iBAAA13C,EAAAw3C,oBACAkL,GAAAmD,cAAA9C,IAEAvH,EAAAz4C,OAAA,EAEAgvE,IAAA,EACAF,IAAA,EAEA14B,GAAAp2C,OAAA,EACA21C,GAAA31C,OAAA,EAEAgyE,GAAAn2E,KAAA0iD,qBACAwzB,GAAArC,GAAAl0E,KAAAK,KAAA69C,eAAAs4B,GAAA/0E,GAEAkiD,EAAApiD,EAAAE,GAEA8xE,EAAA/uE,OAAAgvE,GAAA,EACAH,GAAA7uE,OAAA8uE,GAAA,EAEAa,GAAAO,eAAA,IAEAnB,EAAA33D,KAAAggC,GACAy3B,GAAAz3D,KAAAu3D,IAMAoD,IAAArC,GAAAjE,eAEA2J,EAAA38B,GAEAj8C,GAAAgC,OAAAzB,EAAAE,GAEAq4E,EAAA78B,EAAAx7C,GAEA80E,IAAArC,GAAAhE,aAIA6Q,GAAA1vB,MAAA,EACA0vB,GAAA/rC,SAAA,EACA+rC,GAAA9rC,MAAA,EACA8rC,GAAAC,OAAA,EAEA/5E,SAAA+4D,IAEAA,EAAA,MAIA3/D,KAAAymD,gBAAAkZ,EAIA,IAAA6kB,GAAAtjF,EAAAsjF,UA6CA,IA3CA,OAAAA,EAEAlU,EAAAQ,GAAAthC,EAAAshC,GAAArgC,EAAAqgC,GAAAxxD,EAAAyxD,IAEIyT,KAAA56B,UAEJ0mB,EAAAkU,EAAAh1C,EAAAg1C,EAAA/zC,EAAA+zC,EAAAllE,EAAA,GACAglE,GAAA,IAIAtkF,KAAAggF,WAAAsE,IAEAtkF,KAAA0mD,MAAA1mD,KAAAigF,eAAAjgF,KAAAkgF,eAAAlgF,KAAAmgF,kBAIAqE,KAAAhM,eAEA0I,GAAApoC,iBAAAr9B,KAAAra,EAAA03C,kBAEAooC,GAAAxoC,YAAA+rC,gBAAArjF,EAAAs3C,aACAwoC,GAAAtoC,mBAAAmO,WAAAm6B,GAAAxoC,aAEA2oC,GAAAhlC,SAAAxF,SAAA,MAAAzwC,MAAAo+E,EACAnD,GAAA3mC,gBAAA0B,iBAAA8kC,GAAAtoC,mBAAAyoC,GAAA3oC,aAEA05B,GAAAjwE,OAAAk/E,IAEAvN,GAAArsB,mBAAAy5B,GAAA,KAAAG,GAAA3/B,SAAA2/B,GAAAhlC,SAAAglC,GAAA,OAEImD,KAAApqB,YAEJ+mB,GAAA9kC,SAAA/sC,IAAAk1E,EAEApS,GAAAjwE,OAAAg/E,IAEArN,GAAArsB,mBAAAw5B,GAAA,KAAAE,GAAAz/B,SAAAy/B,GAAA9kC,SAAA8kC,GAAA,OAMAjgF,EAAAszE,iBAAA,CAEA,GAAAA,GAAAtzE,EAAAszE,gBAEAF,GAAApB,EAAAhyE,EAAAE,EAAAozE,GACAF,EAAAtB,GAAA9xE,EAAAE,EAAAozE,OAMA96D,IAAAsgC,YAAAmvB,IACAmL,EAAApB,EAAAhyE,EAAAE,GAIAkzE,EAAAtB,GAAA9xE,EAAAE,EAMAkgF,IAAA3+E,OAAAzB,EAAAE,GACAmgF,GAAA5+E,OAAAzB,EAAAE,EAAAwvE,IAIAjR,GAEAF,GAAAiF,yBAAA/E,GAMAjmD,GAAA6iC,cAAA,GACA7iC,GAAA8+B,eAAA,GACA9+B,GAAAgxD,eAAA,IAwoCA1qE,KAAA0kF,eAAA,SAAArZ,EAAAsZ,GAEAjrE,GAAA2uD,YAAAgD,GACA3xD,GAAA0uD,aAAAuc,IAAAC,KAsBA5kF,KAAA6vC,mBAGA7vC,KAAAqxC,aAAA,WAEA,GAAAwzC,IAAA,CAGA,iBAAA92C,EAAA0yB,GAEA1yB,KAAAssB,sBAEAwqB,IAEAt0D,QAAAC,KAAA,gHACAq0D,GAAA,GAIA92C,aAIA0xB,GAAApuB,aAAAtD,EAAA0yB,OAMAzgE,KAAA8kF,WAAA,WAEA,GAAAD,IAAA,CAEA,iBAAA92C,EAAA0yB,GAEAokB,IAEAt0D,QAAAC,KAAA,6EACAq0D,GAAA,GAIAplB,GAAApuB,aAAAtD,EAAA0yB,OAMAzgE,KAAAwxC,eAAA,WAEA,GAAAqzC,IAAA,CAEA,iBAAA92C,EAAA0yB,GAGA1yB,KAAAqyB,0BAEAykB,IAEAt0D,QAAAC,KAAA,uHACAq0D,GAAA,GAIA92C,aAMAA,KAAAyqC,eACAx8D,MAAAnH,QAAAk5B,EAAAriB,QAAA,IAAAqiB,EAAAriB,MAAAvnB,OAKAs7D,GAAAjuB,eAAAzD,EAAA0yB,GAMAhB,GAAAqC,sBAAA/zB,EAAA0yB,OAQAzgE,KAAAu7D,uBAAA,WAEA,MAAA6U,KAIApwE,KAAAymD,gBAAA,SAAAkZ,GAEAyQ,GAAAzQ,EAEAA,GAAA/4D,SAAAoO,GAAAnL,IAAA81D,GAAAW,oBAEAb,GAAA6E,kBAAA3E,EAIA,IACAsD,GADAgB,EAAAtE,KAAAS,uBAGA,IAAAT,EAAA,CAEA,GAAAO,GAAAlrD,GAAAnL,IAAA81D,EAIAsD,GAFAgB,EAEA/D,EAAAI,mBAAAX,EAAAvxB,gBAIA8xB,EAAAI,mBAIAmQ,GAAAh1D,KAAAkkD,EAAA/xB,SACA2yC,GAAA5gB,EAAA9xB,YAEA+iC,GAAAn1D,KAAAkkD,EAAA7xB,cAIAm1B,GAAA,KAEAwN,GAAAh1D,KAAAi1D,IAAAC,eAAAN,IACAkQ,GAAAE,GAEA7P,GAAAn1D,KAAAo1D,IAAAF,eAAAN,GAgBA,IAZAiQ,KAAArd,IAEAhf,GAAAmf,gBAAAnf,GAAAof,YAAAJ,GACAqd,GAAArd,GAIAvpD,GAAAk0B,QAAA6iC,IACA/2D,GAAAisC,eAAA46B,IAEA7mE,GAAAo0B,SAAA8iC,IAEA3M,EAAA,CAEA,GAAApE,GAAA7qD,GAAAnL,IAAA81D,EAAA5xB,QACAkW,IAAAqf,qBAAArf,GAAAof,YAAApf,GAAAwgB,kBAAAxgB,GAAA2d,4BAAAjC,EAAAvxB,eAAAyxB,EAAAI,eAAAN,EAAAtxB,qBAMAruC,KAAA+kF,uBAAA,SAAAplB,EAAAr+D,EAAAC,EAAAsB,EAAAC,EAAAs6D,GAEA,IAAAuC,KAAAtF,wBAAA,EAGA,WADA9pC,SAAA5W,MAAA,2FAKA,IAAAspD,GAAAjuD,GAAAnL,IAAA81D,GAAAW,kBAEA,IAAA2C,EAAA,CAEA,GAAA+hB,IAAA,CAEA/hB,KAAAqd,KAEAr8B,GAAAmf,gBAAAnf,GAAAof,YAAAJ,GAEA+hB,GAAA,EAIA,KAEA,GAAAj3C,GAAA4xB,EAAA5xB,QACAk3C,EAAAl3C,EAAA5B,OACA41B,EAAAh0B,EAAA3pC,IAEA,IAAA6gF,IAAAh4C,IAAAsxB,EAAA0mB,KAAAhhC,GAAAglB,aAAAhlB,GAAAihC,kCAGA,WADA30D,SAAA5W,MAAA,4GAKA,MAAAooD,IAAA70B,IAAAqxB,EAAAwD,KAAA9d,GAAAglB,aAAAhlB,GAAAkhC,iCACApjB,IAAAC,KAAA7iB,GAAAt1C,IAAA,sBAAAs1C,GAAAt1C,IAAA,8BACAk4D,IAAAE,IAAA9iB,GAAAt1C,IAAA,gCAGA,WADA0mB,SAAA5W,MAAA,sHAKAsqC,IAAAmhC,uBAAAnhC,GAAAof,eAAApf,GAAAohC,qBAIA/jF,GAAA,GAAAA,GAAAq+D,EAAA98D,SAAAtB,GAAA,GAAAA,GAAAo+D,EAAA78D,UAEAmhD,GAAAqhC,WAAAhkF,EAAAC,EAAAsB,EAAAC,EAAAy7D,EAAA0mB,GAAA1mB,EAAAwD,GAAA3E,GAMA7sC,QAAA5W,MAAA,8GAIK,QAELqrE,GAEA/gC,GAAAmf,gBAAAnf,GAAAof,YAAAid,OAiJA,QAAAiF,IAAAvuC,EAAAmF,GAEAn8C,KAAA0H,KAAA,GAEA1H,KAAAg3C,MAAA,GAAAz2C,GAAAy2C,GACAh3C,KAAAm8C,QAAAv1C,SAAAu1C,IAAA,MA2BA,QAAAqpC,IAAAxuC,EAAAgF,EAAAC,GAEAj8C,KAAA0H,KAAA,GAEA1H,KAAAg3C,MAAA,GAAAz2C,GAAAy2C,GAEAh3C,KAAAg8C,KAAAp1C,SAAAo1C,IAAA,EACAh8C,KAAAi8C,IAAAr1C,SAAAq1C,IAAA,IA2BA,QAAA96C,MAEAinD,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,QAEApE,KAAAwkF,WAAA,KACAxkF,KAAA87C,IAAA,KACA97C,KAAAw0E,iBAAA,KAEAx0E,KAAAwlD,YAAA,EAuCA,QAAAigC,IAAA13C,EAAAuE,EAAAuf,EAAA5X,EAAAjD,GAEAoR,GAAAnqD,KAAA+B,MAEAA,KAAA85C,cAEA95C,KAAA05C,eAAA,GAAA/K,GACA3uC,KAAA25C,qBAAA/yC,OAEAA,SAAAmnC,GAEA/tC,KAAA8B,IAAAisC,EAAAuE,EAAAuf,EAAA5X,EAAAjD,GA8FA,QAAA0uC,IAAAhnC,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAAoE,KAAA,iBAEApE,KAAAg3C,MAAA,GAAAz2C,GAAA,UACAP,KAAAsP,IAAA,KAEAtP,KAAAi3C,SAAA,EAEAj3C,KAAA87C,KAAA,EACA97C,KAAA48C,QAAA,EAEA58C,KAAA2/C,UAAAjB,GAyBA,QAAAinC,IAAAtpC,GAEA+L,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,SAEApE,KAAAq8C,SAAAz1C,SAAAy1C,IAAA,GAAAqpC,IAsDA,QAAAE,MAEAx9B,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,MAEA4V,OAAA6uC,iBAAA7oD,MACA6lF,QACAhwD,YAAA,EACAzvB,YAiKA,QAAA0/E,IAAA1+E,EAAAvE,EAAAC,EAAAqpC,EAAA/nC,EAAA0nC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAAAC,GAEAR,EAAA5tC,KAAA+B,KAAA,KAAA8rC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,EAAAC,GAEArsC,KAAA0rB,OAAgBtkB,OAAAvE,QAAAC,UAEhB9C,KAAAisC,UAAArlC,SAAAqlC,IAAAma,GACApmD,KAAAksC,UAAAtlC,SAAAslC,IAAAka,GAEApmD,KAAAotC,iBAAA,EACAptC,KAAAstC,OAAA,EACAttC,KAAAutC,gBAAA,EAgBA,QAAAw4C,IAAA9rB,EAAA+rB,EAAA/uB,GAcA,GAZAj3D,KAAAi3D,iBAAArwD,SAAAqwD,KAEAj3D,KAAAimF,eAAA,GAAAr3C,GAIAqrB,QAEAj6D,KAAAi6D,QAAAppD,MAAA,GAIA7Q,KAAAi3D,iBAAA,CAUA,GAAA3kB,GAAAxxC,KAAAolF,KAAA,EAAAlmF,KAAAi6D,MAAA91D,OACAmuC,GAAA9F,GAAA25C,eAAArlF,KAAAslF,KAAA9zC,IACAA,EAAAxxC,KAAAoQ,IAAAohC,EAAA,GAEAtyC,KAAAqmF,iBAAA/zC,EACAtyC,KAAAsmF,kBAAAh0C,EAEAtyC,KAAAumF,aAAA,GAAA13C,cAAA7uC,KAAAqmF,iBAAArmF,KAAAsmF,kBAAA,GACAtmF,KAAAwmF,YAAA,GAAAV,IAAA9lF,KAAAumF,aAAAvmF,KAAAqmF,iBAAArmF,KAAAsmF,kBAAAr5C,GAAA+0B,QAIAhiE,MAAAumF,aAAA,GAAA13C,cAAA,GAAA7uC,KAAAi6D,MAAA91D,OAMA,IAAAyC,SAAAo/E,EAEAhmF,KAAAymF,wBAIA,IAAAzmF,KAAAi6D,MAAA91D,SAAA6hF,EAAA7hF,OAEAnE,KAAAgmF,eAAAn1E,MAAA,OAEI,CAEJ0f,QAAAC,KAAA,mDAEAxwB,KAAAgmF,eAEA,QAAA1mE,GAAA,EAAAonE,EAAA1mF,KAAAi6D,MAAA91D,OAA4Cmb,EAAAonE,EAAQpnE,IAEpDtf,KAAAgmF,aAAAj6E,KAAA,GAAA6iC,KAwHA,QAAA+3C,IAAAC,GAEAx+B,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,OAEApE,KAAA4mF,OA4BA,QAAAC,IAAAnlC,EAAArF,EAAA4a,GAEA3J,GAAArvD,KAAA+B,KAAA0hD,EAAArF,GAEAr8C,KAAAoE,KAAA,cAEApE,KAAA8mF,SAAA,WACA9mF,KAAA+mF,WAAA,GAAAn4C,GACA5uC,KAAAgnF,kBAAA,GAAAp4C,EAOA,IAAAqrB,KAEA,IAAAj6D,KAAA0hD,UAAA96C,SAAA5G,KAAA0hD,SAAAuY,MAAA,CAIA,OAFAgtB,GAAAC,EAEA5nE,EAAA,EAAAonE,EAAA1mF,KAAA0hD,SAAAuY,MAAA91D,OAAoDmb,EAAAonE,IAAQpnE,EAE5D4nE,EAAAlnF,KAAA0hD,SAAAuY,MAAA36C,GAEA2nE,EAAA,GAAAN,IAAA3mF,MACAi6D,EAAAluD,KAAAk7E,GAEAA,EAAAv/E,KAAAw/E,EAAAx/E,KACAu/E,EAAA5nF,SAAA8nF,UAAAD,EAAApqD,KACAmqD,EAAA3+B,WAAA6+B,UAAAD,EAAAE,MACAxgF,SAAAsgF,EAAAG,KAAAJ,EAAA5+E,MAAA8+E,UAAAD,EAAAG,IAIA,QAAA/nE,GAAA,EAAAonE,EAAA1mF,KAAA0hD,SAAAuY,MAAA91D,OAAoDmb,EAAAonE,IAAQpnE,EAE5D4nE,EAAAlnF,KAAA0hD,SAAAuY,MAAA36C,GAEA4nE,EAAAn9D,UAAA,UAAAm9D,EAAAn9D,QACAnjB,SAAAqzD,EAAAitB,EAAAn9D,QAEAkwC,EAAAitB,EAAAn9D,QAAAjoB,IAAAm4D,EAAA36C,IAIAtf,KAAA8B,IAAAm4D,EAAA36C,IAQAtf,KAAAsnF,uBAEAtnF,KAAA8mD,mBAAA,GACA9mD,KAAAqC,KAAA,GAAA0jF,IAAA9rB,EAAArzD,OAAAqwD,GAAAj3D,KAAA04C,aAqIA,QAAAmiB,IAAAnc,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAAoE,KAAA,oBAEApE,KAAAg3C,MAAA,GAAAz2C,GAAA,UAEAP,KAAA4+C,UAAA,EACA5+C,KAAAunF,QAAA,QACAvnF,KAAAwnF,SAAA,QAEAxnF,KAAA48C,QAAA,EAEA58C,KAAA2/C,UAAAjB,GA2BA,QAAA+oC,IAAA/lC,EAAArF,EAAAyU,GAEA,WAAAA,GAEAvgC,QAAAC,KAAA,mGACA,GAAAk3D,IAAAhmC,EAAArF,KAIA+L,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,OAEApE,KAAA0hD,SAAA96C,SAAA86C,IAAA,GAAA0L,SACAptD,KAAAq8C,SAAAz1C,SAAAy1C,IAAA,GAAAwe,KAA8E7jB,MAAA,SAAAl2C,KAAA8a,aA2K9E,QAAA8rE,IAAAhmC,EAAArF,GAEAorC,GAAAxpF,KAAA+B,KAAA0hD,EAAArF,GAEAr8C,KAAAoE,KAAA,eA0BA,QAAA22D,IAAArc,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAAoE,KAAA,iBAEApE,KAAAg3C,MAAA,GAAAz2C,GAAA,UAEAP,KAAAsP,IAAA,KAEAtP,KAAAsyC,KAAA,EACAtyC,KAAAs3D,iBAAA,EAEAt3D,KAAA48C,QAAA,EAEA58C,KAAA2/C,UAAAjB,GA4BA,QAAAipC,IAAAjmC,EAAArF,GAEA+L,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,SAEApE,KAAA0hD,SAAA96C,SAAA86C,IAAA,GAAA0L,IACAptD,KAAAq8C,SAAAz1C,SAAAy1C,IAAA,GAAA0e,KAA2E/jB,MAAA,SAAAl2C,KAAA8a,WAiI3E,QAAAgsE,MAEAx/B,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,QAcA,QAAAyjF,IAAAC,EAAAh8C,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,GAQA,QAAAjqC,KAEAS,sBAAAT,GAEA2lF,EAAA92D,YAAA82D,EAAAC,oBAEA/kC,EAAA1H,aAAA,GAZAzP,EAAA5tC,KAAA+B,KAAA8nF,EAAAh8C,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,GAEApsC,KAAAotC,iBAAA,CAEA,IAAA4V,GAAAhjD,IAcAmC,KAWA,QAAA6lF,IAAAp7C,EAAA/pC,EAAAC,EAAAqpC,EAAA/nC,EAAA0nC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAAAC,GAEAR,EAAA5tC,KAAA+B,KAAA,KAAA8rC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,EAAAC,GAEArsC,KAAA0rB,OAAgB7oB,QAAAC,UAChB9C,KAAA4sC,UAKA5sC,KAAAstC,OAAA,EAKAttC,KAAAotC,iBAAA,EAaA,QAAA66C,IAAAhtC,EAAAnP,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,GAEAP,EAAA5tC,KAAA+B,KAAAi7C,EAAAnP,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,GAEApsC,KAAAs7C,aAAA,EAYA,QAAA4sC,IAAArlF,EAAAC,EAAAsB,EAAA0nC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAE,EAAAD,GAIA,GAFAA,EAAAvlC,SAAAulC,IAAAg4B,GAEAh4B,IAAAg4B,IAAAh4B,IAAA22B,GAEA,SAAAx/D,OAAA,mFAIAuoC,GAAA5tC,KAAA+B,KAAA,KAAA8rC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/nC,EAAAgoC,GAEApsC,KAAA0rB,OAAgB7oB,QAAAC,UAEhB9C,KAAAoE,KAAAwC,SAAAxC,IAAA43E,GAEAh8E,KAAAisC,UAAArlC,SAAAqlC,IAAAma,GACApmD,KAAAksC,UAAAtlC,SAAAslC,IAAAka,GAEApmD,KAAAstC,OAAA,EACAttC,KAAAotC,iBAAA,EAYA,QAAA+6C,IAAAzmC,GAMA,QAAA0mC,GAAA/oE,EAAAC,GAEA,MAAAD,GAAAC,EANA8tC,GAAAnvD,KAAA+B,KAEA,IAAAqoF,IAAA,KAAA79D,KAQA7L,GAAA,YAEA,IAAA+iC,KAAAU,WAAA,CASA,OAPAzN,GAAA+M,EAAA/M,SACAC,EAAA8M,EAAA9M,MACA0zC,EAAA,EAGAC,EAAA,GAAA/8B,aAAA,EAAA5W,EAAAzwC,QAEAW,EAAA,EAAA2F,EAAAmqC,EAAAzwC,OAAqCW,EAAA2F,EAAO3F,IAI5C,OAFA6hD,GAAA/R,EAAA9vC,GAEAmG,EAAA,EAAoBA,EAAA,EAAOA,IAAA,CAE3Bo9E,EAAA,GAAA1hC,EAAAhoC,EAAA1T,IACAo9E,EAAA,GAAA1hC,EAAAhoC,GAAA1T,EAAA,OACAo9E,EAAA9sE,KAAA6sE,EAEA,IAAA3gF,GAAA4gF,EAAAluE,UAEAvT,UAAA4jB,EAAA/iB,KAEA8gF,EAAA,EAAAD,GAAAD,EAAA,GACAE,EAAA,EAAAD,EAAA,GAAAD,EAAA,GACA79D,EAAA/iB,IAAA,EACA6gF,KAUA,OAFAE,GAAA,GAAA35C,cAAA,EAAAy5C,EAAA,GAEAxjF,EAAA,EAAA2F,EAAA69E,EAAiCxjF,EAAA2F,EAAO3F,IAExC,OAAAmG,GAAA,EAAoBA,EAAA,EAAOA,IAAA,CAE3B,GAAAyrC,GAAA/B,EAAA4zC,EAAA,EAAAzjF,EAAAmG,IAEAtB,EAAA,EAAA7E,EAAA,EAAAmG,CACAu9E,GAAA7+E,EAAA,GAAA+sC,EAAAp1C,EACAknF,EAAA7+E,EAAA,GAAA+sC,EAAAn1C,EACAinF,EAAA7+E,EAAA,GAAA+sC,EAAAl1C,EAMAxB,KAAA8vD,aAAA,cAAAtF,IAAAg+B,EAAA,QAEG,IAAA9mC,KAAAQ,iBAEH,UAAAR,EAAA/3C,MAAA,CAIA,GAAAqjD,GAAAtL,EAAA/3C,MAAAylC,MACAuF,EAAA+M,EAAAh9B,WAAArlB,SACAge,EAAAqkC,EAAArkC,OACAirE,EAAA,CAEA,KAAAjrE,EAAAlZ,QAEAu9C,EAAA8N,SAAA,EAAAxC,EAAA7oD,OAOA,QAFAokF,GAAA,GAAA/8B,aAAA,EAAAwB,EAAA7oD,QAEAskF,EAAA,EAAAC,EAAArrE,EAAAlZ,OAAwCskF,EAAAC,IAAQD,EAOhD,OALAnhC,GAAAjqC,EAAAorE,GAEA1/E,EAAAu+C,EAAAv+C,MACAkpB,EAAAq1B,EAAAr1B,MAEAntB,EAAAiE,EAAA88C,EAAA98C,EAAAkpB,EAA6CntB,EAAA+gD,EAAQ/gD,GAAA,EAErD,OAAAmG,GAAA,EAAsBA,EAAA,EAAOA,IAAA,CAE7Bo9E,EAAA,GAAAr7B,EAAAloD,EAAAmG,GACAo9E,EAAA,GAAAr7B,EAAAloD,GAAAmG,EAAA,MACAo9E,EAAA9sE,KAAA6sE,EAEA,IAAA3gF,GAAA4gF,EAAAluE,UAEAvT,UAAA4jB,EAAA/iB,KAEA8gF,EAAA,EAAAD,GAAAD,EAAA,GACAE,EAAA,EAAAD,EAAA,GAAAD,EAAA,GACA79D,EAAA/iB,IAAA,EACA6gF,KAYA,OAFAE,GAAA,GAAA35C,cAAA,EAAAy5C,EAAA,GAEAxjF,EAAA,EAAA2F,EAAA69E,EAAkCxjF,EAAA2F,EAAO3F,IAEzC,OAAAmG,GAAA,EAAqBA,EAAA,EAAOA,IAAA,CAE5B,GAAAtB,GAAA,EAAA7E,EAAA,EAAAmG,EACA09E,EAAAJ,EAAA,EAAAzjF,EAAAmG,EAEAu9E,GAAA7+E,EAAA,GAAAgrC,EAAAi0C,KAAAD,GACAH,EAAA7+E,EAAA,GAAAgrC,EAAAk0C,KAAAF,GACAH,EAAA7+E,EAAA,GAAAgrC,EAAAm0C,KAAAH,GAMA3oF,KAAA8vD,aAAA,cAAAtF,IAAAg+B,EAAA,QAEI,CAUJ,OANA7zC,GAAA+M,EAAAh9B,WAAArlB,SAAA+vC,MACAk5C,EAAA3zC,EAAAxwC,OAAA,EACA4kF,EAAAT,EAAA,EAEAE,EAAA,GAAA35C,cAAA,EAAAy5C,EAAA,GAEAxjF,EAAA,EAAA2F,EAAAs+E,EAAiCjkF,EAAA2F,EAAO3F,IAExC,OAAAmG,GAAA,EAAqBA,EAAA,EAAOA,IAAA,CAE5B,GAAAtB,GAAA,GAAA7E,EAAA,EAAAmG,EAEA+9E,EAAA,EAAAlkF,EAAA,EAAAmG,CACAu9E,GAAA7+E,EAAA,GAAAgrC,EAAAq0C,GACAR,EAAA7+E,EAAA,GAAAgrC,EAAAq0C,EAAA,GACAR,EAAA7+E,EAAA,GAAAgrC,EAAAq0C,EAAA,EAEA,IAAAL,GAAA,EAAA7jF,EAAA,IAAAmG,EAAA,KACAu9E,GAAA7+E,EAAA,GAAAgrC,EAAAg0C,GACAH,EAAA7+E,EAAA,GAAAgrC,EAAAg0C,EAAA,GACAH,EAAA7+E,EAAA,GAAAgrC,EAAAg0C,EAAA,GAMA3oF,KAAA8vD,aAAA,cAAAtF,IAAAg+B,EAAA,KAkBA,QAAAS,IAAA9xE,EAAA+xE,EAAAC,GAEA/7B,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,2BAEApE,KAAA0+C,YACAvnC,OACA+xE,SACAC,SAKA,IAGArkF,GAAAmG,EAAA7M,EACA+vD,EAAAnoD,EAJA2uC,KACAuY,KAKAk8B,EAAAF,EAAA,CAEA,KAAApkF,EAAA,EAAcA,GAAAqkF,EAAarkF,IAI3B,IAFAkB,EAAAlB,EAAAqkF,EAEAl+E,EAAA,EAAeA,GAAAi+E,EAAaj+E,IAE5BkjD,EAAAljD,EAAAi+E,EAEA9qF,EAAA+Y,EAAAg3C,EAAAnoD,GACA2uC,EAAA5oC,KAAA3N,EAAAkD,EAAAlD,EAAAmD,EAAAnD,EAAAoD,GAEA0rD,EAAAnhD,KAAAoiD,EAAAnoD,EAQA,IACAqZ,GAAAC,EAAAnhB,EAAA6vD,EADAhB,IAGA,KAAAloD,EAAA,EAAcA,EAAAqkF,EAAYrkF,IAE1B,IAAAmG,EAAA,EAAeA,EAAAi+E,EAAYj+E,IAE3BoU,EAAAva,EAAAskF,EAAAn+E,EACAqU,EAAAxa,EAAAskF,EAAAn+E,EAAA,EACA9M,GAAA2G,EAAA,GAAAskF,EAAAn+E,EAAA,EACA+iD,GAAAlpD,EAAA,GAAAskF,EAAAn+E,EAIA+hD,EAAAjhD,KAAAsT,EAAAC,EAAA0uC,GACAhB,EAAAjhD,KAAAuT,EAAAnhB,EAAA6vD,EAQAhuD,MAAA6vD,UAAA7C,EAAA7oD,OAAA,MAAAonD,GAAAF,IAAA2B,EAAA,IACAhtD,KAAA8vD,aAAA,WAAArE,GAAA9W,EAAA,IACA30C,KAAA8vD,aAAA,KAAArE,GAAAyB,EAAA,IAIAltD,KAAAqpF,uBAcA,QAAAC,IAAAnyE,EAAA+xE,EAAAC,GAEAr9B,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,qBAEApE,KAAA0+C,YACAvnC,OACA+xE,SACAC,UAGAnpF,KAAAupF,mBAAA,GAAAN,IAAA9xE,EAAA+xE,EAAAC,IACAnpF,KAAAwpF,gBAWA,QAAAC,IAAA90C,EAAAqY,EAAA1M,EAAArpB,GA4CA,QAAAyyD,GAAAzyD,GAQA,OANA5X,GAAA,GAAAsvB,GACArvB,EAAA,GAAAqvB,GACAxwC,EAAA,GAAAwwC,GAIA7pC,EAAA,EAAmBA,EAAAkoD,EAAA7oD,OAAoBW,GAAA,EAIvC6kF,EAAA38B,EAAAloD,EAAA,GAAAua,GACAsqE,EAAA38B,EAAAloD,EAAA,GAAAwa,GACAqqE,EAAA38B,EAAAloD,EAAA,GAAA3G,GAIAyrF,EAAAvqE,EAAAC,EAAAnhB,EAAA84B,GAMA,QAAA2yD,GAAAvqE,EAAAC,EAAAnhB,EAAA84B,GAEA,GAMAnyB,GAAAmG,EANA4+E,EAAA/oF,KAAAgpF,IAAA,EAAA7yD,GAIAjxB,IAMA,KAAAlB,EAAA,EAAgBA,GAAA+kF,EAAW/kF,IAAA,CAE3BkB,EAAAlB,KAEA,IAAAilF,GAAA1qE,EAAA9P,QAAAy6E,KAAA7rF,EAAA2G,EAAA+kF,GACAI,EAAA3qE,EAAA/P,QAAAy6E,KAAA7rF,EAAA2G,EAAA+kF,GAEAK,EAAAL,EAAA/kF,CAEA,KAAAmG,EAAA,EAAgBA,GAAAi/E,EAAWj/E,IAE3B,IAAAA,GAAAnG,IAAA+kF,EAEA7jF,EAAAlB,GAAAmG,GAAA8+E,EAIA/jF,EAAAlB,GAAAmG,GAAA8+E,EAAAx6E,QAAAy6E,KAAAC,EAAAh/E,EAAAi/E,GAUA,IAAAplF,EAAA,EAAeA,EAAA+kF,EAAW/kF,IAE1B,IAAAmG,EAAA,EAAgBA,EAAA,GAAA4+E,EAAA/kF,GAAA,EAA0BmG,IAAA,CAE1C,GAAAm8C,GAAAtmD,KAAA4uD,MAAAzkD,EAAA,EAEAA,GAAA,OAEAk/E,EAAAnkF,EAAAlB,GAAAsiD,EAAA,IACA+iC,EAAAnkF,EAAAlB,EAAA,GAAAsiD,IACA+iC,EAAAnkF,EAAAlB,GAAAsiD,MAIA+iC,EAAAnkF,EAAAlB,GAAAsiD,EAAA,IACA+iC,EAAAnkF,EAAAlB,EAAA,GAAAsiD,EAAA,IACA+iC,EAAAnkF,EAAAlB,EAAA,GAAAsiD,MAUA,QAAAgjC,GAAA9pC,GAMA,OAJA5J,GAAA,GAAA/H,GAIA7pC,EAAA,EAAmBA,EAAAgwC,EAAA3wC,OAAyBW,GAAA,EAE5C4xC,EAAAp1C,EAAAwzC,EAAAhwC,EAAA,GACA4xC,EAAAn1C,EAAAuzC,EAAAhwC,EAAA,GACA4xC,EAAAl1C,EAAAszC,EAAAhwC,EAAA,GAEA4xC,EAAAmkC,YAAAlK,eAAArwB,GAEAxL,EAAAhwC,EAAA,GAAA4xC,EAAAp1C,EACAwzC,EAAAhwC,EAAA,GAAA4xC,EAAAn1C,EACAuzC,EAAAhwC,EAAA,GAAA4xC,EAAAl1C,EAMA,QAAA6oF,KAIA,OAFA3zC,GAAA,GAAA/H,GAEA7pC,EAAA,EAAmBA,EAAAgwC,EAAA3wC,OAAyBW,GAAA,GAE5C4xC,EAAAp1C,EAAAwzC,EAAAhwC,EAAA,GACA4xC,EAAAn1C,EAAAuzC,EAAAhwC,EAAA,GACA4xC,EAAAl1C,EAAAszC,EAAAhwC,EAAA,EAEA,IAAAqpD,GAAAm8B,EAAA5zC,GAAA,EAAA51C,KAAAu8B,GAAA,GACAr3B,EAAAukF,EAAA7zC,GAAA51C,KAAAu8B,GAAA,EACAmtD,GAAAz+E,KAAAoiD,EAAA,EAAAnoD,GAIAykF,IAEAC,IAIA,QAAAA,KAIA,OAAA5lF,GAAA,EAAmBA,EAAA0lF,EAAArmF,OAAqBW,GAAA,GAIxC,GAAA6lF,GAAAH,EAAA1lF,EAAA,GACA8lF,EAAAJ,EAAA1lF,EAAA,GACA+lF,EAAAL,EAAA1lF,EAAA,GAEAoM,EAAApQ,KAAAoQ,IAAAy5E,EAAAC,EAAAC,GACA9pF,EAAAD,KAAAC,IAAA4pF,EAAAC,EAAAC,EAIA35E,GAAA,IAAAnQ,EAAA,KAEA4pF,EAAA,KAAAH,EAAA1lF,EAAA,OACA8lF,EAAA,KAAAJ,EAAA1lF,EAAA,OACA+lF,EAAA,KAAAL,EAAA1lF,EAAA,SAQA,QAAAqlF,GAAAzzC,GAEA5B,EAAA/oC,KAAA2qC,EAAAp1C,EAAAo1C,EAAAn1C,EAAAm1C,EAAAl1C,GAIA,QAAAmoF,GAAAhgF,EAAA+sC,GAEA,GAAA27B,GAAA,EAAA1oE,CAEA+sC,GAAAp1C,EAAAqzC,EAAA09B,EAAA,GACA37B,EAAAn1C,EAAAozC,EAAA09B,EAAA,GACA37B,EAAAl1C,EAAAmzC,EAAA09B,EAAA,GAIA,QAAAoY,KAYA,OAVAprE,GAAA,GAAAsvB,GACArvB,EAAA,GAAAqvB,GACAxwC,EAAA,GAAAwwC,GAEAm8C,EAAA,GAAAn8C,GAEAo8C,EAAA,GAAAn/C,GACAo/C,EAAA,GAAAp/C,GACAq/C,EAAA,GAAAr/C,GAEA9mC,EAAA,EAAAmG,EAAA,EAA0BnG,EAAAgwC,EAAA3wC,OAAyBW,GAAA,EAAAmG,GAAA,GAEnDoU,EAAApd,IAAA6yC,EAAAhwC,EAAA,GAAAgwC,EAAAhwC,EAAA,GAAAgwC,EAAAhwC,EAAA,IACAwa,EAAArd,IAAA6yC,EAAAhwC,EAAA,GAAAgwC,EAAAhwC,EAAA,GAAAgwC,EAAAhwC,EAAA,IACA3G,EAAA8D,IAAA6yC,EAAAhwC,EAAA,GAAAgwC,EAAAhwC,EAAA,GAAAgwC,EAAAhwC,EAAA,IAEAimF,EAAA9oF,IAAAuoF,EAAAv/E,EAAA,GAAAu/E,EAAAv/E,EAAA,IACA+/E,EAAA/oF,IAAAuoF,EAAAv/E,EAAA,GAAAu/E,EAAAv/E,EAAA,IACAggF,EAAAhpF,IAAAuoF,EAAAv/E,EAAA,GAAAu/E,EAAAv/E,EAAA,IAEA6/E,EAAArvE,KAAA4D,GAAAvd,IAAAwd,GAAAxd,IAAA3D,GAAA+sF,aAAA,EAEA,IAAAC,GAAAb,EAAAQ,EAEAM,GAAAL,EAAA9/E,EAAA,EAAAoU,EAAA8rE,GACAC,EAAAJ,EAAA//E,EAAA,EAAAqU,EAAA6rE,GACAC,EAAAH,EAAAhgF,EAAA,EAAA9M,EAAAgtF,IAMA,QAAAC,GAAAx0C,EAAAy7B,EAAApjB,EAAAq7B,GAEAA,EAAA,OAAA1zC,EAAAt1C,IAEAkpF,EAAAnY,GAAAz7B,EAAAt1C,EAAA,GAIA,IAAA2tD,EAAA3tD,GAAA,IAAA2tD,EAAAztD,IAEAgpF,EAAAnY,GAAAiY,EAAA,EAAAxpF,KAAAu8B,GAAA,IAQA,QAAAitD,GAAAr7B,GAEA,MAAAnuD,MAAAuqF,MAAAp8B,EAAAztD,GAAAytD,EAAA3tD,GAOA,QAAAipF,GAAAt7B,GAEA,MAAAnuD,MAAAuqF,OAAAp8B,EAAA1tD,EAAAT,KAAAolF,KAAAj3B,EAAA3tD,EAAA2tD,EAAA3tD,EAAA2tD,EAAAztD,EAAAytD,EAAAztD,IA3RA4rD,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,2BAEApE,KAAA0+C,YACA/J,WACAqY,UACA1M,SACArpB,UAGAqpB,KAAA,EACArpB,KAAA,CAIA,IAAA6d,MACA01C,IAIAd,GAAAzyD,GAIAmzD,EAAA9pC,GAIA+pC,IAIArqF,KAAA8vD,aAAA,WAAArE,GAAA3W,EAAA,IACA90C,KAAA8vD,aAAA,SAAArE,GAAA3W,EAAAjkC,QAAA,IACA7Q,KAAA8vD,aAAA,KAAArE,GAAA++B,EAAA,IACAxqF,KAAAsrF,mBAEAtrF,KAAAssD,eAAA,GAAAlM,IAAA,GAAAzR,GAAA2R,GAkQA,QAAAirC,IAAAjrC,EAAArpB,GAEA,GAAA0d,IACA,+BAGAqY,GACA,wBAGAy8B,IAAAxrF,KAAA+B,KAAA20C,EAAAqY,EAAA1M,EAAArpB,GAEAj3B,KAAAoE,KAAA,4BAEApE,KAAA0+C,YACA4B,SACArpB,UAYA,QAAAu0D,IAAAlrC,EAAArpB,GAEA60B,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,sBAEApE,KAAA0+C,YACA4B,SACArpB,UAGAj3B,KAAAupF,mBAAA,GAAAgC,IAAAjrC,EAAArpB,IACAj3B,KAAAwpF,gBAWA,QAAAiC,IAAAnrC,EAAArpB,GAEA,GAAA0d,IACA,wCAGAqY,GACA,gDAGAy8B,IAAAxrF,KAAA+B,KAAA20C,EAAAqY,EAAA1M,EAAArpB,GAEAj3B,KAAAoE,KAAA,2BAEApE,KAAA0+C,YACA4B,SACArpB,UAYA,QAAAy0D,IAAAprC,EAAArpB,GAEA60B,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,qBAEApE,KAAA0+C,YACA4B,SACArpB,UAGAj3B,KAAAupF,mBAAA,GAAAkC,IAAAnrC,EAAArpB,IACAj3B,KAAAwpF,gBAWA,QAAAmC,IAAArrC,EAAArpB,GAEA,GAAAtD,IAAA,EAAA7yB,KAAAolF,KAAA,MAEAvxC,IACA,EAAAhhB,EAAA,IAAAA,EAAA,MAAAA,EAAA,KAAAA,EAAA,EACA,KAAAA,EAAA,IAAAA,EAAA,MAAAA,EAAA,KAAAA,EACAA,EAAA,KAAAA,EAAA,KAAAA,EAAA,MAAAA,EAAA,KAGAq5B,GACA,kCACA,kCACA,8BACA,gCAGAy8B,IAAAxrF,KAAA+B,KAAA20C,EAAAqY,EAAA1M,EAAArpB,GAEAj3B,KAAAoE,KAAA,4BAEApE,KAAA0+C,YACA4B,SACArpB,UAYA,QAAA20D,IAAAtrC,EAAArpB,GAEA60B,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,sBAEApE,KAAA0+C,YACA4B,SACArpB,UAGAj3B,KAAAupF,mBAAA,GAAAoC,IAAArrC,EAAArpB,IACAj3B,KAAAwpF,gBAWA,QAAAqC,IAAAvrC,EAAArpB,GAEA,GAAAtD,IAAA,EAAA7yB,KAAAolF,KAAA,MACA12C,EAAA,EAAA7b,EAEAghB,IAGA,iBACA,cACA,eACA,aAGA,GAAAnF,GAAA7b,EAAA,GAAA6b,EAAA7b,EACA,EAAA6b,GAAA7b,EAAA,EAAA6b,EAAA7b,GAGA6b,GAAA7b,EAAA,GAAA6b,EAAA7b,EAAA,EACA6b,GAAA7b,EAAA,EAAA6b,EAAA7b,EAAA,GAGAA,EAAA,GAAA6b,EAAA7b,EAAA,GAAA6b,GACA7b,EAAA,EAAA6b,EAAA7b,EAAA,EAAA6b,GAGAwd,GACA,sBACA,sBACA,uBACA,qBACA,sBACA,sBACA,sBACA,uBACA,qBACA,uBACA,wBACA,qBAGAy8B,IAAAxrF,KAAA+B,KAAA20C,EAAAqY,EAAA1M,EAAArpB,GAEAj3B,KAAAoE,KAAA,6BAEApE,KAAA0+C,YACA4B,SACArpB,UAYA,QAAA60D,IAAAxrC,EAAArpB,GAEA60B,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,uBAEApE,KAAA0+C,YACA4B,SACArpB,UAGAj3B,KAAAupF,mBAAA,GAAAsC,IAAAvrC,EAAArpB,IACAj3B,KAAAwpF,gBAaA,QAAAuC,IAAAp3C,EAAAqY,EAAA1M,EAAArpB,GAEA60B,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,qBAEApE,KAAA0+C,YACA/J,WACAqY,UACA1M,SACArpB,UAGAj3B,KAAAupF,mBAAA,GAAAE,IAAA90C,EAAAqY,EAAA1M,EAAArpB,IACAj3B,KAAAwpF,gBAcA,QAAAwC,IAAAx4C,EAAAy4C,EAAA3rC,EAAA4rC,EAAAC,GAuDA,QAAAC,KAEA,IAAAtnF,EAAA,EAAeA,EAAAmnF,EAAqBnnF,IAEpCunF,EAAAvnF,EASAunF,GAAAF,KAAA,EAAAF,EAAA,GAKA5B,IAIAiC,IAIA,QAAAD,GAAAvnF,GAIA,GAAAynF,GAAA/4C,EAAAg5C,WAAA1nF,EAAAmnF,GAIAQ,EAAAC,EAAAz/B,QAAAnoD,GACA6nF,EAAAD,EAAAE,UAAA9nF,EAIA,KAAAmG,EAAA,EAAeA,GAAAihF,EAAqBjhF,IAAA,CAEpC,GAAAjF,GAAAiF,EAAAihF,EAAAprF,KAAAu8B,GAAA,EAEAwvD,EAAA/rF,KAAA+rF,IAAA7mF,GACAo3B,GAAAt8B,KAAAs8B,IAAAp3B,EAIAw6C,GAAAl/C,EAAA87B,EAAAqvD,EAAAnrF,EAAAurF,EAAAF,EAAArrF,EACAk/C,EAAAj/C,EAAA67B,EAAAqvD,EAAAlrF,EAAAsrF,EAAAF,EAAAprF,EACAi/C,EAAAh/C,EAAA47B,EAAAqvD,EAAAjrF,EAAAqrF,EAAAF,EAAAnrF,EACAg/C,EAAAq6B,YAEA5tB,EAAAlhD,KAAAy0C,EAAAl/C,EAAAk/C,EAAAj/C,EAAAi/C,EAAAh/C,GAIAk1C,EAAAp1C,EAAAirF,EAAAjrF,EAAAg/C,EAAAE,EAAAl/C,EACAo1C,EAAAn1C,EAAAgrF,EAAAhrF,EAAA++C,EAAAE,EAAAj/C,EACAm1C,EAAAl1C,EAAA+qF,EAAA/qF,EAAA8+C,EAAAE,EAAAh/C,EAEAmzC,EAAA5oC,KAAA2qC,EAAAp1C,EAAAo1C,EAAAn1C,EAAAm1C,EAAAl1C,IAMA,QAAA8qF,KAEA,IAAArhF,EAAA,EAAeA,GAAAghF,EAAsBhhF,IAErC,IAAAnG,EAAA,EAAgBA,GAAAonF,EAAqBpnF,IAAA,CAErC,GAAAua,IAAA6sE,EAAA,IAAAjhF,EAAA,IAAAnG,EAAA,GACAwa,GAAA4sE,EAAA,GAAAjhF,GAAAnG,EAAA,GACA3G,GAAA+tF,EAAA,GAAAjhF,EAAAnG,EACAkpD,GAAAk+B,EAAA,IAAAjhF,EAAA,GAAAnG,CAIAkoD,GAAAjhD,KAAAsT,EAAAC,EAAA0uC,GACAhB,EAAAjhD,KAAAuT,EAAAnhB,EAAA6vD,IAQA,QAAAq8B,KAEA,IAAAvlF,EAAA,EAAeA,GAAAmnF,EAAsBnnF,IAErC,IAAAmG,EAAA,EAAgBA,GAAAihF,EAAqBjhF,IAErC2rC,EAAAt1C,EAAAwD,EAAAmnF,EACAr1C,EAAAr1C,EAAA0J,EAAAihF,EAEAh/B,EAAAnhD,KAAA6qC,EAAAt1C,EAAAs1C,EAAAr1C,GAvJA6rD,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,qBAEApE,KAAA0+C,YACAlL,OACAy4C,kBACA3rC,SACA4rC,iBACAC,UAGAF,KAAA,GACA3rC,KAAA,EACA4rC,KAAA,EACAC,MAAA,CAEA,IAAAO,GAAAl5C,EAAAs5C,oBAAAb,EAAAE,EAIAnsF,MAAA+sF,SAAAL,EAAAK,SACA/sF,KAAAitD,QAAAy/B,EAAAz/B,QACAjtD,KAAA4sF,UAAAF,EAAAE,SAIA,IAIA9nF,GAAAmG,EAJAyrC,EAAA,GAAA/H,GACA6R,EAAA,GAAA7R,GACAiI,EAAA,GAAAhL,GAMA+I,KACAsY,KACAC,KACAF,IAIAo/B,KAIApsF,KAAA6vD,UAAA7C,EAAA7oD,OAAA,MAAAonD,GAAAF,IAAA2B,EAAA,IACAhtD,KAAA8vD,aAAA,WAAArE,GAAA9W,EAAA,IACA30C,KAAA8vD,aAAA,SAAArE,GAAAwB,EAAA,IACAjtD,KAAA8vD,aAAA,KAAArE,GAAAyB,EAAA,IA6HA,QAAA8/B,IAAAx5C,EAAAy4C,EAAA3rC,EAAA4rC,EAAAC,EAAAc,GAEAnhC,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,eAEApE,KAAA0+C,YACAlL,OACAy4C,kBACA3rC,SACA4rC,iBACAC,UAGAvlF,SAAAqmF,GAAA18D,QAAAC,KAAA,8CAEA,IAAA08D,GAAA,GAAAlB,IAAAx4C,EAAAy4C,EAAA3rC,EAAA4rC,EAAAC,EAIAnsF,MAAA+sF,SAAAG,EAAAH,SACA/sF,KAAAitD,QAAAigC,EAAAjgC,QACAjtD,KAAA4sF,UAAAM,EAAAN,UAIA5sF,KAAAupF,mBAAA2D,GACAltF,KAAAwpF,gBAYA,QAAA2D,IAAA7sC,EAAA8sC,EAAAnB,EAAAC,EAAA9tF,EAAAivF,GA8IA,QAAAC,GAAAn/B,EAAA/vD,EAAAivF,EAAA/sC,EAAAjhD,GAEA,GAAAkuF,GAAAzsF,KAAAs8B,IAAA+wB,GACAq/B,EAAA1sF,KAAA+rF,IAAA1+B,GACAs/B,EAAAJ,EAAAjvF,EAAA+vD,EACAu/B,EAAA5sF,KAAAs8B,IAAAqwD,EAEApuF,GAAAiC,EAAAg/C,GAAA,EAAAotC,GAAA,GAAAH,EACAluF,EAAAkC,EAAA++C,GAAA,EAAAotC,GAAAF,EAAA,GACAnuF,EAAAmC,EAAA8+C,EAAAx/C,KAAA+rF,IAAAY,GAAA,GArJArgC,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,0BAEApE,KAAA0+C,YACA4B,SACA8sC,OACAnB,kBACAC,iBACA9tF,IACAivF,KAGA/sC,KAAA,IACA8sC,KAAA,GACAnB,EAAAnrF,KAAA4uD,MAAAu8B,IAAA,GACAC,EAAAprF,KAAA4uD,MAAAw8B,IAAA,EACA9tF,KAAA,EACAivF,KAAA,CAGA,IAUAvoF,GAAAmG,EAVA0kD,GAAAu8B,EAAA,IAAAD,EAAA,GACAr8B,EAAAs8B,EAAAD,EAAA,IAGAj/B,EAAA,GAAAxC,IAAA,IAAAoF,EAAA,MAAApE,YAAA3W,aAAA+a,GAAA,GACAjb,EAAA,GAAA6V,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GACA1C,EAAA,GAAAzC,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GACAzC,EAAA,GAAA1C,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GAGAhmD,EAAA,EAAAgkF,EAAA,EAEAj3C,EAAA,GAAA/H,GACA6R,EAAA,GAAA7R,GACAiI,EAAA,GAAAhL,GAEAgiD,EAAA,GAAAj/C,GACAk/C,EAAA,GAAAl/C,GAEAg+C,EAAA,GAAAh+C,GACAm/C,EAAA,GAAAn/C,GACA89C,EAAA,GAAA99C,EAIA,KAAA7pC,EAAA,EAAcA,GAAAmnF,IAAsBnnF,EAAA,CAIpC,GAAAqpD,GAAArpD,EAAAmnF,EAAA7tF,EAAA0C,KAAAu8B,GAAA,CAoBA,KAfAiwD,EAAAn/B,EAAA/vD,EAAAivF,EAAA/sC,EAAAstC,GACAN,EAAAn/B,EAAA,IAAA/vD,EAAAivF,EAAA/sC,EAAAutC,GAIAC,EAAAC,WAAAF,EAAAD,GACAnB,EAAAuB,WAAAH,EAAAD,GACAjB,EAAAsB,aAAAH,EAAArB,GACAA,EAAAwB,aAAAtB,EAAAmB,GAIAnB,EAAA9R,YACA4R,EAAA5R,YAEA5vE,EAAA,EAAeA,GAAAihF,IAAqBjhF,EAAA,CAKpC,GAAAjF,GAAAiF,EAAAihF,EAAAprF,KAAAu8B,GAAA,EACA6wD,GAAAd,EAAAtsF,KAAAs8B,IAAAp3B,GACAmoF,EAAAf,EAAAtsF,KAAA+rF,IAAA7mF,EAKA0wC,GAAAp1C,EAAAssF,EAAAtsF,GAAA4sF,EAAAzB,EAAAnrF,EAAA6sF,EAAAxB,EAAArrF,GACAo1C,EAAAn1C,EAAAqsF,EAAArsF,GAAA2sF,EAAAzB,EAAAlrF,EAAA4sF,EAAAxB,EAAAprF,GACAm1C,EAAAl1C,EAAAosF,EAAApsF,GAAA0sF,EAAAzB,EAAAjrF,EAAA2sF,EAAAxB,EAAAnrF,GAGAmzC,EAAAy5C,OAAAzkF,EAAA+sC,EAAAp1C,EAAAo1C,EAAAn1C,EAAAm1C,EAAAl1C,GAGAg/C,EAAAutC,WAAAr3C,EAAAk3C,GAAA/S,YACA5tB,EAAAmhC,OAAAzkF,EAAA62C,EAAAl/C,EAAAk/C,EAAAj/C,EAAAi/C,EAAAh/C,GAGAo1C,EAAAt1C,EAAAwD,EAAAmnF,EACAr1C,EAAAr1C,EAAA0J,EAAAihF,EACAh/B,EAAAmhC,MAAA1kF,EAAAitC,EAAAt1C,EAAAs1C,EAAAr1C,GAGAoI,KAQA,IAAAsB,EAAA,EAAcA,GAAAghF,EAAsBhhF,IAEpC,IAAAnG,EAAA,EAAeA,GAAAonF,EAAqBpnF,IAAA,CAGpC,GAAAua,IAAA6sE,EAAA,IAAAjhF,EAAA,IAAAnG,EAAA,GACAwa,GAAA4sE,EAAA,GAAAjhF,GAAAnG,EAAA,GACA3G,GAAA+tF,EAAA,GAAAjhF,EAAAnG,EACAkpD,GAAAk+B,EAAA,IAAAjhF,EAAA,GAAAnG,CAGAkoD,GAAAshC,KAAAX,EAAAtuE,GAAmCsuE,IACnC3gC,EAAAshC,KAAAX,EAAAruE,GAAmCquE,IACnC3gC,EAAAshC,KAAAX,EAAA3/B,GAAmC2/B,IAGnC3gC,EAAAshC,KAAAX,EAAAruE,GAAmCquE,IACnC3gC,EAAAshC,KAAAX,EAAAxvF,GAAmCwvF,IACnC3gC,EAAAshC,KAAAX,EAAA3/B,GAAmC2/B,IAQnC3tF,KAAA6vD,SAAA7C,GACAhtD,KAAA8vD,aAAA,WAAAnb,GACA30C,KAAA8vD,aAAA,SAAA7C,GACAjtD,KAAA8vD,aAAA,KAAA5C,GA0BA,QAAAqhC,IAAAjuC,EAAA8sC,EAAAnB,EAAAC,EAAA9tF,EAAAivF,EAAAmB,GAEA1iC,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,oBAEApE,KAAA0+C,YACA4B,SACA8sC,OACAnB,kBACAC,iBACA9tF,IACAivF,KAGAzmF,SAAA4nF,GAAAj+D,QAAAC,KAAA,4FAEAxwB,KAAAupF,mBAAA,GAAA4D,IAAA7sC,EAAA8sC,EAAAnB,EAAAC,EAAA9tF,EAAAivF,IACArtF,KAAAwpF,gBAWA,QAAAiF,IAAAnuC,EAAA8sC,EAAAlB,EAAAD,EAAAyC,GAEAthC,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,sBAEApE,KAAA0+C,YACA4B,SACA8sC,OACAlB,iBACAD,kBACAyC,OAGApuC,KAAA,IACA8sC,KAAA,GACAlB,EAAAprF,KAAA4uD,MAAAw8B,IAAA,EACAD,EAAAnrF,KAAA4uD,MAAAu8B,IAAA,EACAyC,KAAA,EAAA5tF,KAAAu8B,EAGA,IAmBApyB,GAAAnG,EAnBA6qD,GAAAu8B,EAAA,IAAAD,EAAA,GACAr8B,EAAAs8B,EAAAD,EAAA,IAGAj/B,EAAA,IAAA4C,EAAA,MAAApE,YAAA3W,aAAA+a,GACAjb,EAAA,GAAA9F,cAAA,EAAA8gB,GACA1C,EAAA,GAAApe,cAAA,EAAA8gB,GACAzC,EAAA,GAAAre,cAAA,EAAA8gB,GAGAP,EAAA,EACAC,EAAA,EACAE,EAAA,EAGAlP,EAAA,GAAA1R,GACA+H,EAAA,GAAA/H,GACA6R,EAAA,GAAA7R,EAMA,KAAA1jC,EAAA,EAAcA,GAAAihF,EAAqBjhF,IAEnC,IAAAnG,EAAA,EAAeA,GAAAmnF,EAAsBnnF,IAAA,CAErC,GAAAqpD,GAAArpD,EAAAmnF,EAAAyC,EACA1oF,EAAAiF,EAAAihF,EAAAprF,KAAAu8B,GAAA,CAGAqZ,GAAAp1C,GAAAg/C,EAAA8sC,EAAAtsF,KAAAs8B,IAAAp3B,IAAAlF,KAAAs8B,IAAA+wB,GACAzX,EAAAn1C,GAAA++C,EAAA8sC,EAAAtsF,KAAAs8B,IAAAp3B,IAAAlF,KAAA+rF,IAAA1+B,GACAzX,EAAAl1C,EAAA4rF,EAAAtsF,KAAA+rF,IAAA7mF,GAEA2uC,EAAAya,GAAA1Y,EAAAp1C,EACAqzC,EAAAya,EAAA,GAAA1Y,EAAAn1C,EACAozC,EAAAya,EAAA,GAAA1Y,EAAAl1C,EAGA6+C,EAAA/+C,EAAAg/C,EAAAx/C,KAAAs8B,IAAA+wB,GACA9N,EAAA9+C,EAAA++C,EAAAx/C,KAAA+rF,IAAA1+B,GAGA3N,EAAAutC,WAAAr3C,EAAA2J,GAAAw6B,YAEA5tB,EAAAmC,GAAA5O,EAAAl/C,EACA2rD,EAAAmC,EAAA,GAAA5O,EAAAj/C,EACA0rD,EAAAmC,EAAA,GAAA5O,EAAAh/C,EAGA0rD,EAAAmC,GAAAvqD,EAAAmnF,EACA/+B,EAAAmC,EAAA,GAAApkD,EAAAihF,EAGA98B,GAAA,EACAC,GAAA,EAQA,IAAApkD,EAAA,EAAcA,GAAAihF,EAAqBjhF,IAEnC,IAAAnG,EAAA,EAAeA,GAAAmnF,EAAsBnnF,IAAA,CAGrC,GAAAua,IAAA4sE,EAAA,GAAAhhF,EAAAnG,EAAA,EACAwa,GAAA2sE,EAAA,IAAAhhF,EAAA,GAAAnG,EAAA,EACA3G,GAAA8tF,EAAA,IAAAhhF,EAAA,GAAAnG,EACAkpD,GAAAi+B,EAAA,GAAAhhF,EAAAnG,CAGAkoD,GAAAuC,GAAAlwC,EACA2tC,EAAAuC,EAAA,GAAAjwC,EACA0tC,EAAAuC,EAAA,GAAAvB,EAGAhB,EAAAuC,EAAA,GAAAjwC,EACA0tC,EAAAuC,EAAA,GAAApxD,EACA6uD,EAAAuC,EAAA,GAAAvB,EAGAuB,GAAA,EAOAvvD,KAAA6vD,SAAA,GAAArF,IAAAwC,EAAA,IACAhtD,KAAA8vD,aAAA,cAAAtF,IAAA7V,EAAA,IACA30C,KAAA8vD,aAAA,YAAAtF,IAAAyC,EAAA,IACAjtD,KAAA8vD,aAAA,QAAAtF,IAAA0C,EAAA,IAaA,QAAAyhC,IAAAruC,EAAA8sC,EAAAlB,EAAAD,EAAAyC,GAEA5iC,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,gBAEApE,KAAA0+C,YACA4B,SACA8sC,OACAlB,iBACAD,kBACAyC,OAGA1uF,KAAAupF,mBAAA,GAAAkF,IAAAnuC,EAAA8sC,EAAAlB,EAAAD,EAAAyC,IA6xBA,QAAAE,IAAAC,EAAArpF,GAEA,iCAEAqpF,OAKA/iC,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,kBAEAyqF,EAAA7yE,MAAAnH,QAAAg6E,SAEA7uF,KAAA8uF,aAAAD,EAAArpF,OAEAxF,MAAA+uF,sBAsqBA,QAAAC,IAAAnrF,EAAA66C,GAEAA,OAEA,IAAAuwC,GAAAvwC,EAAAuwC,IAEA,KAAAA,KAAAC,WAAA,EAGA,MADA3+D,SAAA5W,MAAA,wEACA,GAAAmyC,GAIA,IAAA+iC,GAAAI,EAAAE,eAAAtrF,EAAA66C,EAAApM,KAAAoM,EAAA0wC,cAIA1wC,GAAA2wC,OAAAzoF,SAAA83C,EAAA57C,OAAA47C,EAAA57C,OAAA,GAIA8D,SAAA83C,EAAA4wC,iBAAA5wC,EAAA4wC,eAAA,IACA1oF,SAAA83C,EAAA6wC,YAAA7wC,EAAA6wC,UAAA,GACA3oF,SAAA83C,EAAA8wC,eAAA9wC,EAAA8wC,cAAA,GAEAZ,GAAA3wF,KAAA+B,KAAA6uF,EAAAnwC,GAEA1+C,KAAAoE,KAAA,eAYA,QAAAqrF,IAAAnvC,EAAAqN,EAAAC,EAAA8hC,EAAAC,EAAAC,EAAAC,GAEAziC,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,uBAEApE,KAAA0+C,YACA4B,SACAqN,gBACAC,iBACA8hC,WACAC,YACAC,aACAC,eAGAvvC,KAAA,GAEAqN,EAAA7sD,KAAAoQ,IAAA,EAAApQ,KAAA4uD,MAAA/B,IAAA,GACAC,EAAA9sD,KAAAoQ,IAAA,EAAApQ,KAAA4uD,MAAA9B,IAAA,GAEA8hC,EAAA9oF,SAAA8oF,IAAA,EACAC,EAAA/oF,SAAA+oF,IAAA,EAAA7uF,KAAAu8B,GAEAuyD,EAAAhpF,SAAAgpF,IAAA,EACAC,EAAAjpF,SAAAipF,IAAA/uF,KAAAu8B,EAYA,QAVAyyD,GAAAF,EAAAC,EAEAlgC,GAAAhC,EAAA,IAAAC,EAAA,GAEAmiC,EAAA,GAAAvlC,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GACA1C,EAAA,GAAAzC,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GACAzC,EAAA,GAAA1C,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GAEAhmD,EAAA,EAAAgrC,KAAA6L,EAAA,GAAA7R,GAEAptC,EAAA,EAAkBA,GAAAqsD,EAAqBrsD,IAAA,CAMvC,OAJAyuF,MAEAhqF,EAAAzE,EAAAqsD,EAEAtsD,EAAA,EAAmBA,GAAAqsD,EAAoBrsD,IAAA,CAEvC,GAAA6sD,GAAA7sD,EAAAqsD,EAEAsiC,GAAA3vC,EAAAx/C,KAAAs8B,IAAAsyD,EAAAvhC,EAAAwhC,GAAA7uF,KAAA+rF,IAAA+C,EAAA5pF,EAAA6pF,GACAK,EAAA5vC,EAAAx/C,KAAAs8B,IAAAwyD,EAAA5pF,EAAA6pF,GACAM,EAAA7vC,EAAAx/C,KAAA+rF,IAAA6C,EAAAvhC,EAAAwhC,GAAA7uF,KAAA+rF,IAAA+C,EAAA5pF,EAAA6pF,EAEArvC,GAAAv+C,IAAAguF,EAAAC,EAAAC,GAAAtV,YAEAkV,EAAA3B,OAAAzkF,EAAAsmF,EAAAC,EAAAC,GACAljC,EAAAmhC,OAAAzkF,EAAA62C,EAAAl/C,EAAAk/C,EAAAj/C,EAAAi/C,EAAAh/C,GACA0rD,EAAAmhC,MAAA1kF,EAAAwkD,EAAA,EAAAnoD,GAEAgqF,EAAAjkF,KAAApC,GAEAA,IAIAgrC,EAAA5oC,KAAAikF,GAMA,OAFAhjC,MAEAzrD,EAAA,EAAkBA,EAAAqsD,EAAoBrsD,IAEtC,OAAAD,GAAA,EAAmBA,EAAAqsD,EAAmBrsD,IAAA,CAEtC,GAAA8uF,GAAAz7C,EAAApzC,GAAAD,EAAA,GACA+uF,EAAA17C,EAAApzC,GAAAD,GACAgvF,EAAA37C,EAAApzC,EAAA,GAAAD,GACAivF,EAAA57C,EAAApzC,EAAA,GAAAD,EAAA,IAEA,IAAAC,GAAAquF,EAAA,IAAA5iC,EAAAjhD,KAAAqkF,EAAAC,EAAAE,IACAhvF,IAAAqsD,EAAA,GAAAkiC,EAAAhvF,KAAAu8B,KAAA2vB,EAAAjhD,KAAAskF,EAAAC,EAAAC,GAMAvwF,KAAA6vD,SAAA,IAAAkgC,EAAA99D,MAAA,MAAAs5B,GAAAF,IAAA2B,EAAA,IACAhtD,KAAA8vD,aAAA,WAAAigC,GACA/vF,KAAA8vD,aAAA,SAAA7C,GACAjtD,KAAA8vD,aAAA,KAAA5C,GAEAltD,KAAAssD,eAAA,GAAAlM,IAAA,GAAAzR,GAAA2R,GAWA,QAAAkwC,IAAAlwC,EAAAqN,EAAAC,EAAA8hC,EAAAC,EAAAC,EAAAC,GAEA/jC,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,iBAEApE,KAAA0+C,YACA4B,SACAqN,gBACAC,iBACA8hC,WACAC,YACAC,aACAC,eAGA7vF,KAAAupF,mBAAA,GAAAkG,IAAAnvC,EAAAqN,EAAAC,EAAA8hC,EAAAC,EAAAC,EAAAC,IAWA,QAAAY,IAAAC,EAAAC,EAAAC,EAAAC,EAAAjB,EAAAC,GAEAziC,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,qBAEApE,KAAA0+C,YACAgyC,cACAC,cACAC,gBACAC,cACAjB,aACAC,eAGAa,KAAA,GACAC,KAAA,GAEAf,EAAAhpF,SAAAgpF,IAAA,EACAC,EAAAjpF,SAAAipF,IAAA,EAAA/uF,KAAAu8B,GAEAuzD,EAAAhqF,SAAAgqF,EAAA9vF,KAAAoQ,IAAA,EAAA0/E,GAAA,EACAC,EAAAjqF,SAAAiqF,EAAA/vF,KAAAoQ,IAAA,EAAA2/E,GAAA,CAGA,IAUAC,GAKA7lF,EAAAnG,EAfA6qD,GAAAihC,EAAA,IAAAC,EAAA,GACAjhC,EAAAghC,EAAAC,EAAA,IAGA7jC,EAAA,GAAAxC,IAAA,IAAAoF,EAAA,MAAApE,YAAA3W,aAAA+a,GAAA,GACAjb,EAAA,GAAA6V,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GACA1C,EAAA,GAAAzC,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GACAzC,EAAA,GAAA1C,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GAGAhmD,EAAA,EAAAgkF,EAAA,EACArtC,EAAAowC,EACAK,GAAAJ,EAAAD,GAAAG,EACAn6C,EAAA,GAAA/H,GACAiI,EAAA,GAAAhL,EAOA,KAAA3gC,EAAA,EAAcA,GAAA4lF,EAAkB5lF,IAAA,CAEhC,IAAAnG,EAAA,EAAeA,GAAA8rF,EAAoB9rF,IAEnCgsF,EAAAlB,EAAA9qF,EAAA8rF,EAAAf,EAGAn5C,EAAAp1C,EAAAg/C,EAAAx/C,KAAAs8B,IAAA0zD,GACAp6C,EAAAn1C,EAAA++C,EAAAx/C,KAAA+rF,IAAAiE,GACAn8C,EAAAy5C,OAAAzkF,EAAA+sC,EAAAp1C,EAAAo1C,EAAAn1C,EAAAm1C,EAAAl1C,GAGAyrD,EAAAmhC,OAAAzkF,EAAA,OAGAitC,EAAAt1C,GAAAo1C,EAAAp1C,EAAAqvF,EAAA,KACA/5C,EAAAr1C,GAAAm1C,EAAAn1C,EAAAovF,EAAA,KACAzjC,EAAAmhC,MAAA1kF,EAAAitC,EAAAt1C,EAAAs1C,EAAAr1C,GAGAoI,GAKA22C,IAAAywC,EAMA,IAAA9lF,EAAA,EAAcA,EAAA4lF,EAAiB5lF,IAAA,CAE/B,GAAA+lF,GAAA/lF,GAAA2lF,EAAA,EAEA,KAAA9rF,EAAA,EAAeA,EAAA8rF,EAAmB9rF,IAAA,CAElCgsF,EAAAhsF,EAAAksF,CAGA,IAAA3xE,GAAAyxE,EACAxxE,EAAAwxE,EAAAF,EAAA,EACAzyF,EAAA2yF,EAAAF,EAAA,EACA5iC,EAAA8iC,EAAA,CAGA9jC,GAAAshC,KAAAX,EAAAtuE,GAAmCsuE,IACnC3gC,EAAAshC,KAAAX,EAAAruE,GAAmCquE,IACnC3gC,EAAAshC,KAAAX,EAAAxvF,GAAmCwvF,IAGnC3gC,EAAAshC,KAAAX,EAAAtuE,GAAmCsuE,IACnC3gC,EAAAshC,KAAAX,EAAAxvF,GAAmCwvF,IACnC3gC,EAAAshC,KAAAX,EAAA3/B,GAAmC2/B,KAQnC3tF,KAAA6vD,SAAA7C,GACAhtD,KAAA8vD,aAAA,WAAAnb,GACA30C,KAAA8vD,aAAA,SAAA7C,GACAjtD,KAAA8vD,aAAA,KAAA5C,GAWA,QAAA+jC,IAAAP,EAAAC,EAAAC,EAAAC,EAAAjB,EAAAC,GAEA/jC,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,eAEApE,KAAA0+C,YACAgyC,cACAC,cACAC,gBACAC,cACAjB,aACAC,eAGA7vF,KAAAupF,mBAAA,GAAAkH,IAAAC,EAAAC,EAAAC,EAAAC,EAAAjB,EAAAC,IAYA,QAAAqB,IAAAruF,EAAAC,EAAA6qD,EAAAC,GAEA9B,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,gBAEApE,KAAA0+C,YACA77C,QACAC,SACA6qD,gBACAC,kBAGA5tD,KAAAupF,mBAAA,GAAAx5B,IAAAltD,EAAAC,EAAA6qD,EAAAC,IAkBA,QAAAujC,IAAAxQ,EAAAyQ,EAAA1B,EAAAC,GAEAviC,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,sBAEApE,KAAA0+C,YACAiiC,SACAyQ,WACA1B,WACAC,aAGAyB,EAAAtwF,KAAA4uD,MAAA0hC,IAAA,GACA1B,KAAA,EACAC,KAAA,EAAA7uF,KAAAu8B,GAGAsyD,EAAAnjD,GAAA6kD,MAAA1B,EAAA,IAAA7uF,KAAAu8B,GAGA,IASA9c,GAIAzb,EAAAmG,EAbA0kD,GAAAyhC,EAAA,GAAAzQ,EAAAx8E,OACAyrD,EAAAwhC,EAAAzQ,EAAAx8E,OAAA,IAGA6oD,EAAA,GAAAxC,IAAA,IAAAoF,EAAA,MAAApE,YAAA3W,aAAA+a,GAAA,GACAjb,EAAA,GAAA6V,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GACAzC,EAAA,GAAA1C,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GAGAhmD,EAAA,EAAAgkF,EAAA,EACA2D,EAAA,EAAAF,EACA16C,EAAA,GAAA/H,GACAiI,EAAA,GAAAhL,EAKA,KAAA9mC,EAAA,EAAcA,GAAAssF,EAAetsF,IAAA,CAE7B,GAAAysF,GAAA7B,EAAA5qF,EAAAwsF,EAAA3B,EAEA9C,EAAA/rF,KAAA+rF,IAAA0E,GACAn0D,EAAAt8B,KAAAs8B,IAAAm0D,EAEA,KAAAtmF,EAAA,EAAeA,GAAA01E,EAAAx8E,OAAA,EAA4B8G,IAG3CyrC,EAAAp1C,EAAAq/E,EAAA11E,GAAA3J,EAAAurF,EACAn2C,EAAAn1C,EAAAo/E,EAAA11E,GAAA1J,EACAm1C,EAAAl1C,EAAAm/E,EAAA11E,GAAA3J,EAAA87B,EACAuX,EAAAy5C,OAAAzkF,EAAA+sC,EAAAp1C,EAAAo1C,EAAAn1C,EAAAm1C,EAAAl1C,GAGAo1C,EAAAt1C,EAAAwD,EAAAssF,EACAx6C,EAAAr1C,EAAA0J,GAAA01E,EAAAx8E,OAAA,GACA+oD,EAAAmhC,MAAA1kF,EAAAitC,EAAAt1C,EAAAs1C,EAAAr1C,GAGAoI,IAQA,IAAA7E,EAAA,EAAcA,EAAAssF,EAActsF,IAE5B,IAAAmG,EAAA,EAAeA,EAAA01E,EAAAx8E,OAAA,EAA2B8G,IAAA,CAE1CsV,EAAAtV,EAAAnG,EAAA67E,EAAAx8E,MAGA,IAAAkb,GAAAkB,EACAjB,EAAAiB,EAAAogE,EAAAx8E,OACAhG,EAAAoiB,EAAAogE,EAAAx8E,OAAA,EACA6pD,EAAAztC,EAAA,CAGAysC,GAAAshC,KAAAX,EAAAtuE,GAAmCsuE,IACnC3gC,EAAAshC,KAAAX,EAAAruE,GAAmCquE,IACnC3gC,EAAAshC,KAAAX,EAAA3/B,GAAmC2/B,IAGnC3gC,EAAAshC,KAAAX,EAAAruE,GAAmCquE,IACnC3gC,EAAAshC,KAAAX,EAAAxvF,GAAmCwvF,IACnC3gC,EAAAshC,KAAAX,EAAA3/B,GAAmC2/B,IAmBnC,GAXA3tF,KAAA6vD,SAAA7C,GACAhtD,KAAA8vD,aAAA,WAAAnb,GACA30C,KAAA8vD,aAAA,KAAA5C,GAIAltD,KAAAqpF,uBAKAsG,IAAA,EAAA7uF,KAAAu8B,GAAA,CAEA,GAAA4vB,GAAAjtD,KAAA0kB,WAAA87B,OAAApR,MACAoiD,EAAA,GAAA7iD,GACA8iD,EAAA,GAAA9iD,GACAhiB,EAAA,GAAAgiB,EAKA,KAFApuB,EAAA6wE,EAAAzQ,EAAAx8E,OAAA,EAEAW,EAAA,EAAAmG,EAAA,EAAqBnG,EAAA67E,EAAAx8E,OAAmBW,IAAAmG,GAAA,EAGxCumF,EAAAlwF,EAAA2rD,EAAAhiD,EAAA,GACAumF,EAAAjwF,EAAA0rD,EAAAhiD,EAAA,GACAumF,EAAAhwF,EAAAyrD,EAAAhiD,EAAA,GAGAwmF,EAAAnwF,EAAA2rD,EAAA1sC,EAAAtV,EAAA,GACAwmF,EAAAlwF,EAAA0rD,EAAA1sC,EAAAtV,EAAA,GACAwmF,EAAAjwF,EAAAyrD,EAAA1sC,EAAAtV,EAAA,GAGA0hB,EAAAqhE,WAAAwD,EAAAC,GAAA5W,YAGA5tB,EAAAhiD,EAAA,GAAAgiD,EAAA1sC,EAAAtV,EAAA,GAAA0hB,EAAArrB,EACA2rD,EAAAhiD,EAAA,GAAAgiD,EAAA1sC,EAAAtV,EAAA,GAAA0hB,EAAAprB,EACA0rD,EAAAhiD,EAAA,GAAAgiD,EAAA1sC,EAAAtV,EAAA,GAAA0hB,EAAAnrB,GAwBA,QAAAkwF,IAAA/Q,EAAAyQ,EAAA1B,EAAAC,GAEA7jC,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,gBAEApE,KAAA0+C,YACAiiC,SACAyQ,WACA1B,WACAC,aAGA3vF,KAAAupF,mBAAA,GAAA4H,IAAAxQ,EAAAyQ,EAAA1B,EAAAC,IACA3vF,KAAAwpF,gBAuBA,QAAAmI,IAAA9C,EAAArpF,GAEAsmD,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,gBAEA4X,MAAAnH,QAAAg6E,MAAA,IAAAA,OAEA7uF,KAAA8uF,aAAAD,EAAArpF,GAEAxF,KAAA+uF,qBA8GA,QAAA6C,IAAAlwC,EAAAmwC,GAUA,QAAAzJ,GAAA/oE,EAAAC,GAEA,MAAAD,GAAAC,EAVA8tC,GAAAnvD,KAAA+B,MAEA6xF,EAAAjrF,SAAAirF,IAAA,CAEA,IAYAC,GAZAC,EAAAjxF,KAAAs8B,IAAAoP,GAAAwlD,QAAAH,GAEAxJ,GAAA,KAAA79D,KAQA7L,GAAA,YAIA+iC,MAAAQ,kBAEA4vC,EAAA,GAAAhmC,IACAgmC,EAAAvI,mBAAA7nC,IAIAowC,EAAApwC,EAAAnyC,QAIAuiF,EAAAtI,gBACAsI,EAAA/C,oBAKA,QAHAp6C,GAAAm9C,EAAAn9C,SACAC,EAAAk9C,EAAAl9C,MAEA9vC,EAAA,EAAA2F,EAAAmqC,EAAAzwC,OAAoCW,EAAA2F,EAAO3F,IAI3C,OAFA6hD,GAAA/R,EAAA9vC,GAEAmG,EAAA,EAAmBA,EAAA,EAAOA,IAAA,CAE1Bo9E,EAAA,GAAA1hC,EAAAhoC,EAAA1T,IACAo9E,EAAA,GAAA1hC,EAAAhoC,GAAA1T,EAAA,OACAo9E,EAAA9sE,KAAA6sE,EAEA,IAAA3gF,GAAA4gF,EAAAluE,UAEAvT,UAAA4jB,EAAA/iB,GAEA+iB,EAAA/iB,IAAoBwqF,MAAA5J,EAAA,GAAA6J,MAAA7J,EAAA,GAAA8J,MAAArtF,EAAAstF,MAAAxrF,QAIpB4jB,EAAA/iB,GAAA2qF,MAAAttF,EAQA,GAAA0jF,KAEA,QAAA/gF,KAAA+iB,GAAA,CAEA,GAAAujC,GAAAvjC,EAAA/iB,EAEA,IAAAb,SAAAmnD,EAAAqkC,OAAAx9C,EAAAmZ,EAAAokC,OAAA3xC,OAAA6xC,IAAAz9C,EAAAmZ,EAAAqkC,OAAA5xC,SAAAuxC,EAAA,CAEA,GAAAr7C,GAAA/B,EAAAoZ,EAAAkkC,MACAzJ,GAAAz8E,KAAA2qC,EAAAp1C,GACAknF,EAAAz8E,KAAA2qC,EAAAn1C,GACAinF,EAAAz8E,KAAA2qC,EAAAl1C,GAEAk1C,EAAA/B,EAAAoZ,EAAAmkC,OACA1J,EAAAz8E,KAAA2qC,EAAAp1C,GACAknF,EAAAz8E,KAAA2qC,EAAAn1C,GACAinF,EAAAz8E,KAAA2qC,EAAAl1C,IAMAxB,KAAA8vD,aAAA,cAAAtF,IAAA,GAAA3b,cAAA25C,GAAA,IAWA,QAAA8J,IAAAC,EAAAC,EAAA1vF,EAAAopF,EAAAt+B,EAAA6kC,EAAA7C,EAAAC,GAiFA,QAAA/hC,KAEA,GAAA77B,IAAAi6D,EAAA,IAAAt+B,EAAA,EAQA,OANA6kC,MAAA,IAEAxgE,IAAAi6D,EAAA,GAAAwG,EAAAxG,EAAAwG,GAIAzgE,EAIA,QAAAg8B,KAEA,GAAAh8B,GAAAi6D,EAAAt+B,EAAA,GAQA,OANA6kC,MAAA,IAEAxgE,GAAAi6D,EAAAwG,EAAA,GAIAzgE,EAIA,QAAA0gE,KAEA,GAAArxF,GAAAC,EACAi/C,EAAA,GAAA7R,GACA+H,EAAA,GAAA/H,GAEAqgB,EAAA,EAGA4jC,GAAAJ,EAAAD,GAAAzvF,CAIA,KAAAvB,EAAA,EAAeA,GAAAqsD,EAAqBrsD,IAAA,CAEpC,GAAAsxF,MAEA7sF,EAAAzE,EAAAqsD,EAGAtN,EAAAt6C,GAAAwsF,EAAAD,IAEA,KAAAjxF,EAAA,EAAgBA,GAAA4qF,EAAqB5qF,IAAA,CAErC,GAAA6sD,GAAA7sD,EAAA4qF,EAEA4G,EAAA3kC,EAAA0hC,EAAAD,EAEAmD,EAAAjyF,KAAA+rF,IAAAiG,GACAE,EAAAlyF,KAAAs8B,IAAA01D,EAGAp8C,GAAAp1C,EAAAg/C,EAAAyyC,EACAr8C,EAAAn1C,GAAAyE,EAAAlD,EAAAmwF,EACAv8C,EAAAl1C,EAAA8+C,EAAA0yC,EACAr+C,EAAAy5C,OAAAzkF,EAAA+sC,EAAAp1C,EAAAo1C,EAAAn1C,EAAAm1C,EAAAl1C,GAGAg/C,EAAAv+C,IAAA8wF,EAAAH,EAAAI,GAAAnY,YACA5tB,EAAAmhC,OAAAzkF,EAAA62C,EAAAl/C,EAAAk/C,EAAAj/C,EAAAi/C,EAAAh/C,GAGA0rD,EAAAmhC,MAAA1kF,EAAAwkD,EAAA,EAAAnoD,GAGA6sF,EAAA9mF,KAAApC,GAGAA,IAKAupF,EAAAnnF,KAAA8mF,GAMA,IAAAvxF,EAAA,EAAeA,EAAA4qF,EAAoB5qF,IAEnC,IAAAC,EAAA,EAAgBA,EAAAqsD,EAAoBrsD,IAAA,CAGpC,GAAA4xF,GAAAD,EAAA3xF,GAAAD,GACA8xF,EAAAF,EAAA3xF,EAAA,GAAAD,GACA+xF,EAAAH,EAAA3xF,EAAA,GAAAD,EAAA,GACAkuE,EAAA0jB,EAAA3xF,GAAAD,EAAA,EAGA0rD,GAAAshC,KAAAX,EAAAwF,GAAqCxF,IACrC3gC,EAAAshC,KAAAX,EAAAyF,GAAqCzF,IACrC3gC,EAAAshC,KAAAX,EAAAne,GAAqCme,IAGrC3gC,EAAAshC,KAAAX,EAAAyF,GAAqCzF,IACrC3gC,EAAAshC,KAAAX,EAAA0F,GAAqC1F,IACrC3gC,EAAAshC,KAAAX,EAAAne,GAAqCme,IAGrC3+B,GAAA,EAOAhM,EAAAwM,SAAAC,EAAAT,EAAA,GAGAS,GAAAT,EAIA,QAAAskC,GAAA/zF,GAEA,GAAA+B,GAAAiyF,EAAAC,EAEA58C,EAAA,GAAAhL,GACA8K,EAAA,GAAA/H,GAEAqgB,EAAA,EAEA1O,EAAA/gD,KAAA,EAAAgzF,EAAAC,EACAiB,EAAAl0F,KAAA,MASA,KANAg0F,EAAA5pF,EAMArI,EAAA,EAAeA,GAAA4qF,EAAqB5qF,IAGpCqzC,EAAAy5C,OAAAzkF,EAAA,EAAAspF,EAAAQ,EAAA,GAGAxmC,EAAAmhC,OAAAzkF,EAAA,EAAA8pF,EAAA,GAGA78C,EAAAt1C,EAAA,GACAs1C,EAAAr1C,EAAA,GAEA2rD,EAAAmhC,MAAA1kF,EAAAitC,EAAAt1C,EAAAs1C,EAAAr1C,GAGAoI,GASA,KAJA6pF,EAAA7pF,EAIArI,EAAA,EAAeA,GAAA4qF,EAAqB5qF,IAAA,CAEpC,GAAA6sD,GAAA7sD,EAAA4qF,EACA4G,EAAA3kC,EAAA0hC,EAAAD,EAEAoD,EAAAlyF,KAAAs8B,IAAA01D,GACAC,EAAAjyF,KAAA+rF,IAAAiG,EAGAp8C,GAAAp1C,EAAAg/C,EAAAyyC,EACAr8C,EAAAn1C,EAAA0xF,EAAAQ,EACA/8C,EAAAl1C,EAAA8+C,EAAA0yC,EACAr+C,EAAAy5C,OAAAzkF,EAAA+sC,EAAAp1C,EAAAo1C,EAAAn1C,EAAAm1C,EAAAl1C,GAGAyrD,EAAAmhC,OAAAzkF,EAAA,EAAA8pF,EAAA,GAGA78C,EAAAt1C,EAAA,GAAA0xF,EAAA,GACAp8C,EAAAr1C,EAAA,GAAAwxF,EAAAU,EAAA,GACAvmC,EAAAmhC,MAAA1kF,EAAAitC,EAAAt1C,EAAAs1C,EAAAr1C,GAGAoI,IAMA,IAAArI,EAAA,EAAeA,EAAA4qF,EAAoB5qF,IAAA,CAEnC,GAAAnD,GAAAo1F,EAAAjyF,EACAwD,EAAA0uF,EAAAlyF,CAEA/B,MAAA,GAGAytD,EAAAshC,KAAAX,EAAA7oF,GAAoC6oF,IACpC3gC,EAAAshC,KAAAX,EAAA7oF,EAAA,GAAwC6oF,IACxC3gC,EAAAshC,KAAAX,EAAAxvF,GAAoCwvF,MAKpC3gC,EAAAshC,KAAAX,EAAA7oF,EAAA,GAAwC6oF,IACxC3gC,EAAAshC,KAAAX,EAAA7oF,GAAoC6oF,IACpC3gC,EAAAshC,KAAAX,EAAAxvF,GAAoCwvF,KAKpC3+B,GAAA,EAKAhM,EAAAwM,SAAAC,EAAAT,EAAAzvD,KAAA,OAGAkwD,GAAAT,EA/SA5B,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,yBAEApE,KAAA0+C,YACA6zC,YACAC,eACA1vF,SACAopF,iBACAt+B,iBACA6kC,YACA7C,aACAC,cAGA,IAAA7sC,GAAAhjD,IAEAuyF,GAAA3rF,SAAA2rF,IAAA,GACAC,EAAA5rF,SAAA4rF,IAAA,GACA1vF,EAAA8D,SAAA9D,IAAA,IAEAopF,EAAAprF,KAAA4uD,MAAAw8B,IAAA,EACAt+B,EAAA9sD,KAAA4uD,MAAA9B,IAAA,EAEA6kC,EAAA7rF,SAAA6rF,KACA7C,EAAAhpF,SAAAgpF,IAAA,EACAC,EAAAjpF,SAAAipF,IAAA,EAAA/uF,KAAAu8B,EAIA,IAAAq1D,GAAA,CAEAD,MAAA,IAEAF,EAAA,GAAAG,IACAF,EAAA,GAAAE,IAIA,IAAA/iC,GAAA7B,IACA8B,EAAA3B,IAIAjB,EAAA,GAAAxC,IAAA,IAAAoF,EAAA,MAAApE,YAAA3W,aAAA+a,GAAA,GACAjb,EAAA,GAAA6V,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GACA1C,EAAA,GAAAzC,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GACAzC,EAAA,GAAA1C,IAAA,GAAA3b,cAAA,EAAA8gB,GAAA,GAIAhmD,EAAA,EACAgkF,EAAA,EACAuF,KACAD,EAAAnwF,EAAA,EAGA2sD,EAAA,CAIAkjC,KAEAF,KAAA,IAEAF,EAAA,GAAAe,GAAA,GACAd,EAAA,GAAAc,GAAA,IAMAtzF,KAAA6vD,SAAA7C,GACAhtD,KAAA8vD,aAAA,WAAAnb,GACA30C,KAAA8vD,aAAA,SAAA7C,GACAjtD,KAAA8vD,aAAA,KAAA5C,GAiPA,QAAAwmC,IAAAnB,EAAAC,EAAA1vF,EAAAopF,EAAAt+B,EAAA6kC,EAAA7C,EAAAC,GAEA/jC,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,mBAEApE,KAAA0+C,YACA6zC,YACAC,eACA1vF,SACAopF,iBACAt+B,iBACA6kC,YACA7C,aACAC,eAGA7vF,KAAAupF,mBAAA,GAAA+I,IAAAC,EAAAC,EAAA1vF,EAAAopF,EAAAt+B,EAAA6kC,EAAA7C,EAAAC,IACA7vF,KAAAwpF,gBAWA,QAAAmK,IAAArzC,EAAAx9C,EAAAopF,EAAAt+B,EAAA6kC,EAAA7C,EAAAC,GAEA6D,GAAAz1F,KAAA+B,KAAA,EAAAsgD,EAAAx9C,EAAAopF,EAAAt+B,EAAA6kC,EAAA7C,EAAAC,GAEA7vF,KAAAoE,KAAA,eAEApE,KAAA0+C,YACA4B,SACAx9C,SACAopF,iBACAt+B,iBACA6kC,YACA7C,aACAC,eAYA,QAAA+D,IAAAtzC,EAAAx9C,EAAAopF,EAAAt+B,EAAA6kC,EAAA7C,EAAAC,GAEAyC,GAAAr0F,KAAA+B,KAAA,EAAAsgD,EAAAx9C,EAAAopF,EAAAt+B,EAAA6kC,EAAA7C,EAAAC,GAEA7vF,KAAAoE,KAAA,qBAEApE,KAAA0+C,YACA4B,SACAx9C,SACAopF,iBACAt+B,iBACA6kC,YACA7C,aACAC,eAYA,QAAAgE,IAAAvzC,EAAA8wC,EAAAxB,EAAAC,GAEAziC,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,uBAEApE,KAAA0+C,YACA4B,SACA8wC,WACAxB,aACAC,eAGAvvC,KAAA,GACA8wC,EAAAxqF,SAAAwqF,EAAAtwF,KAAAoQ,IAAA,EAAAkgF,GAAA,EAEAxB,EAAAhpF,SAAAgpF,IAAA,EACAC,EAAAjpF,SAAAipF,IAAA,EAAA/uF,KAAAu8B,EAEA,IAAAsX,GAAAy8C,EAAA,EAEArB,EAAA,GAAAlhD,cAAA,EAAA8F,GACAsY,EAAA,GAAApe,cAAA,EAAA8F,GACAuY,EAAA,GAAAre,cAAA,EAAA8F,EAGAsY,GAAA,KACAC,EAAA,MACAA,EAAA,KAEA,QAAAttD,GAAA,EAAAkF,EAAA,EAAAgvF,EAAA,EAAkCl0F,GAAAwxF,EAAexxF,IAAAkF,GAAA,EAAAgvF,GAAA,GAEjD,GAAAhD,GAAAlB,EAAAhwF,EAAAwxF,EAAAvB,CAEAE,GAAAjrF,GAAAw7C,EAAAx/C,KAAAs8B,IAAA0zD,GACAf,EAAAjrF,EAAA,GAAAw7C,EAAAx/C,KAAA+rF,IAAAiE,GAEA7jC,EAAAnoD,EAAA,KAEAooD,EAAA4mC,IAAA/D,EAAAjrF,GAAAw7C,EAAA,KACA4M,EAAA4mC,EAAA,IAAA/D,EAAAjrF,EAAA,GAAAw7C,EAAA,KAMA,OAFA0M,MAEAloD,EAAA,EAAkBA,GAAAssF,EAAetsF,IAEjCkoD,EAAAjhD,KAAAjH,IAAA,IAIA9E,MAAA6vD,SAAA,GAAArF,IAAA,GAAA3V,aAAAmY,GAAA;AACAhtD,KAAA8vD,aAAA,cAAAtF,IAAAulC,EAAA,IACA/vF,KAAA8vD,aAAA,YAAAtF,IAAAyC,EAAA,IACAjtD,KAAA8vD,aAAA,QAAAtF,IAAA0C,EAAA,IAEAltD,KAAAssD,eAAA,GAAAlM,IAAA,GAAAzR,GAAA2R,GAWA,QAAAyzC,IAAAzzC,EAAA8wC,EAAAxB,EAAAC,GAEA/jC,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,iBAEApE,KAAA0+C,YACA4B,SACA8wC,WACAxB,aACAC,eAGA7vF,KAAAupF,mBAAA,GAAAsK,IAAAvzC,EAAA8wC,EAAAxB,EAAAC,IAYA,QAAAmE,IAAAnxF,EAAAC,EAAAssB,EAAAu+B,EAAAC,EAAAC,GAEA/B,GAAA7tD,KAAA+B,MAEAA,KAAAoE,KAAA,cAEApE,KAAA0+C,YACA77C,QACAC,SACAssB,QACAu+B,gBACAC,iBACAC,iBAGA7tD,KAAAupF,mBAAA,GAAA77B,IAAA7qD,EAAAC,EAAAssB,EAAAu+B,EAAAC,EAAAC,IACA7tD,KAAAwpF,gBAuDA,QAAAyK,MAEAx1C,EAAAxgD,KAAA+B,MACA62C,SAAAuO,GAAA/6C,OACA6pF,GAAA,QAEArhF,SAAezM,MAAA,MAGfmwC,aAAAye,GAAA,YACAxe,eAAAwe,GAAA,cAGAh1D,KAAA48C,QAAA,EACA58C,KAAAo9C,aAAA,EAEApjC,OAAA6uC,iBAAA7oD,MACA6S,SACAgjB,YAAA,EACAhsB,IAAA,WACA,MAAA7J,MAAA62C,SAAAhkC,QAAAzM,OAEAnE,IAAA,SAAAmE,GACApG,KAAA62C,SAAAhkC,QAAAzM,YAgBA,QAAA+tF,IAAAz1C,GAEAD,EAAAxgD,KAAA+B,KAAA0+C,GAEA1+C,KAAAoE,KAAA,oBAaA,QAAAgwF,IAAAjtC,GAEAnnD,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAAoE,KAAA,gBAEApE,KAAAmnD,sBAAAnrC,OAAAmrC,KAEAnnD,KAAAmnC,SAAA,EA6GA,QAAAwzB,IAAAjc,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAA2+C,SAAkB01C,SAAA,IAElBr0F,KAAAoE,KAAA,uBAEApE,KAAAg3C,MAAA,GAAAz2C,GAAA,UACAP,KAAAk5E,UAAA,GACAl5E,KAAAm5E,UAAA,GAEAn5E,KAAAsP,IAAA,KAEAtP,KAAA62D,SAAA,KACA72D,KAAA64E,kBAAA,EAEA74E,KAAA8pD,MAAA,KACA9pD,KAAA+pD,eAAA,EAEA/pD,KAAAm4E,SAAA,GAAA53E,GAAA,GACAP,KAAAo4E,kBAAA,EACAp4E,KAAA82D,YAAA,KAEA92D,KAAA+zD,QAAA,KACA/zD,KAAAg5E,UAAA,EAEAh5E,KAAAg0D,UAAA,KACAh0D,KAAAi5E,YAAA,GAAArtC,GAAA,KAEA5rC,KAAAggD,gBAAA,KACAhgD,KAAAigD,kBAAA,EACAjgD,KAAAkgD,iBAAA,EAEAlgD,KAAA+2D,aAAA,KAEA/2D,KAAAg3D,aAAA,KAEAh3D,KAAA+/C,SAAA,KAEA//C,KAAAiqD,OAAA,KACAjqD,KAAAo5E,gBAAA,EAEAp5E,KAAAqqD,gBAAA,IAEArqD,KAAA6+C,WAAA,EACA7+C,KAAA8+C,mBAAA,EACA9+C,KAAAsqD,iBAAA,QACAtqD,KAAAuqD,kBAAA,QAEAvqD,KAAAg/C,UAAA,EACAh/C,KAAAi/C,cAAA,EACAj/C,KAAAk/C,cAAA,EAEAl/C,KAAA2/C,UAAAjB,GAyEA,QAAAkc,IAAAlc,GAEAic,GAAA18D,KAAA+B,MAEAA,KAAA2+C,SAAkB21C,SAAA,IAElBt0F,KAAAoE,KAAA,uBAEApE,KAAAoqD,aAAA,GAEApqD,KAAAq5E,UAAA,EACAr5E,KAAAs5E,mBAAA,EAEAt5E,KAAA2/C,UAAAjB,GA0EA,QAAAgc,IAAAhc,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAAoE,KAAA,oBAEApE,KAAAg3C,MAAA,GAAAz2C,GAAA,UACAP,KAAA84E,SAAA,GAAAv4E,GAAA,SACAP,KAAA+4E,UAAA,GAEA/4E,KAAAsP,IAAA,KAEAtP,KAAA62D,SAAA,KACA72D,KAAA64E,kBAAA,EAEA74E,KAAA8pD,MAAA,KACA9pD,KAAA+pD,eAAA,EAEA/pD,KAAAm4E,SAAA,GAAA53E,GAAA,GACAP,KAAAo4E,kBAAA,EACAp4E,KAAA82D,YAAA,KAEA92D,KAAA+zD,QAAA,KACA/zD,KAAAg5E,UAAA,EAEAh5E,KAAAg0D,UAAA,KACAh0D,KAAAi5E,YAAA,GAAArtC,GAAA,KAEA5rC,KAAAggD,gBAAA,KACAhgD,KAAAigD,kBAAA,EACAjgD,KAAAkgD,iBAAA,EAEAlgD,KAAAgqD,YAAA,KAEAhqD,KAAA+/C,SAAA,KAEA//C,KAAAiqD,OAAA,KACAjqD,KAAAkqD,QAAAC,GACAnqD,KAAAoqD,aAAA,EACApqD,KAAAqqD,gBAAA,IAEArqD,KAAA6+C,WAAA,EACA7+C,KAAA8+C,mBAAA,EACA9+C,KAAAsqD,iBAAA,QACAtqD,KAAAuqD,kBAAA,QAEAvqD,KAAAg/C,UAAA,EACAh/C,KAAAi/C,cAAA,EACAj/C,KAAAk/C,cAAA,EAEAl/C,KAAA2/C,UAAAjB,GAwEA,QAAA8b,IAAA9b,GAEAhC,EAAAz+C,KAAA+B,KAAA0+C,GAEA1+C,KAAAoE,KAAA,qBAEApE,KAAA6+C,WAAA,EACA7+C,KAAA8+C,mBAAA,EAEA9+C,KAAA87C,KAAA,EACA97C,KAAA48C,QAAA,EACA58C,KAAAi/C,cAAA,EAEAj/C,KAAA2/C,UAAAjB,GA0DA,QAAA+b,IAAA/b,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAAoE,KAAA,sBAEApE,KAAAg3C,MAAA,GAAAz2C,GAAA,UAEAP,KAAAsP,IAAA,KAEAtP,KAAA62D,SAAA,KACA72D,KAAA64E,kBAAA,EAEA74E,KAAA8pD,MAAA,KACA9pD,KAAA+pD,eAAA,EAEA/pD,KAAAm4E,SAAA,GAAA53E,GAAA,GACAP,KAAAo4E,kBAAA,EACAp4E,KAAA82D,YAAA,KAEA92D,KAAAgqD,YAAA,KAEAhqD,KAAA+/C,SAAA,KAEA//C,KAAAiqD,OAAA,KACAjqD,KAAAkqD,QAAAC,GACAnqD,KAAAoqD,aAAA,EACApqD,KAAAqqD,gBAAA,IAEArqD,KAAA6+C,WAAA,EACA7+C,KAAA8+C,mBAAA,EACA9+C,KAAAsqD,iBAAA,QACAtqD,KAAAuqD,kBAAA,QAEAvqD,KAAAg/C,UAAA,EACAh/C,KAAAi/C,cAAA,EACAj/C,KAAAk/C,cAAA,EAEAl/C,KAAA2/C,UAAAjB,GAgEA,QAAAoc,IAAApc,GAEAhC,EAAAz+C,KAAA+B,MAEAA,KAAAoE,KAAA,qBAEApE,KAAAg3C,MAAA,GAAAz2C,GAAA,UAEAP,KAAA4+C,UAAA,EAEA5+C,KAAAqI,MAAA,EACArI,KAAAy4E,SAAA,EACAz4E,KAAA24E,QAAA,EAEA34E,KAAA48C,QAAA,EAEA58C,KAAA2/C,UAAAjB,GA8FA,QAAA61C,IAAAC,EAAArlE,EAAAslE,GAEA,GAAAzxC,GAAAhjD,KAEA00F,GAAA,EAAAC,EAAA,EAAAC,EAAA,CAEA50F,MAAA60F,QAAAjuF,OACA5G,KAAAw0F,SACAx0F,KAAAmvB,aACAnvB,KAAAy0F,UAEAz0F,KAAA80F,UAAA,SAAAlxD,GAEAgxD,IAEAF,KAAA,GAEA9tF,SAAAo8C,EAAA6xC,SAEA7xC,EAAA6xC,QAAAjxD,EAAA+wD,EAAAC,GAMAF,GAAA,GAIA10F,KAAA+0F,QAAA,SAAAnxD,GAEA+wD,IAEA/tF,SAAAo8C,EAAA7zB,YAEA6zB,EAAA7zB,WAAAyU,EAAA+wD,EAAAC,GAIAD,IAAAC,IAEAF,GAAA,EAEA9tF,SAAAo8C,EAAAwxC,QAEAxxC,EAAAwxC,WAQAx0F,KAAAg1F,UAAA,SAAApxD,GAEAh9B,SAAAo8C,EAAAyxC,SAEAzxC,EAAAyxC,QAAA7wD,IAcA,QAAAqxD,IAAAC,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GA0NA,QAAAC,IAAAF,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GAGAn1F,KAAAq1F,QAAA,KAkIA,QAAAC,IAAAJ,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GAGAn1F,KAAAq1F,QAAA,KAiFA,QAAAE,IAAAL,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GA2EA,QAAAK,IAAAN,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GAkEA,QAAAM,IAAAP,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GAiEA,QAAAO,IAAA1+C,EAAA2iC,GAEAvxB,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,QAEApE,KAAAg3C,MAAA,GAAAz2C,GAAAy2C,GACAh3C,KAAA25E,UAAA/yE,SAAA+yE,IAAA,EAEA35E,KAAAkpD,cAAAtiD,OA+CA,QAAA+uF,IAAA1jC,EAAAC,EAAAynB,GAEA+b,GAAAz3F,KAAA+B,KAAAiyD,EAAA0nB,GAEA35E,KAAAoE,KAAA,kBAEApE,KAAAkC,WAAA0E,OAEA5G,KAAAX,SAAAoc,KAAA2sC,GAAAO,WACA3oD,KAAA41F,eAEA51F,KAAAkyD,YAAA,GAAA3xD,GAAA2xD,GA0BA,QAAA2jC,IAAAz0F,GAEApB,KAAAoB,SAEApB,KAAAq6E,KAAA,EACAr6E,KAAAsgD,OAAA,EAEAtgD,KAAAgmD,QAAA,GAAApa,GAAA,SAEA5rC,KAAAsP,IAAA,KACAtP,KAAAumD,OAAA,GAAA3X,GA8CA,QAAAknD,MAEAD,GAAA53F,KAAA+B,KAAA,GAAAqB,IAAA,cAmCA,QAAAW,IAAAg1C,EAAA2iC,EAAA9nB,EAAA0oB,EAAAC,EAAAxoB,GAEA0jC,GAAAz3F,KAAA+B,KAAAg3C,EAAA2iC,GAEA35E,KAAAoE,KAAA,YAEApE,KAAAX,SAAAoc,KAAA2sC,GAAAO,WACA3oD,KAAA41F,eAEA51F,KAAAiY,OAAA,GAAAmwC,IAEApuC,OAAAwX,eAAAxxB,KAAA,SACA6J,IAAA,WAGA,MAAA7J,MAAA25E,UAAA74E,KAAAu8B,IAEAp7B,IAAA,SAAA8zF,GAGA/1F,KAAA25E,UAAAoc,EAAAj1F,KAAAu8B,MAIAr9B,KAAA6xD,SAAAjrD,SAAAirD,IAAA,EACA7xD,KAAAu6E,MAAA3zE,SAAA2zE,IAAAz5E,KAAAu8B,GAAA,EACAr9B,KAAAw6E,SAAA5zE,SAAA4zE,IAAA,EACAx6E,KAAAgyD,MAAAprD,SAAAorD,IAAA,EAEAhyD,KAAA+lD,OAAA,GAAA+vC,IAkCA,QAAAE,IAAAh/C,EAAA2iC,EAAA9nB,EAAAG,GAEA0jC,GAAAz3F,KAAA+B,KAAAg3C,EAAA2iC,GAEA35E,KAAAoE,KAAA,aAEA4V,OAAAwX,eAAAxxB,KAAA,SACA6J,IAAA,WAGA,SAAA7J,KAAA25E,UAAA74E,KAAAu8B,IAGAp7B,IAAA,SAAA8zF,GAGA/1F,KAAA25E,UAAAoc,GAAA,EAAAj1F,KAAAu8B,OAIAr9B,KAAA6xD,SAAAjrD,SAAAirD,IAAA,EACA7xD,KAAAgyD,MAAAprD,SAAAorD,IAAA,EAEAhyD,KAAA+lD,OAAA,GAAA8vC,IAAA,GAAAx0F,IAAA,cA6BA,QAAA40F,IAAAnwC,GAEA+vC,GAAA53F,KAAA+B,KAAA,GAAAywD,KAAA,kBAeA,QAAAylC,IAAAl/C,EAAA2iC,GAEA+b,GAAAz3F,KAAA+B,KAAAg3C,EAAA2iC,GAEA35E,KAAAoE,KAAA,mBAEApE,KAAAX,SAAAoc,KAAA2sC,GAAAO,WACA3oD,KAAA41F,eAEA51F,KAAAiY,OAAA,GAAAmwC,IAEApoD,KAAA+lD,OAAA,GAAAkwC,IA4BA,QAAAE,IAAAn/C,EAAA2iC,GAEA+b,GAAAz3F,KAAA+B,KAAAg3C,EAAA2iC,GAEA35E,KAAAoE,KAAA,eAEApE,KAAAkC,WAAA0E,OAkMA,QAAAwvF,IACAC,EAAAC,EAAAC,EAAAC,GAEAx2F,KAAAq2F,qBACAr2F,KAAAy2F,aAAA,EAEAz2F,KAAAw2F,aAAA5vF,SAAA4vF,EACAA,EAAA,GAAAF,GAAAt7E,YAAAu7E,GACAv2F,KAAAs2F,eACAt2F,KAAA02F,UAAAH,EA6OA,QAAAI,IACAN,EAAAC,EAAAC,EAAAC,GAEAJ,GAAAn4F,KACA+B,KAAAq2F,EAAAC,EAAAC,EAAAC,GAEAx2F,KAAA42F,aAAA,EACA52F,KAAA62F,aAAA,EACA72F,KAAA82F,aAAA,EACA92F,KAAA+2F,aAAA,EA0IA,QAAAC,IACAX,EAAAC,EAAAC,EAAAC,GAEAJ,GAAAn4F,KACA+B,KAAAq2F,EAAAC,EAAAC,EAAAC,GA2CA,QAAAS,IACAZ,EAAAC,EAAAC,EAAAC,GAEAJ,GAAAn4F,KACA+B,KAAAq2F,EAAAC,EAAAC,EAAAC,GAqXA,QAAAU,IAAAxvF,EAAAyvF,EAAAztF,EAAA0tF,GAEA,GAAAxwF,SAAAc,EAAA,SAAApE,OAAA,0BAEA,IAAAsD,SAAAuwF,GAAA,IAAAA,EAAAhzF,OAEA,SAAAb,OAAA,+BAAAoE,EAIA1H,MAAA0H,OAEA1H,KAAAm3F,MAAAE,GAAAC,aAAAH,EAAAn3F,KAAAu3F,gBACAv3F,KAAA0J,OAAA2tF,GAAAC,aAAA5tF,EAAA1J,KAAAw3F,iBAEAx3F,KAAAy3F,iBAAAL,GAAAp3F,KAAA03F,sBAEA13F,KAAA23F,WACA33F,KAAA43F,WAcA,QAAAC,IAAAnwF,EAAAyvF,EAAAztF,EAAA0tF,GAEAF,GAAAj5F,KAAA+B,KAAA0H,EAAAyvF,EAAAztF,EAAA0tF,GAuBA,QAAAU,IACAzB,EAAAC,EAAAC,EAAAC,GAEAJ,GAAAn4F,KACA+B,KAAAq2F,EAAAC,EAAAC,EAAAC,GAyCA,QAAAuB,IAAArwF,EAAAyvF,EAAAztF,EAAA0tF,GAEAF,GAAAj5F,KAAA+B,KAAA0H,EAAAyvF,EAAAztF,EAAA0tF,GAmCA,QAAAY,IAAAtwF,EAAAyvF,EAAAztF,EAAA0tF,GAEAF,GAAAj5F,KAAA+B,KAAA0H,EAAAyvF,EAAAztF,EAAA0tF,GA2BA,QAAAa,IAAAvwF,EAAAyvF,EAAAztF,EAAA0tF,GAEAF,GAAAj5F,KAAA+B,KAAA0H,EAAAyvF,EAAAztF,EAAA0tF,GA8BA,QAAAc,IAAAxwF,EAAAyvF,EAAAztF,GAEAwtF,GAAAj5F,KAAA+B,KAAA0H,EAAAyvF,EAAAztF,GAiCA,QAAAyuF,IAAAzwF,EAAAyvF,EAAAztF,EAAA0tF,GAEAF,GAAAj5F,KAAA+B,KAAA0H,EAAAyvF,EAAAztF,EAAA0tF,GA+BA,QAAAgB,IAAA1wF,EAAAyvF,EAAAztF,EAAA0tF,GAEAF,GAAAnqF,MAAA/M,KAAAgN,WA4IA,QAAAqrF,IAAA3wF,EAAA+N,EAAA6iF,GAEAt4F,KAAA0H,OACA1H,KAAAs4F,SACAt4F,KAAAyV,SAAA7O,SAAA6O,KAAA,EAEAzV,KAAAusC,KAAAC,GAAAC,eAGAzsC,KAAAyV,SAAA,GAEAzV,KAAAu4F,gBAIAv4F,KAAA43F,WAkVA,QAAAY,IAAAtD,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GACAn1F,KAAAy/D,YAwJA,QAAAg5B,IAAAvD,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GA+FA,QAAAuD,MAEA14F,KAAA24F,YAAA,aACA34F,KAAA44F,eAAA,aACA54F,KAAA64F,eAAA,aAiUA,QAAAC,IAAA5D,GAEA,iBAAAA,KAEA3kE,QAAAC,KAAA,6EACA0kE,EAAAtuF,QAIA5G,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GAEAn1F,KAAA+4F,iBAAA,EA+gBA,QAAAC,IAAA9D,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GACAn1F,KAAAi5F,YAAA,GAqrBA,QAAAC,OAiXA,QAAAC,IAAA/I,EAAAC,GAEArwF,KAAAowF,KACApwF,KAAAqwF,KAkDA,QAAA+I,MAEAp5F,KAAAq5F,UAEAr5F,KAAAs5F,WAAA,EAgOA,QAAAC,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA/5F,KAAAw5F,KACAx5F,KAAAy5F,KAEAz5F,KAAA05F,UACA15F,KAAA25F,UAEA35F,KAAA45F,cACA55F,KAAA65F,YAEA75F,KAAA85F,aAEA95F,KAAA+5F,aAAA,EA2HA,QAAAC,IAAArZ,GAEA3gF,KAAA2gF,OAAA/5E,SAAA+5E,OAmCA,QAAAsZ,IAAAC,EAAA9J,EAAAC,EAAAC,GAEAtwF,KAAAk6F,KACAl6F,KAAAowF,KACApwF,KAAAqwF,KACArwF,KAAAswF,KAkCA,QAAA6J,IAAAD,EAAA9J,EAAAC,GAEArwF,KAAAk6F,KACAl6F,KAAAowF,KACApwF,KAAAqwF,KAkKA,QAAA+J,MAEAC,GAAAttF,MAAA/M,KAAAgN,WAEAhN,KAAAs6F,SAiDA,QAAAD,IAAA1Z,GAEAyY,GAAAn7F,KAAA+B,MACAA,KAAAu6F,aAAA,GAAA3uD,GAEA+0C,GAEA3gF,KAAAw6F,WAAA7Z,GAWA,QAAA8Z,MACAz6F,KAAA06F,YACA16F,KAAA26F,YAAA,KA+PA,QAAAC,IAAAxzF,GAEApH,KAAAoH,OAoKA,QAAAyzF,IAAA3F,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GA4CA,QAAA2F,MAQA,MANAl0F,UAAAoD,KAEAA,GAAA,IAAA1L,OAAAy8F,cAAAz8F,OAAA08F,qBAIAhxF,GAQA,QAAAixF,IAAA/F,GAEAl1F,KAAAk1F,QAAAtuF,SAAAsuF,IAAAC,GA8BA,QAAA+F,MAEAl7F,KAAAoE,KAAA,eAEApE,KAAA+C,OAAA,EAEA/C,KAAAm7F,OAAA,KAEAn7F,KAAAo7F,QAAA,GAAA/5F,IACArB,KAAAo7F,QAAA53C,OAAAnK,OAAA,GACAr5C,KAAAo7F,QAAAryC,kBAAA,EAEA/oD,KAAAq7F,QAAA,GAAAh6F,IACArB,KAAAq7F,QAAA73C,OAAAnK,OAAA,GACAr5C,KAAAq7F,QAAAtyC,kBAAA,EAiFA,QAAAuyC,IAAAt/C,EAAAC,EAAAs/C,GAEAnzC,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,YAEA,IAAAksD,GAAA,GAAAvtD,EAAA,EAEAy4F,EAAA,GAAAn6F,IAAAivD,EAAAvtD,EAAAi5C,EAAAC,EACAu/C,GAAA50C,GAAA3kD,IAAA,QACAu5F,EAAA/5F,OAAA,GAAAktC,GAAA,QACA3uC,KAAA8B,IAAA05F,EAEA,IAAAC,GAAA,GAAAp6F,IAAAivD,EAAAvtD,EAAAi5C,EAAAC,EACAw/C,GAAA70C,GAAA3kD,IAAA,QACAw5F,EAAAh6F,OAAA,GAAAktC,IAAA,QACA3uC,KAAA8B,IAAA25F,EAEA,IAAAC,GAAA,GAAAr6F,IAAAivD,EAAAvtD,EAAAi5C,EAAAC,EACAy/C,GAAA90C,GAAA3kD,IAAA,OACAy5F,EAAAj6F,OAAA,GAAAktC,GAAA,QACA3uC,KAAA8B,IAAA45F,EAEA,IAAAC,GAAA,GAAAt6F,IAAAivD,EAAAvtD,EAAAi5C,EAAAC,EACA0/C,GAAA/0C,GAAA3kD,IAAA,QACA05F,EAAAl6F,OAAA,GAAAktC,GAAA,SACA3uC,KAAA8B,IAAA65F,EAEA,IAAAC,GAAA,GAAAv6F,IAAAivD,EAAAvtD,EAAAi5C,EAAAC,EACA2/C,GAAAh1C,GAAA3kD,IAAA,QACA25F,EAAAn6F,OAAA,GAAAktC,GAAA,QACA3uC,KAAA8B,IAAA85F,EAEA,IAAAC,GAAA,GAAAx6F,IAAAivD,EAAAvtD,EAAAi5C,EAAAC,EACA4/C,GAAAj1C,GAAA3kD,IAAA,QACA45F,EAAAp6F,OAAA,GAAAktC,GAAA,SACA3uC,KAAA8B,IAAA+5F,EAEA,IAAAr2F,IAAiB2mC,OAAAs1B,GAAAx1B,UAAAc,GAAAb,UAAAa,GAEjB/sC,MAAA2/D,aAAA,GAAAxxB,GAAAotD,IAAA/1F,GAEAxF,KAAA87F,cAAA,SAAA37F,EAAAe,GAEA,OAAAlB,KAAA+pB,QAAA/pB,KAAA8mD,mBAEA,IAAA6Y,GAAA3/D,KAAA2/D,aACAvyB,EAAAuyB,EAAA5xB,QAAAX,eAEAuyB,GAAA5xB,QAAAX,iBAAA,EAEAuyB,EAAAvxB,eAAA,EACAjuC,EAAAwC,OAAAzB,EAAAs6F,EAAA77B,GAEAA,EAAAvxB,eAAA,EACAjuC,EAAAwC,OAAAzB,EAAAu6F,EAAA97B,GAEAA,EAAAvxB,eAAA,EACAjuC,EAAAwC,OAAAzB,EAAAw6F,EAAA/7B,GAEAA,EAAAvxB,eAAA,EACAjuC,EAAAwC,OAAAzB,EAAAy6F,EAAAh8B,GAEAA,EAAAvxB,eAAA,EACAjuC,EAAAwC,OAAAzB,EAAA06F,EAAAj8B,GAEAA,EAAA5xB,QAAAX,kBAEAuyB,EAAAvxB,eAAA,EACAjuC,EAAAwC,OAAAzB,EAAA26F,EAAAl8B,GAEAx/D,EAAAsmD,gBAAA,OAaA,QAAAs1C,MAEA3zC,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,gBAEApE,KAAAgK,QAAA8wF,KAEA96F,KAAAg8F,KAAAh8F,KAAAgK,QAAAiyF,aACAj8F,KAAAg8F,KAAAE,QAAAl8F,KAAAgK,QAAAmyF,aAEAn8F,KAAAmF,OAAA,KAiGA,QAAAi3F,IAAAC,GAEAj0C,GAAAnqD,KAAA+B,MAEAA,KAAAoE,KAAA,QAEApE,KAAAgK,QAAAqyF,EAAAryF,QACAhK,KAAAoyB,OAAApyB,KAAAgK,QAAAsyF,qBACAt8F,KAAAoyB,OAAAmqE,QAAAv8F,KAAAw8F,QAAAn6F,KAAArC,MAEAA,KAAAg8F,KAAAh8F,KAAAgK,QAAAiyF,aACAj8F,KAAAg8F,KAAAE,QAAAG,EAAAI,YAEAz8F,KAAA08F,UAAA,EAEA18F,KAAAwV,UAAA,EACAxV,KAAA28F,aAAA,EACA38F,KAAA48F,WAAA,EACA58F,KAAA68F,oBAAA,EACA78F,KAAA88F,WAAA,QAEA98F,KAAA6rB,WA4QA,QAAAkxE,IAAAV,GAEAD,GAAAn+F,KAAA+B,KAAAq8F,GAEAr8F,KAAAg9F,OAAAh9F,KAAAgK,QAAAizF,eACAj9F,KAAAg9F,OAAAd,QAAAl8F,KAAAg8F,MAqFA,QAAAkB,IAAAC,EAAAC,GAEAp9F,KAAAq9F,SAAAF,EAAAnzF,QAAAszF,iBACAt9F,KAAAq9F,SAAAD,QAAAx2F,SAAAw2F,IAAA,KAEAp9F,KAAAoH,KAAA,GAAA4jD,YAAAhrD,KAAAq9F,SAAAE,mBAEAJ,EAAAK,YAAAtB,QAAAl8F,KAAAq9F,UAwCA,QAAAI,IAAAC,EAAAC,EAAAjH,GAEA12F,KAAA09F,UACA19F,KAAA02F,WAEA,IACAkH,GADAhgC,EAAAjS,YAGA,QAAAgyC,GAEA,iBAAAC,EAAA59F,KAAA69F,MAAkD,MAElD,cACA,WAEAjgC,EAAA5hD,MAAA4hF,EAAA59F,KAAA89F,OAAoD,MAEpD,SAAAF,EAAA59F,KAAA+9F,MAIA/9F,KAAAo9D,OAAA,GAAAQ,GAAA,EAAA84B,GAYA12F,KAAAg+F,iBAAAJ,EAEA59F,KAAAi+F,iBAAA,EAEAj+F,KAAAk+F,SAAA,EACAl+F,KAAAm+F,eAAA,EAsKA,QAAAC,IAAAC,EAAA7qD,EAAA8qD,GAEAt+F,KAAAwzC,OACAxzC,KAAAs+F,cACAF,GAAAG,eAAA/qD,GAEAxzC,KAAA+O,KAAAqvF,GAAAI,SACAH,EAAAr+F,KAAAs+F,WAAAl1F,WAAAi1F,EAEAr+F,KAAAq+F,WAspBA,QAAAI,IAAAC,GAEA1+F,KAAAusC,KAAAC,GAAAC,eAGAzsC,KAAAqhD,SAAArlC,MAAAnc,UAAAgR,MAAA5S,KAAA+O,WAEAhN,KAAA2+F,gBAAA,CAGA,IAAA3xC,KACAhtD,MAAA4+F,eAAA5xC,CAEA,QAAAloD,GAAA,EAAA6nB,EAAA3f,UAAA7I,OAAwCW,IAAA6nB,IAAS7nB,EAEjDkoD,EAAAhgD,UAAAlI,GAAAynC,MAAAznC,CAIA9E,MAAA6+F,UACA7+F,KAAA8+F,gBACA9+F,KAAA++F,aACA/+F,KAAAg/F,yBAEA,IAAAh8C,GAAAhjD,IAEAA,MAAAf,OAEAmzE,SACA6sB,YAAiB,MAAAj8C,GAAA3B,SAAAl9C,QACjB+6F,YAAiB,MAAAl/F,MAAAi/F,MAAAj8C,EAAA27C,kBAGjBQ,wBAA4B,MAAAn8C,GAAA+7C,UAAA56F,SA8T5B,QAAAi7F,IAAAC,EAAAC,EAAAC,GAEAv/F,KAAAw/F,OAAAH,EACAr/F,KAAAy/F,MAAAH,EACAt/F,KAAA0/F,WAAAH,GAAA,IAWA,QATAjH,GAAAgH,EAAAhH,OACAqH,EAAArH,EAAAn0F,OACAy7F,EAAA,GAAA5jF,OAAA2jF,GAEAE,GACAC,YAAAC,GACAC,UAAAD,IAGAj7F,EAAA,EAAkBA,IAAA66F,IAAe76F,EAAA,CAEjC,GAAAm7F,GAAA3H,EAAAxzF,GAAAo7F,kBAAA,KACAN,GAAA96F,GAAAm7F,EACAA,EAAAx7D,SAAAo7D,EAIA7/F,KAAAmgG,qBAAAN,EAEA7/F,KAAAogG,cAAAR,EAGA5/F,KAAAqgG,kBAAA,GAAArkF,OAAA2jF,GAEA3/F,KAAAsgG,YAAA,KACAtgG,KAAAugG,kBAAA,KAEAvgG,KAAAwgG,sBAAA,KACAxgG,KAAAygG,mBAAA,KAEAzgG,KAAA0gG,KAAAC,GACA3gG,KAAA4gG,YAAA,EAIA5gG,KAAA6gG,WAAA,KAIA7gG,KAAAm/B,KAAA,EAEAn/B,KAAA8gG,UAAA,EACA9gG,KAAA+gG,oBAAA,EAEA/gG,KAAAghG,OAAA,EACAhhG,KAAAihG,iBAAA,EAEAjhG,KAAAkhG,YAAA1sD,IAEAx0C,KAAAmhG,QAAA,EACAnhG,KAAAY,SAAA,EAEAZ,KAAAohG,mBAAA,EAEAphG,KAAAqhG,kBAAA,EACArhG,KAAAshG,gBAAA,EA+kBA,QAAAC,IAAA72E,GAEA1qB,KAAAwhG,MAAA92E,EACA1qB,KAAAyhG,qBACAzhG,KAAA0hG,WAAA,EAEA1hG,KAAAm/B,KAAA,EAEAn/B,KAAA8gG,UAAA,EAktBA,QAAAa,IAAAv7F,GAEA,gBAAAA,KAEAmqB,QAAAC,KAAA,sDACApqB,EAAA4G,UAAA,IAIAhN,KAAAoG,QAQA,QAAAw7F,MAEAx0C,GAAAnvD,KAAA+B,MAEAA,KAAAoE,KAAA,0BACApE,KAAAoxD,kBAAAxqD,OAyDA,QAAAi7F,IAAAC,EAAAr3C,EAAA9gB,EAAA+gB,GAEA1qD,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAAoH,KAAA06F,EACA9hG,KAAAyqD,WACAzqD,KAAA2pC,SAEA3pC,KAAA0qD,gBAAA,EAyHA,QAAAq3C,IAAA3yD,EAAAijC,GAEAryE,KAAAusC,KAAAC,GAAAC,eAEAzsC,KAAAovC,QACApvC,KAAAqyE,SACAryE,KAAAiyB,MAAArrB,SAAAwoC,IAAAjrC,OAAAkuE,EAAA,EAEAryE,KAAA2qD,SAAA,EACA3qD,KAAA4qD,aAAsBjhB,OAAA,EAAA1X,OAAA,GAEtBjyB,KAAAwa,QAAA,EAqFA,QAAAwnF,IAAA5yD,EAAAijC,EAAAxJ,GAEAk5B,GAAA9jG,KAAA+B,KAAAovC,EAAAijC,GAEAryE,KAAA6oE,oBAAA,EAuBA,QAAAo5B,IAAA7yD,EAAAqb,EAAAoe,GAEAre,GAAAvsD,KAAA+B,KAAAovC,EAAAqb,GAEAzqD,KAAA6oE,oBAAA,EAyBA,QAAAq5B,IAAAp6C,EAAAC,EAAA/L,EAAAC,GAEAj8C,KAAAmiG,IAAA,GAAAt6C,IAAAC,EAAAC,GAGA/nD,KAAAg8C,QAAA,EACAh8C,KAAAi8C,OAAAzH,IAEAx0C,KAAAypC,QACA6jB,QACAm6B,QACA7B,OACA+B,QAAYya,UAAA,GACZzc,WAGA3rE,OAAA6uC,iBAAA7oD,KAAAypC,QACA44D,YACAx4F,IAAA,WAEA,MADA0mB,SAAAC,KAAA,yEACAxwB,KAAA2nF,WAOA,QAAA2a,IAAAjjF,EAAAC,GAEA,MAAAD,GAAAwyC,SAAAvyC,EAAAuyC,SAIA,QAAA0wC,IAAA98F,EAAA+8F,EAAAC,EAAAC,GAEA,GAAAj9F,EAAA0hC,WAAA,IAEA1hC,EAAAk9F,QAAAH,EAAAC,GAEAC,KAAA,GAIA,OAFAx1E,GAAAznB,EAAAynB,SAEApoB,EAAA,EAAA2F,EAAAyiB,EAAA/oB,OAAwCW,EAAA2F,EAAO3F,IAE/Cy9F,GAAAr1E,EAAApoB,GAAA09F,EAAAC,GAAA,GAqFA,QAAAG,IAAAC,GAEA7iG,KAAA6iG,UAAAj8F,SAAAi8F,KAEA7iG,KAAAwV,UAAA,EACAxV,KAAA8iG,QAAA,EACA9iG,KAAA+iG,YAAA,EAEA/iG,KAAAgjG,SAAA,EAmEA,QAAAC,IAAAtiB,GA8JA,QAAAuiB,GAAAviD,EAAAC,EAAAC,EAAAC,EAAAntB,EAAAwvE,EAAAC,GAEA,GAAAlJ,GAAA,IAAAr5C,EAAAF,GACAyvC,EAAA,IAAAtvC,EAAAF,EAEA,WAAAA,EAAAC,GAAAq5C,EAAA9J,GAAAgT,IAAA,GAAAxiD,EAAAC,GAAA,EAAAq5C,EAAA9J,GAAA+S,EAAAjJ,EAAAvmE,EAAAitB,EAjKA5gD,KAAA2gF,QAEA,IACA3kB,GAAAqnC,EAAArC,EAAAsC,EAAAC,EACAC,EAAAC,EAAAC,EAAAC,EAFAxlG,KAAAmyF,GAAoBhvF,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAIpBxB,MAAA4jG,cAAA,SAAAvkF,GAEArf,KAAA2gF,SAEA,QAAA77E,GAAA,EAAmBA,EAAAua,EAAAlb,OAAcW,IAEjC9E,KAAA2gF,OAAA77E,IAAwBxD,EAAA+d,EAAAva,GAAA,GAAAvD,EAAA8d,EAAAva,GAAA,GAAAtD,EAAA6d,EAAAva,GAAA,KAMxB9E,KAAA6jG,SAAA,SAAAz8C,GAuBA,MArBA4U,IAAAh8D,KAAA2gF,OAAAx8E,OAAA,GAAAijD,EACAi8C,EAAAviG,KAAA4uD,MAAAsM,GACAglC,EAAAhlC,EAAAqnC,EAEAllG,EAAA,OAAAklG,MAAA,EACAllG,EAAA,GAAAklG,EACAllG,EAAA,GAAAklG,EAAArjG,KAAA2gF,OAAAx8E,OAAA,EAAAnE,KAAA2gF,OAAAx8E,OAAA,EAAAk/F,EAAA,EACAllG,EAAA,GAAAklG,EAAArjG,KAAA2gF,OAAAx8E,OAAA,EAAAnE,KAAA2gF,OAAAx8E,OAAA,EAAAk/F,EAAA,EAEAG,EAAAxjG,KAAA2gF,OAAAxiF,EAAA,IACAslG,EAAAzjG,KAAA2gF,OAAAxiF,EAAA,IACAulG,EAAA1jG,KAAA2gF,OAAAxiF,EAAA,IACAwlG,EAAA3jG,KAAA2gF,OAAAxiF,EAAA,IAEAmlG,EAAAtC,IACAuC,EAAAvC,EAAAsC,EAEAhT,EAAAhvF,EAAA4hG,EAAAM,EAAAliG,EAAAmiG,EAAAniG,EAAAoiG,EAAApiG,EAAAqiG,EAAAriG,EAAA0/F,EAAAsC,EAAAC,GACAjT,EAAA/uF,EAAA2hG,EAAAM,EAAAjiG,EAAAkiG,EAAAliG,EAAAmiG,EAAAniG,EAAAoiG,EAAApiG,EAAAy/F,EAAAsC,EAAAC,GACAjT,EAAA9uF,EAAA0hG,EAAAM,EAAAhiG,EAAAiiG,EAAAjiG,EAAAkiG,EAAAliG,EAAAmiG,EAAAniG,EAAAw/F,EAAAsC,EAAAC,GAEAjT,GAIAtwF,KAAA8jG,sBAAA,WAEA,GAAAh/F,GAAA1G,EAAAqM,EAAAzK,KAAA2gF,OAAAx8E,OACAqkF,IAEA,KAAA1jF,EAAA,EAAeA,EAAA2F,EAAO3F,IAEtB1G,EAAA4B,KAAA2gF,OAAA77E,GACA0jF,EAAA1jF,IAAA1G,EAAAkD,EAAAlD,EAAAmD,EAAAnD,EAAAoD,EAIA,OAAAgnF,IAMAxoF,KAAA+jG,UAAA,SAAAC,GAEA,GAAAl/F,GAAA6E,EAAAs6F,EAAA5kG,EACA28D,EAAA,EAAAqnC,EAAA,EAAAa,EAAA,EACAC,EAAA,GAAAx1D,GACAy1D,EAAA,GAAAz1D,GACA01D,KACAC,EAAA,CAYA,KARAD,EAAA,KAEAL,MAAA,KAEAC,EAAAjkG,KAAA2gF,OAAAx8E,OAAA6/F,EAEAG,EAAA1oF,KAAAzb,KAAA2gF,OAAA,IAEA77E,EAAA,EAAeA,EAAAm/F,EAAcn/F,IAE7B6E,EAAA7E,EAAAm/F,EAEA5kG,EAAAW,KAAA6jG,SAAAl6F,GACAy6F,EAAA3oF,KAAApc,GAEAilG,GAAAF,EAAAG,WAAAJ,GAEAA,EAAA1oF,KAAApc,GAEA28D,GAAAh8D,KAAA2gF,OAAAx8E,OAAA,GAAAwF,EACA05F,EAAAviG,KAAA4uD,MAAAsM,GAEAqnC,IAAAa,IAEAG,EAAAhB,GAAAiB,EACAJ,EAAAb,EAUA,OAFAgB,KAAAlgG,QAAAmgG,GAEWzwC,OAAAwwC,EAAApF,MAAAqF,IAIXtkG,KAAAwkG,yBAAA,SAAAC,GAEA,GAAA3/F,GAAAmG,EACAtB,EAAA+6F,EAAAC,EACAC,EACAC,EAAAxlG,EACAylG,KACAV,EAAA,GAAAz1D,GACAo2D,EAAA/kG,KAAA+jG,WAIA,KAFAe,EAAA/4F,KAAAq4F,EAAA3oF,KAAAzb,KAAA2gF,OAAA,IAAApxE,SAEAzK,EAAA,EAAeA,EAAA9E,KAAA2gF,OAAAx8E,OAAwBW,IAAA,CAYvC,IAPA8/F,EAAAG,EAAAlxC,OAAA/uD,GAAAigG,EAAAlxC,OAAA/uD,EAAA,GAEA+/F,EAAA/jG,KAAAslF,KAAAqe,EAAAG,EAAAG,EAAA9F,OAEAyF,GAAA5/F,EAAA,IAAA9E,KAAA2gF,OAAAx8E,OAAA,GACAwgG,EAAA7/F,GAAA9E,KAAA2gF,OAAAx8E,OAAA,GAEA8G,EAAA,EAAgBA,EAAA45F,EAAA,EAAkB55F,IAElCtB,EAAA+6F,EAAAz5F,GAAA,EAAA45F,IAAAF,EAAAD,GAEArlG,EAAAW,KAAA6jG,SAAAl6F,GACAm7F,EAAA/4F,KAAAq4F,EAAA3oF,KAAApc,GAAAkQ,QAIAu1F,GAAA/4F,KAAAq4F,EAAA3oF,KAAAzb,KAAA2gF,OAAA77E,IAAAyK,SAIAvP,KAAA2gF,OAAAmkB,GA2BA,QAAAE,IAAA1kD,EAAAixC,EAAAuB,GAMA,MAJA9yF,MAAAsgD,OAAA15C,SAAA05C,IAAA,EACAtgD,KAAAuxF,IAAA3qF,SAAA2qF,IAAA,EACAvxF,KAAA8yF,MAAAlsF,SAAAksF,IAAA,EAEA9yF,KAsEA,QAAAilG,IAAAvjD,EAAArF,GAEAiR,GAAArvD,KAAA+B,KAAA0hD,EAAArF,GAEAr8C,KAAAklG,iBACAllG,KAAAmlG,iBAKA,IAAAC,GAAAplG,KAAA0hD,SAAAzC,aAAA96C,OAEAuD,EAAA,YAEA29F,EAAA,EACAC,EAAAF,EAAA,EAEAG,EAAAH,EAAA,CAEAplG,MAAAwlG,gBAAA99F,EAAA29F,EAAAC,EAAAC,GACAvlG,KAAAylG,mBAAA/9F,EAAA,GAwSA,QAAAg+F,IAAArpD,GAEA+L,GAAAnqD,KAAA+B,MAEAA,KAAAq8C,WACAr8C,KAAA2C,OAAA,SAAAgjG,KAcA,QAAAC,IAAAngG,EAAA6sC,EAAAuzD,EAAAjnD,GAEA5+C,KAAAyF,SAEAzF,KAAAsyC,KAAA1rC,SAAA0rC,IAAA,CAEA,IAAA0E,GAAApwC,SAAAi/F,IAAA,SAEAhjG,EAAA+D,SAAAg4C,IAAA,EAIAknD,EAAA,EAEAC,EAAA/lG,KAAAyF,OAAAi8C,QAEAqkD,MAAA3jD,WAEA0jD,EAAA,EAAAC,EAAAnxD,MAAAzwC,OAEG4hG,KAAA7jD,mBAEH4jD,EAAAC,EAAArhF,WAAA87B,OAAAvuB,MAMA,IAAAyvB,GAAA,GAAA0L,IAEA2iC,EAAA,GAAAtkC,IAAA,EAAAq6C,EAAA,IAEApkD,GAAAoO,aAAA,WAAAigC,GAEArI,GAAAzpF,KAAA+B,KAAA0hD,EAAA,GAAAmZ,KAA6D7jB,QAAA4H,UAAA/7C,KAI7D7C,KAAA+oD,kBAAA,EAEA/oD,KAAAmC,SA2GA,QAAA6jG,IAAAlgD,GAEAsC,GAAAnqD,KAAA+B,MAEAA,KAAA8lD,QACA9lD,KAAA8lD,MAAAgB,oBAEA9mD,KAAAumD,OAAAT,EAAApN,YACA14C,KAAA+oD,kBAAA,CAYA,QAVArH,GAAA,GAAA0L,IAEA2iC,GACA,YACA,YACA,aACA,YACA,cAGAjrF,EAAA,EAAAmG,EAAA,EAAAR,EAAA,GAAiC3F,EAAA2F,EAAO3F,IAAAmG,IAAA,CAExC,GAAA21C,GAAA97C,EAAA2F,EAAA3J,KAAAu8B,GAAA,EACAwjB,EAAA51C,EAAAR,EAAA3J,KAAAu8B,GAAA,CAEA0yD,GAAAhkF,KACAjL,KAAAs8B,IAAAwjB,GAAA9/C,KAAA+rF,IAAAjsC,GAAA,EACA9/C,KAAAs8B,IAAAyjB,GAAA//C,KAAA+rF,IAAAhsC,GAAA,GAKAa,EAAAoO,aAAA,cAAArE,IAAAskC,EAAA,GAEA,IAAA1zC,GAAA,GAAAwe,KAAyC/e,KAAA,GAEzC97C,MAAAimG,KAAA,GAAAve,IAAAhmC,EAAArF,GACAr8C,KAAA8B,IAAA9B,KAAAimG,MAEAjmG,KAAAmC,SA4CA,QAAA+jG,IAAAzgG,GAEAzF,KAAAi6D,MAAAj6D,KAAAmmG,YAAA1gG,EAIA,QAFAi8C,GAAA,GAAAoK,IAEAhnD,EAAA,EAAkBA,EAAA9E,KAAAi6D,MAAA91D,OAAuBW,IAAA,CAEzC,GAAAmiF,GAAAjnF,KAAAi6D,MAAAn1D,EAEAmiF,GAAAl9D,QAAAk9D,EAAAl9D,OAAAq8E,SAEA1kD,EAAA/M,SAAA5oC,KAAA,GAAA4iC,IACA+S,EAAA/M,SAAA5oC,KAAA,GAAA4iC,IACA+S,EAAAsK,OAAAjgD,KAAA,GAAAxL,GAAA,QACAmhD,EAAAsK,OAAAjgD,KAAA,GAAAxL,GAAA,SAMAmhD,EAAAiJ,SAAA,CAEA,IAAAtO,GAAA,GAAAwe,KAAyC3d,aAAAmpD,GAAA7pD,WAAA,EAAAC,YAAA,EAAAW,aAAA,GAEzCsqC,IAAAzpF,KAAA+B,KAAA0hD,EAAArF,GAEAr8C,KAAA0qB,KAAAjlB,EAEAzF,KAAAumD,OAAA9gD,EAAAizC,YACA14C,KAAA+oD,kBAAA,EAEA/oD,KAAAmC,SAmEA,QAAAmkG,IAAAxgD,EAAAygD,GAEAvmG,KAAA8lD,QACA9lD,KAAA8lD,MAAAgB,mBAEA,IAAApF,GAAA,GAAA+tC,IAAA8W,EAAA,KACAlqD,EAAA,GAAAwN,KAAyChL,WAAA,EAAA/C,KAAA,GACzCO,GAAArF,MAAAv7B,KAAAzb,KAAA8lD,MAAA9O,OAAA25B,eAAA3wE,KAAA8lD,MAAA6zB,WAEArsB,GAAArvD,KAAA+B,KAAA0hD,EAAArF,GAEAr8C,KAAAumD,OAAAvmD,KAAA8lD,MAAApN,YACA14C,KAAA+oD,kBAAA,EA8DA,QAAAy9C,IAAA1gD,EAAAygD,GAEAn+C,GAAAnqD,KAAA+B,MAEAA,KAAA8lD,QACA9lD,KAAA8lD,MAAAgB,oBAEA9mD,KAAAumD,OAAAT,EAAApN,YACA14C,KAAA+oD,kBAAA,EAEA/oD,KAAAgsD,QAAA,GAAAzrD,GAAA,GAAAA,GAEA,IAAAmhD,GAAA,GAAA8uC,IAAA+V,EAAA,IACA7kD,GAAA+kD,SAAA3lG,KAAAu8B,GAAA,EAEA,QAAAv4B,GAAA,EAAA+gD,EAAA,EAA0B/gD,EAAA+gD,EAAQ/gD,IAElC48C,EAAA9M,MAAA9vC,GAAAkyC,MAAAh3C,KAAAgsD,OAAAlnD,EAAA,MAIA,IAAAu3C,GAAA,GAAAwN,KAAyC3M,aAAAwpD,GAAA7nD,WAAA,GAEzC7+C,MAAA2mG,YAAA,GAAAr5C,IAAA5L,EAAArF,GACAr8C,KAAA8B,IAAA9B,KAAA2mG,aAEA3mG,KAAAmC,SAkCA,QAAAykG,IAAAt0D,EAAAu0D,EAAAC,EAAAC,GAEAF,KAAA,EACAC,EAAA,GAAAvmG,GAAAqG,SAAAkgG,IAAA,SACAC,EAAA,GAAAxmG,GAAAqG,SAAAmgG,IAAA,QAMA,QAJA1mD,GAAAwmD,EAAA,EACA9pE,EAAA,EAAAuV,EAAAu0D,EACAlyD,KAAAqX,KAEAlnD,EAAA,EAAAmG,EAAA,EAAAm8C,GAAA9U,EAAqCxtC,GAAA+hG,EAAgB/hG,IAAAsiD,GAAArqB,EAAA,CAErD4X,EAAA5oC,MAAAumC,EAAA,EAAA8U,EAAA9U,EAAA,EAAA8U,GACAzS,EAAA5oC,KAAAq7C,EAAA,GAAA9U,EAAA8U,EAAA,EAAA9U,EAEA,IAAA0E,GAAAlyC,IAAAu7C,EAAAymD,EAAAC,CAEA/vD,GAAA/7B,QAAA+wC,EAAA/gD,GAA8BA,GAAA,EAC9B+rC,EAAA/7B,QAAA+wC,EAAA/gD,GAA8BA,GAAA,EAC9B+rC,EAAA/7B,QAAA+wC,EAAA/gD,GAA8BA,GAAA,EAC9B+rC,EAAA/7B,QAAA+wC,EAAA/gD,GAA8BA,GAAA,EAI9B,GAAAy2C,GAAA,GAAA0L,GACA1L,GAAAoO,aAAA,cAAArE,IAAA9W,EAAA,IACA+M,EAAAoO,aAAA,WAAArE,IAAAO,EAAA,GAEA,IAAA3P,GAAA,GAAAwe,KAAyC3d,aAAAmpD,IAEzC3e,IAAAzpF,KAAA+B,KAAA0hD,EAAArF,GAkBA,QAAA2qD,IAAAvhG,EAAA6sC,EAAAuzD,EAAAjnD,GAIA5+C,KAAAyF,SAEAzF,KAAAsyC,KAAA1rC,SAAA0rC,IAAA,CAEA,IAAA0E,GAAApwC,SAAAi/F,IAAA,SAEAhjG,EAAA+D,SAAAg4C,IAAA,EAIAknD,EAAA,EAEAC,EAAA/lG,KAAAyF,OAAAi8C,QAEAqkD,MAAA3jD,WAEA0jD,EAAAC,EAAAnxD,MAAAzwC,OAIAosB,QAAAC,KAAA,qGAMA,IAAAkxB,GAAA,GAAA0L,IAEA2iC,EAAA,GAAAtkC,IAAA,EAAAq6C,EAAA,IAEApkD,GAAAoO,aAAA,WAAAigC,GAEArI,GAAAzpF,KAAA+B,KAAA0hD,EAAA,GAAAmZ,KAA6D7jB,QAAA4H,UAAA/7C,KAI7D7C,KAAA+oD,kBAAA,EACA/oD,KAAAmC,SAuEA,QAAA8kG,IAAAnhD,EAAAxT,GAEA8V,GAAAnqD,KAAA+B,MAEAA,KAAA8lD,QACA9lD,KAAA8lD,MAAAgB,oBAEA9mD,KAAAumD,OAAAT,EAAApN,YACA14C,KAAA+oD,kBAAA,EAEAniD,SAAA0rC,MAAA,EAEA,IAAAoP,GAAA,GAAA0L,GACA1L,GAAAoO,aAAA,cAAArE,MACAnZ,IAAA,EACAA,IAAA,EACAA,KAAA,GACAA,KAAA,GACAA,IAAA,GACA,GAEA,IAAA+J,GAAA,GAAAwe,KAAyC/e,KAAA,GAEzC97C,MAAA8B,IAAA,GAAA2lF,IAAA/lC,EAAArF,IAEAqF,EAAA,GAAA0L,IACA1L,EAAAoO,aAAA,cAAArE,KAAA,iBAEAzrD,KAAA8B,IAAA,GAAA2lF,IAAA/lC,EAAArF,IAEAr8C,KAAAmC,SAqDA,QAAA+kG,IAAA9lG,GA8DA,QAAA+lG,GAAA9nF,EAAAC,EAAAumF,GAEAuB,EAAA/nF,EAAAwmF,GACAuB,EAAA9nF,EAAAumF,GAIA,QAAAuB,GAAArpG,EAAA8nG,GAEAnkD,EAAA/M,SAAA5oC,KAAA,GAAA4iC,IACA+S,EAAAsK,OAAAjgD,KAAA,GAAAxL,GAAAslG,IAEAj/F,SAAAygG,EAAAtpG,KAEAspG,EAAAtpG,OAIAspG,EAAAtpG,GAAAgO,KAAA21C,EAAA/M,SAAAxwC,OAAA,GA9EA,GAAAu9C,GAAA,GAAAoK,IACAzP,EAAA,GAAAwe,KAAyC7jB,MAAA,SAAAkG,aAAAwpD,KAEzCW,KAIAC,EAAA,SACAC,EAAA,SACAC,EAAA,MACAC,EAAA,SACAC,EAAA,OAIAP,GAAA,UAAAG,GACAH,EAAA,UAAAG,GACAH,EAAA,UAAAG,GACAH,EAAA,UAAAG,GAIAH,EAAA,UAAAG,GACAH,EAAA,UAAAG,GACAH,EAAA,UAAAG,GACAH,EAAA,UAAAG,GAIAH,EAAA,UAAAG,GACAH,EAAA,UAAAG,GACAH,EAAA,UAAAG,GACAH,EAAA,UAAAG,GAIAH,EAAA,SAAAI,GACAJ,EAAA,SAAAI,GACAJ,EAAA,SAAAI,GACAJ,EAAA,SAAAI,GAIAJ,EAAA,UAAAK,GACAL,EAAA,UAAAK,GACAL,EAAA,UAAAK,GAIAL,EAAA,QAAAM,GACAN,EAAA,QAAAO,GAIAP,EAAA,YAAAO,GACAP,EAAA,YAAAO,GAEAP,EAAA,YAAAO,GACAP,EAAA,YAAAO,GAwBAhgB,GAAAzpF,KAAA+B,KAAA0hD,EAAArF,GAEAr8C,KAAAoB,SACApB,KAAAoB,OAAA4B,wBAAAhD,KAAAoB,OAAA4B,yBAEAhD,KAAAumD,OAAAnlD,EAAAs3C,YACA14C,KAAA+oD,kBAAA,EAEA/oD,KAAAqnG,WAEArnG,KAAAmC,SA6FA,QAAAwlG,IAAAliG,EAAAogG,GAEA,GAAA7uD,GAAApwC,SAAAi/F,IAAA,OAEA7lG,MAAAyF,SAEAzF,KAAA4nG,IAAA,GAAAznD,IAEAmN,GAAArvD,KAAA+B,KAAA,GAAAg0F,IAAA,UAAAnqC,KAAuE7S,QAAA6H,WAAA,KAqBvE,QAAAgpD,IAAApiG,EAAAuxC,GAEApwC,SAAAowC,MAAA,SAEA,IAAAgW,GAAA,GAAAnY,cAAA,kDACAk7C,EAAA,GAAAlhD,cAAA,IAEA6S,EAAA,GAAA0L,GACA1L,GAAAmO,SAAA,GAAArF,IAAAwC,EAAA,IACAtL,EAAAoO,aAAA,cAAAtF,IAAAulC,EAAA,IAEArI,GAAAzpF,KAAA+B,KAAA0hD,EAAA,GAAAmZ,KAA6D7jB,WAE7DpwC,SAAAnB,GAEAzF,KAAAmC,OAAAsD,GAwFA,QAAAqiG,IAAAxiG,EAAAwiD,EAAA3jD,EAAA6yC,EAAA+wD,EAAAC,GAIA5/C,GAAAnqD,KAAA+B,MAEA4G,SAAAowC,MAAA,UACApwC,SAAAzC,MAAA,GACAyC,SAAAmhG,MAAA,GAAA5jG,GACAyC,SAAAohG,MAAA,GAAAD,GAEA/nG,KAAAX,SAAAoc,KAAAqsC,GAEA9nD,KAAAioG,KAAA,GAAAxgB,IAAAygB,GAAA,GAAArtC,KAA8D7jB,WAC9Dh3C,KAAAioG,KAAAl/C,kBAAA,EACA/oD,KAAA8B,IAAA9B,KAAAioG,MAEAjoG,KAAAimG,KAAA,GAAA34C,IAAA66C,GAAA,GAAAt+C,KAA8D7S,WAC9Dh3C,KAAAimG,KAAAl9C,kBAAA,EACA/oD,KAAA8B,IAAA9B,KAAAimG,MAEAjmG,KAAAooG,aAAA9iG,GACAtF,KAAAqoG,UAAAlkG,EAAA4jG,EAAAC,GAgEA,QAAAM,IAAAh2D,GAEAA,KAAA,CAEA,IAAAqC,GAAA,GAAA9F,eACA,MAAAyD,EAAA,IACA,QAAAA,EAAA,EACA,UAAAA,IAGA0Z,EAAA,GAAAnd,eACA,aACA,aACA,eAGA6S,EAAA,GAAA0L,GACA1L,GAAAoO,aAAA,cAAAtF,IAAA7V,EAAA,IACA+M,EAAAoO,aAAA,WAAAtF,IAAAwB,EAAA,GAEA,IAAA3P,GAAA,GAAAwe,KAAyC3d,aAAAmpD,IAEzC3e,IAAAzpF,KAAA+B,KAAA0hD,EAAArF,GAiMA,QAAAksD,IAAA5nB,GAEApwD,QAAAC,KAAA,oFAEAg4E,GAAAvqG,KAAA+B,KAAA2gF,GACA3gF,KAAAoE,KAAA,aACApE,KAAAmsF,QAAA,EA2IA,QAAAsc,IAAAjP,EAAAC,EAAAiP,EAAA9O,EAAAC,EAAAC,GAEAP,GAAAt7F,KAAA+B,KAAAw5F,EAAAC,EAAAiP,IAAA9O,EAAAC,EAAAC,GAoDA,QAAA6O,IAAAtpF,EAAAC,EAAAnhB,EAAA6vD,EAAAxN,EAAAxJ,EAAAwQ,GAEA,MADAj3B,SAAAC,KAAA,wEACA,GAAAi5B,IAAApqC,EAAAC,EAAAnhB,EAAAqiD,EAAAxJ,EAAAwQ,GAOA,QAAA66C,IAAA3gD,EAAArF,GAEA,MADA9rB,SAAAC,KAAA,sDACA,GAAAm3D,IAAAjmC,EAAArF,GAGA,QAAAusD,IAAAlnD,EAAArF,GAEA,MADA9rB,SAAAC,KAAA,0DACA,GAAAm3D,IAAAjmC,EAAArF,GAGA,QAAAwsD,IAAAnqD,GAEA,MADAnuB,SAAAC,KAAA,sEACA,GAAAuqC,IAAArc,GAGA,QAAAoqD,IAAApqD,GAEA,MADAnuB,SAAAC,KAAA,yEACA,GAAAuqC,IAAArc,GAGA,QAAAqqD,IAAArqD,GAEA,MADAnuB,SAAAC,KAAA,0EACA,GAAAuqC,IAAArc,GAGA,QAAAsqD,IAAA1nG,EAAAC,EAAAC,GAEA,MADA+uB,SAAAC,KAAA,6DACA,GAAAme,GAAArtC,EAAAC,EAAAC,GAKA,QAAAynG,IAAAxjG,EAAAogG,GAEA,MADAt1E,SAAAC,KAAA,wEACA,GAAAk3D,IAAA,GAAAkK,IAAAnsF,EAAAi8C,UAAA,GAAAmZ,KAAyF7jB,MAAApwC,SAAAi/F,IAAA,YAGzF,QAAAqD,IAAAzjG,EAAAogG,GAEA,MADAt1E,SAAAC,KAAA,gFACA,GAAAk3D,IAAA,GAAAS,IAAA1iF,EAAAi8C,UAAA,GAAAmZ,KAA6F7jB,MAAApwC,SAAAi/F,IAAA,YAsuB7F,QAAAsD,MAEA54E,QAAA5W,MAAA,0EAEA3Z,KAAAopG,cAAA,SAAAn6C,EAAA7tD,GAEAmvB,QAAAC,KAAA,8DACAy+B,EAAAo6C,QAAAjoG,IAIApB,KAAAspG,gBAAA,SAAAr6C,EAAA7tD,GAEAmvB,QAAAC,KAAA,kEACAy+B,EAAAs6C,UAAAnoG,IAIApB,KAAAwpG,WAAA,SAAAv6C,EAAA7tD,GAEAmvB,QAAA5W,MAAA,qEAQA,QAAA8vF,MAEAl5E,QAAA5W,MAAA,mFAEA3Z,KAAAb,WAAAK,SAAA07C,gBAAA,yCACAl7C,KAAA0mD,MAAA,aACA1mD,KAAA2C,OAAA,aACA3C,KAAAM,cAAA,aACAN,KAAAQ,QAAA,aAl7xCAoG,SAAA8iG,OAAAC,UAEAD,OAAAC,QAAA7oG,KAAAgpF,IAAA,QAMAljF,SAAA9F,KAAA2yF,OAIA3yF,KAAA2yF,KAAA,SAAAnyF,GAEA,MAAAA,GAAA,KAAAA,EAAA,KAAAA,IAMAsF,SAAAgjG,SAAA/pG,UAAA6H,MAKAsS,OAAAwX,eAAAo4E,SAAA/pG,UAAA,QAEAgK,IAAA,WAEA,MAAA7J,MAAAma,WAAAxU,MAAA,mCAQAiB,SAAAoT,OAAA6vF,SAKA,WAEA7vF,OAAA6vF,OAAA,SAAA5xF,GAIA,GAAArR,SAAAqR,GAAA,OAAAA,EAEA,SAAAwX,WAAA,6CAMA,QAFAq6E,GAAA9vF,OAAA/B,GAEAtO,EAAA,EAAwBA,EAAAqD,UAAA7I,OAA0BwF,IAAA,CAElD,GAAAyoB,GAAAplB,UAAArD,EAEA,IAAA/C,SAAAwrB,GAAA,OAAAA,EAEA,OAAA23E,KAAA33E,GAEApY,OAAAna,UAAAwa,eAAApc,KAAAm0B,EAAA23E,KAEAD,EAAAC,GAAA33E,EAAA23E,IAUA,MAAAD,OAcA9vF,OAAA6vF,OAAAl+D,EAAA9rC,WAEAinB,iBAAA,SAAA1iB,EAAAi4F,GAEAz1F,SAAA5G,KAAAgqG,aAAAhqG,KAAAgqG,cAEA,IAAAC,GAAAjqG,KAAAgqG,UAEApjG,UAAAqjG,EAAA7lG,KAEA6lG,EAAA7lG,OAIA6lG,EAAA7lG,GAAAY,QAAAq3F,MAAA,GAEA4N,EAAA7lG,GAAA2H,KAAAswF,IAMA6N,iBAAA,SAAA9lG,EAAAi4F,GAEA,GAAAz1F,SAAA5G,KAAAgqG,WAAA,QAEA,IAAAC,GAAAjqG,KAAAgqG,UAEA,OAAApjG,UAAAqjG,EAAA7lG,IAAA6lG,EAAA7lG,GAAAY,QAAAq3F,MAAA,GAUAv1F,oBAAA,SAAA1C,EAAAi4F,GAEA,GAAAz1F,SAAA5G,KAAAgqG,WAAA,CAEA,GAAAC,GAAAjqG,KAAAgqG,WACAG,EAAAF,EAAA7lG,EAEA,IAAAwC,SAAAujG,EAAA,CAEA,GAAAxgG,GAAAwgG,EAAAnlG,QAAAq3F,EAEA1yF,MAAA,GAEAwgG,EAAA3uF,OAAA7R,EAAA,MAQAygG,cAAA,SAAAv9F,GAEA,GAAAjG,SAAA5G,KAAAgqG,WAAA,CAEA,GAAAC,GAAAjqG,KAAAgqG,WACAG,EAAAF,EAAAp9F,EAAAzI,KAEA,IAAAwC,SAAAujG,EAAA,CAEAt9F,EAAAoL,OAAAjY,IAEA,IAAAovC,MAAAtqC,EAAA,EACAX,EAAAgmG,EAAAhmG,MAEA,KAAAW,EAAA,EAAgBA,EAAAX,EAAYW,IAE5BsqC,EAAAtqC,GAAAqlG,EAAArlG,EAIA,KAAAA,EAAA,EAAgBA,EAAAX,EAAYW,IAE5BsqC,EAAAtqC,GAAA7G,KAAA+B,KAAA6M,OAUA,IAAAuyE,IAAA,KACAirB,IAAcC,KAAA,EAAAC,OAAA,EAAAC,MAAA,GACdl/B,GAAA,EACAhD,GAAA,EACAmD,GAAA,EACAg/B,GAAA,EACA7lB,GAAA,EACA8lB,GAAA,EACAC,GAAA,EACAllD,GAAA,EACA+P,GAAA,EACAzY,GAAA,EACAqG,GAAA,EACAF,GAAA,EACA0Y,GAAA,EACA3e,GAAA,EACAE,GAAA,EACAupD,GAAA,EACAL,GAAA,EACAl9B,GAAA,EACAtsB,GAAA,EACAysB,GAAA,EACAO,GAAA,EACAI,GAAA,EACAE,GAAA,EACAygC,IACAzhC,cACAtsB,kBACAysB,oBACAO,uBACAI,oBACAE,mBAEA5sB,GAAA,IACAm/B,GAAA,IACAE,GAAA,IACAkC,GAAA,IACAC,GAAA,IACAjC,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACA5/B,GAAA,IACAC,GAAA,IACA4/B,GAAA,IACAE,GAAA,IACAE,GAAA,IACAE,GAAA,IACAE,GAAA,IACA5X,GAAA,EACAE,GAAA,EACAE,GAAA,EACAtoB,GAAA,EACAyoB,GAAA,EACAE,GAAA,EACAE,GAAA,EACAE,GAAA,EACAxc,GAAA,EACA+L,GAAA,EACAC,GAAA,EACAwB,GAAA,EACApE,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,EACAm3C,GAAA,IACA77D,GAAA,IACA4mB,GAAA,IACAG,GAAA,IACAC,GAAA,IACAC,GAAA,IACAJ,GAAA,IACAC,GAAA,IACAg1C,IACAD,aACA77D,yBACA4mB,yBACAG,oCACAC,oCACAC,8BACAJ,2BACAC,4BAEAilB,GAAA,IACAjuC,GAAA,KACAmuC,GAAA,KACA8vB,IACAhwB,kBACAjuC,uBACAmuC,2BAEA70B,GAAA,KACA+Y,GAAA,KACAC,GAAA,KACAryB,GAAA,KACAsuC,GAAA,KACAruC,GAAA,KACAg+D,IACA5kD,iBACA+Y,8BACAC,6BACAryB,gBACAsuC,6BACAruC,6BAEAE,GAAA,KACA4uC,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,KACAla,GAAA,KACAC,GAAA,KACAuZ,GAAA,KACAE,GAAA,KACAE,GAAA,KACAsD,GAAA,KACA9C,GAAA,KACA3a,GAAA,KACAx0B,GAAA,KACAqvC,GAAA,KACAE,GAAA,KACAyuB,GAAAh+D,GACAk3B,GAAA,KACArB,GAAA,KACA8a,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,KACAK,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,KACAK,GAAA,KACAssB,GAAA,KACAvK,GAAA,KACAwK,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,KACAvL,GAAA,KACAwL,GAAA,KACAC,GAAA,KACAh+C,GAAA,EACAu2B,GAAA,EACAE,GAAA,EACAz2C,GAAA,IACAklB,GAAA,KACAK,GAAA,KACAJ,GAAA,KACA84C,GAAA,KACA74C,GAAA,KACAC,GAAA,KACAC,GAAA,KACAhT,GAAA,KACAkF,GAAA,KAOAxY,IAEAwlD,QAAAlxF,KAAAu8B,GAAA,IACAquE,QAAA,IAAA5qG,KAAAu8B,GAEAoP,aAAA,WAIA,GAEA+C,GAFAm8D,EAAA,iEAAAnyF,MAAA,IACA+yB,EAAA,GAAAvwB,OAAA,IACA4vF,EAAA,CAEA,mBAEA,OAAA9mG,GAAA,EAAoBA,EAAA,GAAQA,IAE5B,IAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,EAEAynC,EAAAznC,GAAA,IAEM,KAAAA,EAENynC,EAAAznC,GAAA,KAIA8mG,GAAA,IAAAA,EAAA,kBAAA9qG,KAAA8a,SAAA,GACA4zB,EAAA,GAAAo8D,EACAA,IAAA,EACAr/D,EAAAznC,GAAA6mG,EAAA,KAAA7mG,EAAA,EAAA0qC,EAAA,EAAAA,GAMA,OAAAjD,GAAA71B,KAAA,QAMA26E,MAAA,SAAAjrF,EAAArF,EAAAmQ,GAEA,MAAApQ,MAAAoQ,IAAAnQ,EAAAD,KAAAC,IAAAmQ,EAAA9K,KAOAylG,gBAAA,SAAAl/E,EAAAzuB,GAEA,OAAAyuB,EAAAzuB,QAMA4tG,UAAA,SAAAxqG,EAAAyqG,EAAAC,EAAAC,EAAAC,GAEA,MAAAD,IAAA3qG,EAAAyqG,IAAAG,EAAAD,IAAAD,EAAAD,IAMA/hB,KAAA,SAAA1oF,EAAAC,EAAAoyB,GAEA,SAAAA,GAAAryB,EAAAqyB,EAAApyB,GAMA4qG,WAAA,SAAA7qG,EAAAP,EAAAmQ,GAEA,MAAA5P,IAAAP,EAAA,EACAO,GAAA4P,EAAA,GAEA5P,KAAAP,IAAAmQ,EAAAnQ,GAEAO,KAAA,IAAAA,KAIA8qG,aAAA,SAAA9qG,EAAAP,EAAAmQ,GAEA,MAAA5P,IAAAP,EAAA,EACAO,GAAA4P,EAAA,GAEA5P,KAAAP,IAAAmQ,EAAAnQ,GAEAO,UAAA,EAAAA,EAAA,UAIA+qG,SAAA,WAGA,MADA97E,SAAAC,KAAA,yEACA1vB,KAAA8a,UAMA0wF,QAAA,SAAAC,EAAApmF,GAEA,MAAAomF,GAAAzrG,KAAA4uD,MAAA5uD,KAAA8a,UAAAuK,EAAAomF,EAAA,KAMAC,UAAA,SAAAD,EAAApmF,GAEA,MAAAomF,GAAAzrG,KAAA8a,UAAAuK,EAAAomF,IAMAE,gBAAA,SAAAC,GAEA,MAAAA,IAAA,GAAA5rG,KAAA8a,WAIA+wF,SAAA,SAAAC,GAEA,MAAAA,GAAApgE,GAAAwlD,SAIA6a,SAAA,SAAAC,GAEA,MAAAA,GAAAtgE,GAAAk/D,SAIA/sC,aAAA,SAAAv4D,GAEA,YAAAA,IAAA,QAAAA,GAIA24D,kBAAA,SAAA34D,GAEA,MAAAtF,MAAAgpF,IAAA,EAAAhpF,KAAAisG,MAAAjsG,KAAAk4D,IAAA5yD,GAAAtF,KAAA21E,OAIA0P,eAAA,SAAA//E,GAUA,MARAA,KACAA,MAAA,EACAA,MAAA,EACAA,MAAA,EACAA,MAAA,EACAA,MAAA,GACAA,IAEAA,GAoBAwlC,GAAA/rC,WAEAmb,YAAA4wB,EAEAohE,WAAA,EAEAnqG,YAEA,MAAA7C,MAAAsB,GAIAuB,UAAAuD,GAEApG,KAAAsB,EAAA8E,GAIAtD,aAEA,MAAA9C,MAAAuB,GAIAuB,WAAAsD,GAEApG,KAAAuB,EAAA6E,GAMAnE,IAAA,SAAAX,EAAAC,GAKA,MAHAvB,MAAAsB,IACAtB,KAAAuB,IAEAvB,MAIAitG,UAAA,SAAAC,GAKA,MAHAltG,MAAAsB,EAAA4rG,EACAltG,KAAAuB,EAAA2rG,EAEAltG,MAIAsuF,KAAA,SAAAhtF,GAIA,MAFAtB,MAAAsB,IAEAtB,MAIAmtG,KAAA,SAAA5rG,GAIA,MAFAvB,MAAAuB,IAEAvB,MAIAotG,aAAA,SAAAzjG,EAAAvD,GAEA,OAAAuD,GAEA,OAAA3J,KAAAsB,EAAA8E,CAA2B,MAC3B,QAAApG,KAAAuB,EAAA6E,CAA2B,MAC3B,kBAAA9C,OAAA,0BAAAqG,GAIA,MAAA3J,OAIAqtG,aAAA,SAAA1jG,GAEA,OAAAA,GAEA,aAAA3J,MAAAsB,CACA,cAAAtB,MAAAuB,CACA,kBAAA+B,OAAA,0BAAAqG,KAMA4F,MAAA,WAEA,UAAAvP,MAAAgb,YAAAhb,KAAAsB,EAAAtB,KAAAuB,IAIAka,KAAA,SAAAzV,GAKA,MAHAhG,MAAAsB,EAAA0E,EAAA1E,EACAtB,KAAAuB,EAAAyE,EAAAzE,EAEAvB,MAIA8B,IAAA,SAAAkE,EAAA3C,GAEA,MAAAuD,UAAAvD,GAEAktB,QAAAC,KAAA,yFACAxwB,KAAAguF,WAAAhoF,EAAA3C,KAIArD,KAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EAEAvB,OAIAstG,UAAA,SAAA1tG,GAKA,MAHAI,MAAAsB,GAAA1B,EACAI,KAAAuB,GAAA3B,EAEAI,MAIAguF,WAAA,SAAA3uE,EAAAC,GAKA,MAHAtf,MAAAsB,EAAA+d,EAAA/d,EAAAge,EAAAhe,EACAtB,KAAAuB,EAAA8d,EAAA9d,EAAA+d,EAAA/d,EAEAvB,MAIAutG,gBAAA,SAAAvnG,EAAApG,GAKA,MAHAI,MAAAsB,GAAA0E,EAAA1E,EAAA1B,EACAI,KAAAuB,GAAAyE,EAAAzE,EAAA3B,EAEAI,MAIAm6E,IAAA,SAAAn0E,EAAA3C,GAEA,MAAAuD,UAAAvD,GAEAktB,QAAAC,KAAA,yFACAxwB,KAAA+tF,WAAA/nF,EAAA3C,KAIArD,KAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EAEAvB,OAIAwtG,UAAA,SAAA5tG,GAKA,MAHAI,MAAAsB,GAAA1B,EACAI,KAAAuB,GAAA3B,EAEAI,MAIA+tF,WAAA,SAAA1uE,EAAAC,GAKA,MAHAtf,MAAAsB,EAAA+d,EAAA/d,EAAAge,EAAAhe,EACAtB,KAAAuB,EAAA8d,EAAA9d,EAAA+d,EAAA/d,EAEAvB,MAIAgnD,SAAA,SAAAhhD,GAKA,MAHAhG,MAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EAEAvB,MAIA2wE,eAAA,SAAAu8B,GAcA,MAZA7wE,UAAA6wE,IAEAltG,KAAAsB,GAAA4rG,EACAltG,KAAAuB,GAAA2rG,IAIAltG,KAAAsB,EAAA,EACAtB,KAAAuB,EAAA,GAIAvB,MAIAytG,OAAA,SAAAznG,GAKA,MAHAhG,MAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EAEAvB,MAIAkrF,aAAA,SAAAgiB,GAEA,MAAAltG,MAAA2wE,eAAA,EAAAu8B,IAIAnsG,IAAA,SAAAiF,GAKA,MAHAhG,MAAAsB,EAAAR,KAAAC,IAAAf,KAAAsB,EAAA0E,EAAA1E,GACAtB,KAAAuB,EAAAT,KAAAC,IAAAf,KAAAuB,EAAAyE,EAAAzE,GAEAvB,MAIAkR,IAAA,SAAAlL,GAKA,MAHAhG,MAAAsB,EAAAR,KAAAoQ,IAAAlR,KAAAsB,EAAA0E,EAAA1E,GACAtB,KAAAuB,EAAAT,KAAAoQ,IAAAlR,KAAAuB,EAAAyE,EAAAzE,GAEAvB,MAIAqxF,MAAA,SAAAtwF,EAAAmQ,GAOA,MAHAlR,MAAAsB,EAAAR,KAAAoQ,IAAAnQ,EAAAO,EAAAR,KAAAC,IAAAmQ,EAAA5P,EAAAtB,KAAAsB,IACAtB,KAAAuB,EAAAT,KAAAoQ,IAAAnQ,EAAAQ,EAAAT,KAAAC,IAAAmQ,EAAA3P,EAAAvB,KAAAuB,IAEAvB,MAIA0tG,YAAA,WAEA,GAAA3sG,GAAAmQ,CAEA,iBAAAy8F,EAAAC,GAYA,MAVAhnG,UAAA7F,IAEAA,EAAA,GAAA6qC,GACA16B,EAAA,GAAA06B,IAIA7qC,EAAAkB,IAAA0rG,KACAz8F,EAAAjP,IAAA2rG,KAEA5tG,KAAAqxF,MAAAtwF,EAAAmQ,OAMA28F,YAAA,SAAA9sG,EAAAmQ,GAEA,GAAA/M,GAAAnE,KAAAmE,QAEA,OAAAnE,MAAA2wE,eAAA7vE,KAAAoQ,IAAAnQ,EAAAD,KAAAC,IAAAmQ,EAAA/M,QAIAurD,MAAA,WAKA,MAHA1vD,MAAAsB,EAAAR,KAAA4uD,MAAA1vD,KAAAsB,GACAtB,KAAAuB,EAAAT,KAAA4uD,MAAA1vD,KAAAuB,GAEAvB,MAIAomF,KAAA,WAKA,MAHApmF,MAAAsB,EAAAR,KAAAslF,KAAApmF,KAAAsB,GACAtB,KAAAuB,EAAAT,KAAAslF,KAAApmF,KAAAuB,GAEAvB,MAIA+sG,MAAA,WAKA,MAHA/sG,MAAAsB,EAAAR,KAAAisG,MAAA/sG,KAAAsB,GACAtB,KAAAuB,EAAAT,KAAAisG,MAAA/sG,KAAAuB,GAEAvB,MAIA8tG,YAAA,WAKA,MAHA9tG,MAAAsB,EAAAtB,KAAAsB,EAAA,EAAAR,KAAAslF,KAAApmF,KAAAsB,GAAAR,KAAA4uD,MAAA1vD,KAAAsB,GACAtB,KAAAuB,EAAAvB,KAAAuB,EAAA,EAAAT,KAAAslF,KAAApmF,KAAAuB,GAAAT,KAAA4uD,MAAA1vD,KAAAuB,GAEAvB,MAIAy6E,OAAA,WAKA,MAHAz6E,MAAAsB,GAAAtB,KAAAsB,EACAtB,KAAAuB,GAAAvB,KAAAuB,EAEAvB,MAIAqyF,IAAA,SAAArsF,GAEA,MAAAhG,MAAAsB,EAAA0E,EAAA1E,EAAAtB,KAAAuB,EAAAyE,EAAAzE,GAIAwsG,SAAA,WAEA,MAAA/tG,MAAAsB,EAAAtB,KAAAsB,EAAAtB,KAAAuB,EAAAvB,KAAAuB,GAIA4C,OAAA,WAEA,MAAArD,MAAAolF,KAAAlmF,KAAAsB,EAAAtB,KAAAsB,EAAAtB,KAAAuB,EAAAvB,KAAAuB,IAIAysG,gBAAA,WAEA,MAAAltG,MAAA+xE,IAAA7yE,KAAAsB,GAAAR,KAAA+xE,IAAA7yE,KAAAuB,IAIAs5E,UAAA,WAEA,MAAA76E,MAAAkrF,aAAAlrF,KAAAmE,WAIAo2E,MAAA,WAIA,GAAAA,GAAAz5E,KAAAuqF,MAAArrF,KAAAuB,EAAAvB,KAAAsB,EAIA,OAFAi5E,GAAA,IAAAA,GAAA,EAAAz5E,KAAAu8B,IAEAk9C,GAIAgqB,WAAA,SAAAv+F,GAEA,MAAAlF,MAAAolF,KAAAlmF,KAAAiuG,kBAAAjoG,KAIAioG,kBAAA,SAAAjoG,GAEA,GAAAkoG,GAAAluG,KAAAsB,EAAA0E,EAAA1E,EAAA6sG,EAAAnuG,KAAAuB,EAAAyE,EAAAzE,CACA,OAAA2sG,KAAAC,KAIAC,oBAAA,SAAApoG,GAEA,MAAAlF,MAAA+xE,IAAA7yE,KAAAsB,EAAA0E,EAAA1E,GAAAR,KAAA+xE,IAAA7yE,KAAAuB,EAAAyE,EAAAzE,IAIA8mG,UAAA,SAAAlkG,GAEA,MAAAnE,MAAA2wE,eAAAxsE,EAAAnE,KAAAmE,WAIA6lF,KAAA,SAAAhkF,EAAAw5E,GAKA,MAHAx/E,MAAAsB,IAAA0E,EAAA1E,EAAAtB,KAAAsB,GAAAk+E,EACAx/E,KAAAuB,IAAAyE,EAAAzE,EAAAvB,KAAAuB,GAAAi+E,EAEAx/E,MAIAquG,YAAA,SAAAje,EAAAC,EAAA7Q,GAEA,MAAAx/E,MAAA+tF,WAAAsC,EAAAD,GAAAzf,eAAA6O,GAAA19E,IAAAsuF,IAIA9qB,OAAA,SAAAt/D,GAEA,MAAAA,GAAA1E,IAAAtB,KAAAsB,GAAA0E,EAAAzE,IAAAvB,KAAAuB,GAIA4lF,UAAA,SAAA/3C,EAAAzF,GAOA,MALA/iC,UAAA+iC,MAAA,GAEA3pC,KAAAsB,EAAA8tC,EAAAzF,GACA3pC,KAAAuB,EAAA6tC,EAAAzF,EAAA,GAEA3pC,MAIAib,QAAA,SAAAm0B,EAAAzF,GAQA,MANA/iC,UAAAwoC,UACAxoC,SAAA+iC,MAAA,GAEAyF,EAAAzF,GAAA3pC,KAAAsB,EACA8tC,EAAAzF,EAAA,GAAA3pC,KAAAuB,EAEA6tC,GAIAk/D,cAAA,SAAApxC,EAAAvzD,EAAAggC,GASA,MAPA/iC,UAAA+iC,MAAA,GAEAhgC,IAAAuzD,EAAAzS,SAAA9gB,EAEA3pC,KAAAsB,EAAA47D,EAAA9tB,MAAAzlC,GACA3J,KAAAuB,EAAA27D,EAAA9tB,MAAAzlC,EAAA,GAEA3J,MAIAuuG,aAAA,SAAAluD,EAAAk6B,GAEA,GAAAp8E,GAAA2C,KAAAs8B,IAAAm9C,GAAA36E,EAAAkB,KAAA+rF,IAAAtS,GAEAj5E,EAAAtB,KAAAsB,EAAA++C,EAAA/+C,EACAC,EAAAvB,KAAAuB,EAAA8+C,EAAA9+C,CAKA,OAHAvB,MAAAsB,IAAAnD,EAAAoD,EAAA3B,EAAAygD,EAAA/+C,EACAtB,KAAAuB,EAAAD,EAAA1B,EAAA2B,EAAApD,EAAAkiD,EAAA9+C,EAEAvB,OAyDA6rC,EAAAc,cAAA/lC,OACAilC,EAAAgB,gBAAAg+D,GAEAh/D,EAAAhsC,WAEAmb,YAAA6wB,EAEAuuB,WAAA,EAEA9e,gBAAAl1C,GAEAA,KAAA,GAAApG,KAAAwa,WAIAjL,MAAA,WAEA,UAAAvP,MAAAgb,aAAAS,KAAAzb,OAIAyb,KAAA,SAAA2W,GA2BA,MAzBApyB,MAAA0rB,MAAA0G,EAAA1G,MACA1rB,KAAA4sC,QAAAxa,EAAAwa,QAAA/7B,MAAA,GAEA7Q,KAAA8rC,QAAA1Z,EAAA0Z,QAEA9rC,KAAA+rC,MAAA3Z,EAAA2Z,MACA/rC,KAAAgsC,MAAA5Z,EAAA4Z,MAEAhsC,KAAAisC,UAAA7Z,EAAA6Z,UACAjsC,KAAAksC,UAAA9Z,EAAA8Z,UAEAlsC,KAAAosC,WAAAha,EAAAga,WAEApsC,KAAAmsC,OAAA/Z,EAAA+Z,OACAnsC,KAAAoE,KAAAguB,EAAAhuB,KAEApE,KAAA2pC,OAAAluB,KAAA2W,EAAAuX,QACA3pC,KAAAmtC,OAAA1xB,KAAA2W,EAAA+a,QAEAntC,KAAAotC,gBAAAhb,EAAAgb,gBACAptC,KAAAqtC,iBAAAjb,EAAAib,iBACArtC,KAAAstC,MAAAlb,EAAAkb,MACAttC,KAAAutC,gBAAAnb,EAAAmb,gBACAvtC,KAAAqsC,SAAAja,EAAAia,SAEArsC,MAIAwuG,OAAA,SAAAC,GAQA,QAAAC,GAAAhjF,GAEA,GAAAuvB,EAgBA,OAdAr0C,UAAA8kB,EAAAijF,UAEA1zD,EAAAvvB,GAIAuvB,EAAAz7C,SAAA07C,gBAAA,yCACAD,EAAAp4C,MAAA6oB,EAAA7oB,MACAo4C,EAAAn4C,OAAA4oB,EAAA5oB,OAEAm4C,EAAAE,WAAA,MAAAujB,UAAAhzC,EAAA,IAAAA,EAAA7oB,MAAA6oB,EAAA5oB,SAIAm4C,EAAAp4C,MAAA,MAAAo4C,EAAAn4C,OAAA,KAEAm4C,EAAA0zD,UAAA,iBAIA1zD,EAAA0zD,UAAA,aA9BA,GAAA/nG,SAAA6nG,EAAAhvC,SAAAz/D,KAAAusC,MAEA,MAAAkiE,GAAAhvC,SAAAz/D,KAAAusC,KAkCA,IAAAu9D,IACA8E,UACAp0F,QAAA,IACApW,KAAA,UACAyqG,UAAA,kBAGAtiE,KAAAvsC,KAAAusC,KACA7kC,KAAA1H,KAAA0H,KAEAokC,QAAA9rC,KAAA8rC,QAEAqB,QAAAntC,KAAAmtC,OAAA7rC,EAAAtB,KAAAmtC,OAAA5rC,GACAooC,QAAA3pC,KAAA2pC,OAAAroC,EAAAtB,KAAA2pC,OAAApoC,GACAwJ,MAAA/K,KAAA+rC,MAAA/rC,KAAAgsC,OAEAE,UAAAlsC,KAAAksC,UACAD,UAAAjsC,KAAAisC,UACAG,WAAApsC,KAAAosC,WAEAkB,MAAAttC,KAAAstC,MAGA,IAAA1mC,SAAA5G,KAAA0rB,MAAA,CAIA,GAAAA,GAAA1rB,KAAA0rB,KAEA9kB,UAAA8kB,EAAA6gB,OAEA7gB,EAAA6gB,KAAAC,GAAAC,gBAIA7lC,SAAA6nG,EAAA1/D,OAAArjB,EAAA6gB,QAEAkiE,EAAA1/D,OAAArjB,EAAA6gB,OACAA,KAAA7gB,EAAA6gB,KACA3I,IAAA8qE,EAAAhjF,KAKAo+E,EAAAp+E,QAAA6gB,KAMA,MAFAkiE,GAAAhvC,SAAAz/D,KAAAusC,MAAAu9D,EAEAA,GAIA3pC,QAAA,WAEAngE,KAAAoqG,eAAwBhmG,KAAA;IAIxB0qG,YAAA,SAAAl4D,GAEA,GAAA52C,KAAA8rC,UAAA++D,GAAA,CAKA,GAHAj0D,EAAAoQ,SAAAhnD,KAAAmtC,QACAyJ,EAAA90C,IAAA9B,KAAA2pC,QAEAiN,EAAAt1C,EAAA,GAAAs1C,EAAAt1C,EAAA,EAEA,OAAAtB,KAAA+rC,OAEA,IAAAgvC,IAEAnkC,EAAAt1C,EAAAs1C,EAAAt1C,EAAAR,KAAA4uD,MAAA9Y,EAAAt1C,EACA,MAEA,KAAAwrC,IAEA8J,EAAAt1C,EAAAs1C,EAAAt1C,EAAA,KACA,MAEA,KAAA25E,IAEA,IAAAn6E,KAAA+xE,IAAA/xE,KAAA4uD,MAAA9Y,EAAAt1C,GAAA,GAEAs1C,EAAAt1C,EAAAR,KAAAslF,KAAAxvC,EAAAt1C,GAAAs1C,EAAAt1C,EAIAs1C,EAAAt1C,EAAAs1C,EAAAt1C,EAAAR,KAAA4uD,MAAA9Y,EAAAt1C,GASA,GAAAs1C,EAAAr1C,EAAA,GAAAq1C,EAAAr1C,EAAA,EAEA,OAAAvB,KAAAgsC,OAEA,IAAA+uC,IAEAnkC,EAAAr1C,EAAAq1C,EAAAr1C,EAAAT,KAAA4uD,MAAA9Y,EAAAr1C,EACA,MAEA,KAAAurC,IAEA8J,EAAAr1C,EAAAq1C,EAAAr1C,EAAA,KACA,MAEA,KAAA05E,IAEA,IAAAn6E,KAAA+xE,IAAA/xE,KAAA4uD,MAAA9Y,EAAAr1C,GAAA,GAEAq1C,EAAAr1C,EAAAT,KAAAslF,KAAAxvC,EAAAr1C,GAAAq1C,EAAAr1C,EAIAq1C,EAAAr1C,EAAAq1C,EAAAr1C,EAAAT,KAAA4uD,MAAA9Y,EAAAr1C,GASAvB,KAAAstC,QAEAsJ,EAAAr1C,EAAA,EAAAq1C,EAAAr1C,MAQAyY,OAAA6vF,OAAAh+D,EAAAhsC,UAAA8rC,EAAA9rC,UAEA,IAAAoyB,IAAA,CAoBAyb,GAAA7tC,WAEAmb,YAAA0yB,EAEAqhE,WAAA,EAEA9sG,IAAA,SAAAX,EAAAC,EAAAC,EAAA6B,GAOA,MALArD,MAAAsB,IACAtB,KAAAuB,IACAvB,KAAAwB,IACAxB,KAAAqD,IAEArD,MAIAitG,UAAA,SAAAC,GAOA,MALAltG,MAAAsB,EAAA4rG,EACAltG,KAAAuB,EAAA2rG,EACAltG,KAAAwB,EAAA0rG,EACAltG,KAAAqD,EAAA6pG,EAEAltG,MAIAsuF,KAAA,SAAAhtF,GAIA,MAFAtB,MAAAsB,IAEAtB,MAIAmtG,KAAA,SAAA5rG,GAIA,MAFAvB,MAAAuB,IAEAvB,MAIAgvG,KAAA,SAAAxtG,GAIA,MAFAxB,MAAAwB,IAEAxB,MAIAivG,KAAA,SAAA5rG,GAIA,MAFArD,MAAAqD,IAEArD,MAIAotG,aAAA,SAAAzjG,EAAAvD,GAEA,OAAAuD,GAEA,OAAA3J,KAAAsB,EAAA8E,CAA2B,MAC3B,QAAApG,KAAAuB,EAAA6E,CAA2B,MAC3B,QAAApG,KAAAwB,EAAA4E,CAA2B,MAC3B,QAAApG,KAAAqD,EAAA+C,CAA2B,MAC3B,kBAAA9C,OAAA,0BAAAqG,GAIA,MAAA3J,OAIAqtG,aAAA,SAAA1jG,GAEA,OAAAA,GAEA,aAAA3J,MAAAsB,CACA,cAAAtB,MAAAuB,CACA,cAAAvB,MAAAwB,CACA,cAAAxB,MAAAqD,CACA,kBAAAC,OAAA,0BAAAqG,KAMA4F,MAAA,WAEA,UAAAvP,MAAAgb,YAAAhb,KAAAsB,EAAAtB,KAAAuB,EAAAvB,KAAAwB,EAAAxB,KAAAqD,IAIAoY,KAAA,SAAAzV,GAOA,MALAhG,MAAAsB,EAAA0E,EAAA1E,EACAtB,KAAAuB,EAAAyE,EAAAzE,EACAvB,KAAAwB,EAAAwE,EAAAxE,EACAxB,KAAAqD,EAAAuD,SAAAZ,EAAA3C,EAAA2C,EAAA3C,EAAA,EAEArD,MAIA8B,IAAA,SAAAkE,EAAA3C,GAEA,MAAAuD,UAAAvD,GAEAktB,QAAAC,KAAA,yFACAxwB,KAAAguF,WAAAhoF,EAAA3C,KAIArD,KAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EACAvB,KAAAwB,GAAAwE,EAAAxE,EACAxB,KAAAqD,GAAA2C,EAAA3C,EAEArD,OAIAstG,UAAA,SAAA1tG,GAOA,MALAI,MAAAsB,GAAA1B,EACAI,KAAAuB,GAAA3B,EACAI,KAAAwB,GAAA5B,EACAI,KAAAqD,GAAAzD,EAEAI,MAIAguF,WAAA,SAAA3uE,EAAAC,GAOA,MALAtf,MAAAsB,EAAA+d,EAAA/d,EAAAge,EAAAhe,EACAtB,KAAAuB,EAAA8d,EAAA9d,EAAA+d,EAAA/d,EACAvB,KAAAwB,EAAA6d,EAAA7d,EAAA8d,EAAA9d,EACAxB,KAAAqD,EAAAgc,EAAAhc,EAAAic,EAAAjc,EAEArD,MAIAutG,gBAAA,SAAAvnG,EAAApG,GAOA,MALAI,MAAAsB,GAAA0E,EAAA1E,EAAA1B,EACAI,KAAAuB,GAAAyE,EAAAzE,EAAA3B,EACAI,KAAAwB,GAAAwE,EAAAxE,EAAA5B,EACAI,KAAAqD,GAAA2C,EAAA3C,EAAAzD,EAEAI,MAIAm6E,IAAA,SAAAn0E,EAAA3C,GAEA,MAAAuD,UAAAvD,GAEAktB,QAAAC,KAAA,yFACAxwB,KAAA+tF,WAAA/nF,EAAA3C,KAIArD,KAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EACAvB,KAAAwB,GAAAwE,EAAAxE,EACAxB,KAAAqD,GAAA2C,EAAA3C,EAEArD,OAIAwtG,UAAA,SAAA5tG,GAOA,MALAI,MAAAsB,GAAA1B,EACAI,KAAAuB,GAAA3B,EACAI,KAAAwB,GAAA5B,EACAI,KAAAqD,GAAAzD,EAEAI,MAIA+tF,WAAA,SAAA1uE,EAAAC,GAOA,MALAtf,MAAAsB,EAAA+d,EAAA/d,EAAAge,EAAAhe,EACAtB,KAAAuB,EAAA8d,EAAA9d,EAAA+d,EAAA/d,EACAvB,KAAAwB,EAAA6d,EAAA7d,EAAA8d,EAAA9d,EACAxB,KAAAqD,EAAAgc,EAAAhc,EAAAic,EAAAjc,EAEArD,MAIA2wE,eAAA,SAAAu8B,GAkBA,MAhBA7wE,UAAA6wE,IAEAltG,KAAAsB,GAAA4rG,EACAltG,KAAAuB,GAAA2rG,EACAltG,KAAAwB,GAAA0rG,EACAltG,KAAAqD,GAAA6pG,IAIAltG,KAAAsB,EAAA,EACAtB,KAAAuB,EAAA,EACAvB,KAAAwB,EAAA,EACAxB,KAAAqD,EAAA,GAIArD,MAIA24C,aAAA,SAAAz6C,GAEA,GAAAoD,GAAAtB,KAAAsB,EAAAC,EAAAvB,KAAAuB,EAAAC,EAAAxB,KAAAwB,EAAA6B,EAAArD,KAAAqD,EACA1B,EAAAzD,EAAAsG,QAOA,OALAxE,MAAAsB,EAAAK,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EAAAG,EAAA,IAAA0B,EACArD,KAAAuB,EAAAI,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EAAAG,EAAA,IAAA0B,EACArD,KAAAwB,EAAAG,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,IAAAH,EAAAG,EAAA,IAAA0B,EACArD,KAAAqD,EAAA1B,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,IAAAH,EAAAG,EAAA,IAAA0B,EAEArD,MAIAkrF,aAAA,SAAAgiB,GAEA,MAAAltG,MAAA2wE,eAAA,EAAAu8B,IAIAgC,2BAAA,SAAA7hB,GAMArtF,KAAAqD,EAAA,EAAAvC,KAAAquG,KAAA9hB,EAAAhqF,EAEA,IAAAzD,GAAAkB,KAAAolF,KAAA,EAAAmH,EAAAhqF,EAAAgqF,EAAAhqF,EAgBA,OAdAzD,GAAA,MAEAI,KAAAsB,EAAA,EACAtB,KAAAuB,EAAA,EACAvB,KAAAwB,EAAA,IAIAxB,KAAAsB,EAAA+rF,EAAA/rF,EAAA1B,EACAI,KAAAuB,EAAA8rF,EAAA9rF,EAAA3B,EACAI,KAAAwB,EAAA6rF,EAAA7rF,EAAA5B,GAIAI,MAIAovG,+BAAA,SAAAlxG,GAMA,GAAAq8E,GAAAj5E,EAAAC,EAAAC,EACA6tG,EAAA,IACAC,EAAA,GAEAC,EAAArxG,EAAAsG,SAEAgrG,EAAAD,EAAA,GAAAE,EAAAF,EAAA,GAAAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GAAAK,EAAAL,EAAA,GAAAM,EAAAN,EAAA,GACAO,EAAAP,EAAA,GAAAQ,EAAAR,EAAA,GAAAS,EAAAT,EAAA,GAEA,IAAAzuG,KAAA+xE,IAAA48B,EAAAE,GAAAN,GACAvuG,KAAA+xE,IAAA68B,EAAAI,GAAAT,GACAvuG,KAAA+xE,IAAAg9B,EAAAE,GAAAV,EAAA,CAMA,GAAAvuG,KAAA+xE,IAAA48B,EAAAE,GAAAL,GACAxuG,KAAA+xE,IAAA68B,EAAAI,GAAAR,GACAxuG,KAAA+xE,IAAAg9B,EAAAE,GAAAT,GACAxuG,KAAA+xE,IAAA28B,EAAAI,EAAAI,EAAA,GAAAV,EAMA,MAFAtvG,MAAAiC,IAAA,SAEAjC,IAMAu6E,GAAAz5E,KAAAu8B,EAEA,IAAA4yE,IAAAT,EAAA,KACAU,GAAAN,EAAA,KACAO,GAAAH,EAAA,KACAI,GAAAX,EAAAE,GAAA,EACAU,GAAAX,EAAAI,GAAA,EACAQ,GAAAT,EAAAE,GAAA,CA4DA,OA1DAE,GAAAC,GAAAD,EAAAE,EAIAF,EAAAZ,GAEA/tG,EAAA,EACAC,EAAA,WACAC,EAAA,aAIAF,EAAAR,KAAAolF,KAAA+pB,GACA1uG,EAAA6uG,EAAA9uG,EACAE,EAAA6uG,EAAA/uG,GAIK4uG,EAAAC,EAILD,EAAAb,GAEA/tG,EAAA,WACAC,EAAA,EACAC,EAAA,aAIAD,EAAAT,KAAAolF,KAAAgqB,GACA5uG,EAAA8uG,EAAA7uG,EACAC,EAAA8uG,EAAA/uG,GAQA4uG,EAAAd,GAEA/tG,EAAA,WACAC,EAAA,WACAC,EAAA,IAIAA,EAAAV,KAAAolF,KAAAiqB,GACA7uG,EAAA+uG,EAAA7uG,EACAD,EAAA+uG,EAAA9uG,GAMAxB,KAAAiC,IAAAX,EAAAC,EAAAC,EAAA+4E,GAEAv6E,KAMA,GAAAJ,GAAAkB,KAAAolF,MAAA6pB,EAAAF,IAAAE,EAAAF,IACAH,EAAAI,IAAAJ,EAAAI,IACAH,EAAAF,IAAAE,EAAAF,GAYA,OAVA3uG,MAAA+xE,IAAAjzE,GAAA,OAAAA,EAAA,GAKAI,KAAAsB,GAAAyuG,EAAAF,GAAAjwG,EACAI,KAAAuB,GAAAmuG,EAAAI,GAAAlwG,EACAI,KAAAwB,GAAAmuG,EAAAF,GAAA7vG,EACAI,KAAAqD,EAAAvC,KAAAquG,MAAAK,EAAAI,EAAAI,EAAA,MAEAhwG,MAIAe,IAAA,SAAAiF,GAOA,MALAhG,MAAAsB,EAAAR,KAAAC,IAAAf,KAAAsB,EAAA0E,EAAA1E,GACAtB,KAAAuB,EAAAT,KAAAC,IAAAf,KAAAuB,EAAAyE,EAAAzE,GACAvB,KAAAwB,EAAAV,KAAAC,IAAAf,KAAAwB,EAAAwE,EAAAxE,GACAxB,KAAAqD,EAAAvC,KAAAC,IAAAf,KAAAqD,EAAA2C,EAAA3C,GAEArD,MAIAkR,IAAA,SAAAlL,GAOA,MALAhG,MAAAsB,EAAAR,KAAAoQ,IAAAlR,KAAAsB,EAAA0E,EAAA1E,GACAtB,KAAAuB,EAAAT,KAAAoQ,IAAAlR,KAAAuB,EAAAyE,EAAAzE,GACAvB,KAAAwB,EAAAV,KAAAoQ,IAAAlR,KAAAwB,EAAAwE,EAAAxE,GACAxB,KAAAqD,EAAAvC,KAAAoQ,IAAAlR,KAAAqD,EAAA2C,EAAA3C,GAEArD,MAIAqxF,MAAA,SAAAtwF,EAAAmQ,GASA,MALAlR,MAAAsB,EAAAR,KAAAoQ,IAAAnQ,EAAAO,EAAAR,KAAAC,IAAAmQ,EAAA5P,EAAAtB,KAAAsB,IACAtB,KAAAuB,EAAAT,KAAAoQ,IAAAnQ,EAAAQ,EAAAT,KAAAC,IAAAmQ,EAAA3P,EAAAvB,KAAAuB,IACAvB,KAAAwB,EAAAV,KAAAoQ,IAAAnQ,EAAAS,EAAAV,KAAAC,IAAAmQ,EAAA1P,EAAAxB,KAAAwB,IACAxB,KAAAqD,EAAAvC,KAAAoQ,IAAAnQ,EAAAsC,EAAAvC,KAAAC,IAAAmQ,EAAA7N,EAAArD,KAAAqD,IAEArD,MAIA0tG,YAAA,WAEA,GAAA3sG,GAAAmQ,CAEA,iBAAAy8F,EAAAC,GAYA,MAVAhnG,UAAA7F,IAEAA,EAAA,GAAA2sC,GACAx8B,EAAA,GAAAw8B,IAIA3sC,EAAAkB,IAAA0rG,SACAz8F,EAAAjP,IAAA2rG,SAEA5tG,KAAAqxF,MAAAtwF,EAAAmQ,OAMAw+C,MAAA,WAOA,MALA1vD,MAAAsB,EAAAR,KAAA4uD,MAAA1vD,KAAAsB,GACAtB,KAAAuB,EAAAT,KAAA4uD,MAAA1vD,KAAAuB,GACAvB,KAAAwB,EAAAV,KAAA4uD,MAAA1vD,KAAAwB,GACAxB,KAAAqD,EAAAvC,KAAA4uD,MAAA1vD,KAAAqD,GAEArD,MAIAomF,KAAA,WAOA,MALApmF,MAAAsB,EAAAR,KAAAslF,KAAApmF,KAAAsB,GACAtB,KAAAuB,EAAAT,KAAAslF,KAAApmF,KAAAuB,GACAvB,KAAAwB,EAAAV,KAAAslF,KAAApmF,KAAAwB,GACAxB,KAAAqD,EAAAvC,KAAAslF,KAAApmF,KAAAqD,GAEArD,MAIA+sG,MAAA,WAOA,MALA/sG,MAAAsB,EAAAR,KAAAisG,MAAA/sG,KAAAsB,GACAtB,KAAAuB,EAAAT,KAAAisG,MAAA/sG,KAAAuB,GACAvB,KAAAwB,EAAAV,KAAAisG,MAAA/sG,KAAAwB,GACAxB,KAAAqD,EAAAvC,KAAAisG,MAAA/sG,KAAAqD,GAEArD,MAIA8tG,YAAA,WAOA,MALA9tG,MAAAsB,EAAAtB,KAAAsB,EAAA,EAAAR,KAAAslF,KAAApmF,KAAAsB,GAAAR,KAAA4uD,MAAA1vD,KAAAsB,GACAtB,KAAAuB,EAAAvB,KAAAuB,EAAA,EAAAT,KAAAslF,KAAApmF,KAAAuB,GAAAT,KAAA4uD,MAAA1vD,KAAAuB,GACAvB,KAAAwB,EAAAxB,KAAAwB,EAAA,EAAAV,KAAAslF,KAAApmF,KAAAwB,GAAAV,KAAA4uD,MAAA1vD,KAAAwB,GACAxB,KAAAqD,EAAArD,KAAAqD,EAAA,EAAAvC,KAAAslF,KAAApmF,KAAAqD,GAAAvC,KAAA4uD,MAAA1vD,KAAAqD,GAEArD,MAIAy6E,OAAA,WAOA,MALAz6E,MAAAsB,GAAAtB,KAAAsB,EACAtB,KAAAuB,GAAAvB,KAAAuB,EACAvB,KAAAwB,GAAAxB,KAAAwB,EACAxB,KAAAqD,GAAArD,KAAAqD,EAEArD,MAIAqyF,IAAA,SAAArsF,GAEA,MAAAhG,MAAAsB,EAAA0E,EAAA1E,EAAAtB,KAAAuB,EAAAyE,EAAAzE,EAAAvB,KAAAwB,EAAAwE,EAAAxE,EAAAxB,KAAAqD,EAAA2C,EAAA3C,GAIA0qG,SAAA,WAEA,MAAA/tG,MAAAsB,EAAAtB,KAAAsB,EAAAtB,KAAAuB,EAAAvB,KAAAuB,EAAAvB,KAAAwB,EAAAxB,KAAAwB,EAAAxB,KAAAqD,EAAArD,KAAAqD,GAIAc,OAAA,WAEA,MAAArD,MAAAolF,KAAAlmF,KAAAsB,EAAAtB,KAAAsB,EAAAtB,KAAAuB,EAAAvB,KAAAuB,EAAAvB,KAAAwB,EAAAxB,KAAAwB,EAAAxB,KAAAqD,EAAArD,KAAAqD,IAIA2qG,gBAAA,WAEA,MAAAltG,MAAA+xE,IAAA7yE,KAAAsB,GAAAR,KAAA+xE,IAAA7yE,KAAAuB,GAAAT,KAAA+xE,IAAA7yE,KAAAwB,GAAAV,KAAA+xE,IAAA7yE,KAAAqD,IAIAw3E,UAAA,WAEA,MAAA76E,MAAAkrF,aAAAlrF,KAAAmE,WAIAkkG,UAAA,SAAAlkG,GAEA,MAAAnE,MAAA2wE,eAAAxsE,EAAAnE,KAAAmE,WAIA6lF,KAAA,SAAAhkF,EAAAw5E,GAOA,MALAx/E,MAAAsB,IAAA0E,EAAA1E,EAAAtB,KAAAsB,GAAAk+E,EACAx/E,KAAAuB,IAAAyE,EAAAzE,EAAAvB,KAAAuB,GAAAi+E,EACAx/E,KAAAwB,IAAAwE,EAAAxE,EAAAxB,KAAAwB,GAAAg+E,EACAx/E,KAAAqD,IAAA2C,EAAA3C,EAAArD,KAAAqD,GAAAm8E,EAEAx/E,MAIAquG,YAAA,SAAAje,EAAAC,EAAA7Q,GAEA,MAAAx/E,MAAA+tF,WAAAsC,EAAAD,GAAAzf,eAAA6O,GAAA19E,IAAAsuF,IAIA9qB,OAAA,SAAAt/D,GAEA,MAAAA,GAAA1E,IAAAtB,KAAAsB,GAAA0E,EAAAzE,IAAAvB,KAAAuB,GAAAyE,EAAAxE,IAAAxB,KAAAwB,GAAAwE,EAAA3C,IAAArD,KAAAqD,GAIA8jF,UAAA,SAAA/3C,EAAAzF,GASA,MAPA/iC,UAAA+iC,MAAA,GAEA3pC,KAAAsB,EAAA8tC,EAAAzF,GACA3pC,KAAAuB,EAAA6tC,EAAAzF,EAAA,GACA3pC,KAAAwB,EAAA4tC,EAAAzF,EAAA,GACA3pC,KAAAqD,EAAA+rC,EAAAzF,EAAA,GAEA3pC,MAIAib,QAAA,SAAAm0B,EAAAzF,GAUA,MARA/iC,UAAAwoC,UACAxoC,SAAA+iC,MAAA,GAEAyF,EAAAzF,GAAA3pC,KAAAsB,EACA8tC,EAAAzF,EAAA,GAAA3pC,KAAAuB,EACA6tC,EAAAzF,EAAA,GAAA3pC,KAAAwB,EACA4tC,EAAAzF,EAAA,GAAA3pC,KAAAqD,EAEA+rC,GAIAk/D,cAAA,SAAApxC,EAAAvzD,EAAAggC,GAWA,MATA/iC,UAAA+iC,MAAA,GAEAhgC,IAAAuzD,EAAAzS,SAAA9gB,EAEA3pC,KAAAsB,EAAA47D,EAAA9tB,MAAAzlC,GACA3J,KAAAuB,EAAA27D,EAAA9tB,MAAAzlC,EAAA,GACA3J,KAAAwB,EAAA07D,EAAA9tB,MAAAzlC,EAAA,GACA3J,KAAAqD,EAAA65D,EAAA9tB,MAAAzlC,EAAA,GAEA3J,OAyCAga,OAAA6vF,OAAAl8D,EAAA9tC,UAAA8rC,EAAA9rC,WAEAw6D,qBAAA,EAEA75D,QAAA,SAAAqC,EAAAC,GAEA9C,KAAA6C,WAAA7C,KAAA8C,aAEA9C,KAAA6C,QACA7C,KAAA8C,SAEA9C,KAAAmgE,WAIAngE,KAAA8tC,SAAA7rC,IAAA,IAAAY,EAAAC,GACA9C,KAAA4tC,QAAA3rC,IAAA,IAAAY,EAAAC,IAIAyM,MAAA,WAEA,UAAAvP,MAAAgb,aAAAS,KAAAzb,OAIAyb,KAAA,SAAA2W,GAaA,MAXApyB,MAAA6C,MAAAuvB,EAAAvvB,MACA7C,KAAA8C,OAAAsvB,EAAAtvB,OAEA9C,KAAA8tC,SAAAryB,KAAA2W,EAAA0b,UAEA9tC,KAAA+tC,QAAA3b,EAAA2b,QAAAx+B,QAEAvP,KAAAguC,YAAA5b,EAAA4b,YACAhuC,KAAAiuC,cAAA7b,EAAA6b,cACAjuC,KAAAkuC,aAAA9b,EAAA8b,aAEAluC,MAIAmgE,QAAA,WAEAngE,KAAAoqG,eAAwBhmG,KAAA,eAmBxB+pC,EAAAtuC,UAAAma,OAAAu2F,OAAA5iE,EAAA9tC,WACAsuC,EAAAtuC,UAAAmb,YAAAmzB,EAEAA,EAAAtuC,UAAAugE,yBAAA,EAkBA9xB,EAAAzuC,WAEAmb,YAAAszB,EAEAhtC,QAEA,MAAAtB,MAAAuuC,IAIAjtC,MAAA8E,GAEApG,KAAAuuC,GAAAnoC,EACApG,KAAAwwG,oBAIAjvG,QAEA,MAAAvB,MAAAwuC,IAIAjtC,MAAA6E,GAEApG,KAAAwuC,GAAApoC,EACApG,KAAAwwG,oBAIAhvG,QAEA,MAAAxB,MAAAyuC,IAIAjtC,MAAA4E,GAEApG,KAAAyuC,GAAAroC,EACApG,KAAAwwG,oBAIAntG,QAEA,MAAArD,MAAA0uC,IAIArrC,MAAA+C,GAEApG,KAAA0uC,GAAAtoC,EACApG,KAAAwwG,oBAIAvuG,IAAA,SAAAX,EAAAC,EAAAC,EAAA6B,GASA,MAPArD,MAAAuuC,GAAAjtC,EACAtB,KAAAwuC,GAAAjtC,EACAvB,KAAAyuC,GAAAjtC,EACAxB,KAAA0uC,GAAArrC,EAEArD,KAAAwwG,mBAEAxwG,MAIAuP,MAAA,WAEA,UAAAvP,MAAAgb,YAAAhb,KAAAuuC,GAAAvuC,KAAAwuC,GAAAxuC,KAAAyuC,GAAAzuC,KAAA0uC,KAIAjzB,KAAA,SAAA6sC,GASA,MAPAtoD,MAAAuuC,GAAA+Z,EAAAhnD,EACAtB,KAAAwuC,GAAA8Z,EAAA/mD,EACAvB,KAAAyuC,GAAA6Z,EAAA9mD,EACAxB,KAAA0uC,GAAA4Z,EAAAjlD,EAEArD,KAAAwwG,mBAEAxwG,MAIAuoD,aAAA,SAAAkoD,EAAAtuG,GAEA,IAAAsuG,KAAAC,YAAA,EAEA,SAAAptG,OAAA,mGAQA,IAAAqtG,GAAA7vG,KAAAs8B,IAAAqzE,EAAAliE,GAAA,GACAqiE,EAAA9vG,KAAAs8B,IAAAqzE,EAAAjiE,GAAA,GACAqiE,EAAA/vG,KAAAs8B,IAAAqzE,EAAAhiE,GAAA,GACAqiE,EAAAhwG,KAAA+rF,IAAA4jB,EAAAliE,GAAA,GACAwiE,EAAAjwG,KAAA+rF,IAAA4jB,EAAAjiE,GAAA,GACAwiE,EAAAlwG,KAAA+rF,IAAA4jB,EAAAhiE,GAAA,GAEA5S,EAAA40E,EAAA50E,KAgDA,OA9CA,QAAAA,GAEA77B,KAAAuuC,GAAAuiE,EAAAF,EAAAC,EAAAF,EAAAI,EAAAC,EACAhxG,KAAAwuC,GAAAmiE,EAAAI,EAAAF,EAAAC,EAAAF,EAAAI,EACAhxG,KAAAyuC,GAAAkiE,EAAAC,EAAAI,EAAAF,EAAAC,EAAAF,EACA7wG,KAAA0uC,GAAAiiE,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEI,QAAAn1E,GAEJ77B,KAAAuuC,GAAAuiE,EAAAF,EAAAC,EAAAF,EAAAI,EAAAC,EACAhxG,KAAAwuC,GAAAmiE,EAAAI,EAAAF,EAAAC,EAAAF,EAAAI,EACAhxG,KAAAyuC,GAAAkiE,EAAAC,EAAAI,EAAAF,EAAAC,EAAAF,EACA7wG,KAAA0uC,GAAAiiE,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEI,QAAAn1E,GAEJ77B,KAAAuuC,GAAAuiE,EAAAF,EAAAC,EAAAF,EAAAI,EAAAC,EACAhxG,KAAAwuC,GAAAmiE,EAAAI,EAAAF,EAAAC,EAAAF,EAAAI,EACAhxG,KAAAyuC,GAAAkiE,EAAAC,EAAAI,EAAAF,EAAAC,EAAAF,EACA7wG,KAAA0uC,GAAAiiE,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEI,QAAAn1E,GAEJ77B,KAAAuuC,GAAAuiE,EAAAF,EAAAC,EAAAF,EAAAI,EAAAC,EACAhxG,KAAAwuC,GAAAmiE,EAAAI,EAAAF,EAAAC,EAAAF,EAAAI,EACAhxG,KAAAyuC,GAAAkiE,EAAAC,EAAAI,EAAAF,EAAAC,EAAAF,EACA7wG,KAAA0uC,GAAAiiE,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEI,QAAAn1E,GAEJ77B,KAAAuuC,GAAAuiE,EAAAF,EAAAC,EAAAF,EAAAI,EAAAC,EACAhxG,KAAAwuC,GAAAmiE,EAAAI,EAAAF,EAAAC,EAAAF,EAAAI,EACAhxG,KAAAyuC,GAAAkiE,EAAAC,EAAAI,EAAAF,EAAAC,EAAAF,EACA7wG,KAAA0uC,GAAAiiE,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEI,QAAAn1E,IAEJ77B,KAAAuuC,GAAAuiE,EAAAF,EAAAC,EAAAF,EAAAI,EAAAC,EACAhxG,KAAAwuC,GAAAmiE,EAAAI,EAAAF,EAAAC,EAAAF,EAAAI,EACAhxG,KAAAyuC,GAAAkiE,EAAAC,EAAAI,EAAAF,EAAAC,EAAAF,EACA7wG,KAAA0uC,GAAAiiE,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAIA7uG,KAAA,GAAAnC,KAAAwwG,mBAEAxwG,MAIAixG,iBAAA,SAAAC,EAAA32B,GAMA,GAAA42B,GAAA52B,EAAA,EAAA36E,EAAAkB,KAAA+rF,IAAAskB,EASA,OAPAnxG,MAAAuuC,GAAA2iE,EAAA5vG,EAAA1B,EACAI,KAAAwuC,GAAA0iE,EAAA3vG,EAAA3B,EACAI,KAAAyuC,GAAAyiE,EAAA1vG,EAAA5B,EACAI,KAAA0uC,GAAA5tC,KAAAs8B,IAAA+zE,GAEAnxG,KAAAwwG,mBAEAxwG,MAIAoxG,sBAAA,SAAAlzG,GAMA,GAOA0B,GAPA2vG,EAAArxG,EAAAsG,SAEAgrG,EAAAD,EAAA,GAAAE,EAAAF,EAAA,GAAAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GAAAK,EAAAL,EAAA,GAAAM,EAAAN,EAAA,GACAO,EAAAP,EAAA,GAAAQ,EAAAR,EAAA,GAAAS,EAAAT,EAAA,IAEA8B,EAAA7B,EAAAI,EAAAI,CA2CA,OAxCAqB,GAAA,GAEAzxG,EAAA,GAAAkB,KAAAolF,KAAAmrB,EAAA,GAEArxG,KAAA0uC,GAAA,IAAA9uC,EACAI,KAAAuuC,IAAAwhE,EAAAF,GAAAjwG,EACAI,KAAAwuC,IAAAkhE,EAAAI,GAAAlwG,EACAI,KAAAyuC,IAAAkhE,EAAAF,GAAA7vG,GAEI4vG,EAAAI,GAAAJ,EAAAQ,GAEJpwG,EAAA,EAAAkB,KAAAolF,KAAA,EAAAspB,EAAAI,EAAAI,GAEAhwG,KAAA0uC,IAAAqhE,EAAAF,GAAAjwG,EACAI,KAAAuuC,GAAA,IAAA3uC,EACAI,KAAAwuC,IAAAihE,EAAAE,GAAA/vG,EACAI,KAAAyuC,IAAAihE,EAAAI,GAAAlwG,GAEIgwG,EAAAI,GAEJpwG,EAAA,EAAAkB,KAAAolF,KAAA,EAAA0pB,EAAAJ,EAAAQ,GAEAhwG,KAAA0uC,IAAAghE,EAAAI,GAAAlwG,EACAI,KAAAuuC,IAAAkhE,EAAAE,GAAA/vG,EACAI,KAAAwuC,GAAA,IAAA5uC,EACAI,KAAAyuC,IAAAohE,EAAAE,GAAAnwG,IAIAA,EAAA,EAAAkB,KAAAolF,KAAA,EAAA8pB,EAAAR,EAAAI,GAEA5vG,KAAA0uC,IAAAihE,EAAAF,GAAA7vG,EACAI,KAAAuuC,IAAAmhE,EAAAI,GAAAlwG,EACAI,KAAAwuC,IAAAqhE,EAAAE,GAAAnwG,EACAI,KAAAyuC,GAAA,IAAA7uC,GAIAI,KAAAwwG,mBAEAxwG,MAIAsxG,mBAAA,WAMA,GAAAlhB,GAAA5gD,EAEA+hE,EAAA,IAEA,iBAAAC,EAAAC,GA+BA,MA7BA7qG,UAAAwpF,MAAA,GAAAzhD,IAEAa,EAAAgiE,EAAAnf,IAAAof,GAAA,EAEAjiE,EAAA+hE,GAEA/hE,EAAA,EAEA1uC,KAAA+xE,IAAA2+B,EAAAlwG,GAAAR,KAAA+xE,IAAA2+B,EAAAhwG,GAEA4uF,EAAAnuF,KAAAuvG,EAAAjwG,EAAAiwG,EAAAlwG,EAAA,GAIA8uF,EAAAnuF,IAAA,GAAAuvG,EAAAhwG,EAAAgwG,EAAAjwG,IAMA6uF,EAAAnC,aAAAujB,EAAAC,GAIAzxG,KAAAuuC,GAAA6hD,EAAA9uF,EACAtB,KAAAwuC,GAAA4hD,EAAA7uF,EACAvB,KAAAyuC,GAAA2hD,EAAA5uF,EACAxB,KAAA0uC,GAAAc,EAEAxvC,KAAA66E,gBAMA62B,QAAA,WAEA,MAAA1xG,MAAA2xG,YAAA92B,aAIA82B,UAAA,WAQA,MANA3xG,MAAAuuC,KAAA,EACAvuC,KAAAwuC,KAAA,EACAxuC,KAAAyuC,KAAA,EAEAzuC,KAAAwwG,mBAEAxwG,MAIAqyF,IAAA,SAAArsF,GAEA,MAAAhG,MAAAuuC,GAAAvoC,EAAAuoC,GAAAvuC,KAAAwuC,GAAAxoC,EAAAwoC,GAAAxuC,KAAAyuC,GAAAzoC,EAAAyoC,GAAAzuC,KAAA0uC,GAAA1oC,EAAA0oC,IAIAq/D,SAAA,WAEA,MAAA/tG,MAAAuuC,GAAAvuC,KAAAuuC,GAAAvuC,KAAAwuC,GAAAxuC,KAAAwuC,GAAAxuC,KAAAyuC,GAAAzuC,KAAAyuC,GAAAzuC,KAAA0uC,GAAA1uC,KAAA0uC,IAIAvqC,OAAA,WAEA,MAAArD,MAAAolF,KAAAlmF,KAAAuuC,GAAAvuC,KAAAuuC,GAAAvuC,KAAAwuC,GAAAxuC,KAAAwuC,GAAAxuC,KAAAyuC,GAAAzuC,KAAAyuC,GAAAzuC,KAAA0uC,GAAA1uC,KAAA0uC,KAIAmsC,UAAA,WAEA,GAAApwE,GAAAzK,KAAAmE,QAsBA,OApBA,KAAAsG,GAEAzK,KAAAuuC,GAAA,EACAvuC,KAAAwuC,GAAA,EACAxuC,KAAAyuC,GAAA,EACAzuC,KAAA0uC,GAAA,IAIAjkC,EAAA,EAAAA,EAEAzK,KAAAuuC,GAAAvuC,KAAAuuC,GAAA9jC,EACAzK,KAAAwuC,GAAAxuC,KAAAwuC,GAAA/jC,EACAzK,KAAAyuC,GAAAzuC,KAAAyuC,GAAAhkC,EACAzK,KAAA0uC,GAAA1uC,KAAA0uC,GAAAjkC,GAIAzK,KAAAwwG,mBAEAxwG,MAIAgnD,SAAA,SAAAqmC,EAAAjvF,GAEA,MAAAwI,UAAAxI,GAEAmyB,QAAAC,KAAA,0GACAxwB,KAAA4xG,oBAAAvkB,EAAAjvF,IAIA4B,KAAA4xG,oBAAA5xG,KAAAqtF,IAIAwkB,YAAA,SAAAxkB,GAEA,MAAArtF,MAAA4xG,oBAAAvkB,EAAArtF,OAIA4xG,oBAAA,SAAAvyF,EAAAC,GAIA,GAAAwyF,GAAAzyF,EAAAkvB,GAAAwjE,EAAA1yF,EAAAmvB,GAAAwjE,EAAA3yF,EAAAovB,GAAAwjE,EAAA5yF,EAAAqvB,GACAwjE,EAAA5yF,EAAAivB,GAAA4jE,EAAA7yF,EAAAkvB,GAAA4jE,EAAA9yF,EAAAmvB,GAAA4jE,EAAA/yF,EAAAovB,EASA,OAPA1uC,MAAAuuC,GAAAujE,EAAAO,EAAAJ,EAAAC,EAAAH,EAAAK,EAAAJ,EAAAG,EACAnyG,KAAAwuC,GAAAujE,EAAAM,EAAAJ,EAAAE,EAAAH,EAAAE,EAAAJ,EAAAM,EACApyG,KAAAyuC,GAAAujE,EAAAK,EAAAJ,EAAAG,EAAAN,EAAAK,EAAAJ,EAAAG,EACAlyG,KAAA0uC,GAAAujE,EAAAI,EAAAP,EAAAI,EAAAH,EAAAI,EAAAH,EAAAI,EAEApyG,KAAAwwG,mBAEAxwG,MAIAsyG,MAAA,SAAAC,EAAA5+E,GAEA,OAAAA,EAAA,MAAA3zB,KACA,QAAA2zB,EAAA,MAAA3zB,MAAAyb,KAAA82F,EAEA,IAAAjxG,GAAAtB,KAAAuuC,GAAAhtC,EAAAvB,KAAAwuC,GAAAhtC,EAAAxB,KAAAyuC,GAAAprC,EAAArD,KAAA0uC,GAIA8jE,EAAAnvG,EAAAkvG,EAAA7jE,GAAAptC,EAAAixG,EAAAhkE,GAAAhtC,EAAAgxG,EAAA/jE,GAAAhtC,EAAA+wG,EAAA9jE,EAiBA,IAfA+jE,EAAA,GAEAxyG,KAAA0uC,IAAA6jE,EAAA7jE,GACA1uC,KAAAuuC,IAAAgkE,EAAAhkE,GACAvuC,KAAAwuC,IAAA+jE,EAAA/jE,GACAxuC,KAAAyuC,IAAA8jE,EAAA9jE,GAEA+jE,MAIAxyG,KAAAyb,KAAA82F,GAIAC,GAAA,EAOA,MALAxyG,MAAA0uC,GAAArrC,EACArD,KAAAuuC,GAAAjtC,EACAtB,KAAAwuC,GAAAjtC,EACAvB,KAAAyuC,GAAAjtC,EAEAxB,IAIA,IAAAyyG,GAAA3xG,KAAAolF,KAAA,EAAAssB,IAEA,IAAA1xG,KAAA+xE,IAAA4/B,GAAA,KAOA,MALAzyG,MAAA0uC,GAAA,IAAArrC,EAAArD,KAAA0uC,IACA1uC,KAAAuuC,GAAA,IAAAjtC,EAAAtB,KAAAuuC,IACAvuC,KAAAwuC,GAAA,IAAAjtC,EAAAvB,KAAAwuC,IACAxuC,KAAAyuC,GAAA,IAAAjtC,EAAAxB,KAAAyuC,IAEAzuC,IAIA,IAAA0yG,GAAA5xG,KAAAuqF,MAAAonB,EAAAD,GACAG,EAAA7xG,KAAA+rF,KAAA,EAAAl5D,GAAA++E,GAAAD,EACAG,EAAA9xG,KAAA+rF,IAAAl5D,EAAA++E,GAAAD,CASA,OAPAzyG,MAAA0uC,GAAArrC,EAAAsvG,EAAA3yG,KAAA0uC,GAAAkkE,EACA5yG,KAAAuuC,GAAAjtC,EAAAqxG,EAAA3yG,KAAAuuC,GAAAqkE,EACA5yG,KAAAwuC,GAAAjtC,EAAAoxG,EAAA3yG,KAAAwuC,GAAAokE,EACA5yG,KAAAyuC,GAAAjtC,EAAAmxG,EAAA3yG,KAAAyuC,GAAAmkE,EAEA5yG,KAAAwwG,mBAEAxwG,MAIAslE,OAAA,SAAAhd,GAEA,MAAAA,GAAA/Z,KAAAvuC,KAAAuuC,IAAA+Z,EAAA9Z,KAAAxuC,KAAAwuC,IAAA8Z,EAAA7Z,KAAAzuC,KAAAyuC,IAAA6Z,EAAA5Z,KAAA1uC,KAAA0uC,IAIAy4C,UAAA,SAAA/3C,EAAAzF,GAWA,MATA/iC,UAAA+iC,MAAA,GAEA3pC,KAAAuuC,GAAAa,EAAAzF,GACA3pC,KAAAwuC,GAAAY,EAAAzF,EAAA,GACA3pC,KAAAyuC,GAAAW,EAAAzF,EAAA,GACA3pC,KAAA0uC,GAAAU,EAAAzF,EAAA,GAEA3pC,KAAAwwG,mBAEAxwG,MAIAib,QAAA,SAAAm0B,EAAAzF,GAUA,MARA/iC,UAAAwoC,UACAxoC,SAAA+iC,MAAA,GAEAyF,EAAAzF,GAAA3pC,KAAAuuC,GACAa,EAAAzF,EAAA,GAAA3pC,KAAAwuC,GACAY,EAAAzF,EAAA,GAAA3pC,KAAAyuC,GACAW,EAAAzF,EAAA,GAAA3pC,KAAA0uC,GAEAU,GAIAwZ,SAAA,SAAAj6C,GAIA,MAFA3O,MAAAwwG,iBAAA7hG,EAEA3O,MAIAwwG,iBAAA,cAIAx2F,OAAA6vF,OAAAv7D,GAEAgkE,MAAA,SAAAO,EAAAN,EAAAO,EAAAn/E,GAEA,MAAAm/E,GAAAr3F,KAAAo3F,GAAAP,MAAAC,EAAA5+E,IAIAo/E,UAAA,SACAC,EAAAhkC,EAAAikC,EAAAC,EAAAC,EAAAC,EAAAz/E,GAIA,GAAAg3D,GAAAsoB,EAAAC,EAAA,GACAG,EAAAJ,EAAAC,EAAA,GACAI,EAAAL,EAAAC,EAAA,GACAK,EAAAN,EAAAC,EAAA,GAEAtoB,EAAAuoB,EAAAC,EAAA,GACAI,EAAAL,EAAAC,EAAA,GACAK,EAAAN,EAAAC,EAAA,GACAM,EAAAP,EAAAC,EAAA,EAEA,IAAAG,IAAAG,GAAA/oB,IAAAC,GAAAyoB,IAAAG,GAAAF,IAAAG,EAAA,CAEA,GAAA7zG,GAAA,EAAA+zB,EAEAyJ,EAAAutD,EAAAC,EAAAyoB,EAAAG,EAAAF,EAAAG,EAAAF,EAAAG,EAEApuG,EAAA83B,GAAA,OACAu2E,EAAA,EAAAv2E,GAGA,IAAAu2E,EAAAjK,OAAAC,QAAA,CAEA,GAAA9c,GAAA/rF,KAAAolF,KAAAytB,GACAr4F,EAAAxa,KAAAuqF,MAAAwB,EAAAzvD,EAAA93B,EAEA1F,GAAAkB,KAAA+rF,IAAAjtF,EAAA0b,GAAAuxE,EACAl5D,EAAA7yB,KAAA+rF,IAAAl5D,EAAArY,GAAAuxE,EAIA,GAAA+mB,GAAAjgF,EAAAruB,CAQA,IANAqlF,IAAA/qF,EAAAgrF,EAAAgpB,EACAP,IAAAzzG,EAAA4zG,EAAAI,EACAN,IAAA1zG,EAAA6zG,EAAAG,EACAL,IAAA3zG,EAAA8zG,EAAAE,EAGAh0G,IAAA,EAAA+zB,EAAA,CAEA,GAAAurC,GAAA,EAAAp+D,KAAAolF,KAAAyE,IAAA0oB,IAAAC,IAAAC,IAEA5oB,IAAAzrB,EACAm0C,GAAAn0C,EACAo0C,GAAAp0C,EACAq0C,GAAAr0C,GAMA8zC,EAAAhkC,GAAA2b,EACAqoB,EAAAhkC,EAAA,GAAAqkC,EACAL,EAAAhkC,EAAA,GAAAskC,EACAN,EAAAhkC,EAAA,GAAAukC,KAuBA5kE,EAAA9uC,WAEAmb,YAAA2zB,EAEA+a,WAAA,EAEAznD,IAAA,SAAAX,EAAAC,EAAAC,GAMA,MAJAxB,MAAAsB,IACAtB,KAAAuB,IACAvB,KAAAwB,IAEAxB,MAIAitG,UAAA,SAAAC,GAMA,MAJAltG,MAAAsB,EAAA4rG,EACAltG,KAAAuB,EAAA2rG,EACAltG,KAAAwB,EAAA0rG,EAEAltG,MAIAsuF,KAAA,SAAAhtF,GAIA,MAFAtB,MAAAsB,IAEAtB,MAIAmtG,KAAA,SAAA5rG,GAIA,MAFAvB,MAAAuB,IAEAvB,MAIAgvG,KAAA,SAAAxtG,GAIA,MAFAxB,MAAAwB,IAEAxB,MAIAotG,aAAA,SAAAzjG,EAAAvD,GAEA,OAAAuD,GAEA,OAAA3J,KAAAsB,EAAA8E,CAA2B,MAC3B,QAAApG,KAAAuB,EAAA6E,CAA2B,MAC3B,QAAApG,KAAAwB,EAAA4E,CAA2B,MAC3B,kBAAA9C,OAAA,0BAAAqG,GAIA,MAAA3J,OAIAqtG,aAAA,SAAA1jG,GAEA,OAAAA,GAEA,aAAA3J,MAAAsB,CACA,cAAAtB,MAAAuB,CACA,cAAAvB,MAAAwB,CACA,kBAAA8B,OAAA,0BAAAqG,KAMA4F,MAAA,WAEA,UAAAvP,MAAAgb,YAAAhb,KAAAsB,EAAAtB,KAAAuB,EAAAvB,KAAAwB,IAIAia,KAAA,SAAAzV,GAMA,MAJAhG,MAAAsB,EAAA0E,EAAA1E,EACAtB,KAAAuB,EAAAyE,EAAAzE,EACAvB,KAAAwB,EAAAwE,EAAAxE,EAEAxB,MAIA8B,IAAA,SAAAkE,EAAA3C,GAEA,MAAAuD,UAAAvD,GAEAktB,QAAAC,KAAA,yFACAxwB,KAAAguF,WAAAhoF,EAAA3C,KAIArD,KAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EACAvB,KAAAwB,GAAAwE,EAAAxE,EAEAxB,OAIAstG,UAAA,SAAA1tG,GAMA,MAJAI,MAAAsB,GAAA1B,EACAI,KAAAuB,GAAA3B,EACAI,KAAAwB,GAAA5B,EAEAI,MAIAguF,WAAA,SAAA3uE,EAAAC,GAMA,MAJAtf,MAAAsB,EAAA+d,EAAA/d,EAAAge,EAAAhe,EACAtB,KAAAuB,EAAA8d,EAAA9d,EAAA+d,EAAA/d,EACAvB,KAAAwB,EAAA6d,EAAA7d,EAAA8d,EAAA9d,EAEAxB,MAIAutG,gBAAA,SAAAvnG,EAAApG,GAMA,MAJAI,MAAAsB,GAAA0E,EAAA1E,EAAA1B,EACAI,KAAAuB,GAAAyE,EAAAzE,EAAA3B,EACAI,KAAAwB,GAAAwE,EAAAxE,EAAA5B,EAEAI,MAIAm6E,IAAA,SAAAn0E,EAAA3C,GAEA,MAAAuD,UAAAvD,GAEAktB,QAAAC,KAAA,yFACAxwB,KAAA+tF,WAAA/nF,EAAA3C,KAIArD,KAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EACAvB,KAAAwB,GAAAwE,EAAAxE,EAEAxB,OAIAwtG,UAAA,SAAA5tG,GAMA,MAJAI,MAAAsB,GAAA1B,EACAI,KAAAuB,GAAA3B,EACAI,KAAAwB,GAAA5B,EAEAI,MAIA+tF,WAAA,SAAA1uE,EAAAC,GAMA,MAJAtf,MAAAsB,EAAA+d,EAAA/d,EAAAge,EAAAhe,EACAtB,KAAAuB,EAAA8d,EAAA9d,EAAA+d,EAAA/d,EACAvB,KAAAwB,EAAA6d,EAAA7d,EAAA8d,EAAA9d,EAEAxB,MAIAgnD,SAAA,SAAAhhD,EAAA3C,GAEA,MAAAuD,UAAAvD,GAEAktB,QAAAC,KAAA,mGACAxwB,KAAA6zG,gBAAA7tG,EAAA3C,KAIArD,KAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EACAvB,KAAAwB,GAAAwE,EAAAxE,EAEAxB,OAIA2wE,eAAA,SAAAu8B,GAgBA,MAdA7wE,UAAA6wE,IAEAltG,KAAAsB,GAAA4rG,EACAltG,KAAAuB,GAAA2rG,EACAltG,KAAAwB,GAAA0rG,IAIAltG,KAAAsB,EAAA,EACAtB,KAAAuB,EAAA,EACAvB,KAAAwB,EAAA,GAIAxB,MAIA6zG,gBAAA,SAAAx0F,EAAAC,GAMA,MAJAtf,MAAAsB,EAAA+d,EAAA/d,EAAAge,EAAAhe,EACAtB,KAAAuB,EAAA8d,EAAA9d,EAAA+d,EAAA/d,EACAvB,KAAAwB,EAAA6d,EAAA7d,EAAA8d,EAAA9d,EAEAxB,MAIA8zG,WAAA,WAEA,GAAAxrD,EAEA,iBAAAmoD,GAUA,OARAA,KAAAC,YAAA,GAEAngF,QAAA5W,MAAA,+FAIA/S,SAAA0hD,MAAA,GAAAha,IAEAtuC,KAAA+zG,gBAAAzrD,EAAAC,aAAAkoD,QAMAuD,eAAA,WAEA,GAAA1rD,EAEA,iBAAA4oD,EAAA32B,GAIA,MAFA3zE,UAAA0hD,MAAA,GAAAha,IAEAtuC,KAAA+zG,gBAAAzrD,EAAA2oD,iBAAAC,EAAA32B,QAMA05B,aAAA,SAAA/1G,GAEA,GAAAoD,GAAAtB,KAAAsB,EAAAC,EAAAvB,KAAAuB,EAAAC,EAAAxB,KAAAwB,EACAG,EAAAzD,EAAAsG,QAMA,OAJAxE,MAAAsB,EAAAK,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EACAxB,KAAAuB,EAAAI,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EACAxB,KAAAwB,EAAAG,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EAEAxB,MAIA24C,aAAA,SAAAz6C,GAIA,GAAAoD,GAAAtB,KAAAsB,EAAAC,EAAAvB,KAAAuB,EAAAC,EAAAxB,KAAAwB,EACAG,EAAAzD,EAAAsG,QAMA,OAJAxE,MAAAsB,EAAAK,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EAAAG,EAAA,IACA3B,KAAAuB,EAAAI,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EAAAG,EAAA,IACA3B,KAAAwB,EAAAG,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,IAAAH,EAAAG,EAAA,IAEA3B,MAIA64C,gBAAA,SAAA36C,GAIA,GAAAoD,GAAAtB,KAAAsB,EAAAC,EAAAvB,KAAAuB,EAAAC,EAAAxB,KAAAwB,EACAG,EAAAzD,EAAAsG,SACAwpD,EAAA,GAAArsD,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,IAAAH,EAAAG,EAAA,IAMA,OAJA3B,MAAAsB,GAAAK,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EAAAG,EAAA,KAAAqsD,EACAhuD,KAAAuB,GAAAI,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EAAAG,EAAA,KAAAqsD,EACAhuD,KAAAwB,GAAAG,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,IAAAH,EAAAG,EAAA,KAAAqsD,EAEAhuD,MAIA+zG,gBAAA,SAAA1mB,GAEA,GAAA/rF,GAAAtB,KAAAsB,EAAAC,EAAAvB,KAAAuB,EAAAC,EAAAxB,KAAAwB,EACA0yG,EAAA7mB,EAAA/rF,EAAA6yG,EAAA9mB,EAAA9rF,EAAA6yG,EAAA/mB,EAAA7rF,EAAA6yG,EAAAhnB,EAAAhqF,EAIA8rD,EAAAklD,EAAA/yG,EAAA6yG,EAAA3yG,EAAA4yG,EAAA7yG,EACA2tD,EAAAmlD,EAAA9yG,EAAA6yG,EAAA9yG,EAAA4yG,EAAA1yG,EACA8yG,EAAAD,EAAA7yG,EAAA0yG,EAAA3yG,EAAA4yG,EAAA7yG,EACAizG,GAAAL,EAAA5yG,EAAA6yG,EAAA5yG,EAAA6yG,EAAA5yG,CAQA,OAJAxB,MAAAsB,EAAA6tD,EAAAklD,EAAAE,GAAAL,EAAAhlD,GAAAklD,EAAAE,GAAAH,EACAn0G,KAAAuB,EAAA2tD,EAAAmlD,EAAAE,GAAAJ,EAAAG,GAAAJ,EAAA/kD,GAAAilD,EACAp0G,KAAAwB,EAAA8yG,EAAAD,EAAAE,GAAAH,EAAAjlD,GAAAglD,EAAAjlD,GAAAglD,EAEAl0G,MAIAqpG,QAAA,WAEA,GAAA9iD,EAEA,iBAAAnlD,GAKA,MAHAwF,UAAA2/C,MAAA,GAAA3X,IAEA2X,EAAAnK,iBAAAh7C,EAAA03C,iBAAAyN,EAAAQ,WAAA3lD,EAAAs3C,cACA14C,KAAA64C,gBAAA0N,OAMAgjD,UAAA,WAEA,GAAAhjD,EAEA,iBAAAnlD,GAKA,MAHAwF,UAAA2/C,MAAA,GAAA3X,IAEA2X,EAAAnK,iBAAAh7C,EAAAs3C,YAAA6N,EAAAQ,WAAA3lD,EAAA03C,mBACA94C,KAAA64C,gBAAA0N,OAMA6zB,mBAAA,SAAAl8E,GAKA,GAAAoD,GAAAtB,KAAAsB,EAAAC,EAAAvB,KAAAuB,EAAAC,EAAAxB,KAAAwB,EACAG,EAAAzD,EAAAsG,QAMA,OAJAxE,MAAAsB,EAAAK,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EACAxB,KAAAuB,EAAAI,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,GAAAH,EACAxB,KAAAwB,EAAAG,EAAA,GAAAL,EAAAK,EAAA,GAAAJ,EAAAI,EAAA,IAAAH,EAEAxB,KAAA66E,aAIA4yB,OAAA,SAAAznG,GAMA,MAJAhG,MAAAsB,GAAA0E,EAAA1E,EACAtB,KAAAuB,GAAAyE,EAAAzE,EACAvB,KAAAwB,GAAAwE,EAAAxE,EAEAxB,MAIAkrF,aAAA,SAAAgiB,GAEA,MAAAltG,MAAA2wE,eAAA,EAAAu8B,IAIAnsG,IAAA,SAAAiF,GAMA,MAJAhG,MAAAsB,EAAAR,KAAAC,IAAAf,KAAAsB,EAAA0E,EAAA1E,GACAtB,KAAAuB,EAAAT,KAAAC,IAAAf,KAAAuB,EAAAyE,EAAAzE,GACAvB,KAAAwB,EAAAV,KAAAC,IAAAf,KAAAwB,EAAAwE,EAAAxE,GAEAxB,MAIAkR,IAAA,SAAAlL,GAMA,MAJAhG,MAAAsB,EAAAR,KAAAoQ,IAAAlR,KAAAsB,EAAA0E,EAAA1E,GACAtB,KAAAuB,EAAAT,KAAAoQ,IAAAlR,KAAAuB,EAAAyE,EAAAzE,GACAvB,KAAAwB,EAAAV,KAAAoQ,IAAAlR,KAAAwB,EAAAwE,EAAAxE,GAEAxB,MAIAqxF,MAAA,SAAAtwF,EAAAmQ,GAQA,MAJAlR,MAAAsB,EAAAR,KAAAoQ,IAAAnQ,EAAAO,EAAAR,KAAAC,IAAAmQ,EAAA5P,EAAAtB,KAAAsB,IACAtB,KAAAuB,EAAAT,KAAAoQ,IAAAnQ,EAAAQ,EAAAT,KAAAC,IAAAmQ,EAAA3P,EAAAvB,KAAAuB,IACAvB,KAAAwB,EAAAV,KAAAoQ,IAAAnQ,EAAAS,EAAAV,KAAAC,IAAAmQ,EAAA1P,EAAAxB,KAAAwB,IAEAxB,MAIA0tG,YAAA,WAEA,GAAA3sG,GAAAmQ,CAEA,iBAAAy8F,EAAAC,GAYA,MAVAhnG,UAAA7F,IAEAA,EAAA,GAAA4tC,GACAz9B,EAAA,GAAAy9B,IAIA5tC,EAAAkB,IAAA0rG,OACAz8F,EAAAjP,IAAA2rG,OAEA5tG,KAAAqxF,MAAAtwF,EAAAmQ,OAMA28F,YAAA,SAAA9sG,EAAAmQ,GAEA,GAAA/M,GAAAnE,KAAAmE,QAEA,OAAAnE,MAAA2wE,eAAA7vE,KAAAoQ,IAAAnQ,EAAAD,KAAAC,IAAAmQ,EAAA/M,QAIAurD,MAAA,WAMA,MAJA1vD,MAAAsB,EAAAR,KAAA4uD,MAAA1vD,KAAAsB,GACAtB,KAAAuB,EAAAT,KAAA4uD,MAAA1vD,KAAAuB,GACAvB,KAAAwB,EAAAV,KAAA4uD,MAAA1vD,KAAAwB,GAEAxB,MAIAomF,KAAA,WAMA,MAJApmF,MAAAsB,EAAAR,KAAAslF,KAAApmF,KAAAsB,GACAtB,KAAAuB,EAAAT,KAAAslF,KAAApmF,KAAAuB,GACAvB,KAAAwB,EAAAV,KAAAslF,KAAApmF,KAAAwB,GAEAxB,MAIA+sG,MAAA,WAMA,MAJA/sG,MAAAsB,EAAAR,KAAAisG,MAAA/sG,KAAAsB,GACAtB,KAAAuB,EAAAT,KAAAisG,MAAA/sG,KAAAuB,GACAvB,KAAAwB,EAAAV,KAAAisG,MAAA/sG,KAAAwB,GAEAxB,MAIA8tG,YAAA,WAMA,MAJA9tG,MAAAsB,EAAAtB,KAAAsB,EAAA,EAAAR,KAAAslF,KAAApmF,KAAAsB,GAAAR,KAAA4uD,MAAA1vD,KAAAsB,GACAtB,KAAAuB,EAAAvB,KAAAuB,EAAA,EAAAT,KAAAslF,KAAApmF,KAAAuB,GAAAT,KAAA4uD,MAAA1vD,KAAAuB,GACAvB,KAAAwB,EAAAxB,KAAAwB,EAAA,EAAAV,KAAAslF,KAAApmF,KAAAwB,GAAAV,KAAA4uD,MAAA1vD,KAAAwB,GAEAxB,MAIAy6E,OAAA,WAMA,MAJAz6E,MAAAsB,GAAAtB,KAAAsB,EACAtB,KAAAuB,GAAAvB,KAAAuB,EACAvB,KAAAwB,GAAAxB,KAAAwB,EAEAxB,MAIAqyF,IAAA,SAAArsF,GAEA,MAAAhG,MAAAsB,EAAA0E,EAAA1E,EAAAtB,KAAAuB,EAAAyE,EAAAzE,EAAAvB,KAAAwB,EAAAwE,EAAAxE,GAIAusG,SAAA,WAEA,MAAA/tG,MAAAsB,EAAAtB,KAAAsB,EAAAtB,KAAAuB,EAAAvB,KAAAuB,EAAAvB,KAAAwB,EAAAxB,KAAAwB,GAIA2C,OAAA,WAEA,MAAArD,MAAAolF,KAAAlmF,KAAAsB,EAAAtB,KAAAsB,EAAAtB,KAAAuB,EAAAvB,KAAAuB,EAAAvB,KAAAwB,EAAAxB,KAAAwB,IAIAwsG,gBAAA,WAEA,MAAAltG,MAAA+xE,IAAA7yE,KAAAsB,GAAAR,KAAA+xE,IAAA7yE,KAAAuB,GAAAT,KAAA+xE,IAAA7yE,KAAAwB,IAIAq5E,UAAA,WAEA,MAAA76E,MAAAkrF,aAAAlrF,KAAAmE,WAIAkkG,UAAA,SAAAlkG,GAEA,MAAAnE,MAAA2wE,eAAAxsE,EAAAnE,KAAAmE,WAIA6lF,KAAA,SAAAhkF,EAAAw5E,GAMA,MAJAx/E,MAAAsB,IAAA0E,EAAA1E,EAAAtB,KAAAsB,GAAAk+E,EACAx/E,KAAAuB,IAAAyE,EAAAzE,EAAAvB,KAAAuB,GAAAi+E,EACAx/E,KAAAwB,IAAAwE,EAAAxE,EAAAxB,KAAAwB,GAAAg+E,EAEAx/E,MAIAquG,YAAA,SAAAje,EAAAC,EAAA7Q,GAEA,MAAAx/E,MAAA+tF,WAAAsC,EAAAD,GAAAzf,eAAA6O,GAAA19E,IAAAsuF,IAIAokB,MAAA,SAAAxuG,EAAA3C,GAEA,GAAAuD,SAAAvD,EAGA,MADAktB,SAAAC,KAAA,6FACAxwB,KAAAiuF,aAAAjoF,EAAA3C,EAIA,IAAA/B,GAAAtB,KAAAsB,EAAAC,EAAAvB,KAAAuB,EAAAC,EAAAxB,KAAAwB,CAMA,OAJAxB,MAAAsB,EAAAC,EAAAyE,EAAAxE,IAAAwE,EAAAzE,EACAvB,KAAAuB,EAAAC,EAAAwE,EAAA1E,IAAA0E,EAAAxE,EACAxB,KAAAwB,EAAAF,EAAA0E,EAAAzE,IAAAyE,EAAA1E,EAEAtB,MAIAiuF,aAAA,SAAA5uE,EAAAC,GAEA,GAAAm1F,GAAAp1F,EAAA/d,EAAAozG,EAAAr1F,EAAA9d,EAAAozG,EAAAt1F,EAAA7d,EACAozG,EAAAt1F,EAAAhe,EAAAuzG,EAAAv1F,EAAA/d,EAAAuzG,EAAAx1F,EAAA9d,CAMA,OAJAxB,MAAAsB,EAAAozG,EAAAI,EAAAH,EAAAE,EACA70G,KAAAuB,EAAAozG,EAAAC,EAAAH,EAAAK,EACA90G,KAAAwB,EAAAizG,EAAAI,EAAAH,EAAAE,EAEA50G,MAIA+0G,gBAAA,SAAA9lD,GAEA,GAAAi+C,GAAAj+C,EAAAojC,IAAAryF,MAAAivD,EAAA8+C,UAEA,OAAA/tG,MAAAyb,KAAAwzC,GAAA0hB,eAAAu8B,IAIA8H,eAAA,WAEA,GAAA5kB,EAEA,iBAAA6kB,GAMA,MAJAruG,UAAAwpF,MAAA,GAAAzhD,IAEAyhD,EAAA30E,KAAAzb,MAAA+0G,gBAAAE,GAEAj1G,KAAAm6E,IAAAiW,OAMA8kB,QAAA,WAKA,GAAA9kB,EAEA,iBAAA5vC,GAIA,MAFA55C,UAAAwpF,MAAA,GAAAzhD,IAEA3uC,KAAAm6E,IAAAiW,EAAA30E,KAAA+kC,GAAAmwB,eAAA,EAAA3wE,KAAAqyF,IAAA7xC,SAMA20D,QAAA,SAAAnvG,GAEA,GAAA8sF,GAAA9yF,KAAAqyF,IAAArsF,GAAAlF,KAAAolF,KAAAlmF,KAAA+tG,WAAA/nG,EAAA+nG,WAIA,OAAAjtG,MAAAquG,KAAA3iE,GAAA6kD,MAAAyB,GAAA,OAIAyR,WAAA,SAAAv+F,GAEA,MAAAlF,MAAAolF,KAAAlmF,KAAAiuG,kBAAAjoG,KAIAioG,kBAAA,SAAAjoG,GAEA,GAAAkoG,GAAAluG,KAAAsB,EAAA0E,EAAA1E,EAAA6sG,EAAAnuG,KAAAuB,EAAAyE,EAAAzE,EAAA6zG,EAAAp1G,KAAAwB,EAAAwE,EAAAxE,CAEA,OAAA0sG,KAAAC,IAAAiH,KAIAhH,oBAAA,SAAApoG,GAEA,MAAAlF,MAAA+xE,IAAA7yE,KAAAsB,EAAA0E,EAAA1E,GAAAR,KAAA+xE,IAAA7yE,KAAAuB,EAAAyE,EAAAzE,GAAAT,KAAA+xE,IAAA7yE,KAAAwB,EAAAwE,EAAAxE,IAIA6zG,iBAAA,SAAAz1G,GAEA,GAAA01G,GAAAx0G,KAAA+rF,IAAAjtF,EAAA2xF,KAAA3xF,EAAA0gD,MAMA,OAJAtgD,MAAAsB,EAAAg0G,EAAAx0G,KAAA+rF,IAAAjtF,EAAAkzF,OACA9yF,KAAAuB,EAAAT,KAAAs8B,IAAAx9B,EAAA2xF,KAAA3xF,EAAA0gD,OACAtgD,KAAAwB,EAAA8zG,EAAAx0G,KAAAs8B,IAAAx9B,EAAAkzF,OAEA9yF,MAIAwmD,sBAAA,SAAAtoD,GAEA,MAAA8B,MAAAu1G,oBAAAr3G,EAAA,IAIAs3G,mBAAA,SAAAt3G,GAEA,GAAAu3G,GAAAz1G,KAAAu1G,oBAAAr3G,EAAA,GAAAiG,SACAuxG,EAAA11G,KAAAu1G,oBAAAr3G,EAAA,GAAAiG,SACAwxG,EAAA31G,KAAAu1G,oBAAAr3G,EAAA,GAAAiG,QAMA,OAJAnE,MAAAsB,EAAAm0G,EACAz1G,KAAAuB,EAAAm0G,EACA11G,KAAAwB,EAAAm0G,EAEA31G,MAIAu1G,oBAAA,SAAAr3G,EAAAyL,GAEA,mBAAAzL,GAAA,CAEAqyB,QAAAC,KAAA,oEACA,IAAAtnB,GAAAhL,CACAA,GAAAyL,EACAA,EAAAT,EAIA,MAAAlJ,MAAAmnF,UAAAjpF,EAAAsG,SAAA,EAAAmF,IAIA27D,OAAA,SAAAt/D,GAEA,MAAAA,GAAA1E,IAAAtB,KAAAsB,GAAA0E,EAAAzE,IAAAvB,KAAAuB,GAAAyE,EAAAxE,IAAAxB,KAAAwB,GAIA2lF,UAAA,SAAA/3C,EAAAzF,GAQA,MANA/iC,UAAA+iC,MAAA,GAEA3pC,KAAAsB,EAAA8tC,EAAAzF,GACA3pC,KAAAuB,EAAA6tC,EAAAzF,EAAA,GACA3pC,KAAAwB,EAAA4tC,EAAAzF,EAAA,GAEA3pC,MAIAib,QAAA,SAAAm0B,EAAAzF,GASA,MAPA/iC,UAAAwoC,UACAxoC,SAAA+iC,MAAA,GAEAyF,EAAAzF,GAAA3pC,KAAAsB,EACA8tC,EAAAzF,EAAA,GAAA3pC,KAAAuB,EACA6tC,EAAAzF,EAAA,GAAA3pC,KAAAwB,EAEA4tC,GAIAk/D,cAAA,SAAApxC,EAAAvzD,EAAAggC,GAUA,MARA/iC,UAAA+iC,MAAA,GAEAhgC,IAAAuzD,EAAAzS,SAAA9gB,EAEA3pC,KAAAsB,EAAA47D,EAAA9tB,MAAAzlC,GACA3J,KAAAuB,EAAA27D,EAAA9tB,MAAAzlC,EAAA,GACA3J,KAAAwB,EAAA07D,EAAA9tB,MAAAzlC,EAAA,GAEA3J,OAsCA4uC,EAAA/uC,WAEAmb,YAAA4zB,EAEAgnE,WAAA,EAEA3zG,IAAA,SAAA4zG,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA,GAAArH,GAAAvvG,KAAAwE,QAOA,OALA+qG,GAAA,GAAAsG,EAAiBtG,EAAA,GAAAuG,EAAevG,EAAA,GAAAwG,EAAexG,EAAA,IAAAyG,EAC/CzG,EAAA,GAAA0G,EAAiB1G,EAAA,GAAA2G,EAAe3G,EAAA,GAAA4G,EAAe5G,EAAA,IAAA6G,EAC/C7G,EAAA,GAAA8G,EAAiB9G,EAAA,GAAA+G,EAAe/G,EAAA,IAAAgH,EAAgBhH,EAAA,IAAAiH,EAChDjH,EAAA,GAAAkH,EAAiBlH,EAAA,GAAAmH,EAAenH,EAAA,IAAAoH,EAAgBpH,EAAA,IAAAqH,EAEhD52G,MAIA06E,SAAA,WAWA,MATA16E,MAAAiC,IAEA,QACA,QACA,QACA,SAIAjC,MAIAuP,MAAA,WAEA,UAAAq/B,IAAAu4C,UAAAnnF,KAAAwE,WAIAiX,KAAA,SAAAvd,GAIA,MAFA8B,MAAAwE,SAAAvC,IAAA/D,EAAAsG,UAEAxE,MAIA62G,aAAA,SAAA34G,GAEA,GAAAqxG,GAAAvvG,KAAAwE,SACAsyG,EAAA54G,EAAAsG,QAMA,OAJA+qG,GAAA,IAAAuH,EAAA,IACAvH,EAAA,IAAAuH,EAAA,IACAvH,EAAA,IAAAuH,EAAA,IAEA92G,MAIA+2G,aAAA,SAAAC,EAAAC,EAAAC,GAMA,MAJAF,GAAAzB,oBAAAv1G,KAAA,GACAi3G,EAAA1B,oBAAAv1G,KAAA,GACAk3G,EAAA3B,oBAAAv1G,KAAA,GAEAA,MAIAm3G,UAAA,SAAAH,EAAAC,EAAAC,GASA,MAPAl3G,MAAAiC,IACA+0G,EAAA11G,EAAA21G,EAAA31G,EAAA41G,EAAA51G,EAAA,EACA01G,EAAAz1G,EAAA01G,EAAA11G,EAAA21G,EAAA31G,EAAA,EACAy1G,EAAAx1G,EAAAy1G,EAAAz1G,EAAA01G,EAAA11G,EAAA,EACA,SAGAxB,MAIAykF,gBAAA,WAEA,GAAA2L,EAEA,iBAAAlyF,GAEA0I,SAAAwpF,MAAA,GAAAzhD,GAEA,IAAA4gE,GAAAvvG,KAAAwE,SACAsyG,EAAA54G,EAAAsG,SAEA4yG,EAAA,EAAAhnB,EAAAmlB,oBAAAr3G,EAAA,GAAAiG,SACAkzG,EAAA,EAAAjnB,EAAAmlB,oBAAAr3G,EAAA,GAAAiG,SACAmzG,EAAA,EAAAlnB,EAAAmlB,oBAAAr3G,EAAA,GAAAiG,QAcA,OAZAorG,GAAA,GAAAuH,EAAA,GAAAM,EACA7H,EAAA,GAAAuH,EAAA,GAAAM,EACA7H,EAAA,GAAAuH,EAAA,GAAAM,EAEA7H,EAAA,GAAAuH,EAAA,GAAAO,EACA9H,EAAA,GAAAuH,EAAA,GAAAO,EACA9H,EAAA,GAAAuH,EAAA,GAAAO,EAEA9H,EAAA,GAAAuH,EAAA,GAAAQ,EACA/H,EAAA,GAAAuH,EAAA,GAAAQ,EACA/H,EAAA,IAAAuH,EAAA,IAAAQ,EAEAt3G,SAMAu3G,sBAAA,SAAA9G,IAEAA,KAAAC,YAAA,GAEAngF,QAAA5W,MAAA,uGAIA,IAAA41F,GAAAvvG,KAAAwE,SAEAlD,EAAAmvG,EAAAnvG,EAAAC,EAAAkvG,EAAAlvG,EAAAC,EAAAivG,EAAAjvG,EACA6d,EAAAve,KAAAs8B,IAAA97B,GAAAge,EAAAxe,KAAA+rF,IAAAvrF,GACAnD,EAAA2C,KAAAs8B,IAAA77B,GAAAysD,EAAAltD,KAAA+rF,IAAAtrF,GACAI,EAAAb,KAAAs8B,IAAA57B,GAAA09D,EAAAp+D,KAAA+rF,IAAArrF,EAEA,YAAAivG,EAAA50E,MAAA,CAEA,GAAA27E,GAAAn4F,EAAA1d,EAAA81G,EAAAp4F,EAAA6/C,EAAAw4C,EAAAp4F,EAAA3d,EAAAg2G,EAAAr4F,EAAA4/C,CAEAqwC,GAAA,GAAApxG,EAAAwD,EACA4tG,EAAA,IAAApxG,EAAA+gE,EACAqwC,EAAA,GAAAvhD,EAEAuhD,EAAA,GAAAkI,EAAAC,EAAA1pD,EACAuhD,EAAA,GAAAiI,EAAAG,EAAA3pD,EACAuhD,EAAA,IAAAjwF,EAAAnhB,EAEAoxG,EAAA,GAAAoI,EAAAH,EAAAxpD,EACAuhD,EAAA,GAAAmI,EAAAD,EAAAzpD,EACAuhD,EAAA,IAAAlwF,EAAAlhB,MAEI,YAAAsyG,EAAA50E,MAAA,CAEJ,GAAA+7E,GAAAz5G,EAAAwD,EAAAk2G,EAAA15G,EAAA+gE,EAAA44C,EAAA9pD,EAAArsD,EAAAo2G,EAAA/pD,EAAAkR,CAEAqwC,GAAA,GAAAqI,EAAAG,EAAAz4F,EACAiwF,EAAA,GAAAuI,EAAAx4F,EAAAu4F,EACAtI,EAAA,GAAAlwF,EAAA2uC,EAEAuhD,EAAA,GAAAlwF,EAAA6/C,EACAqwC,EAAA,GAAAlwF,EAAA1d,EACA4tG,EAAA,IAAAjwF,EAEAiwF,EAAA,GAAAsI,EAAAv4F,EAAAw4F,EACAvI,EAAA,GAAAwI,EAAAH,EAAAt4F,EACAiwF,EAAA,IAAAlwF,EAAAlhB,MAEI,YAAAsyG,EAAA50E,MAAA,CAEJ,GAAA+7E,GAAAz5G,EAAAwD,EAAAk2G,EAAA15G,EAAA+gE,EAAA44C,EAAA9pD,EAAArsD,EAAAo2G,EAAA/pD,EAAAkR,CAEAqwC,GAAA,GAAAqI,EAAAG,EAAAz4F,EACAiwF,EAAA,IAAAlwF,EAAA6/C,EACAqwC,EAAA,GAAAuI,EAAAD,EAAAv4F,EAEAiwF,EAAA,GAAAsI,EAAAC,EAAAx4F,EACAiwF,EAAA,GAAAlwF,EAAA1d,EACA4tG,EAAA,GAAAwI,EAAAH,EAAAt4F,EAEAiwF,EAAA,IAAAlwF,EAAA2uC,EACAuhD,EAAA,GAAAjwF,EACAiwF,EAAA,IAAAlwF,EAAAlhB,MAEI,YAAAsyG,EAAA50E,MAAA,CAEJ,GAAA27E,GAAAn4F,EAAA1d,EAAA81G,EAAAp4F,EAAA6/C,EAAAw4C,EAAAp4F,EAAA3d,EAAAg2G,EAAAr4F,EAAA4/C,CAEAqwC,GAAA,GAAApxG,EAAAwD,EACA4tG,EAAA,GAAAmI,EAAA1pD,EAAAypD,EACAlI,EAAA,GAAAiI,EAAAxpD,EAAA2pD,EAEApI,EAAA,GAAApxG,EAAA+gE,EACAqwC,EAAA,GAAAoI,EAAA3pD,EAAAwpD,EACAjI,EAAA,GAAAkI,EAAAzpD,EAAA0pD,EAEAnI,EAAA,IAAAvhD,EACAuhD,EAAA,GAAAjwF,EAAAnhB,EACAoxG,EAAA,IAAAlwF,EAAAlhB,MAEI,YAAAsyG,EAAA50E,MAAA,CAEJ,GAAAm8E,GAAA34F,EAAAlhB,EAAA85G,EAAA54F,EAAA2uC,EAAAkqD,EAAA54F,EAAAnhB,EAAAg6G,EAAA74F,EAAA0uC,CAEAuhD,GAAA,GAAApxG,EAAAwD,EACA4tG,EAAA,GAAA4I,EAAAH,EAAA94C,EACAqwC,EAAA,GAAA2I,EAAAh5C,EAAA+4C,EAEA1I,EAAA,GAAArwC,EACAqwC,EAAA,GAAAlwF,EAAA1d,EACA4tG,EAAA,IAAAjwF,EAAA3d,EAEA4tG,EAAA,IAAAvhD,EAAArsD,EACA4tG,EAAA,GAAA0I,EAAA/4C,EAAAg5C,EACA3I,EAAA,IAAAyI,EAAAG,EAAAj5C,MAEI,YAAAuxC,EAAA50E,MAAA,CAEJ,GAAAm8E,GAAA34F,EAAAlhB,EAAA85G,EAAA54F,EAAA2uC,EAAAkqD,EAAA54F,EAAAnhB,EAAAg6G,EAAA74F,EAAA0uC,CAEAuhD,GAAA,GAAApxG,EAAAwD,EACA4tG,EAAA,IAAArwC,EACAqwC,EAAA,GAAAvhD,EAAArsD,EAEA4tG,EAAA,GAAAyI,EAAA94C,EAAAi5C,EACA5I,EAAA,GAAAlwF,EAAA1d,EACA4tG,EAAA,GAAA0I,EAAA/4C,EAAAg5C,EAEA3I,EAAA,GAAA2I,EAAAh5C,EAAA+4C,EACA1I,EAAA,GAAAjwF,EAAA3d,EACA4tG,EAAA,IAAA4I,EAAAj5C,EAAA84C,EAeA,MAVAzI,GAAA,KACAA,EAAA,KACAA,EAAA,MAGAA,EAAA,MACAA,EAAA,MACAA,EAAA,MACAA,EAAA,MAEAvvG,MAIAo4G,2BAAA,SAAA/qB,GAEA,GAAAkiB,GAAAvvG,KAAAwE,SAEAlD,EAAA+rF,EAAA/rF,EAAAC,EAAA8rF,EAAA9rF,EAAAC,EAAA6rF,EAAA7rF,EAAA6B,EAAAgqF,EAAAhqF,EACAwnF,EAAAvpF,IAAA+2G,EAAA92G,IAAA+2G,EAAA92G,IACAyuG,EAAA3uG,EAAAupF,EAAAulB,EAAA9uG,EAAA+2G,EAAAhI,EAAA/uG,EAAAg3G,EACApI,EAAA3uG,EAAA82G,EAAA/H,EAAA/uG,EAAA+2G,EAAAnI,EAAA3uG,EAAA82G,EACAC,EAAAl1G,EAAAwnF,EAAA2tB,EAAAn1G,EAAAg1G,EAAAI,EAAAp1G,EAAAi1G,CAyBA,OAvBA/I,GAAA,MAAAW,EAAAC,GACAZ,EAAA,GAAAa,EAAAqI,EACAlJ,EAAA,GAAAc,EAAAmI,EAEAjJ,EAAA,GAAAa,EAAAqI,EACAlJ,EAAA,MAAAU,EAAAE,GACAZ,EAAA,GAAAe,EAAAiI,EAEAhJ,EAAA,GAAAc,EAAAmI,EACAjJ,EAAA,GAAAe,EAAAiI,EACAhJ,EAAA,OAAAU,EAAAC,GAGAX,EAAA,KACAA,EAAA,KACAA,EAAA,MAGAA,EAAA,MACAA,EAAA,MACAA,EAAA,MACAA,EAAA,MAEAvvG,MAIAyB,OAAA,WAEA,GAAAH,GAAAC,EAAAC,CAEA,iBAAAk3G,EAAAzgG,EAAA2uC,GAEAhgD,SAAAtF,IAEAA,EAAA,GAAAqtC,GACAptC,EAAA,GAAAotC,GACAntC,EAAA,GAAAmtC,GAIA,IAAA4gE,GAAAvvG,KAAAwE,QA0BA,OAxBAhD,GAAAusF,WAAA2qB,EAAAzgG,GAAA4iE,YAEA,IAAAr5E,EAAAusG,aAEAvsG,IAAA,GAIAF,EAAA2sF,aAAArnC,EAAAplD,GAAAq5E,YAEA,IAAAv5E,EAAAysG,aAEAvsG,KAAA,KACAF,EAAA2sF,aAAArnC,EAAAplD,GAAAq5E,aAIAt5E,EAAA0sF,aAAAzsF,EAAAF,GAGAiuG,EAAA,GAAAjuG,IAAkBiuG,EAAA,GAAAhuG,EAAAD,EAAeiuG,EAAA,GAAA/tG,EAAAF,EACjCiuG,EAAA,GAAAjuG,EAAAC,EAAkBguG,EAAA,GAAAhuG,IAAeguG,EAAA,GAAA/tG,EAAAD,EACjCguG,EAAA,GAAAjuG,EAAAE,EAAkB+tG,EAAA,GAAAhuG,EAAAC,EAAe+tG,EAAA,IAAA/tG,IAEjCxB,SAMAgnD,SAAA,SAAA9oD,EAAAyuB,GAEA,MAAA/lB,UAAA+lB,GAEA4D,QAAAC,KAAA,oGACAxwB,KAAAo8C,iBAAAl+C,EAAAyuB,IAIA3sB,KAAAo8C,iBAAAp8C,KAAA9B,IAIA2zG,YAAA,SAAA3zG,GAEA,MAAA8B,MAAAo8C,iBAAAl+C,EAAA8B,OAIAo8C,iBAAA,SAAA/8B,EAAAC,GAEA,GAAAk4F,GAAAn4F,EAAA7a,SACAkzG,EAAAp4F,EAAA9a,SACA+qG,EAAAvvG,KAAAwE,SAEAm0G,EAAAnB,EAAA,GAAAoB,EAAApB,EAAA,GAAAqB,EAAArB,EAAA,GAAAsB,EAAAtB,EAAA,IACAuB,EAAAvB,EAAA,GAAAwB,EAAAxB,EAAA,GAAAyB,EAAAzB,EAAA,GAAA0B,EAAA1B,EAAA,IACA2B,EAAA3B,EAAA,GAAA4B,EAAA5B,EAAA,GAAA6B,EAAA7B,EAAA,IAAA8B,EAAA9B,EAAA,IACA+B,EAAA/B,EAAA,GAAAgC,EAAAhC,EAAA,GAAAiC,EAAAjC,EAAA,IAAAkC,EAAAlC,EAAA,IAEAmC,EAAAjC,EAAA,GAAAkC,EAAAlC,EAAA,GAAAmC,EAAAnC,EAAA,GAAAoC,EAAApC,EAAA,IACAqC,EAAArC,EAAA,GAAAsC,EAAAtC,EAAA,GAAAuC,EAAAvC,EAAA,GAAAwC,EAAAxC,EAAA,IACAyC,EAAAzC,EAAA,GAAA0C,EAAA1C,EAAA,GAAA2C,EAAA3C,EAAA,IAAA4C,EAAA5C,EAAA,IACA6C,EAAA7C,EAAA,GAAA8C,EAAA9C,EAAA,GAAA+C,EAAA/C,EAAA,IAAAgD,EAAAhD,EAAA,GAsBA,OApBAnI,GAAA,GAAAoJ,EAAAgB,EAAAf,EAAAmB,EAAAlB,EAAAsB,EAAArB,EAAAyB,EACAhL,EAAA,GAAAoJ,EAAAiB,EAAAhB,EAAAoB,EAAAnB,EAAAuB,EAAAtB,EAAA0B,EACAjL,EAAA,GAAAoJ,EAAAkB,EAAAjB,EAAAqB,EAAApB,EAAAwB,EAAAvB,EAAA2B,EACAlL,EAAA,IAAAoJ,EAAAmB,EAAAlB,EAAAsB,EAAArB,EAAAyB,EAAAxB,EAAA4B,EAEAnL,EAAA,GAAAwJ,EAAAY,EAAAX,EAAAe,EAAAd,EAAAkB,EAAAjB,EAAAqB,EACAhL,EAAA,GAAAwJ,EAAAa,EAAAZ,EAAAgB,EAAAf,EAAAmB,EAAAlB,EAAAsB,EACAjL,EAAA,GAAAwJ,EAAAc,EAAAb,EAAAiB,EAAAhB,EAAAoB,EAAAnB,EAAAuB,EACAlL,EAAA,IAAAwJ,EAAAe,EAAAd,EAAAkB,EAAAjB,EAAAqB,EAAApB,EAAAwB,EAEAnL,EAAA,GAAA4J,EAAAQ,EAAAP,EAAAW,EAAAV,EAAAc,EAAAb,EAAAiB,EACAhL,EAAA,GAAA4J,EAAAS,EAAAR,EAAAY,EAAAX,EAAAe,EAAAd,EAAAkB,EACAjL,EAAA,IAAA4J,EAAAU,EAAAT,EAAAa,EAAAZ,EAAAgB,EAAAf,EAAAmB,EACAlL,EAAA,IAAA4J,EAAAW,EAAAV,EAAAc,EAAAb,EAAAiB,EAAAhB,EAAAoB,EAEAnL,EAAA,GAAAgK,EAAAI,EAAAH,EAAAO,EAAAN,EAAAU,EAAAT,EAAAa,EACAhL,EAAA,GAAAgK,EAAAK,EAAAJ,EAAAQ,EAAAP,EAAAW,EAAAV,EAAAc,EACAjL,EAAA,IAAAgK,EAAAM,EAAAL,EAAAS,EAAAR,EAAAY,EAAAX,EAAAe,EACAlL,EAAA,IAAAgK,EAAAO,EAAAN,EAAAU,EAAAT,EAAAa,EAAAZ,EAAAgB,EAEA16G,MAIA26G,gBAAA,SAAAt7F,EAAAC,EAAAkwB,GAEA,GAAA+/D,GAAAvvG,KAAAwE,QASA,OAPAxE,MAAAo8C,iBAAA/8B,EAAAC,GAEAkwB,EAAA,GAAA+/D,EAAA,GAAoB//D,EAAA,GAAA+/D,EAAA,GAAkB//D,EAAA,GAAA+/D,EAAA,GAAkB//D,EAAA,GAAA+/D,EAAA,GACxD//D,EAAA,GAAA+/D,EAAA,GAAoB//D,EAAA,GAAA+/D,EAAA,GAAkB//D,EAAA,GAAA+/D,EAAA,GAAkB//D,EAAA,GAAA+/D,EAAA,GACxD//D,EAAA,GAAA+/D,EAAA,GAAqB//D,EAAA,GAAA+/D,EAAA,GAAmB//D,EAAA,IAAA+/D,EAAA,IAAoB//D,EAAA,IAAA+/D,EAAA,IAC5D//D,EAAA,IAAA+/D,EAAA,IAAsB//D,EAAA,IAAA+/D,EAAA,IAAoB//D,EAAA,IAAA+/D,EAAA,IAAoB//D,EAAA,IAAA+/D,EAAA,IAE9DvvG,MAIA2wE,eAAA,SAAA/wE,GAEA,GAAA2vG,GAAAvvG,KAAAwE,QAOA,OALA+qG,GAAA,IAAA3vG,EAAgB2vG,EAAA,IAAA3vG,EAAc2vG,EAAA,IAAA3vG,EAAc2vG,EAAA,KAAA3vG,EAC5C2vG,EAAA,IAAA3vG,EAAgB2vG,EAAA,IAAA3vG,EAAc2vG,EAAA,IAAA3vG,EAAc2vG,EAAA,KAAA3vG,EAC5C2vG,EAAA,IAAA3vG,EAAgB2vG,EAAA,IAAA3vG,EAAc2vG,EAAA,KAAA3vG,EAAe2vG,EAAA,KAAA3vG,EAC7C2vG,EAAA,IAAA3vG,EAAgB2vG,EAAA,IAAA3vG,EAAc2vG,EAAA,KAAA3vG,EAAe2vG,EAAA,KAAA3vG,EAE7CI,MAIA46G,oBAAA,WAEA,GAAAxqB,EAEA,iBAAAhhD,EAAAzF,EAAAxlC,GAEAyC,SAAAwpF,MAAA,GAAAzhD,IACA/nC,SAAA+iC,MAAA,GACA/iC,SAAAzC,MAAAirC,EAAAjrC,OAEA,QAAAW,GAAA,EAAAmG,EAAA0+B,EAAgC7kC,EAAAX,EAAYW,GAAA,EAAAmG,GAAA,EAE5CmlF,EAAAjJ,UAAA/3C,EAAAnkC,GACAmlF,EAAAz3C,aAAA34C,MACAowF,EAAAn1E,QAAAm0B,EAAAnkC,EAIA,OAAAmkC,OAMAyrE,cAAA,WAEA,GAAAzqB,EAEA,iBAAAhzB,EAAAzzB,EAAAxlC,GAEAyC,SAAAwpF,MAAA,GAAAzhD,IACA/nC,SAAA+iC,MAAA,GACA/iC,SAAAzC,MAAAi5D,EAAAj5D,OAAAi5D,EAAA3S,SAEA,QAAA3lD,GAAA,EAAAmG,EAAA0+B,EAAgC7kC,EAAAX,EAAYW,IAAAmG,IAE5CmlF,EAAA9uF,EAAA87D,EAAAwrB,KAAA39E,GACAmlF,EAAA7uF,EAAA67D,EAAAyrB,KAAA59E,GACAmlF,EAAA5uF,EAAA47D,EAAA0rB,KAAA79E,GAEAmlF,EAAAz3C,aAAA34C,MAEAo9D,EAAAgxB,OAAAnjF,EAAAmlF,EAAA9uF,EAAA8uF,EAAA7uF,EAAA6uF,EAAA5uF,EAIA,OAAA47D,OAMA09C,YAAA,WAEA,GAAAvL,GAAAvvG,KAAAwE,SAEAqxG,EAAAtG,EAAA,GAAAuG,EAAAvG,EAAA,GAAAwG,EAAAxG,EAAA,GAAAyG,EAAAzG,EAAA,IACA0G,EAAA1G,EAAA,GAAA2G,EAAA3G,EAAA,GAAA4G,EAAA5G,EAAA,GAAA6G,EAAA7G,EAAA,IACA8G,EAAA9G,EAAA,GAAA+G,EAAA/G,EAAA,GAAAgH,EAAAhH,EAAA,IAAAiH,EAAAjH,EAAA,IACAkH,EAAAlH,EAAA,GAAAmH,EAAAnH,EAAA,GAAAoH,EAAApH,EAAA,IAAAqH,EAAArH,EAAA,GAKA,OACAkH,KACAT,EAAAG,EAAAG,EACAP,EAAAK,EAAAE,EACAN,EAAAE,EAAAK,EACAT,EAAAM,EAAAG,EACAR,EAAAG,EAAAM,EACAV,EAAAK,EAAAK,GAEAE,IACAb,EAAAM,EAAAK,EACAX,EAAAO,EAAAG,EACAP,EAAAC,EAAAM,EACAR,EAAAE,EAAAO,EACAT,EAAAK,EAAAC,EACAL,EAAAG,EAAAE,GAEAM,IACAd,EAAAO,EAAAE,EACAT,EAAAK,EAAAM,EACAR,EAAAC,EAAAK,EACAR,EAAAG,EAAAO,EACAR,EAAAE,EAAAG,EACAP,EAAAM,EAAAC,GAEAO,IACAb,EAAAG,EAAAG,EACAR,EAAAM,EAAAG,EACAT,EAAAK,EAAAK,EACAR,EAAAE,EAAAK,EACAR,EAAAG,EAAAM,EACAT,EAAAK,EAAAE,IAOA0E,UAAA,WAEA,GACAjwG,GADAykG,EAAAvvG,KAAAwE,QAWA,OARAsG,GAAAykG,EAAA,GAAiBA,EAAA,GAAAA,EAAA,GAAmBA,EAAA,GAAAzkG,EACpCA,EAAAykG,EAAA,GAAiBA,EAAA,GAAAA,EAAA,GAAmBA,EAAA,GAAAzkG,EACpCA,EAAAykG,EAAA,GAAiBA,EAAA,GAAAA,EAAA,GAAmBA,EAAA,GAAAzkG,EAEpCA,EAAAykG,EAAA,GAAiBA,EAAA,GAAAA,EAAA,IAAoBA,EAAA,IAAAzkG,EACrCA,EAAAykG,EAAA,GAAiBA,EAAA,GAAAA,EAAA,IAAoBA,EAAA,IAAAzkG,EACrCA,EAAAykG,EAAA,IAAkBA,EAAA,IAAAA,EAAA,IAAqBA,EAAA,IAAAzkG,EAEvC9K,MAIAg7G,qBAAA,SAAA5rE,EAAAzF,GAKA,MAHApZ,SAAAC,KAAA,mFAGAxwB,KAAAib,QAAAm0B,EAAAzF,IAIAsxE,YAAA,WAEA,GAAA7qB,EAEA,mBAKA,MAHAxpF,UAAAwpF,MAAA,GAAAzhD,IACApe,QAAAC,KAAA,wGAEA4/D,EAAAmlB,oBAAAv1G,KAAA,OAMA26E,YAAA,SAAA30E,GAEA,GAAAupG,GAAAvvG,KAAAwE,QAMA,OAJA+qG,GAAA,IAAAvpG,EAAA1E,EACAiuG,EAAA,IAAAvpG,EAAAzE,EACAguG,EAAA,IAAAvpG,EAAAxE,EAEAxB,MAIA+mD,WAAA,SAAA7oD,EAAAg9G,GAGA,GAAA3L,GAAAvvG,KAAAwE,SACAsyG,EAAA54G,EAAAsG,SAEAqxG,EAAAiB,EAAA,GAAAb,EAAAa,EAAA,GAAAT,EAAAS,EAAA,GAAAL,EAAAK,EAAA,GACAhB,EAAAgB,EAAA,GAAAZ,EAAAY,EAAA,GAAAR,EAAAQ,EAAA,GAAAJ,EAAAI,EAAA,GACAf,EAAAe,EAAA,GAAAX,EAAAW,EAAA,GAAAP,EAAAO,EAAA,IAAAH,EAAAG,EAAA,IACAd,EAAAc,EAAA,IAAAV,EAAAU,EAAA,IAAAN,EAAAM,EAAA,IAAAF,EAAAE,EAAA,IAEAqE,EAAAhF,EAAAK,EAAAE,EAAAN,EAAAG,EAAAG,EAAAN,EAAAE,EAAAK,EAAAT,EAAAM,EAAAG,EAAAR,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,EACAwE,EAAApF,EAAAO,EAAAG,EAAAX,EAAAS,EAAAE,EAAAV,EAAAM,EAAAK,EAAAb,EAAAU,EAAAG,EAAAZ,EAAAO,EAAAM,EAAAd,EAAAS,EAAAK,EACAyE,EAAAtF,EAAAK,EAAAM,EAAAV,EAAAG,EAAAO,EAAAV,EAAAE,EAAAS,EAAAb,EAAAM,EAAAO,EAAAZ,EAAAG,EAAAU,EAAAd,EAAAK,EAAAS,EACA0E,EAAAtF,EAAAG,EAAAG,EAAAP,EAAAK,EAAAE,EAAAN,EAAAE,EAAAK,EAAAT,EAAAM,EAAAG,EAAAR,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,EAEA+E,EAAA1F,EAAAsF,EAAAlF,EAAAmF,EAAA/E,EAAAgF,EAAA5E,EAAA6E,CAEA,QAAAC,EAAA,CAEA,GAAAz/F,GAAA,mEAEA,IAAAo/F,KAAA,EAEA,SAAA53G,OAAAwY,EAQA,OAJAyU,SAAAC,KAAA1U,GAIA9b,KAAA06E,WAIA,GAAA8gC,GAAA,EAAAD,CAsBA,OApBAhM,GAAA,GAAA4L,EAAAK,EACAjM,EAAA,IAAA6G,EAAAG,EAAAE,EAAAN,EAAAK,EAAAC,EAAAL,EAAAC,EAAAM,EAAAV,EAAAO,EAAAG,EAAAR,EAAAE,EAAAO,EAAAX,EAAAM,EAAAK,GAAA4E,EACAjM,EAAA,IAAA2G,EAAAM,EAAAC,EAAAL,EAAAE,EAAAG,EAAAL,EAAAC,EAAAK,EAAAT,EAAAO,EAAAE,EAAAR,EAAAG,EAAAO,EAAAX,EAAAK,EAAAM,GAAA4E,EACAjM,EAAA,IAAA4G,EAAAG,EAAAG,EAAAP,EAAAK,EAAAE,EAAAN,EAAAE,EAAAK,EAAAT,EAAAM,EAAAG,EAAAR,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,GAAA6E,EAEAjM,EAAA,GAAA6L,EAAAI,EACAjM,EAAA,IAAAwG,EAAAS,EAAAC,EAAAT,EAAAO,EAAAE,EAAAT,EAAAK,EAAAM,EAAAd,EAAAW,EAAAG,EAAAZ,EAAAM,EAAAO,EAAAf,EAAAU,EAAAK,GAAA4E,EACAjM,EAAA,IAAAyG,EAAAM,EAAAG,EAAAX,EAAAU,EAAAC,EAAAT,EAAAK,EAAAK,EAAAb,EAAAW,EAAAE,EAAAZ,EAAAO,EAAAO,EAAAf,EAAAS,EAAAM,GAAA4E,EACAjM,EAAA,IAAAuG,EAAAS,EAAAE,EAAAV,EAAAO,EAAAG,EAAAV,EAAAM,EAAAK,EAAAb,EAAAU,EAAAG,EAAAZ,EAAAO,EAAAM,EAAAd,EAAAS,EAAAK,GAAA6E,EAEAjM,EAAA,GAAA8L,EAAAG,EACAjM,EAAA,IAAAyG,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,EAAAT,EAAAC,EAAAU,EAAAd,EAAAO,EAAAO,EAAAZ,EAAAE,EAAAW,EAAAf,EAAAM,EAAAS,GAAA4E,EACAjM,EAAA,KAAAuG,EAAAM,EAAAK,EAAAT,EAAAE,EAAAO,EAAAT,EAAAC,EAAAS,EAAAb,EAAAO,EAAAM,EAAAZ,EAAAG,EAAAW,EAAAf,EAAAK,EAAAU,GAAA4E,EACAjM,EAAA,KAAAwG,EAAAG,EAAAO,EAAAX,EAAAK,EAAAM,EAAAV,EAAAE,EAAAS,EAAAb,EAAAM,EAAAO,EAAAZ,EAAAG,EAAAU,EAAAd,EAAAK,EAAAS,GAAA6E,EAEAjM,EAAA,IAAA+L,EAAAE,EACAjM,EAAA,KAAAwG,EAAAK,EAAAC,EAAAL,EAAAG,EAAAE,EAAAL,EAAAC,EAAAM,EAAAV,EAAAO,EAAAG,EAAAR,EAAAE,EAAAO,EAAAX,EAAAM,EAAAK,GAAAgF,EACAjM,EAAA,KAAAyG,EAAAE,EAAAG,EAAAP,EAAAM,EAAAC,EAAAL,EAAAC,EAAAK,EAAAT,EAAAO,EAAAE,EAAAR,EAAAG,EAAAO,EAAAX,EAAAK,EAAAM,GAAAgF,EACAjM,EAAA,KAAAuG,EAAAK,EAAAE,EAAAN,EAAAG,EAAAG,EAAAN,EAAAE,EAAAK,EAAAT,EAAAM,EAAAG,EAAAR,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,GAAAiF,EAEAx7G,MAIAqI,MAAA,SAAArC,GAEA,GAAAupG,GAAAvvG,KAAAwE,SACAlD,EAAA0E,EAAA1E,EAAAC,EAAAyE,EAAAzE,EAAAC,EAAAwE,EAAAxE,CAOA,OALA+tG,GAAA,IAAAjuG,EAAgBiuG,EAAA,IAAAhuG,EAAcguG,EAAA,IAAA/tG,EAC9B+tG,EAAA,IAAAjuG,EAAgBiuG,EAAA,IAAAhuG,EAAcguG,EAAA,IAAA/tG,EAC9B+tG,EAAA,IAAAjuG,EAAgBiuG,EAAA,IAAAhuG,EAAcguG,EAAA,KAAA/tG,EAC9B+tG,EAAA,IAAAjuG,EAAgBiuG,EAAA,IAAAhuG,EAAcguG,EAAA,KAAA/tG,EAE9BxB,MAIAy7G,kBAAA,WAEA,GAAAlM,GAAAvvG,KAAAwE,SAEAk3G,EAAAnM,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAoM,EAAApM,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAqM,EAAArM,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,GAEA,OAAAzuG,MAAAolF,KAAAplF,KAAAoQ,IAAAwqG,EAAAC,EAAAC,KAIAC,gBAAA,SAAAv6G,EAAAC,EAAAC,GAWA,MATAxB,MAAAiC,IAEA,MAAAX,EACA,MAAAC,EACA,MAAAC,EACA,SAIAxB,MAIA87G,cAAA,SAAAhpB,GAEA,GAAA30F,GAAA2C,KAAAs8B,IAAA01D,GAAAlzF,EAAAkB,KAAA+rF,IAAAiG,EAWA,OATA9yF,MAAAiC,IAEA,QACA,EAAA9D,GAAAyB,EAAA,EACA,EAAAA,EAAAzB,EAAA,EACA,SAIA6B,MAIA+7G,cAAA,SAAAjpB,GAEA,GAAA30F,GAAA2C,KAAAs8B,IAAA01D,GAAAlzF,EAAAkB,KAAA+rF,IAAAiG,EAWA,OATA9yF,MAAAiC,IAEA9D,EAAA,EAAAyB,EAAA,EACA,SACAA,EAAA,EAAAzB,EAAA,EACA,SAIA6B,MAIAg8G,cAAA,SAAAlpB,GAEA,GAAA30F,GAAA2C,KAAAs8B,IAAA01D,GAAAlzF,EAAAkB,KAAA+rF,IAAAiG,EAWA,OATA9yF,MAAAiC,IAEA9D,GAAAyB,EAAA,IACAA,EAAAzB,EAAA,IACA,QACA,SAIA6B,MAIAi8G,iBAAA,SAAA/K,EAAA32B,GAIA,GAAAp8E,GAAA2C,KAAAs8B,IAAAm9C,GACA36E,EAAAkB,KAAA+rF,IAAAtS,GACA5mD,EAAA,EAAAx1B,EACAmD,EAAA4vG,EAAA5vG,EAAAC,EAAA2vG,EAAA3vG,EAAAC,EAAA0vG,EAAA1vG,EACA06G,EAAAvoF,EAAAryB,EAAA66G,EAAAxoF,EAAApyB,CAWA,OATAvB,MAAAiC,IAEAi6G,EAAA56G,EAAAnD,EAAA+9G,EAAA36G,EAAA3B,EAAA4B,EAAA06G,EAAA16G,EAAA5B,EAAA2B,EAAA,EACA26G,EAAA36G,EAAA3B,EAAA4B,EAAA26G,EAAA56G,EAAApD,EAAAg+G,EAAA36G,EAAA5B,EAAA0B,EAAA,EACA46G,EAAA16G,EAAA5B,EAAA2B,EAAA46G,EAAA36G,EAAA5B,EAAA0B,EAAAqyB,EAAAnyB,IAAArD,EAAA,EACA,SAIA6B,MAIAo8G,UAAA,SAAA96G,EAAAC,EAAAC,GAWA,MATAxB,MAAAiC,IAEAX,EAAA,MACA,EAAAC,EAAA,IACA,IAAAC,EAAA,EACA,SAIAxB,MAIAq8G,QAAA,SAAAh9G,EAAAipD,EAAAjgD,GAMA,MAJArI,MAAAo4G,2BAAA9vD,GACAtoD,KAAAqI,SACArI,KAAA26E,YAAAt7E,GAEAW,MAIAs8C,UAAA,WAEA,GAAA2S,GAAA1I,CAEA,iBAAAlnD,EAAAipD,EAAAjgD,GAEAzB,SAAAqoD,IAEAA,EAAA,GAAAtgB,GACA4X,EAAA,GAAA3X,GAIA,IAAA2gE,GAAAvvG,KAAAwE,SAEAixG,EAAAxmD,EAAAhtD,IAAAstG,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAprG,SACAuxG,EAAAzmD,EAAAhtD,IAAAstG,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAprG,SACAwxG,EAAA1mD,EAAAhtD,IAAAstG,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAAAprG,SAGAo3G,EAAAv7G,KAAA86G,aACAS,GAAA,IAEA9F,MAIAp2G,EAAAiC,EAAAiuG,EAAA,IACAlwG,EAAAkC,EAAAguG,EAAA,IACAlwG,EAAAmC,EAAA+tG,EAAA,IAIAhpD,EAAA/hD,SAAAvC,IAAAjC,KAAAwE,SAEA,IAAA83G,GAAA,EAAA7G,EACA8G,EAAA,EAAA7G,EACA8G,EAAA,EAAA7G,CAoBA,OAlBApvD,GAAA/hD,SAAA,IAAA83G,EACA/1D,EAAA/hD,SAAA,IAAA83G,EACA/1D,EAAA/hD,SAAA,IAAA83G,EAEA/1D,EAAA/hD,SAAA,IAAA+3G,EACAh2D,EAAA/hD,SAAA,IAAA+3G,EACAh2D,EAAA/hD,SAAA,IAAA+3G,EAEAh2D,EAAA/hD,SAAA,IAAAg4G,EACAj2D,EAAA/hD,SAAA,IAAAg4G,EACAj2D,EAAA/hD,SAAA,KAAAg4G,EAEAl0D,EAAA8oD,sBAAA7qD,GAEAl+C,EAAA/G,EAAAm0G,EACAptG,EAAA9G,EAAAm0G,EACArtG,EAAA7G,EAAAm0G,EAEA31G,SAMAy8G,YAAA,SAAAn9G,EAAAoxD,EAAAC,EAAApxD,EAAAy8C,EAAAC,GAEA,GAAAszD,GAAAvvG,KAAAwE,SACAlD,EAAA,EAAA06C,GAAA0U,EAAApxD,GACAiC,EAAA,EAAAy6C,GAAAz8C,EAAAoxD,GAEAtxC,GAAAqxC,EAAApxD,IAAAoxD,EAAApxD,GACAggB,GAAA/f,EAAAoxD,IAAApxD,EAAAoxD,GACAxyD,IAAA89C,EAAAD,IAAAC,EAAAD,GACAgS,GAAA,EAAA/R,EAAAD,GAAAC,EAAAD,EAOA,OALAuzD,GAAA,GAAAjuG,EAAeiuG,EAAA,KAAaA,EAAA,GAAAlwF,EAAakwF,EAAA,MACzCA,EAAA,KAAeA,EAAA,GAAAhuG,EAAaguG,EAAA,GAAAjwF,EAAaiwF,EAAA,MACzCA,EAAA,KAAeA,EAAA,KAAaA,EAAA,IAAApxG,EAAcoxG,EAAA,IAAAvhD,EAC1CuhD,EAAA,KAAeA,EAAA,KAAaA,EAAA,OAAgBA,EAAA,MAE5CvvG,MAIA08G,gBAAA,SAAApsD,EAAAvtD,EAAAi5C,EAAAC,GAEA,GAAA0gE,GAAA3gE,EAAAl7C,KAAA87G,IAAApwE,GAAAwlD,QAAA1hC,EAAA,IACAusD,GAAAF,EACAG,EAAAD,EAAA95G,EACAg6G,EAAAJ,EAAA55G,CAEA,OAAA/C,MAAAy8G,YAAAK,EAAAC,EAAAF,EAAAF,EAAA3gE,EAAAC,IAIA+gE,iBAAA,SAAA19G,EAAAoxD,EAAAnxD,EAAAoxD,EAAA3U,EAAAC,GAEA,GAAAszD,GAAAvvG,KAAAwE,SACAnB,EAAA,GAAAqtD,EAAApxD,GACAyuD,EAAA,GAAAxuD,EAAAoxD,GACAvyD,EAAA,GAAA69C,EAAAD,GAEA16C,GAAAovD,EAAApxD,GAAA+D,EACA9B,GAAAhC,EAAAoxD,GAAA5C,EACAvsD,GAAAy6C,EAAAD,GAAA59C,CAOA,OALAmxG,GAAA,KAAAlsG,EAAmBksG,EAAA,KAAaA,EAAA,KAAaA,EAAA,KAAAjuG,EAC7CiuG,EAAA,KAAeA,EAAA,KAAAxhD,EAAiBwhD,EAAA,KAAaA,EAAA,KAAAhuG,EAC7CguG,EAAA,KAAeA,EAAA,KAAaA,EAAA,OAAAnxG,EAAoBmxG,EAAA,KAAA/tG,EAChD+tG,EAAA,KAAeA,EAAA,KAAaA,EAAA,MAAcA,EAAA,MAE1CvvG,MAIAslE,OAAA,SAAA/e,GAKA,OAHAgpD,GAAAvvG,KAAAwE,SACAsyG,EAAAvwD,EAAA/hD,SAEAM,EAAA,EAAmBA,EAAA,GAAQA,IAE3B,GAAAyqG,EAAAzqG,KAAAgyG,EAAAhyG,GAAA,QAIA,WAIAqiF,UAAA,SAAA/3C,EAAAzF,GAEA/iC,SAAA+iC,MAAA,EAEA,QAAA7kC,GAAA,EAAkBA,EAAA,GAAQA,IAE1B9E,KAAAwE,SAAAM,GAAAsqC,EAAAtqC,EAAA6kC,EAIA,OAAA3pC,OAIAib,QAAA,SAAAm0B,EAAAzF,GAEA/iC,SAAAwoC,UACAxoC,SAAA+iC,MAAA,EAEA,IAAA4lE,GAAAvvG,KAAAwE,QAsBA,OApBA4qC,GAAAzF,GAAA4lE,EAAA,GACAngE,EAAAzF,EAAA,GAAA4lE,EAAA,GACAngE,EAAAzF,EAAA,GAAA4lE,EAAA,GACAngE,EAAAzF,EAAA,GAAA4lE,EAAA,GAEAngE,EAAAzF,EAAA,GAAA4lE,EAAA,GACAngE,EAAAzF,EAAA,GAAA4lE,EAAA,GACAngE,EAAAzF,EAAA,GAAA4lE,EAAA,GACAngE,EAAAzF,EAAA,GAAA4lE,EAAA,GAEAngE,EAAAzF,EAAA,GAAA4lE,EAAA,GACAngE,EAAAzF,EAAA,GAAA4lE,EAAA,GACAngE,EAAAzF,EAAA,IAAA4lE,EAAA,IACAngE,EAAAzF,EAAA,IAAA4lE,EAAA,IAEAngE,EAAAzF,EAAA,IAAA4lE,EAAA,IACAngE,EAAAzF,EAAA,IAAA4lE,EAAA,IACAngE,EAAAzF,EAAA,IAAA4lE,EAAA,IACAngE,EAAAzF,EAAA,IAAA4lE,EAAA,IAEAngE,IAqBAN,EAAAjvC,UAAAma,OAAAu2F,OAAA1kE,EAAAhsC,WACAivC,EAAAjvC,UAAAmb,YAAA8zB,EAEAA,EAAAjvC,UAAA24E,eAAA,EAEAx+D,OAAAwX,eAAAsd,EAAAjvC,UAAA,UAEAgK,IAAA,WAEA,MAAA7J,MAAA0rB,OAIAzpB,IAAA,SAAAmE,GAEApG,KAAA0rB,MAAAtlB,IAuDA,IAAAkrC,IAAA,GAAAzF,GACA4F,GAAA,GAAA3C,GAeAW,MACAE,KA8SAyD,GAAAvzC,UAAAqzC,SAAA,SAAAnD,EAAA3pC,GAOA,OAFA8oC,GAAAlvC,KAAAkvC,IAEApqC,EAAA,EAAA6nB,EAAAuiB,EAAA/qC,OAAkCW,IAAA6nB,IAAS7nB,EAAA,CAE3C,GAAAqpD,GAAAjf,EAAApqC,EACAqpD,GAAAjb,SAAAnD,EAAA3pC,EAAA+nD,EAAApwD,MAUA,IAAA21C,IAAA,0BA0FAK,GAAAl0C,UAAAqzC,SAAA,SAAAnD,EAAAroC,EAAAtB,GAEA,GAAA+nD,GAAAnuD,KAAAsP,IAAA5H,EAEAd,UAAAunD,KAAAjb,SAAAnD,EAAA3pC,EAAApG,KAAAG,WAIA4zC,EAAAl0C,UAAAoC,IAAA,SAAA8tC,EAAAtqC,EAAAiC,GAEA,GAAAymD,GAAAnuD,KAAAsP,IAAA5H,EAEAd,UAAAunD,KAAAjb,SAAAnD,EAAAtqC,EAAAiC,GAAA1H,KAAAG,WAIA4zC,EAAAl0C,UAAAm3E,YAAA,SAAAjnC,EAAAtqC,EAAAiC,GAEA,GAAA1B,GAAAP,EAAAiC,EAEAd,UAAAZ,GAAAhG,KAAAkzC,SAAAnD,EAAAroC,EAAA1B,IAOA+tC,EAAAkkC,OAAA,SAAAloC,EAAAb,EAAAxlC,EAAAvJ,GAEA,OAAA2E,GAAA,EAAA6nB,EAAAuiB,EAAA/qC,OAAkCW,IAAA6nB,IAAS7nB,EAAA,CAE3C,GAAAqpD,GAAAjf,EAAApqC,GACAkB,EAAA0D,EAAAykD,EAAApwD,GAEAiI,GAAAs1C,eAAA,GAGA6S,EAAAjb,SAAAnD,EAAA/pC,EAAAI,MAAAjG,KAQA4zC,EAAAiiC,aAAA,SAAA9mC,EAAAxlC,GAIA,OAFA8lC,MAEA1qC,EAAA,EAAA6nB,EAAAuiB,EAAA/qC,OAAkCW,IAAA6nB,IAAS7nB,EAAA,CAE3C,GAAAqpD,GAAAjf,EAAApqC,EACAqpD,GAAApwD,KAAA2L,IAAA8lC,EAAAzjC,KAAAoiD,GAIA,MAAA3e,GAQA,IAAA4V,KAEA/6C,MAAA,SAAAwsC,GAIA,OAFAomE,MAEA9uD,EAAA,EAAmBA,EAAAtX,EAAA1yC,OAAqBgqD,IAAA,CAExC,GAAArjD,GAAA9K,KAAAuP,MAAAsnC,EAAAsX,GAEA,QAAA/vD,KAAA0M,GAEAmyG,EAAA7+G,GAAA0M,EAAA1M,GAMA,MAAA6+G,IAIA1tG,MAAA,SAAA2tG,GAEA,GAAAC,KAEA,QAAAhvD,KAAA+uD,GAAA,CAEAC,EAAAhvD,KAEA,QAAA/vD,KAAA8+G,GAAA/uD,GAAA,CAEA,GAAAivD,GAAAF,EAAA/uD,GAAA/vD,EAEAg/G,OAAAxzD,SACAwzD,EAAAC,WAAAD,EAAAxH,WACAwH,EAAApQ,WAAAoQ,EAAA1zD,WAAA0zD,EAAArO,WACAqO,EAAAhjD,WAEA+iD,EAAAhvD,GAAA/vD,GAAAg/G,EAAA7tG,QAEMyM,MAAAnH,QAAAuoG,GAEND,EAAAhvD,GAAA/vD,GAAAg/G,EAAAvsG,QAIAssG,EAAAhvD,GAAA/vD,GAAAg/G,GAQA,MAAAD,KAMAG,GAAA,mFAEAC,GAAA,+DAEAC,GAAA,2EAEAC,GAAA,6aAEAC,GAAA,wFAEAC,GAAA,2CAEAC,GAAA,0CAEAC,GAAA,89HAEAC,GAAA,yzBAEAC,GAAA,ghBAEAC,GAAA,6LAEAC,GAAA,sHAEAC,GAAA,4HAEAC,GAAA,0DAEAC,GAAA,qDAEAC,GAAA,mDAEAC,GAAA,sDAEAC,GAAA,myDAEAC,GAAA,2lIAEAC,GAAA,sHAEAC,GAAA,oJAEAC,GAAA,iJAEAC,GAAA,+MAEAC,GAAA,qEAEAC,GAAA,0DAEAC,GAAA,0vFAEAC,GAAA,inDAEAC,GAAA,mnBAEAC,GAAA,iOAEAC,GAAA,ugBAEAC,GAAA,gcAEAC,GAAA,+KAEAC,GAAA,+HAEAC,GAAA,iGAEAC,GAAA,6oEAEAC,GAAA,wjOAEAC,GAAA,wMAEAC,GAAA,2xCAEAC,GAAA,8iBAEAC,GAAA,mwGAEAC,GAAA,kqGAEAC,GAAA,oIAEAC,GAAA,0IAEAC,GAAA,wIAEAC,GAAA,qQAEAC,GAAA,sJAEAC,GAAA,qDAEAC,GAAA,qMAEAC,GAAA,mFAEAC,GAAA,yKAEAC,GAAA,qEAEAC,GAAA,gVAEAC,GAAA,2KAEAC,GAAA,0qBAEAC,GAAA,iIAEAC,GAAA,ugBAEAC,GAAA,gmBAEAC,GAAA,qyCAEAC,GAAA,8EAEAC,GAAA,sMAEAC,GAAA,yKAEAC,GAAA,qEAEAC,GAAA,sgNAEAC,GAAA,0eAEAC,GAAA,ihBAEAC,GAAA,8oCAEAC,GAAA,kOAEAC,GAAA,sjCAEAC,GAAA,sXAEAC,GAAA,8WAEAC,GAAA,0LAEAC,GAAA,mEAEAC,GAAA,+FAEAC,GAAA,o5BAEAC,GAAA,iQAEAC,GAAA,iSAEAC,GAAA,6RAEAC,GAAA,oFAEAC,GAAA,2GAEAC,GAAA,6EAEAC,GAAA,iSAEAC,GAAA,2QAEAC,GAAA,+LAEAC,GAAA,ivBAEAC,GAAA,ohBAEAC,GAAA,+RAEAC,GAAA,8aAEAC,GAAA,wXAEAC,GAAA,+LAEAC,GAAA,qyBAEAC,GAAA,6dAEAC,GAAA,80CAEAC,GAAA,kzBAEAC,GAAA,wiEAEAC,GAAA,ugCAEAC,GAAA,+yDAEAC,GAAA,knCAEAC,GAAA,koEAEAC,GAAA,gmCAEAC,GAAA,oUAEAC,GAAA,+XAEAC,GAAA,8yBAEAC,GAAA,ujBAEAC,GAAA,sRAEAC,GAAA,4KAEA9uD;AACAsoD,qBACAC,0BACAC,sBACAC,kBACAC,uBACAC,gBACAC,sBACAC,SACAC,yBACAC,4BACAC,iCACAC,+BACAC,0BACAC,kBACAC,uBACAC,qBACAC,gBACAC,UACAC,+BACAC,wBACAC,+BACAC,0BACAC,wBACAC,6BACAC,sBACAC,2BACAC,mBACAC,wBACAC,sBACAC,iBACAC,gBACAC,qBACAC,qBACAC,0BACAC,yBACAC,eACAC,yBACAC,8BACAC,4BACAC,iCACAC,mBACAC,wBACAC,6BACAC,2BACAC,sBACAC,gBACAC,qBACAC,yBACAC,8BACAC,yBACAC,8BACAC,sBACAC,2BACAC,sBACAC,eACAC,mBACAC,2BACAC,WACAC,gCACAC,kBACAC,yBACAC,8BACAC,2BACAC,yBACAC,oBACAC,4BACAC,mBACAC,wBACAC,mBACAC,qBACAC,wBACAC,6BACAC,wBACAC,6BACAC,oBACAC,kBACAC,aACAC,qBACAC,mBACAC,cACAC,mBAEAC,aACAC,aACAC,cACAC,cACAC,qBACAC,qBACAC,iBACAC,iBACAC,mBACAC,mBACAC,kBACAC,kBACAC,oBACAC,oBACAC,kBACAC,kBACAC,qBACAC,qBACAC,eACAC,eACAC,eACAC,eACAC,eACAC,eAoBAvjH,GAAAV,WAEAmb,YAAAza,EAEAqpD,SAAA,EAEApa,EAAA,EAAAiB,EAAA,EAAAnxB,EAAA,EAEArd,IAAA,SAAAmE,GAgBA,MAdAA,MAAAwjD,QAEA5pD,KAAAyb,KAAArV,GAEI,gBAAAA,GAEJpG,KAAA+jH,OAAA39G,GAEI,gBAAAA,IAEJpG,KAAAgkH,SAAA59G,GAIApG,MAIAitG,UAAA,SAAAC,GAMA,MAJAltG,MAAAwvC,EAAA09D,EACAltG,KAAAywC,EAAAy8D,EACAltG,KAAAsf,EAAA4tF,EAEAltG,MAIA+jH,OAAA,SAAAle,GAQA,MANAA,G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AA++E,2BACA/+E,EAAAihF,eACAjhF,EAAAkhF,eACAlhF,EAAAi/E,cACAj/E,EAAAk/E,aACAl/E,EAAAm/E,kBACAn/E,EAAAo/E,0BACAp/E,EAAAw/C,kBACAx/C,EAAAy/C,0BACAz/C,EAAAq/E,kBACAr/E,EAAAu/E,0BACAv/E,EAAAy/E,kBACAz/E,EAAA2/E,0BACA3/E,EAAA6/E,0BACA7/E,EAAAioE,cACAjoE,EAAAmoE,eACAnoE,EAAAqoE,aACAroE,EAAA+/C,kBACA//C,EAAAwoE,cACAxoE,EAAA0oE,qBACA1oE,EAAA4oE,gBACA5oE,EAAA8oE,iBACA9oE,EAAAssD,qBACAtsD,EAAAq4D,gBACAr4D,EAAAs4D,gBACAt4D,EAAA85D,iBACA95D,EAAA01D,qBACA11D,EAAA21D,uBACA31D,EAAA41D,yBACA51D,EAAA61D,qBACA71D,EAAAgtG,aACAhtG,EAAAmxC,yBACAnxC,EAAA+3D,yBACA/3D,EAAAk4D,oCACAl4D,EAAAm4D,oCACAn4D,EAAAo4D,8BACAp4D,EAAAg4D,2BACAh4D,EAAAi4D,2BACAj4D,EAAAitG,kBACAjtG,EAAAk9E,kBACAl9E,EAAAivC,uBACAjvC,EAAAo9E,0BACAp9E,EAAAktG,mBACAltG,EAAAuoD,iBACAvoD,EAAAshE,8BACAthE,EAAAuhE,6BACAvhE,EAAAkvC,gBACAlvC,EAAAw9E,6BACAx9E,EAAAmvC,4BACAnvC,EAAAmtG,iBACAntG,EAAAqvC,oBACArvC,EAAAi+E,YACAj+E,EAAAk+E,aACAl+E,EAAAm+E,qBACAn+E,EAAAo+E,WACAp+E,EAAAq+E,mBACAr+E,EAAAmkE,aACAnkE,EAAAokE,iBACApkE,EAAA29E,yBACA39E,EAAA69E,yBACA79E,EAAA+9E,wBACA/9E,EAAAqhF,sBACArhF,EAAAu+E,eACAv+E,EAAA4jE,aACA5jE,EAAAovC,cACApvC,EAAAy+E,mBACAz+E,EAAA2+E,wBACA3+E,EAAAotG,cACAptG,EAAAsmE,eACAtmE,EAAAilE,sBACAjlE,EAAA+/E,wBACA//E,EAAAggF,yBACA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","file":"index.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cats = __webpack_require__(1);\n\t\n\t// console.log(cats);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function($) {window.THREE = __webpack_require__(3);\n\tvar Stats = __webpack_require__(4);\n\tvar dat = __webpack_require__(5);\n\t\n\t__webpack_require__(8);\n\t__webpack_require__(9);\n\t\n\t(function () {\n\t\n\t  var sample = window.sample || {};\n\t  window.sample = sample;\n\t\n\t  //\n\t  $(function () {\n\t    new sample.MainDisplay();\n\t  });\n\t})();\n\t\n\t//Cube\n\tvar CubeObject = new Cube();\n\t\n\t//Plane\n\tvar PlaneObject = new Plane();\n\t\n\t(function () {\n\t  var sample = window.sample || {};\n\t  window.sample = sample;\n\t\n\t  /**\n\t   * \n\t   */\n\t  sample.MainDisplay = function () {\n\t    //\n\t    p.init();\n\t  };\n\t\n\t  var p, s;\n\t\n\t  s = sample.MainDisplay;\n\t  p = s.prototype;\n\t\n\t  var renderScene;\n\t\n\t  /**\n\t   * \n\t   */\n\t  p.init = function () {\n\t    var self = this;\n\t\n\t    this.$window = $(window);\n\t    this.$MainDisplay = $('#WebGL-output');\n\t\n\t    //WebGL renderer\n\t    this.renderer = new THREE.WebGLRenderer();\n\t    if (!this.renderer) {\n\t      alert('Three.js');\n\t    }\n\t    this.renderer.setClearColor(new THREE.Color(0xEEEEEE));\n\t    this.renderer.setSize(window.innerWidth, window.innerHeight);\n\t    this.renderer.shadowMap.enabled = true;\n\t\n\t    // \n\t    var pixelRatio = Math.min(window.devicePixelRatio || 1, 2);\n\t    this.renderer.setPixelRatio(pixelRatio);\n\t\n\t    //scene\n\t    this.scene = new THREE.Scene();\n\t\n\t    //camera\n\t    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n\t    this.camera.position.x = -30;\n\t    this.camera.position.y = 40;\n\t    this.camera.position.z = 30;\n\t    this.camera.lookAt(this.scene.position);\n\t\n\t    // window resize\n\t    this.$window.on('resize', function (e) {\n\t      self.onResize();\n\t    });\n\t\n\t    // resize\n\t    this.$window.trigger('resize');\n\t\n\t    //axes\n\t    // var axes = new THREE.AxisHelper(20);\n\t    // this.scene.add(axes);\n\t\n\t    //Plane\n\t    this.scene.add(PlaneObject.init());\n\t\n\t    //Cube\n\t    this.scene.add(CubeObject.init());\n\t\n\t    //sphereGeometry\n\t    // var sphereGeometry = new THREE.SphereGeometry(4, 20,20);\n\t    //\n\t    // //sphereMaterial\n\t    // var sphereMaterial = new THREE.MeshLambertMaterial({\n\t    //   color: 0x7777ff, wireframe: false\n\t    // });\n\t    //\n\t    // //sphere\n\t    // var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);\n\t    // sphere.castShadow = true;\n\t    // //sphere\n\t    // sphere.position.x = 20;\n\t    // sphere.position.y = 4;\n\t    // sphere.position.z = 2;\n\t    // this.scene.add(sphere);\n\t\n\t\n\t    var spotLight = new THREE.SpotLight(0xffffff);\n\t    spotLight.position.set(-20, 30, -5);\n\t    spotLight.castShadow = true;\n\t    this.scene.add(spotLight);\n\t\n\t    document.getElementById(\"WebGL-output\").appendChild(this.renderer.domElement);\n\t\n\t    var stats = initStats();\n\t    renderScene = function () {\n\t      stats.update();\n\t      // rotate the cube around its axes\n\t      // CubeObject.init().rotation.x += 0.02;\n\t      // CubeObject.init().rotation.y += 0.02;\n\t      // CubeObject.init().rotation.z += 0.02;\n\t\n\t      // bounce the sphere up and down\n\t      // step += 0.04;\n\t      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n\t      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\t\n\t      // render using requestAnimationFrame\n\t      this.updateAnimation();\n\t    }.bind(this);\n\t\n\t    // call the render function\n\t    var step = 0;\n\t    renderScene();\n\t\n\t    /**\n\t     * dat.gui\n\t     * dat.gui\n\t     */\n\t    var controls = new function () {\n\t      this.rotationSpeed = 0.001;\n\t      this.bouncingSpeed = 0.001;\n\t    }();\n\t\n\t    var gui = new dat.GUI();\n\t    gui.add(controls, 'rotationSpeed', 0, 0.1);\n\t    gui.add(controls, 'bouncingSpeed', 0, 0.1);\n\t\n\t    var render = function () {\n\t      stats.update();\n\t      // rotate the cube around its axes\n\t      // cube.rotation.x += controls.rotationSpeed;\n\t      // cube.rotation.y += controls.rotationSpeed;\n\t      // cube.rotation.z += controls.rotationSpeed;\n\t\n\t      // bounce the sphere up and down\n\t      // step += controls.bouncingSpeed;\n\t      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n\t      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\t\n\t      requestAnimationFrame(render);\n\t      this.renderer.render(this.scene, this.camera);\n\t    }.bind(this);\n\t    render();\n\t  };\n\t\n\t  //Stats\n\t  function initStats() {\n\t\n\t    var stats = new Stats();\n\t\n\t    stats.setMode(0); // 0: fps, 1: ms\n\t\n\t    // Align top-left\n\t    stats.domElement.style.position = 'absolute';\n\t    stats.domElement.style.left = '0px';\n\t    stats.domElement.style.top = '0px';\n\t\n\t    document.getElementById(\"Stats-output\").appendChild(stats.domElement);\n\t\n\t    return stats;\n\t  }\n\t\n\t  /**\n\t   * \n\t   */\n\t  // p.start = function () {\n\t  //   var self = this;\n\t  //\n\t  //   var enterFrameHandler = function() {\n\t  //     requestAnimationFrame(enterFrameHandler);\n\t  //     self.update();\n\t  //   };\n\t  //\n\t  //   enterFrameHandler();\n\t  // };\n\t\n\t  /**\n\t   * \n\t   */\n\t  p.updateAnimation = function () {\n\t    requestAnimationFrame(renderScene);\n\t    this.renderer.render(this.scene, this.camera);\n\t  };\n\t\n\t  /**\n\t   * \n\t   * @param {jQuery.Event} e - jQuery\n\t   */\n\t  p.onResize = function () {\n\t\n\t    this.width = this.$window.width();\n\t    this.height = this.$window.height();\n\t\n\t    this.camera.aspect = this.width / this.height;\n\t    this.camera.updateProjectionMatrix();\n\t\n\t    this.renderer.setSize(this.width, this.height);\n\t  };\n\t\n\t  // p.createDatGUIBox = function () {\n\t\n\t  // };\n\t})();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * jQuery JavaScript Library v3.1.1\n\t * https://jquery.com/\n\t *\n\t * Includes Sizzle.js\n\t * https://sizzlejs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * https://jquery.org/license\n\t *\n\t * Date: 2016-09-22T22:30Z\n\t */\n\t( function( global, factory ) {\n\t\n\t\t\"use strict\";\n\t\n\t\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\n\t\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t\t// is present, execute the factory and get jQuery.\n\t\t\t// For environments that do not have a `window` with a `document`\n\t\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t\t// This accentuates the need for the creation of a real `window`.\n\t\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t\t// See ticket #14549 for more info.\n\t\t\tmodule.exports = global.document ?\n\t\t\t\tfactory( global, true ) :\n\t\t\t\tfunction( w ) {\n\t\t\t\t\tif ( !w.document ) {\n\t\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn factory( w );\n\t\t\t\t};\n\t\t} else {\n\t\t\tfactory( global );\n\t\t}\n\t\n\t// Pass this if window is not defined yet\n\t} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\t\n\t// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n\t// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n\t// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n\t// enough that all such attempts are guarded in a try block.\n\t\"use strict\";\n\t\n\tvar arr = [];\n\t\n\tvar document = window.document;\n\t\n\tvar getProto = Object.getPrototypeOf;\n\t\n\tvar slice = arr.slice;\n\t\n\tvar concat = arr.concat;\n\t\n\tvar push = arr.push;\n\t\n\tvar indexOf = arr.indexOf;\n\t\n\tvar class2type = {};\n\t\n\tvar toString = class2type.toString;\n\t\n\tvar hasOwn = class2type.hasOwnProperty;\n\t\n\tvar fnToString = hasOwn.toString;\n\t\n\tvar ObjectFunctionString = fnToString.call( Object );\n\t\n\tvar support = {};\n\t\n\t\n\t\n\t\tfunction DOMEval( code, doc ) {\n\t\t\tdoc = doc || document;\n\t\n\t\t\tvar script = doc.createElement( \"script\" );\n\t\n\t\t\tscript.text = code;\n\t\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t\t}\n\t/* global Symbol */\n\t// Defining this global in .eslintrc.json would create a danger of using the global\n\t// unguarded in another place, it seems safer to define global only for this module\n\t\n\t\n\t\n\tvar\n\t\tversion = \"3.1.1\",\n\t\n\t\t// Define a local copy of jQuery\n\t\tjQuery = function( selector, context ) {\n\t\n\t\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\t\treturn new jQuery.fn.init( selector, context );\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only\n\t\t// Make sure we trim BOM and NBSP\n\t\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\t\n\t\t// Matches dashed string for camelizing\n\t\trmsPrefix = /^-ms-/,\n\t\trdashAlpha = /-([a-z])/g,\n\t\n\t\t// Used by jQuery.camelCase as callback to replace()\n\t\tfcamelCase = function( all, letter ) {\n\t\t\treturn letter.toUpperCase();\n\t\t};\n\t\n\tjQuery.fn = jQuery.prototype = {\n\t\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\t\n\t\tconstructor: jQuery,\n\t\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\t\n\t\ttoArray: function() {\n\t\t\treturn slice.call( this );\n\t\t},\n\t\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function( num ) {\n\t\n\t\t\t// Return all the elements in a clean array\n\t\t\tif ( num == null ) {\n\t\t\t\treturn slice.call( this );\n\t\t\t}\n\t\n\t\t\t// Return just the one element from the set\n\t\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t\t},\n\t\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function( elems ) {\n\t\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\t\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\t\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\t\n\t\t// Execute a callback for every element in the matched set.\n\t\teach: function( callback ) {\n\t\t\treturn jQuery.each( this, callback );\n\t\t},\n\t\n\t\tmap: function( callback ) {\n\t\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\t\treturn callback.call( elem, i, elem );\n\t\t\t} ) );\n\t\t},\n\t\n\t\tslice: function() {\n\t\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t\t},\n\t\n\t\tfirst: function() {\n\t\t\treturn this.eq( 0 );\n\t\t},\n\t\n\t\tlast: function() {\n\t\t\treturn this.eq( -1 );\n\t\t},\n\t\n\t\teq: function( i ) {\n\t\t\tvar len = this.length,\n\t\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t\t},\n\t\n\t\tend: function() {\n\t\t\treturn this.prevObject || this.constructor();\n\t\t},\n\t\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: arr.sort,\n\t\tsplice: arr.splice\n\t};\n\t\n\tjQuery.extend = jQuery.fn.extend = function() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[ 0 ] || {},\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif ( typeof target === \"boolean\" ) {\n\t\t\tdeep = target;\n\t\n\t\t\t// Skip the boolean and the target\n\t\t\ttarget = arguments[ i ] || {};\n\t\t\ti++;\n\t\t}\n\t\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\t// Extend jQuery itself if only one argument is passed\n\t\tif ( i === length ) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\t\n\t\tfor ( ; i < length; i++ ) {\n\t\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ( ( options = arguments[ i ] ) != null ) {\n\t\n\t\t\t\t// Extend the base object\n\t\t\t\tfor ( name in options ) {\n\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\tcopy = options[ name ];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\t\n\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\t\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\tjQuery.extend( {\n\t\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\t\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\t\n\t\terror: function( msg ) {\n\t\t\tthrow new Error( msg );\n\t\t},\n\t\n\t\tnoop: function() {},\n\t\n\t\tisFunction: function( obj ) {\n\t\t\treturn jQuery.type( obj ) === \"function\";\n\t\t},\n\t\n\t\tisArray: Array.isArray,\n\t\n\t\tisWindow: function( obj ) {\n\t\t\treturn obj != null && obj === obj.window;\n\t\t},\n\t\n\t\tisNumeric: function( obj ) {\n\t\n\t\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t\t// strings and numbers (primitives or objects)\n\t\t\t// that can be coerced to finite numbers (gh-2662)\n\t\t\tvar type = jQuery.type( obj );\n\t\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\t\n\t\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t\t// subtraction forces infinities to NaN\n\t\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t\t},\n\t\n\t\tisPlainObject: function( obj ) {\n\t\t\tvar proto, Ctor;\n\t\n\t\t\t// Detect obvious negatives\n\t\t\t// Use toString instead of jQuery.type to catch host objects\n\t\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tproto = getProto( obj );\n\t\n\t\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\t\tif ( !proto ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t\t},\n\t\n\t\tisEmptyObject: function( obj ) {\n\t\n\t\t\t/* eslint-disable no-unused-vars */\n\t\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\t\tvar name;\n\t\n\t\t\tfor ( name in obj ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\ttype: function( obj ) {\n\t\t\tif ( obj == null ) {\n\t\t\t\treturn obj + \"\";\n\t\t\t}\n\t\n\t\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\t\ttypeof obj;\n\t\t},\n\t\n\t\t// Evaluates a script in a global context\n\t\tglobalEval: function( code ) {\n\t\t\tDOMEval( code );\n\t\t},\n\t\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function( string ) {\n\t\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t\t},\n\t\n\t\tnodeName: function( elem, name ) {\n\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t\t},\n\t\n\t\teach: function( obj, callback ) {\n\t\t\tvar length, i = 0;\n\t\n\t\t\tif ( isArrayLike( obj ) ) {\n\t\t\t\tlength = obj.length;\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn obj;\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only\n\t\ttrim: function( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t\t},\n\t\n\t\t// results is for internal usage only\n\t\tmakeArray: function( arr, results ) {\n\t\t\tvar ret = results || [];\n\t\n\t\t\tif ( arr != null ) {\n\t\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call( ret, arr );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn ret;\n\t\t},\n\t\n\t\tinArray: function( elem, arr, i ) {\n\t\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t\t},\n\t\n\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\tmerge: function( first, second ) {\n\t\t\tvar len = +second.length,\n\t\t\t\tj = 0,\n\t\t\t\ti = first.length;\n\t\n\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\n\t\t\tfirst.length = i;\n\t\n\t\t\treturn first;\n\t\t},\n\t\n\t\tgrep: function( elems, callback, invert ) {\n\t\t\tvar callbackInverse,\n\t\t\t\tmatches = [],\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tcallbackExpect = !invert;\n\t\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn matches;\n\t\t},\n\t\n\t\t// arg is for internal usage only\n\t\tmap: function( elems, callback, arg ) {\n\t\t\tvar length, value,\n\t\t\t\ti = 0,\n\t\t\t\tret = [];\n\t\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif ( isArrayLike( elems ) ) {\n\t\t\t\tlength = elems.length;\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor ( i in elems ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\t\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply( [], ret );\n\t\t},\n\t\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\t\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function( fn, context ) {\n\t\t\tvar tmp, args, proxy;\n\t\n\t\t\tif ( typeof context === \"string\" ) {\n\t\t\t\ttmp = fn[ context ];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\t\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\n\t\t\t// Simulated bind\n\t\t\targs = slice.call( arguments, 2 );\n\t\t\tproxy = function() {\n\t\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t\t};\n\t\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\t\n\t\t\treturn proxy;\n\t\t},\n\t\n\t\tnow: Date.now,\n\t\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t} );\n\t\n\tif ( typeof Symbol === \"function\" ) {\n\t\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n\t}\n\t\n\t// Populate the class2type map\n\tjQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\n\tfunction( i, name ) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t} );\n\t\n\tfunction isArrayLike( obj ) {\n\t\n\t\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn't used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\t\ttype = jQuery.type( obj );\n\t\n\t\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\treturn type === \"array\" || length === 0 ||\n\t\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n\t * Sizzle CSS Selector Engine v2.3.3\n\t * https://sizzlejs.com/\n\t *\n\t * Copyright jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2016-08-08\n\t */\n\t(function( window ) {\n\t\n\tvar i,\n\t\tsupport,\n\t\tExpr,\n\t\tgetText,\n\t\tisXML,\n\t\ttokenize,\n\t\tcompile,\n\t\tselect,\n\t\toutermostContext,\n\t\tsortInput,\n\t\thasDuplicate,\n\t\n\t\t// Local document vars\n\t\tsetDocument,\n\t\tdocument,\n\t\tdocElem,\n\t\tdocumentIsHTML,\n\t\trbuggyQSA,\n\t\trbuggyMatches,\n\t\tmatches,\n\t\tcontains,\n\t\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + 1 * new Date(),\n\t\tpreferredDoc = window.document,\n\t\tdirruns = 0,\n\t\tdone = 0,\n\t\tclassCache = createCache(),\n\t\ttokenCache = createCache(),\n\t\tcompilerCache = createCache(),\n\t\tsortOrder = function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\t\n\t\t// Instance methods\n\t\thasOwn = ({}).hasOwnProperty,\n\t\tarr = [],\n\t\tpop = arr.pop,\n\t\tpush_native = arr.push,\n\t\tpush = arr.push,\n\t\tslice = arr.slice,\n\t\t// Use a stripped-down indexOf as it's faster than native\n\t\t// https://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function( list, elem ) {\n\t\t\tvar i = 0,\n\t\t\t\tlen = list.length;\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tif ( list[i] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\n\t\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\t\n\t\t// Regular expressions\n\t\n\t\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\t\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t\t// Operator (capture 2)\n\t\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\t\"*\\\\]\",\n\t\n\t\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t\t// 2. simple (capture 6)\n\t\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t\t// 3. anything else (capture 2)\n\t\t\t\".*\" +\n\t\t\t\")\\\\)|)\",\n\t\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\t\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\t\n\t\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\t\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\t\n\t\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\t\n\t\trpseudo = new RegExp( pseudos ),\n\t\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\t\n\t\tmatchExpr = {\n\t\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t\t},\n\t\n\t\trinputs = /^(?:input|select|textarea|button)$/i,\n\t\trheader = /^h\\d$/i,\n\t\n\t\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\t\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\n\t\trsibling = /[+~]/,\n\t\n\t\t// CSS escapes\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\t\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ?\n\t\t\t\tescaped :\n\t\t\t\thigh < 0 ?\n\t\t\t\t\t// BMP codepoint\n\t\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t\t},\n\t\n\t\t// CSS string/identifier serialization\n\t\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\t\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\t\tfcssescape = function( ch, asCodePoint ) {\n\t\t\tif ( asCodePoint ) {\n\t\n\t\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\t\treturn \"\\uFFFD\";\n\t\t\t\t}\n\t\n\t\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t\t}\n\t\n\t\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\t\treturn \"\\\\\" + ch;\n\t\t},\n\t\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a \"Permission Denied\"\n\t\t// error in IE\n\t\tunloadHandler = function() {\n\t\t\tsetDocument();\n\t\t},\n\t\n\t\tdisabledAncestor = addCombinator(\n\t\t\tfunction( elem ) {\n\t\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t\t},\n\t\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t\t);\n\t\n\t// Optimize for push.apply( _, NodeList )\n\ttry {\n\t\tpush.apply(\n\t\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\t\tpreferredDoc.childNodes\n\t\t);\n\t\t// Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\t\tarr[ preferredDoc.childNodes.length ].nodeType;\n\t} catch ( e ) {\n\t\tpush = { apply: arr.length ?\n\t\n\t\t\t// Leverage slice if possible\n\t\t\tfunction( target, els ) {\n\t\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t\t} :\n\t\n\t\t\t// Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction( target, els ) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t\ti = 0;\n\t\t\t\t// Can't trust NodeList.length\n\t\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction Sizzle( selector, context, results, seed ) {\n\t\tvar m, i, elem, nid, match, groups, newSelector,\n\t\t\tnewContext = context && context.ownerDocument,\n\t\n\t\t\t// nodeType defaults to 9, since context defaults to document\n\t\t\tnodeType = context ? context.nodeType : 9;\n\t\n\t\tresults = results || [];\n\t\n\t\t// Return early from calls with invalid selector or context\n\t\tif ( typeof selector !== \"string\" || !selector ||\n\t\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\t\n\t\t\treturn results;\n\t\t}\n\t\n\t\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\t\tif ( !seed ) {\n\t\n\t\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\t\tsetDocument( context );\n\t\t\t}\n\t\t\tcontext = context || document;\n\t\n\t\t\tif ( documentIsHTML ) {\n\t\n\t\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\n\t\t\t\t\t// ID selector\n\t\t\t\t\tif ( (m = match[1]) ) {\n\t\n\t\t\t\t\t\t// Document context\n\t\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\t\n\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Element context\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\t\telem.id === m ) {\n\t\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t// Type selector\n\t\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\t\treturn results;\n\t\n\t\t\t\t\t// Class selector\n\t\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\t\tcontext.getElementsByClassName ) {\n\t\n\t\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Take advantage of querySelectorAll\n\t\t\t\tif ( support.qsa &&\n\t\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\n\t\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\t\tnewContext = context;\n\t\t\t\t\t\tnewSelector = selector;\n\t\n\t\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t\t// Support: IE <=8\n\t\t\t\t\t// Exclude object elements\n\t\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\t\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\n\t\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\t\tcontext;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( newSelector ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// All others\n\t\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n\t}\n\t\n\t/**\n\t * Create key-value caches of limited size\n\t * @returns {function(string, object)} Returns the Object data after storing it on itself with\n\t *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n\t *\tdeleting the oldest entry\n\t */\n\tfunction createCache() {\n\t\tvar keys = [];\n\t\n\t\tfunction cache( key, value ) {\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[ keys.shift() ];\n\t\t\t}\n\t\t\treturn (cache[ key + \" \" ] = value);\n\t\t}\n\t\treturn cache;\n\t}\n\t\n\t/**\n\t * Mark a function for special use by Sizzle\n\t * @param {Function} fn The function to mark\n\t */\n\tfunction markFunction( fn ) {\n\t\tfn[ expando ] = true;\n\t\treturn fn;\n\t}\n\t\n\t/**\n\t * Support testing using an element\n\t * @param {Function} fn Passed the created element and returns a boolean result\n\t */\n\tfunction assert( fn ) {\n\t\tvar el = document.createElement(\"fieldset\");\n\t\n\t\ttry {\n\t\t\treturn !!fn( el );\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t// Remove from its parent by default\n\t\t\tif ( el.parentNode ) {\n\t\t\t\tel.parentNode.removeChild( el );\n\t\t\t}\n\t\t\t// release memory in IE\n\t\t\tel = null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the same handler for all of the specified attrs\n\t * @param {String} attrs Pipe-separated list of attributes\n\t * @param {Function} handler The method that will be applied\n\t */\n\tfunction addHandle( attrs, handler ) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t\ti = arr.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks document order of two siblings\n\t * @param {Element} a\n\t * @param {Element} b\n\t * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n\t */\n\tfunction siblingCheck( a, b ) {\n\t\tvar cur = b && a,\n\t\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t\ta.sourceIndex - b.sourceIndex;\n\t\n\t\t// Use IE sourceIndex if available on both nodes\n\t\tif ( diff ) {\n\t\t\treturn diff;\n\t\t}\n\t\n\t\t// Check if b follows a\n\t\tif ( cur ) {\n\t\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\t\tif ( cur === b ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn a ? 1 : -1;\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for input types\n\t * @param {String} type\n\t */\n\tfunction createInputPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for buttons\n\t * @param {String} type\n\t */\n\tfunction createButtonPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for :enabled/:disabled\n\t * @param {Boolean} disabled true for :disabled; false for :enabled\n\t */\n\tfunction createDisabledPseudo( disabled ) {\n\t\n\t\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\t\treturn function( elem ) {\n\t\n\t\t\t// Only certain elements can match :enabled or :disabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\t\tif ( \"form\" in elem ) {\n\t\n\t\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t\t// * option elements in a disabled optgroup\n\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t\t// All such elements have a \"form\" property.\n\t\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\t\n\t\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\t\treturn elem.isDisabled === disabled ||\n\t\n\t\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t\t}\n\t\n\t\t\t\treturn elem.disabled === disabled;\n\t\n\t\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t\t// even exist on them, let alone have a boolean value.\n\t\t\t} else if ( \"label\" in elem ) {\n\t\t\t\treturn elem.disabled === disabled;\n\t\t\t}\n\t\n\t\t\t// Remaining elements are neither :enabled nor :disabled\n\t\t\treturn false;\n\t\t};\n\t}\n\t\n\t/**\n\t * Returns a function to use in pseudos for positionals\n\t * @param {Function} fn\n\t */\n\tfunction createPositionalPseudo( fn ) {\n\t\treturn markFunction(function( argument ) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function( seed, matches ) {\n\t\t\t\tvar j,\n\t\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\t\ti = matchIndexes.length;\n\t\n\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t\n\t/**\n\t * Checks a node for validity as a Sizzle context\n\t * @param {Element|Object=} context\n\t * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n\t */\n\tfunction testContext( context ) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t}\n\t\n\t// Expose support vars for convenience\n\tsupport = Sizzle.support = {};\n\t\n\t/**\n\t * Detects XML nodes\n\t * @param {Element|Object} elem An element or a document\n\t * @returns {Boolean} True iff elem is a non-HTML XML node\n\t */\n\tisXML = Sizzle.isXML = function( elem ) {\n\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t// (such as loading iframes in IE - #4833)\n\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t};\n\t\n\t/**\n\t * Sets document-related variables once based on the current document\n\t * @param {Element|Object} [doc] An element or document object to use to set the document\n\t * @returns {Object} Returns the current document\n\t */\n\tsetDocument = Sizzle.setDocument = function( node ) {\n\t\tvar hasCompare, subWindow,\n\t\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\t\n\t\t// Return early if doc is invalid or already selected\n\t\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\t\treturn document;\n\t\t}\n\t\n\t\t// Update global variables\n\t\tdocument = doc;\n\t\tdocElem = document.documentElement;\n\t\tdocumentIsHTML = !isXML( document );\n\t\n\t\t// Support: IE 9-11, Edge\n\t\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t\tif ( preferredDoc !== document &&\n\t\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\t\n\t\t\t// Support: IE 11, Edge\n\t\t\tif ( subWindow.addEventListener ) {\n\t\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\t\n\t\t\t// Support: IE 9 - 10 only\n\t\t\t} else if ( subWindow.attachEvent ) {\n\t\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t\t}\n\t\t}\n\t\n\t\t/* Attributes\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\t\tsupport.attributes = assert(function( el ) {\n\t\t\tel.className = \"i\";\n\t\t\treturn !el.getAttribute(\"className\");\n\t\t});\n\t\n\t\t/* getElement(s)By*\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\tsupport.getElementsByTagName = assert(function( el ) {\n\t\t\tel.appendChild( document.createComment(\"\") );\n\t\t\treturn !el.getElementsByTagName(\"*\").length;\n\t\t});\n\t\n\t\t// Support: IE<9\n\t\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\t\n\t\t// Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programmatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\t\tsupport.getById = assert(function( el ) {\n\t\t\tdocElem.appendChild( el ).id = expando;\n\t\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t\t});\n\t\n\t\t// ID filter and find\n\t\tif ( support.getById ) {\n\t\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\n\t\t\t// Support: IE 6 - 7 only\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar node, i, elems,\n\t\t\t\t\t\telem = context.getElementById( id );\n\t\n\t\t\t\t\tif ( elem ) {\n\t\n\t\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\t// Tag\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\t\tfunction( tag, context ) {\n\t\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\t\treturn context.getElementsByTagName( tag );\n\t\n\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t\t} else if ( support.qsa ) {\n\t\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t\t}\n\t\t\t} :\n\t\n\t\t\tfunction( tag, context ) {\n\t\t\t\tvar elem,\n\t\t\t\t\ttmp = [],\n\t\t\t\t\ti = 0,\n\t\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\t\tresults = context.getElementsByTagName( tag );\n\t\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif ( tag === \"*\" ) {\n\t\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\n\t\t// Class\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\t\treturn context.getElementsByClassName( className );\n\t\t\t}\n\t\t};\n\t\n\t\t/* QSA/matchesSelector\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// QSA and matchesSelector support\n\t\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\trbuggyMatches = [];\n\t\n\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See https://bugs.jquery.com/ticket/13378\n\t\trbuggyQSA = [];\n\t\n\t\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function( el ) {\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\t\"<option selected=''></option></select>\";\n\t\n\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t}\n\t\n\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t}\n\t\n\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tassert(function( el ) {\n\t\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\t\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = document.createElement(\"input\");\n\t\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\t\n\t\t\t\t// Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t\t}\n\t\n\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Support: IE9-11+\n\t\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\t\n\t\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\t\tdocElem.webkitMatchesSelector ||\n\t\t\tdocElem.mozMatchesSelector ||\n\t\t\tdocElem.oMatchesSelector ||\n\t\t\tdocElem.msMatchesSelector) )) ) {\n\t\n\t\t\tassert(function( el ) {\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\t\n\t\t\t\t// This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t\t});\n\t\t}\n\t\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\t\n\t\t/* Contains\n\t\t---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\t\n\t\t// Element contains another\n\t\t// Purposefully self-exclusive\n\t\t// As in, an element does not contain itself\n\t\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\t\tfunction( a, b ) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t\tbup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\t\tadown.contains ?\n\t\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t\t));\n\t\t\t} :\n\t\t\tfunction( a, b ) {\n\t\t\t\tif ( b ) {\n\t\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\n\t\t/* Sorting\n\t\t---------------------------------------------------------------------- */\n\t\n\t\t// Document order sorting\n\t\tsortOrder = hasCompare ?\n\t\tfunction( a, b ) {\n\t\n\t\t\t// Flag for duplicate removal\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\tif ( compare ) {\n\t\t\t\treturn compare;\n\t\t\t}\n\t\n\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\t\ta.compareDocumentPosition( b ) :\n\t\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\t\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\t\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\t\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\taup = a.parentNode,\n\t\t\t\tbup = b.parentNode,\n\t\t\t\tap = [ a ],\n\t\t\t\tbp = [ b ];\n\t\n\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\tif ( !aup || !bup ) {\n\t\t\t\treturn a === document ? -1 :\n\t\t\t\t\tb === document ? 1 :\n\t\t\t\t\taup ? -1 :\n\t\t\t\t\tbup ? 1 :\n\t\t\t\t\tsortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\n\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t} else if ( aup === bup ) {\n\t\t\t\treturn siblingCheck( a, b );\n\t\t\t}\n\t\n\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\tcur = a;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tap.unshift( cur );\n\t\t\t}\n\t\t\tcur = b;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tbp.unshift( cur );\n\t\t\t}\n\t\n\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\twhile ( ap[i] === bp[i] ) {\n\t\t\t\ti++;\n\t\t\t}\n\t\n\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\t\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t\t0;\n\t\t};\n\t\n\t\treturn document;\n\t};\n\t\n\tSizzle.matches = function( expr, elements ) {\n\t\treturn Sizzle( expr, null, null, elements );\n\t};\n\t\n\tSizzle.matchesSelector = function( elem, expr ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\t// Make sure that attribute selectors are quoted\n\t\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\t\n\t\tif ( support.matchesSelector && documentIsHTML &&\n\t\t\t!compilerCache[ expr + \" \" ] &&\n\t\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\t\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call( elem, expr );\n\t\n\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t\n\t\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n\t};\n\t\n\tSizzle.contains = function( context, elem ) {\n\t\t// Set document vars if needed\n\t\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\treturn contains( context, elem );\n\t};\n\t\n\tSizzle.attr = function( elem, name ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\t\n\t\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\t\tundefined;\n\t\n\t\treturn val !== undefined ?\n\t\t\tval :\n\t\t\tsupport.attributes || !documentIsHTML ?\n\t\t\t\telem.getAttribute( name ) :\n\t\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t};\n\t\n\tSizzle.escape = function( sel ) {\n\t\treturn (sel + \"\").replace( rcssescape, fcssescape );\n\t};\n\t\n\tSizzle.error = function( msg ) {\n\t\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n\t};\n\t\n\t/**\n\t * Document sorting and removing duplicates\n\t * @param {ArrayLike} results\n\t */\n\tSizzle.uniqueSort = function( results ) {\n\t\tvar elem,\n\t\t\tduplicates = [],\n\t\t\tj = 0,\n\t\t\ti = 0;\n\t\n\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice( 0 );\n\t\tresults.sort( sortOrder );\n\t\n\t\tif ( hasDuplicate ) {\n\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\t\tj = duplicates.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( j-- ) {\n\t\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t\t}\n\t\t}\n\t\n\t\t// Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\tsortInput = null;\n\t\n\t\treturn results;\n\t};\n\t\n\t/**\n\t * Utility function for retrieving the text value of an array of DOM nodes\n\t * @param {Array|Element} elem\n\t */\n\tgetText = Sizzle.getText = function( elem ) {\n\t\tvar node,\n\t\t\tret = \"\",\n\t\t\ti = 0,\n\t\t\tnodeType = elem.nodeType;\n\t\n\t\tif ( !nodeType ) {\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile ( (node = elem[i++]) ) {\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText( node );\n\t\t\t}\n\t\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\t\t\t\t// Traverse its children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tret += getText( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\t\t// Do not include comment or processing instruction nodes\n\t\n\t\treturn ret;\n\t};\n\t\n\tExpr = Sizzle.selectors = {\n\t\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\t\n\t\tcreatePseudo: markFunction,\n\t\n\t\tmatch: matchExpr,\n\t\n\t\tattrHandle: {},\n\t\n\t\tfind: {},\n\t\n\t\trelative: {\n\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t},\n\t\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function( match ) {\n\t\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\t\n\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\t\n\t\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\t\n\t\t\t\treturn match.slice( 0, 4 );\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( match ) {\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t\t1 type (only|nth|...)\n\t\t\t\t\t2 what (child|of-type)\n\t\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t\t5 sign of xn-component\n\t\t\t\t\t6 x of xn-component\n\t\t\t\t\t7 sign of y-component\n\t\t\t\t\t8 y of y-component\n\t\t\t\t*/\n\t\t\t\tmatch[1] = match[1].toLowerCase();\n\t\n\t\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\t\n\t\t\t\t// other types prohibit arguments\n\t\t\t\t} else if ( match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\t\n\t\t\t\treturn match;\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( match ) {\n\t\t\t\tvar excess,\n\t\t\t\t\tunquoted = !match[6] && match[2];\n\t\n\t\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\tif ( match[3] ) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\t\n\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\t\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t\t}\n\t\n\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\treturn match.slice( 0, 3 );\n\t\t\t}\n\t\t},\n\t\n\t\tfilter: {\n\t\n\t\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\t\tfunction() { return true; } :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CLASS\": function( className ) {\n\t\t\t\tvar pattern = classCache[ className + \" \" ];\n\t\n\t\t\t\treturn pattern ||\n\t\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar result = Sizzle.attr( elem, name );\n\t\n\t\t\t\t\tif ( result == null ) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( !operator ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresult += \"\";\n\t\n\t\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\t\tfalse;\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\t\tofType = what === \"of-type\";\n\t\n\t\t\t\treturn first === 1 && last === 0 ?\n\t\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} :\n\t\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\t\tdiff = false;\n\t\n\t\t\t\t\t\tif ( parent ) {\n\t\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\t\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif ( forward && useCache ) {\n\t\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\t\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\n\t\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t\t++diff ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\t\n\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\t\t\t\tif ( fn[ expando ] ) {\n\t\t\t\t\treturn fn( argument );\n\t\t\t\t}\n\t\n\t\t\t\t// But maintain support for old signatures\n\t\t\t\tif ( fn.length > 1 ) {\n\t\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\t\n\t\tpseudos: {\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function( selector ) {\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t\tresults = [],\n\t\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\t\n\t\t\t\treturn matcher[ expando ] ?\n\t\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\t\ti = seed.length;\n\t\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"has\": markFunction(function( selector ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t\"contains\": markFunction(function( text ) {\n\t\t\t\ttext = text.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t\t}\n\t\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar elemLang;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\t\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\t\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function( elem ) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t\t},\n\t\n\t\t\t\"root\": function( elem ) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\t\n\t\t\t\"focus\": function( elem ) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\t\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\t\"disabled\": createDisabledPseudo( true ),\n\t\n\t\t\t\"checked\": function( elem ) {\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t\t},\n\t\n\t\t\t\"selected\": function( elem ) {\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\t\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\t\n\t\t\t// Contents\n\t\t\t\"empty\": function( elem ) {\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\n\t\t\t\"parent\": function( elem ) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t\t},\n\t\n\t\t\t// Element/input types\n\t\t\t\"header\": function( elem ) {\n\t\t\t\treturn rheader.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"input\": function( elem ) {\n\t\t\t\treturn rinputs.test( elem.nodeName );\n\t\t\t},\n\t\n\t\t\t\"button\": function( elem ) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\t\n\t\t\t\"text\": function( elem ) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\t\telem.type === \"text\" &&\n\t\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t\t},\n\t\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function() {\n\t\t\t\treturn [ 0 ];\n\t\t\t}),\n\t\n\t\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\treturn [ length - 1 ];\n\t\t\t}),\n\t\n\t\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t\t}),\n\t\n\t\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 1;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\n\t\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\t\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\t\n\t// Add button/input type pseudos\n\tfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\t\tExpr.pseudos[ i ] = createInputPseudo( i );\n\t}\n\tfor ( i in { submit: true, reset: true } ) {\n\t\tExpr.pseudos[ i ] = createButtonPseudo( i );\n\t}\n\t\n\t// Easy API for creating new setFilters\n\tfunction setFilters() {}\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\t\n\ttokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\t\tvar matched, match, tokens, type,\n\t\t\tsoFar, groups, preFilters,\n\t\t\tcached = tokenCache[ selector + \" \" ];\n\t\n\t\tif ( cached ) {\n\t\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t\t}\n\t\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\t\n\t\twhile ( soFar ) {\n\t\n\t\t\t// Comma and first run\n\t\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\t\tif ( match ) {\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t\t}\n\t\t\t\tgroups.push( (tokens = []) );\n\t\t\t}\n\t\n\t\t\tmatched = false;\n\t\n\t\t\t// Combinators\n\t\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\n\t\t\t// Filters\n\t\t\tfor ( type in Expr.filter ) {\n\t\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( !matched ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\t\treturn parseOnly ?\n\t\t\tsoFar.length :\n\t\t\tsoFar ?\n\t\t\t\tSizzle.error( selector ) :\n\t\t\t\t// Cache the tokens\n\t\t\t\ttokenCache( selector, groups ).slice( 0 );\n\t};\n\t\n\tfunction toSelector( tokens ) {\n\t\tvar i = 0,\n\t\t\tlen = tokens.length,\n\t\t\tselector = \"\";\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\t\treturn selector;\n\t}\n\t\n\tfunction addCombinator( matcher, combinator, base ) {\n\t\tvar dir = combinator.dir,\n\t\t\tskip = combinator.next,\n\t\t\tkey = skip || dir,\n\t\t\tcheckNonElements = base && key === \"parentNode\",\n\t\t\tdoneName = done++;\n\t\n\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} :\n\t\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\t\tnewCache = [ dirruns, doneName ];\n\t\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\t\tif ( xml ) {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\t\n\t\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\t\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\t\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t}\n\t\n\tfunction elementMatcher( matchers ) {\n\t\treturn matchers.length > 1 ?\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} :\n\t\t\tmatchers[0];\n\t}\n\t\n\tfunction multipleContexts( selector, contexts, results ) {\n\t\tvar i = 0,\n\t\t\tlen = contexts.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tSizzle( selector, contexts[i], results );\n\t\t}\n\t\treturn results;\n\t}\n\t\n\tfunction condense( unmatched, map, filter, context, xml ) {\n\t\tvar elem,\n\t\t\tnewUnmatched = [],\n\t\t\ti = 0,\n\t\t\tlen = unmatched.length,\n\t\t\tmapped = map != null;\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\t\tif ( mapped ) {\n\t\t\t\t\t\tmap.push( i );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn newUnmatched;\n\t}\n\t\n\tfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\t\tif ( postFilter && !postFilter[ expando ] ) {\n\t\t\tpostFilter = setMatcher( postFilter );\n\t\t}\n\t\tif ( postFinder && !postFinder[ expando ] ) {\n\t\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t\t}\n\t\treturn markFunction(function( seed, results, context, xml ) {\n\t\t\tvar temp, i, elem,\n\t\t\t\tpreMap = [],\n\t\t\t\tpostMap = [],\n\t\t\t\tpreexisting = results.length,\n\t\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\t\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\t\telems,\n\t\n\t\t\t\tmatcherOut = matcher ?\n\t\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\t\n\t\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t\t[] :\n\t\n\t\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\t\tresults :\n\t\t\t\t\tmatcherIn;\n\t\n\t\t\t// Find primary matches\n\t\t\tif ( matcher ) {\n\t\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t\t}\n\t\n\t\t\t// Apply postFilter\n\t\t\tif ( postFilter ) {\n\t\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\t\tpostFilter( temp, [], context, xml );\n\t\n\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\ti = temp.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( seed ) {\n\t\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\t\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(\n\t\t\t\t\tmatcherOut === results ?\n\t\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\t\tmatcherOut\n\t\t\t\t);\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t\n\tfunction matcherFromTokens( tokens ) {\n\t\tvar checkContext, matcher, j,\n\t\t\tlen = tokens.length,\n\t\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\ti = leadingRelative ? 1 : 0,\n\t\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t} ];\n\t\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\t\n\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\t\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn setMatcher(\n\t\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tmatchers.push( matcher );\n\t\t\t}\n\t\t}\n\t\n\t\treturn elementMatcher( matchers );\n\t}\n\t\n\tfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t\tbyElement = elementMatchers.length > 0,\n\t\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\t\tvar elem, j, matcher,\n\t\t\t\t\tmatchedCount = 0,\n\t\t\t\t\ti = \"0\",\n\t\t\t\t\tunmatched = seed && [],\n\t\t\t\t\tsetMatched = [],\n\t\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\t\tlen = elems.length;\n\t\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t\t}\n\t\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif ( bySet ) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t\t// makes the latter nonnegative.\n\t\t\t\tmatchedCount += i;\n\t\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t\t// no element matchers and no seed.\n\t\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t\t// numerically zero.\n\t\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply( results, setMatched );\n\t\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\t\n\t\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\t\n\t\t\t\treturn unmatched;\n\t\t\t};\n\t\n\t\treturn bySet ?\n\t\t\tmarkFunction( superMatcher ) :\n\t\t\tsuperMatcher;\n\t}\n\t\n\tcompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\t\tvar i,\n\t\t\tsetMatchers = [],\n\t\t\telementMatchers = [],\n\t\t\tcached = compilerCache[ selector + \" \" ];\n\t\n\t\tif ( !cached ) {\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif ( !match ) {\n\t\t\t\tmatch = tokenize( selector );\n\t\t\t}\n\t\t\ti = match.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\t\tif ( cached[ expando ] ) {\n\t\t\t\t\tsetMatchers.push( cached );\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push( cached );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Cache the compiled function\n\t\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t\n\t\t\t// Save selector and tokenization\n\t\t\tcached.selector = selector;\n\t\t}\n\t\treturn cached;\n\t};\n\t\n\t/**\n\t * A low-level selection function that works with Sizzle's compiled\n\t *  selector functions\n\t * @param {String|Function} selector A selector or a pre-compiled\n\t *  selector function built with Sizzle.compile\n\t * @param {Element} context\n\t * @param {Array} [results]\n\t * @param {Array} [seed] A set of elements to match against\n\t */\n\tselect = Sizzle.select = function( selector, context, results, seed ) {\n\t\tvar i, tokens, token, type, find,\n\t\t\tcompiled = typeof selector === \"function\" && selector,\n\t\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\t\n\t\tresults = results || [];\n\t\n\t\t// Try to minimize operations if there is only one selector in the list and no seed\n\t\t// (the latter of which guarantees us context)\n\t\tif ( match.length === 1 ) {\n\t\n\t\t\t// Reduce context if the leading compound selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\t\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\n\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if ( compiled ) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\t\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\t\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\t\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t\t)) ) {\n\t\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t( compiled || compile( selector, match ) )(\n\t\t\tseed,\n\t\t\tcontext,\n\t\t\t!documentIsHTML,\n\t\t\tresults,\n\t\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t\t);\n\t\treturn results;\n\t};\n\t\n\t// One-time assignments\n\t\n\t// Sort stability\n\tsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\t\n\t// Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\tsupport.detectDuplicates = !!hasDuplicate;\n\t\n\t// Initialize against the default document\n\tsetDocument();\n\t\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\tsupport.sortDetached = assert(function( el ) {\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n\t});\n\t\n\t// Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif ( !assert(function( el ) {\n\t\tel.innerHTML = \"<a href='#'></a>\";\n\t\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n\t}) ) {\n\t\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\tif ( !support.attributes || !assert(function( el ) {\n\t\tel.innerHTML = \"<input/>\";\n\t\tel.firstChild.setAttribute( \"value\", \"\" );\n\t\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n\t}) ) {\n\t\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t}\n\t\n\t// Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\tif ( !assert(function( el ) {\n\t\treturn el.getAttribute(\"disabled\") == null;\n\t}) ) {\n\t\taddHandle( booleans, function( elem, name, isXML ) {\n\t\t\tvar val;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn Sizzle;\n\t\n\t})( window );\n\t\n\t\n\t\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\t\n\t// Deprecated\n\tjQuery.expr[ \":\" ] = jQuery.expr.pseudos;\n\tjQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\tjQuery.escapeSelector = Sizzle.escape;\n\t\n\t\n\t\n\t\n\tvar dir = function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\t\n\t\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t};\n\t\n\t\n\tvar siblings = function( n, elem ) {\n\t\tvar matched = [];\n\t\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\t\n\t\treturn matched;\n\t};\n\t\n\t\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\t\n\tvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\t\n\t\n\t\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\t\n\t// Implement the identical functionality for filter and not\n\tfunction winnow( elements, qualifier, not ) {\n\t\tif ( jQuery.isFunction( qualifier ) ) {\n\t\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Single element\n\t\tif ( qualifier.nodeType ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( elem === qualifier ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Arraylike of elements (jQuery, arguments, Array)\n\t\tif ( typeof qualifier !== \"string\" ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t\t} );\n\t\t}\n\t\n\t\t// Simple selector that can be filtered directly, removing non-Elements\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\t\n\t\t// Complex selector, compare the two sets, removing non-Elements\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t\t} );\n\t}\n\t\n\tjQuery.filter = function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\t\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\t\n\t\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t\t}\n\t\n\t\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t} ) );\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tfind: function( selector ) {\n\t\t\tvar i, ret,\n\t\t\t\tlen = this.length,\n\t\t\t\tself = this;\n\t\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) );\n\t\t\t}\n\t\n\t\t\tret = this.pushStack( [] );\n\t\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t\t}\n\t\n\t\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t\t},\n\t\tfilter: function( selector ) {\n\t\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t\t},\n\t\tnot: function( selector ) {\n\t\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t\t},\n\t\tis: function( selector ) {\n\t\t\treturn !!winnow(\n\t\t\t\tthis,\n\t\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector ) :\n\t\t\t\t\tselector || [],\n\t\t\t\tfalse\n\t\t\t).length;\n\t\t}\n\t} );\n\t\n\t\n\t// Initialize a jQuery object\n\t\n\t\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\t\n\t\t// A simple way to check for HTML strings\n\t\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t\t// Strict HTML recognition (#11290: must start with <)\n\t\t// Shortcut simple #id case for speed\n\t\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\t\n\t\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\t\tvar match, elem;\n\t\n\t\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\t\tif ( !selector ) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t// Method init() accepts an alternate rootjQuery\n\t\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\t\troot = root || rootjQuery;\n\t\n\t\t\t// Handle HTML strings\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\t\tselector.length >= 3 ) {\n\t\n\t\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\t\tmatch = [ null, selector, null ];\n\t\n\t\t\t\t} else {\n\t\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t\t}\n\t\n\t\t\t\t// Match html or make sure no context is specified for #id\n\t\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\t\n\t\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\t\n\t\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t) );\n\t\n\t\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\t\tfor ( match in context ) {\n\t\n\t\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\t\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\t\n\t\t\t\t\t\tif ( elem ) {\n\t\n\t\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\t\treturn ( context || root ).find( selector );\n\t\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t\t} else {\n\t\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t\t}\n\t\n\t\t\t// HANDLE: $(DOMElement)\n\t\t\t} else if ( selector.nodeType ) {\n\t\t\t\tthis[ 0 ] = selector;\n\t\t\t\tthis.length = 1;\n\t\t\t\treturn this;\n\t\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\t\treturn root.ready !== undefined ?\n\t\t\t\t\troot.ready( selector ) :\n\t\n\t\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\t\tselector( jQuery );\n\t\t\t}\n\t\n\t\t\treturn jQuery.makeArray( selector, this );\n\t\t};\n\t\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\t\n\t// Initialize central reference\n\trootjQuery = jQuery( document );\n\t\n\t\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t\n\t\t// Methods guaranteed to produce a unique set when starting from a unique set\n\t\tguaranteedUnique = {\n\t\t\tchildren: true,\n\t\t\tcontents: true,\n\t\t\tnext: true,\n\t\t\tprev: true\n\t\t};\n\t\n\tjQuery.fn.extend( {\n\t\thas: function( target ) {\n\t\t\tvar targets = jQuery( target, this ),\n\t\t\t\tl = targets.length;\n\t\n\t\t\treturn this.filter( function() {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tclosest: function( selectors, context ) {\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tmatched = [],\n\t\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\t\n\t\t\t// Positional selectors never match, since there's no _selection_ context\n\t\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\t\n\t\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\t\n\t\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\t\n\t\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t\t},\n\t\n\t\t// Determine the position of an element within the set\n\t\tindex: function( elem ) {\n\t\n\t\t\t// No argument, return index in parent\n\t\t\tif ( !elem ) {\n\t\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t\t}\n\t\n\t\t\t// Index in selector\n\t\t\tif ( typeof elem === \"string\" ) {\n\t\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t\t}\n\t\n\t\t\t// Locate the position of the desired element\n\t\t\treturn indexOf.call( this,\n\t\n\t\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t\t);\n\t\t},\n\t\n\t\tadd: function( selector, context ) {\n\t\t\treturn this.pushStack(\n\t\t\t\tjQuery.uniqueSort(\n\t\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\n\t\taddBack: function( selector ) {\n\t\t\treturn this.add( selector == null ?\n\t\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t\t);\n\t\t}\n\t} );\n\t\n\tfunction sibling( cur, dir ) {\n\t\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\t\treturn cur;\n\t}\n\t\n\tjQuery.each( {\n\t\tparent: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function( elem ) {\n\t\t\treturn dir( elem, \"parentNode\" );\n\t\t},\n\t\tparentsUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"parentNode\", until );\n\t\t},\n\t\tnext: function( elem ) {\n\t\t\treturn sibling( elem, \"nextSibling\" );\n\t\t},\n\t\tprev: function( elem ) {\n\t\t\treturn sibling( elem, \"previousSibling\" );\n\t\t},\n\t\tnextAll: function( elem ) {\n\t\t\treturn dir( elem, \"nextSibling\" );\n\t\t},\n\t\tprevAll: function( elem ) {\n\t\t\treturn dir( elem, \"previousSibling\" );\n\t\t},\n\t\tnextUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"nextSibling\", until );\n\t\t},\n\t\tprevUntil: function( elem, i, until ) {\n\t\t\treturn dir( elem, \"previousSibling\", until );\n\t\t},\n\t\tsiblings: function( elem ) {\n\t\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t\t},\n\t\tchildren: function( elem ) {\n\t\t\treturn siblings( elem.firstChild );\n\t\t},\n\t\tcontents: function( elem ) {\n\t\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t\t}\n\t}, function( name, fn ) {\n\t\tjQuery.fn[ name ] = function( until, selector ) {\n\t\t\tvar matched = jQuery.map( this, fn, until );\n\t\n\t\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\t\tselector = until;\n\t\t\t}\n\t\n\t\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t\t}\n\t\n\t\t\tif ( this.length > 1 ) {\n\t\n\t\t\t\t// Remove duplicates\n\t\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t\t}\n\t\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\t\tmatched.reverse();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( matched );\n\t\t};\n\t} );\n\tvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\t\n\t\n\t\n\t// Convert String-formatted options into Object-formatted ones\n\tfunction createOptions( options ) {\n\t\tvar object = {};\n\t\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\t\tobject[ flag ] = true;\n\t\t} );\n\t\treturn object;\n\t}\n\t\n\t/*\n\t * Create a callback list using the following parameters:\n\t *\n\t *\toptions: an optional list of space-separated options that will change how\n\t *\t\t\tthe callback list behaves or a more traditional option object\n\t *\n\t * By default a callback list will act like an event callback list and can be\n\t * \"fired\" multiple times.\n\t *\n\t * Possible options:\n\t *\n\t *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n\t *\n\t *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n\t *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n\t *\t\t\t\t\tvalues (like a Deferred)\n\t *\n\t *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n\t *\n\t *\tstopOnFalse:\tinterrupt callings when a callback returns false\n\t *\n\t */\n\tjQuery.Callbacks = function( options ) {\n\t\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ?\n\t\t\tcreateOptions( options ) :\n\t\t\tjQuery.extend( {}, options );\n\t\n\t\tvar // Flag to know if list is currently firing\n\t\t\tfiring,\n\t\n\t\t\t// Last fire value for non-forgettable lists\n\t\t\tmemory,\n\t\n\t\t\t// Flag to know if list was already fired\n\t\t\tfired,\n\t\n\t\t\t// Flag to prevent firing\n\t\t\tlocked,\n\t\n\t\t\t// Actual callback list\n\t\t\tlist = [],\n\t\n\t\t\t// Queue of execution data for repeatable lists\n\t\t\tqueue = [],\n\t\n\t\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\t\tfiringIndex = -1,\n\t\n\t\t\t// Fire callbacks\n\t\t\tfire = function() {\n\t\n\t\t\t\t// Enforce single-firing\n\t\t\t\tlocked = options.once;\n\t\n\t\t\t\t// Execute callbacks for all pending executions,\n\t\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\t\tfired = firing = true;\n\t\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\t\tmemory = queue.shift();\n\t\t\t\t\twhile ( ++firingIndex < list.length ) {\n\t\n\t\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\t\toptions.stopOnFalse ) {\n\t\n\t\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Forget the data if we're done with it\n\t\t\t\tif ( !options.memory ) {\n\t\t\t\t\tmemory = false;\n\t\t\t\t}\n\t\n\t\t\t\tfiring = false;\n\t\n\t\t\t\t// Clean up if we're done firing for good\n\t\t\t\tif ( locked ) {\n\t\n\t\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\t\tif ( memory ) {\n\t\t\t\t\t\tlist = [];\n\t\n\t\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// Actual Callbacks object\n\t\t\tself = {\n\t\n\t\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\t\tadd: function() {\n\t\t\t\t\tif ( list ) {\n\t\n\t\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\t\n\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} )( arguments );\n\t\n\t\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Remove a callback from the list\n\t\t\t\tremove: function() {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Check if a given callback is in the list.\n\t\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\t\thas: function( fn ) {\n\t\t\t\t\treturn fn ?\n\t\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\t\tlist.length > 0;\n\t\t\t\t},\n\t\n\t\t\t\t// Remove all callbacks from the list\n\t\t\t\tempty: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\tlist = [];\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Disable .fire and .add\n\t\t\t\t// Abort any current/pending executions\n\t\t\t\t// Clear all callbacks and values\n\t\t\t\tdisable: function() {\n\t\t\t\t\tlocked = queue = [];\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tdisabled: function() {\n\t\t\t\t\treturn !list;\n\t\t\t\t},\n\t\n\t\t\t\t// Disable .fire\n\t\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t\t// Abort any pending executions\n\t\t\t\tlock: function() {\n\t\t\t\t\tlocked = queue = [];\n\t\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tlocked: function() {\n\t\t\t\t\treturn !!locked;\n\t\t\t\t},\n\t\n\t\t\t\t// Call all callbacks with the given context and arguments\n\t\t\t\tfireWith: function( context, args ) {\n\t\t\t\t\tif ( !locked ) {\n\t\t\t\t\t\targs = args || [];\n\t\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\t\tqueue.push( args );\n\t\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// Call all the callbacks with the given arguments\n\t\t\t\tfire: function() {\n\t\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\n\t\t\t\t// To know if the callbacks have already been called at least once\n\t\t\t\tfired: function() {\n\t\t\t\t\treturn !!fired;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\treturn self;\n\t};\n\t\n\t\n\tfunction Identity( v ) {\n\t\treturn v;\n\t}\n\tfunction Thrower( ex ) {\n\t\tthrow ex;\n\t}\n\t\n\tfunction adoptValue( value, resolve, reject ) {\n\t\tvar method;\n\t\n\t\ttry {\n\t\n\t\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\t\n\t\t\t// Other thenables\n\t\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\t\tmethod.call( value, resolve, reject );\n\t\n\t\t\t// Other non-thenables\n\t\t\t} else {\n\t\n\t\t\t\t// Support: Android 4.0 only\n\t\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\t\tresolve.call( undefined, value );\n\t\t\t}\n\t\n\t\t// For Promises/A+, convert exceptions into rejections\n\t\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t\t// Deferred#then to conditionally suppress rejection.\n\t\t} catch ( value ) {\n\t\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\treject.call( undefined, value );\n\t\t}\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\tDeferred: function( func ) {\n\t\t\tvar tuples = [\n\t\n\t\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t\t],\n\t\t\t\tstate = \"pending\",\n\t\t\t\tpromise = {\n\t\t\t\t\tstate: function() {\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t},\n\t\t\t\t\talways: function() {\n\t\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Keep pipe for back-compat\n\t\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\t\tvar fns = arguments;\n\t\n\t\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\n\t\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\t\n\t\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tfns = null;\n\t\t\t\t\t\t} ).promise();\n\t\t\t\t\t},\n\t\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\t\tvar returned, then;\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\t\tthen = returned &&\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\t\treturned.then;\n\t\n\t\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\n\t\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\n\t\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} ).promise();\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Get a promise for this deferred\n\t\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdeferred = {};\n\t\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\tvar list = tuple[ 2 ],\n\t\t\t\t\tstateString = tuple[ 5 ];\n\t\n\t\t\t\t// promise.progress = list.add\n\t\t\t\t// promise.done = list.add\n\t\t\t\t// promise.fail = list.add\n\t\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\t\n\t\t\t\t// Handle state\n\t\t\t\tif ( stateString ) {\n\t\t\t\t\tlist.add(\n\t\t\t\t\t\tfunction() {\n\t\n\t\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t\t},\n\t\n\t\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\t\n\t\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\t// progress_handlers.fire\n\t\t\t\t// fulfilled_handlers.fire\n\t\t\t\t// rejected_handlers.fire\n\t\t\t\tlist.add( tuple[ 3 ].fire );\n\t\n\t\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\n\t\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t\t} );\n\t\n\t\t\t// Make the deferred a promise\n\t\t\tpromise.promise( deferred );\n\t\n\t\t\t// Call given func if any\n\t\t\tif ( func ) {\n\t\t\t\tfunc.call( deferred, deferred );\n\t\t\t}\n\t\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\t\n\t\t// Deferred helper\n\t\twhen: function( singleValue ) {\n\t\t\tvar\n\t\n\t\t\t\t// count of uncompleted subordinates\n\t\t\t\tremaining = arguments.length,\n\t\n\t\t\t\t// count of unprocessed arguments\n\t\t\t\ti = remaining,\n\t\n\t\t\t\t// subordinate fulfillment data\n\t\t\t\tresolveContexts = Array( i ),\n\t\t\t\tresolveValues = slice.call( arguments ),\n\t\n\t\t\t\t// the master Deferred\n\t\t\t\tmaster = jQuery.Deferred(),\n\t\n\t\t\t\t// subordinate callback factory\n\t\t\t\tupdateFunc = function( i ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\n\t\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\t\tif ( remaining <= 1 ) {\n\t\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\t\n\t\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\t\n\t\t\t\t\treturn master.then();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\t\twhile ( i-- ) {\n\t\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t\t}\n\t\n\t\t\treturn master.promise();\n\t\t}\n\t} );\n\t\n\t\n\t// These usually indicate a programmer mistake during development,\n\t// warn about them ASAP rather than swallowing them by default.\n\tvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\t\n\tjQuery.Deferred.exceptionHook = function( error, stack ) {\n\t\n\t\t// Support: IE 8 - 9 only\n\t\t// Console exists when dev tools are open, which can happen at any time\n\t\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t\t}\n\t};\n\t\n\t\n\t\n\t\n\tjQuery.readyException = function( error ) {\n\t\twindow.setTimeout( function() {\n\t\t\tthrow error;\n\t\t} );\n\t};\n\t\n\t\n\t\n\t\n\t// The deferred used on DOM ready\n\tvar readyList = jQuery.Deferred();\n\t\n\tjQuery.fn.ready = function( fn ) {\n\t\n\t\treadyList\n\t\t\t.then( fn )\n\t\n\t\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t\t// happens at the time of error handling instead of callback\n\t\t\t// registration.\n\t\t\t.catch( function( error ) {\n\t\t\t\tjQuery.readyException( error );\n\t\t\t} );\n\t\n\t\treturn this;\n\t};\n\t\n\tjQuery.extend( {\n\t\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\t\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\t\n\t\t// Hold (or release) the ready event\n\t\tholdReady: function( hold ) {\n\t\t\tif ( hold ) {\n\t\t\t\tjQuery.readyWait++;\n\t\t\t} else {\n\t\t\t\tjQuery.ready( true );\n\t\t\t}\n\t\t},\n\t\n\t\t// Handle when the DOM is ready\n\t\tready: function( wait ) {\n\t\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\t\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith( document, [ jQuery ] );\n\t\t}\n\t} );\n\t\n\tjQuery.ready.then = readyList.then;\n\t\n\t// The ready event handler and self cleanup method\n\tfunction completed() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\t\twindow.removeEventListener( \"load\", completed );\n\t\tjQuery.ready();\n\t}\n\t\n\t// Catch cases where $(document).ready() is called\n\t// after the browser event has already occurred.\n\t// Support: IE <=9 - 10 only\n\t// Older IE sometimes signals \"interactive\" too soon\n\tif ( document.readyState === \"complete\" ||\n\t\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\t\n\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\twindow.setTimeout( jQuery.ready );\n\t\n\t} else {\n\t\n\t\t// Use the handy event callback\n\t\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\t\n\t\t// A fallback to window.onload, that will always work\n\t\twindow.addEventListener( \"load\", completed );\n\t}\n\t\n\t\n\t\n\t\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlen = elems.length,\n\t\t\tbulk = key == null;\n\t\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t\t}\n\t\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\t\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\t\n\t\t\tif ( bulk ) {\n\t\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\t\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tfn(\n\t\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\t\tvalue :\n\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif ( chainable ) {\n\t\t\treturn elems;\n\t\t}\n\t\n\t\t// Gets\n\t\tif ( bulk ) {\n\t\t\treturn fn.call( elems );\n\t\t}\n\t\n\t\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n\t};\n\tvar acceptData = function( owner ) {\n\t\n\t\t// Accepts only:\n\t\t//  - Node\n\t\t//    - Node.ELEMENT_NODE\n\t\t//    - Node.DOCUMENT_NODE\n\t\t//  - Object\n\t\t//    - Any\n\t\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n\t};\n\t\n\t\n\t\n\t\n\tfunction Data() {\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\t\n\tData.uid = 1;\n\t\n\tData.prototype = {\n\t\n\t\tcache: function( owner ) {\n\t\n\t\t\t// Check if the owner object already has a cache\n\t\t\tvar value = owner[ this.expando ];\n\t\n\t\t\t// If not, create one\n\t\t\tif ( !value ) {\n\t\t\t\tvalue = {};\n\t\n\t\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t\t// but we should not, see #8335.\n\t\t\t\t// Always return an empty object.\n\t\t\t\tif ( acceptData( owner ) ) {\n\t\n\t\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t\t// use plain assignment\n\t\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\t\towner[ this.expando ] = value;\n\t\n\t\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t\t// deleted when data is removed\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn value;\n\t\t},\n\t\tset: function( owner, data, value ) {\n\t\t\tvar prop,\n\t\t\t\tcache = this.cache( owner );\n\t\n\t\t\t// Handle: [ owner, key, value ] args\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\t\n\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\t\n\t\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cache;\n\t\t},\n\t\tget: function( owner, key ) {\n\t\t\treturn key === undefined ?\n\t\t\t\tthis.cache( owner ) :\n\t\n\t\t\t\t// Always use camelCase key (gh-2257)\n\t\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t\t},\n\t\taccess: function( owner, key, value ) {\n\t\n\t\t\t// In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\t\t\tif ( key === undefined ||\n\t\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\t\n\t\t\t\treturn this.get( owner, key );\n\t\t\t}\n\t\n\t\t\t// When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\t\t\tthis.set( owner, key, value );\n\t\n\t\t\t// Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function( owner, key ) {\n\t\t\tvar i,\n\t\t\t\tcache = owner[ this.expando ];\n\t\n\t\t\tif ( cache === undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( key !== undefined ) {\n\t\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif ( jQuery.isArray( key ) ) {\n\t\n\t\t\t\t\t// If key is an array of keys...\n\t\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t\t} else {\n\t\t\t\t\tkey = jQuery.camelCase( key );\n\t\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tkey = key in cache ?\n\t\t\t\t\t\t[ key ] :\n\t\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t\t}\n\t\n\t\t\t\ti = key.length;\n\t\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove the expando if there's no more data\n\t\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\t\n\t\t\t\t// Support: Chrome <=35 - 45\n\t\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tdelete owner[ this.expando ];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function( owner ) {\n\t\t\tvar cache = owner[ this.expando ];\n\t\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t\t}\n\t};\n\tvar dataPriv = new Data();\n\t\n\tvar dataUser = new Data();\n\t\n\t\n\t\n\t//\tImplementation Summary\n\t//\n\t//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t//\t2. Improve the module's maintainability by reducing the storage\n\t//\t\tpaths to a single mechanism.\n\t//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\t\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t\trmultiDash = /[A-Z]/g;\n\t\n\tfunction getData( data ) {\n\t\tif ( data === \"true\" ) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif ( data === \"false\" ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif ( data === \"null\" ) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Only convert to a number if it doesn't change the string\n\t\tif ( data === +data + \"\" ) {\n\t\t\treturn +data;\n\t\t}\n\t\n\t\tif ( rbrace.test( data ) ) {\n\t\t\treturn JSON.parse( data );\n\t\t}\n\t\n\t\treturn data;\n\t}\n\t\n\tfunction dataAttr( elem, key, data ) {\n\t\tvar name;\n\t\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\t\tdata = elem.getAttribute( name );\n\t\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\ttry {\n\t\t\t\t\tdata = getData( data );\n\t\t\t\t} catch ( e ) {}\n\t\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tdataUser.set( elem, key, data );\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\t\n\tjQuery.extend( {\n\t\thasData: function( elem ) {\n\t\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t\t},\n\t\n\t\tdata: function( elem, name, data ) {\n\t\t\treturn dataUser.access( elem, name, data );\n\t\t},\n\t\n\t\tremoveData: function( elem, name ) {\n\t\t\tdataUser.remove( elem, name );\n\t\t},\n\t\n\t\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t\t// with direct calls to dataPriv methods, these can be deprecated.\n\t\t_data: function( elem, name, data ) {\n\t\t\treturn dataPriv.access( elem, name, data );\n\t\t},\n\t\n\t\t_removeData: function( elem, name ) {\n\t\t\tdataPriv.remove( elem, name );\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tdata: function( key, value ) {\n\t\t\tvar i, name, data,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tattrs = elem && elem.attributes;\n\t\n\t\t\t// Gets all values\n\t\t\tif ( key === undefined ) {\n\t\t\t\tif ( this.length ) {\n\t\t\t\t\tdata = dataUser.get( elem );\n\t\n\t\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\n\t\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\t\t}\n\t\n\t\t\t// Sets multiple values\n\t\t\tif ( typeof key === \"object\" ) {\n\t\t\t\treturn this.each( function() {\n\t\t\t\t\tdataUser.set( this, key );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar data;\n\t\n\t\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\t\tif ( elem && value === undefined ) {\n\t\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Set the data...\n\t\t\t\tthis.each( function() {\n\t\n\t\t\t\t\t// We always store the camelCased key\n\t\t\t\t\tdataUser.set( this, key, value );\n\t\t\t\t} );\n\t\t\t}, null, value, arguments.length > 1, null, true );\n\t\t},\n\t\n\t\tremoveData: function( key ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.remove( this, key );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.extend( {\n\t\tqueue: function( elem, type, data ) {\n\t\t\tvar queue;\n\t\n\t\t\tif ( elem ) {\n\t\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\t\tqueue = dataPriv.get( elem, type );\n\t\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push( data );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\t\n\t\tdequeue: function( elem, type ) {\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\t\tstartLength = queue.length,\n\t\t\t\tfn = queue.shift(),\n\t\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\t\tnext = function() {\n\t\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t\t};\n\t\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif ( fn === \"inprogress\" ) {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\t\n\t\t\tif ( fn ) {\n\t\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif ( type === \"fx\" ) {\n\t\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t\t}\n\t\n\t\t\t\t// Clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call( elem, next, hooks );\n\t\t\t}\n\t\n\t\t\tif ( !startLength && hooks ) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\t\n\t\t// Not public - generate a queueHooks object, or return the current one\n\t\t_queueHooks: function( elem, type ) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t\t} )\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tqueue: function( type, data ) {\n\t\t\tvar setter = 2;\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\t\n\t\t\tif ( arguments.length < setter ) {\n\t\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t\t}\n\t\n\t\t\treturn data === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function() {\n\t\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\t\n\t\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\t\tjQuery._queueHooks( this, type );\n\t\n\t\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t},\n\t\tdequeue: function( type ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t} );\n\t\t},\n\t\tclearQueue: function( type ) {\n\t\t\treturn this.queue( type || \"fx\", [] );\n\t\t},\n\t\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function( type, obj ) {\n\t\t\tvar tmp,\n\t\t\t\tcount = 1,\n\t\t\t\tdefer = jQuery.Deferred(),\n\t\t\t\telements = this,\n\t\t\t\ti = this.length,\n\t\t\t\tresolve = function() {\n\t\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\t\n\t\t\twhile ( i-- ) {\n\t\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add( resolve );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise( obj );\n\t\t}\n\t} );\n\tvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\t\n\tvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\t\n\t\n\tvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\t\n\tvar isHiddenWithinTree = function( elem, el ) {\n\t\n\t\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t\t// in that case, element will be second argument\n\t\t\telem = el || elem;\n\t\n\t\t\t// Inline style trumps all\n\t\t\treturn elem.style.display === \"none\" ||\n\t\t\t\telem.style.display === \"\" &&\n\t\n\t\t\t\t// Otherwise, check computed style\n\t\t\t\t// Support: Firefox <=43 - 45\n\t\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t\t// in the document.\n\t\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\t\n\t\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t\t};\n\t\n\tvar swap = function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\t\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\t\n\t\tret = callback.apply( elem, args || [] );\n\t\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\t\n\t\treturn ret;\n\t};\n\t\n\t\n\t\n\t\n\tfunction adjustCSS( elem, prop, valueParts, tween ) {\n\t\tvar adjusted,\n\t\t\tscale = 1,\n\t\t\tmaxIterations = 20,\n\t\t\tcurrentValue = tween ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn tween.cur();\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t\t},\n\t\t\tinitial = currentValue(),\n\t\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\t\n\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\t\n\t\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\t\n\t\t\t// Trust units reported by jQuery.css\n\t\t\tunit = unit || initialInUnit[ 3 ];\n\t\n\t\t\t// Make sure we update the tween properties later on\n\t\t\tvalueParts = valueParts || [];\n\t\n\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\tinitialInUnit = +initial || 1;\n\t\n\t\t\tdo {\n\t\n\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\tscale = scale || \".5\";\n\t\n\t\t\t\t// Adjust and apply\n\t\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\n\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t\t} while (\n\t\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t\t);\n\t\t}\n\t\n\t\tif ( valueParts ) {\n\t\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\t\n\t\t\t// Apply relative offset (+=/-=) if specified\n\t\t\tadjusted = valueParts[ 1 ] ?\n\t\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t\t+valueParts[ 2 ];\n\t\t\tif ( tween ) {\n\t\t\t\ttween.unit = unit;\n\t\t\t\ttween.start = initialInUnit;\n\t\t\t\ttween.end = adjusted;\n\t\t\t}\n\t\t}\n\t\treturn adjusted;\n\t}\n\t\n\t\n\tvar defaultDisplayMap = {};\n\t\n\tfunction getDefaultDisplay( elem ) {\n\t\tvar temp,\n\t\t\tdoc = elem.ownerDocument,\n\t\t\tnodeName = elem.nodeName,\n\t\t\tdisplay = defaultDisplayMap[ nodeName ];\n\t\n\t\tif ( display ) {\n\t\t\treturn display;\n\t\t}\n\t\n\t\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\t\tdisplay = jQuery.css( temp, \"display\" );\n\t\n\t\ttemp.parentNode.removeChild( temp );\n\t\n\t\tif ( display === \"none\" ) {\n\t\t\tdisplay = \"block\";\n\t\t}\n\t\tdefaultDisplayMap[ nodeName ] = display;\n\t\n\t\treturn display;\n\t}\n\t\n\tfunction showHide( elements, show ) {\n\t\tvar display, elem,\n\t\t\tvalues = [],\n\t\t\tindex = 0,\n\t\t\tlength = elements.length;\n\t\n\t\t// Determine new display value for elements that need to change\n\t\tfor ( ; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tdisplay = elem.style.display;\n\t\t\tif ( show ) {\n\t\n\t\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t\t// inline or about-to-be-restored)\n\t\t\t\tif ( display === \"none\" ) {\n\t\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( display !== \"none\" ) {\n\t\t\t\t\tvalues[ index ] = \"none\";\n\t\n\t\t\t\t\t// Remember what we're overwriting\n\t\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Set the display of the elements in a second loop to avoid constant reflow\n\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\tif ( values[ index ] != null ) {\n\t\t\t\telements[ index ].style.display = values[ index ];\n\t\t\t}\n\t\t}\n\t\n\t\treturn elements;\n\t}\n\t\n\tjQuery.fn.extend( {\n\t\tshow: function() {\n\t\t\treturn showHide( this, true );\n\t\t},\n\t\thide: function() {\n\t\t\treturn showHide( this );\n\t\t},\n\t\ttoggle: function( state ) {\n\t\t\tif ( typeof state === \"boolean\" ) {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\t\tjQuery( this ).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery( this ).hide();\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\tvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\t\n\tvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\t\n\tvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\t\n\t\n\t\n\t// We have to close these tags to support XHTML (#13200)\n\tvar wrapMap = {\n\t\n\t\t// Support: IE <=9 only\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\n\t\t// XHTML parsers do not magically insert elements in the\n\t\t// same way that tag soup parsers do. So we cannot shorten\n\t\t// this by omitting <tbody> or other required elements.\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\t\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\t\n\t// Support: IE <=9 only\n\twrapMap.optgroup = wrapMap.option;\n\t\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\t\n\t\n\tfunction getAll( context, tag ) {\n\t\n\t\t// Support: IE <=9 - 11 only\n\t\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\t\tvar ret;\n\t\n\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\tret = context.getElementsByTagName( tag || \"*\" );\n\t\n\t\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\t\tret = context.querySelectorAll( tag || \"*\" );\n\t\n\t\t} else {\n\t\t\tret = [];\n\t\t}\n\t\n\t\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\t\treturn jQuery.merge( [ context ], ret );\n\t\t}\n\t\n\t\treturn ret;\n\t}\n\t\n\t\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval( elems, refElements ) {\n\t\tvar i = 0,\n\t\t\tl = elems.length;\n\t\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tdataPriv.set(\n\t\t\t\telems[ i ],\n\t\t\t\t\"globalEval\",\n\t\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t\t);\n\t\t}\n\t}\n\t\n\t\n\tvar rhtml = /<|&#?\\w+;/;\n\t\n\tfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\t\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\t\n\t\t\tif ( elem || elem === 0 ) {\n\t\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\t\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\t\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\t\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\t\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\t\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\t\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\t\n\t\ti = 0;\n\t\twhile ( ( elem = nodes[ i++ ] ) ) {\n\t\n\t\t\t// Skip elements already in the context collection (trac-4087)\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\t\tif ( ignored ) {\n\t\t\t\t\tignored.push( elem );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\t\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\t\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn fragment;\n\t}\n\t\n\t\n\t( function() {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\t\tinput = document.createElement( \"input\" );\n\t\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Check state lost if the name is set (#11217)\n\t\t// Support: Windows Web Apps (WWA)\n\t\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\t\tinput.setAttribute( \"type\", \"radio\" );\n\t\tinput.setAttribute( \"checked\", \"checked\" );\n\t\tinput.setAttribute( \"name\", \"t\" );\n\t\n\t\tdiv.appendChild( input );\n\t\n\t\t// Support: Android <=4.1 only\n\t\t// Older WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\t\n\t\t// Support: IE <=11 only\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\t} )();\n\tvar documentElement = document.documentElement;\n\t\n\t\n\t\n\tvar\n\t\trkeyEvent = /^key/,\n\t\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\t\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\t\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\t\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\t\n\t// Support: IE <=9 only\n\t// See #13393 for more info\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch ( err ) { }\n\t}\n\t\n\tfunction on( elem, types, selector, data, fn, one ) {\n\t\tvar origFn, type;\n\t\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn elem;\n\t\t}\n\t\n\t\tif ( data == null && fn == null ) {\n\t\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn elem;\n\t\t}\n\t\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn elem.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t} );\n\t}\n\t\n\t/*\n\t * Helper functions for managing events -- not part of the public interface.\n\t * Props to Dean Edwards' addEvent library for many of the ideas.\n\t */\n\tjQuery.event = {\n\t\n\t\tglobal: {},\n\t\n\t\tadd: function( elem, types, handler, data, selector ) {\n\t\n\t\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = dataPriv.get( elem );\n\t\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif ( !elemData ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif ( handler.handler ) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\t\n\t\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\t\tif ( selector ) {\n\t\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t\t}\n\t\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif ( !handler.guid ) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\t\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif ( !( events = elemData.events ) ) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\t\teventHandle = elemData.handle = function( e ) {\n\t\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\t\ttype = origType = tmp[ 1 ];\n\t\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend( {\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t\t}, handleObjIn );\n\t\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\t\n\t\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\t\tif ( !special.setup ||\n\t\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\n\t\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( special.add ) {\n\t\t\t\t\tspecial.add.call( elem, handleObj );\n\t\n\t\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif ( selector ) {\n\t\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push( handleObj );\n\t\t\t\t}\n\t\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[ type ] = true;\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// Detach an event or set of events from an element\n\t\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\n\t\t\tvar j, origCount, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\t\n\t\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\t\ttype = origType = tmp[ 1 ];\n\t\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\t\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tfor ( type in events ) {\n\t\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\t\thandlers = events[ type ] || [];\n\t\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\t\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\thandleObj = handlers[ j ];\n\t\n\t\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\t\thandlers.splice( j, 1 );\n\t\n\t\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\n\t\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdelete events[ type ];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove data and the expando if it's no longer used\n\t\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t\t}\n\t\t},\n\t\n\t\tdispatch: function( nativeEvent ) {\n\t\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tvar event = jQuery.event.fix( nativeEvent );\n\t\n\t\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\t\targs = new Array( arguments.length ),\n\t\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\t\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[ 0 ] = event;\n\t\n\t\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\t\targs[ i ] = arguments[ i ];\n\t\t\t}\n\t\n\t\t\tevent.delegateTarget = this;\n\t\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\t\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\t\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\t\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\t\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\t\n\t\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\t\n\t\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif ( special.postDispatch ) {\n\t\t\t\tspecial.postDispatch.call( this, event );\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\thandlers: function( event, handlers ) {\n\t\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\t\thandlerQueue = [],\n\t\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\t\tcur = event.target;\n\t\n\t\t\t// Find delegate handlers\n\t\t\tif ( delegateCount &&\n\t\n\t\t\t\t// Support: IE <=9\n\t\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\t\tcur.nodeType &&\n\t\n\t\t\t\t// Support: Firefox <=42\n\t\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t\t// Support: IE 11 only\n\t\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\t\n\t\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\t\n\t\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\t\thandleObj = handlers[ i ];\n\t\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\t\n\t\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tcur = this;\n\t\t\tif ( delegateCount < handlers.length ) {\n\t\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t\t}\n\t\n\t\t\treturn handlerQueue;\n\t\t},\n\t\n\t\taddProp: function( name, hook ) {\n\t\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\n\t\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t\t}\n\t\t\t\t\t} :\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\n\t\t\t\tset: function( value ) {\n\t\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tfix: function( originalEvent ) {\n\t\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\t\toriginalEvent :\n\t\t\t\tnew jQuery.Event( originalEvent );\n\t\t},\n\t\n\t\tspecial: {\n\t\t\tload: {\n\t\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\t\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\t\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function( event ) {\n\t\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function( event ) {\n\t\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.removeEvent = function( elem, type, handle ) {\n\t\n\t\t// This \"if\" is needed for plain objects\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle );\n\t\t}\n\t};\n\t\n\tjQuery.Event = function( src, props ) {\n\t\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif ( !( this instanceof jQuery.Event ) ) {\n\t\t\treturn new jQuery.Event( src, props );\n\t\t}\n\t\n\t\t// Event object\n\t\tif ( src && src.type ) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\t\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\n\t\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\t\tsrc.returnValue === false ?\n\t\t\t\treturnTrue :\n\t\t\t\treturnFalse;\n\t\n\t\t\t// Create target properties\n\t\t\t// Support: Safari <=6 - 7 only\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\t\tsrc.target.parentNode :\n\t\t\t\tsrc.target;\n\t\n\t\t\tthis.currentTarget = src.currentTarget;\n\t\t\tthis.relatedTarget = src.relatedTarget;\n\t\n\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\t\n\t\t// Put explicitly provided properties onto the event object\n\t\tif ( props ) {\n\t\t\tjQuery.extend( this, props );\n\t\t}\n\t\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\t\n\t\t// Mark it as fixed\n\t\tthis[ jQuery.expando ] = true;\n\t};\n\t\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tconstructor: jQuery.Event,\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\t\tisSimulated: false,\n\t\n\t\tpreventDefault: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isPropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tstopImmediatePropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\t\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\n\t\t\tif ( e && !this.isSimulated ) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\t\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\t\n\t// Includes all common event props including KeyEvent and MouseEvent specific props\n\tjQuery.each( {\n\t\taltKey: true,\n\t\tbubbles: true,\n\t\tcancelable: true,\n\t\tchangedTouches: true,\n\t\tctrlKey: true,\n\t\tdetail: true,\n\t\teventPhase: true,\n\t\tmetaKey: true,\n\t\tpageX: true,\n\t\tpageY: true,\n\t\tshiftKey: true,\n\t\tview: true,\n\t\t\"char\": true,\n\t\tcharCode: true,\n\t\tkey: true,\n\t\tkeyCode: true,\n\t\tbutton: true,\n\t\tbuttons: true,\n\t\tclientX: true,\n\t\tclientY: true,\n\t\toffsetX: true,\n\t\toffsetY: true,\n\t\tpointerId: true,\n\t\tpointerType: true,\n\t\tscreenX: true,\n\t\tscreenY: true,\n\t\ttargetTouches: true,\n\t\ttoElement: true,\n\t\ttouches: true,\n\t\n\t\twhich: function( event ) {\n\t\t\tvar button = event.button;\n\t\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t\t}\n\t\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\t\tif ( button & 1 ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\tif ( button & 2 ) {\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\n\t\t\t\tif ( button & 4 ) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\treturn event.which;\n\t\t}\n\t}, jQuery.event.addProp );\n\t\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// so that event delegation works in jQuery.\n\t// Do the same for pointerenter/pointerleave and pointerover/pointerout\n\t//\n\t// Support: Safari 7 only\n\t// Safari sends mouseenter too often; see:\n\t// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n\t// for the description of the bug (it existed in older Chrome versions as well).\n\tjQuery.each( {\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t}, function( orig, fix ) {\n\t\tjQuery.event.special[ orig ] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\t\n\t\t\thandle: function( event ) {\n\t\t\t\tvar ret,\n\t\t\t\t\ttarget = this,\n\t\t\t\t\trelated = event.relatedTarget,\n\t\t\t\t\thandleObj = event.handleObj;\n\t\n\t\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\n\t\ton: function( types, selector, data, fn ) {\n\t\t\treturn on( this, types, selector, data, fn );\n\t\t},\n\t\tone: function( types, selector, data, fn ) {\n\t\t\treturn on( this, types, selector, data, fn, 1 );\n\t\t},\n\t\toff: function( types, selector, fn ) {\n\t\t\tvar handleObj, type;\n\t\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\t\thandleObj.namespace ?\n\t\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\t\thandleObj.origType,\n\t\t\t\t\thandleObj.selector,\n\t\t\t\t\thandleObj.handler\n\t\t\t\t);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( typeof types === \"object\" ) {\n\t\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t\n\tvar\n\t\n\t\t/* eslint-disable max-len */\n\t\n\t\t// See https://github.com/eslint/eslint/issues/3229\n\t\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\t\n\t\t/* eslint-enable */\n\t\n\t\t// Support: IE <=10 - 11, Edge 12 - 13\n\t\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\t\trnoInnerhtml = /<script|<style|<link/i,\n\t\n\t\t// checked=\"checked\" or checked\n\t\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t\trscriptTypeMasked = /^true\\/(.*)/,\n\t\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\t\n\tfunction manipulationTarget( elem, content ) {\n\t\tif ( jQuery.nodeName( elem, \"table\" ) &&\n\t\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\t\n\t\t\treturn elem.getElementsByTagName( \"tbody\" )[ 0 ] || elem;\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript( elem ) {\n\t\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript( elem ) {\n\t\tvar match = rscriptTypeMasked.exec( elem.type );\n\t\n\t\tif ( match ) {\n\t\t\telem.type = match[ 1 ];\n\t\t} else {\n\t\t\telem.removeAttribute( \"type\" );\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\tfunction cloneCopyEvent( src, dest ) {\n\t\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\t\n\t\tif ( dest.nodeType !== 1 ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// 1. Copy private data: events, handlers, etc.\n\t\tif ( dataPriv.hasData( src ) ) {\n\t\t\tpdataOld = dataPriv.access( src );\n\t\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\t\tevents = pdataOld.events;\n\t\n\t\t\tif ( events ) {\n\t\t\t\tdelete pdataCur.handle;\n\t\t\t\tpdataCur.events = {};\n\t\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// 2. Copy user data\n\t\tif ( dataUser.hasData( src ) ) {\n\t\t\tudataOld = dataUser.access( src );\n\t\t\tudataCur = jQuery.extend( {}, udataOld );\n\t\n\t\t\tdataUser.set( dest, udataCur );\n\t\t}\n\t}\n\t\n\t// Fix IE bugs, see support tests\n\tfunction fixInput( src, dest ) {\n\t\tvar nodeName = dest.nodeName.toLowerCase();\n\t\n\t\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\t\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t\tdest.checked = src.checked;\n\t\n\t\t// Fails to return the selected option to the default selected state when cloning options\n\t\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\t\n\tfunction domManip( collection, args, callback, ignored ) {\n\t\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\t\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = collection.length,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn collection.each( function( index ) {\n\t\t\t\tvar self = collection.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tdomManip( self, args, callback, ignored );\n\t\t\t} );\n\t\t}\n\t\n\t\tif ( l ) {\n\t\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\t\tfirst = fragment.firstChild;\n\t\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\t\n\t\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\t\tif ( first || ignored ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\t\n\t\t\t\t// Use the original fragment for the last item\n\t\t\t\t// instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\t\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\t\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\n\t\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\t\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\t\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\t\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn collection;\n\t}\n\t\n\tfunction remove( elem, selector, keepData ) {\n\t\tvar node,\n\t\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\t\ti = 0;\n\t\n\t\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t\t}\n\t\n\t\t\tif ( node.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t\t}\n\t\t\t\tnode.parentNode.removeChild( node );\n\t\t\t}\n\t\t}\n\t\n\t\treturn elem;\n\t}\n\t\n\tjQuery.extend( {\n\t\thtmlPrefilter: function( html ) {\n\t\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t\t},\n\t\n\t\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\t\tvar i, l, srcElements, destElements,\n\t\t\t\tclone = elem.cloneNode( true ),\n\t\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\t\n\t\t\t// Fix IE cloning issues\n\t\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\t\n\t\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll( clone );\n\t\t\t\tsrcElements = getAll( elem );\n\t\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif ( dataAndEvents ) {\n\t\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\t\tdestElements = destElements || getAll( clone );\n\t\n\t\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll( clone, \"script\" );\n\t\t\tif ( destElements.length > 0 ) {\n\t\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t\t}\n\t\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\t\n\t\tcleanData: function( elems ) {\n\t\t\tvar data, elem, type,\n\t\t\t\tspecial = jQuery.event.special,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\t\n\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\t\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tdetach: function( selector ) {\n\t\t\treturn remove( this, selector, true );\n\t\t},\n\t\n\t\tremove: function( selector ) {\n\t\t\treturn remove( this, selector );\n\t\t},\n\t\n\t\ttext: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\tjQuery.text( this ) :\n\t\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\tappend: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.appendChild( elem );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tprepend: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tbefore: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tafter: function() {\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\tempty: function() {\n\t\t\tvar elem,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\n\t\t\t\t\t// Prevent memory leaks\n\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\n\t\t\t\t\t// Remove any remaining nodes\n\t\t\t\t\telem.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\t\n\t\t\treturn this.map( function() {\n\t\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t\t} );\n\t\t},\n\t\n\t\thtml: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\t\ti = 0,\n\t\t\t\t\tl = this.length;\n\t\n\t\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\t\treturn elem.innerHTML;\n\t\t\t\t}\n\t\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\t\n\t\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\t\telem = this[ i ] || {};\n\t\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\telem = 0;\n\t\n\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch ( e ) {}\n\t\t\t\t}\n\t\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tthis.empty().append( value );\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\t\n\t\treplaceWith: function() {\n\t\t\tvar ignored = [];\n\t\n\t\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\t\tvar parent = this.parentNode;\n\t\n\t\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\t\tif ( parent ) {\n\t\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// Force callback invocation\n\t\t\t}, ignored );\n\t\t}\n\t} );\n\t\n\tjQuery.each( {\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function( name, original ) {\n\t\tjQuery.fn[ name ] = function( selector ) {\n\t\t\tvar elems,\n\t\t\t\tret = [],\n\t\t\t\tinsert = jQuery( selector ),\n\t\t\t\tlast = insert.length - 1,\n\t\t\t\ti = 0;\n\t\n\t\t\tfor ( ; i <= last; i++ ) {\n\t\t\t\telems = i === last ? this : this.clone( true );\n\t\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\t\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tpush.apply( ret, elems.get() );\n\t\t\t}\n\t\n\t\t\treturn this.pushStack( ret );\n\t\t};\n\t} );\n\tvar rmargin = ( /^margin/ );\n\t\n\tvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\t\n\tvar getStyles = function( elem ) {\n\t\n\t\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t\t// IE throws on elements created in popups\n\t\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\t\tvar view = elem.ownerDocument.defaultView;\n\t\n\t\t\tif ( !view || !view.opener ) {\n\t\t\t\tview = window;\n\t\t\t}\n\t\n\t\t\treturn view.getComputedStyle( elem );\n\t\t};\n\t\n\t\n\t\n\t( function() {\n\t\n\t\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t\t// so they're executed at the same time to save the second computation.\n\t\tfunction computeStyleTests() {\n\t\n\t\t\t// This is a singleton, we need to execute it only once\n\t\t\tif ( !div ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tdiv.style.cssText =\n\t\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\t\"position:relative;display:block;\" +\n\t\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\t\"top:1%;width:50%\";\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdocumentElement.appendChild( container );\n\t\n\t\t\tvar divStyle = window.getComputedStyle( div );\n\t\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\n\t\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\t\n\t\t\t// Support: Android 4.0 - 4.3 only\n\t\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\t\tdiv.style.marginRight = \"50%\";\n\t\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\t\n\t\t\tdocumentElement.removeChild( container );\n\t\n\t\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t\t// it will also be a sign that checks already performed\n\t\t\tdiv = null;\n\t\t}\n\t\n\t\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\t\tcontainer = document.createElement( \"div\" ),\n\t\t\tdiv = document.createElement( \"div\" );\n\t\n\t\t// Finish early in limited (non-browser) environments\n\t\tif ( !div.style ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Support: IE <=9 - 11 only\n\t\t// Style of cloned element affects source element cloned (#8908)\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\t\n\t\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\t\"padding:0;margin-top:1px;position:absolute\";\n\t\tcontainer.appendChild( div );\n\t\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\tpixelMarginRight: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelMarginRightVal;\n\t\t\t},\n\t\t\treliableMarginLeft: function() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn reliableMarginLeftVal;\n\t\t\t}\n\t\t} );\n\t} )();\n\t\n\t\n\tfunction curCSS( elem, name, computed ) {\n\t\tvar width, minWidth, maxWidth, ret,\n\t\t\tstyle = elem.style;\n\t\n\t\tcomputed = computed || getStyles( elem );\n\t\n\t\t// Support: IE <=9 only\n\t\t// getPropertyValue is only needed for .css('filter') (#12537)\n\t\tif ( computed ) {\n\t\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\t\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Android Browser returns percentage for some values,\n\t\t\t// but width seems to be reliably pixels.\n\t\t\t// This is against the CSSOM draft spec:\n\t\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\t\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\t\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\t\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\t\n\t\treturn ret !== undefined ?\n\t\n\t\t\t// Support: IE <=9 - 11 only\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\tret + \"\" :\n\t\t\tret;\n\t}\n\t\n\t\n\tfunction addGetHookIf( conditionFn, hookFn ) {\n\t\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\tif ( conditionFn() ) {\n\t\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t\t// to missing dependency), remove it.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t\t}\n\t\t};\n\t}\n\t\n\t\n\tvar\n\t\n\t\t// Swappable if display is none or starts with table\n\t\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\t\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t\tcssNormalTransform = {\n\t\t\tletterSpacing: \"0\",\n\t\t\tfontWeight: \"400\"\n\t\t},\n\t\n\t\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\t\temptyStyle = document.createElement( \"div\" ).style;\n\t\n\t// Return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName( name ) {\n\t\n\t\t// Shortcut for names that are not vendor prefixed\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t\n\t\t// Check for vendor prefixed names\n\t\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\t\ti = cssPrefixes.length;\n\t\n\t\twhile ( i-- ) {\n\t\t\tname = cssPrefixes[ i ] + capName;\n\t\t\tif ( name in emptyStyle ) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction setPositiveNumber( elem, value, subtract ) {\n\t\n\t\t// Any relative (+/-) values have already been\n\t\t// normalized at this point\n\t\tvar matches = rcssNum.exec( value );\n\t\treturn matches ?\n\t\n\t\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\t\tvalue;\n\t}\n\t\n\tfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\t\tvar i,\n\t\t\tval = 0;\n\t\n\t\t// If we already have the right measurement, avoid augmentation\n\t\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\t\ti = 4;\n\t\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\t} else {\n\t\t\ti = name === \"width\" ? 1 : 0;\n\t\t}\n\t\n\t\tfor ( ; i < 4; i += 2 ) {\n\t\n\t\t\t// Both box models exclude margin, so add it if we want it\n\t\t\tif ( extra === \"margin\" ) {\n\t\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t\t}\n\t\n\t\t\tif ( isBorderBox ) {\n\t\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif ( extra === \"content\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t\t}\n\t\n\t\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t} else {\n\t\n\t\t\t\t// At this point, extra isn't content, so add padding\n\t\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\n\t\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn val;\n\t}\n\t\n\tfunction getWidthOrHeight( elem, name, extra ) {\n\t\n\t\t// Start with offset property, which is equivalent to the border-box value\n\t\tvar val,\n\t\t\tvalueIsBorderBox = true,\n\t\t\tstyles = getStyles( elem ),\n\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\t\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a disconnected node\n\t\t// in IE throws an error.\n\t\tif ( elem.getClientRects().length ) {\n\t\t\tval = elem.getBoundingClientRect()[ name ];\n\t\t}\n\t\n\t\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\t\tif ( val <= 0 || val == null ) {\n\t\n\t\t\t// Fall back to computed then uncomputed css if necessary\n\t\t\tval = curCSS( elem, name, styles );\n\t\t\tif ( val < 0 || val == null ) {\n\t\t\t\tval = elem.style[ name ];\n\t\t\t}\n\t\n\t\t\t// Computed unit is not pixels. Stop here and return.\n\t\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\t\treturn val;\n\t\t\t}\n\t\n\t\t\t// Check for style in case a browser which returns unreliable values\n\t\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\t\n\t\t\t// Normalize \"\", auto, and prepare for extra\n\t\t\tval = parseFloat( val ) || 0;\n\t\t}\n\t\n\t\t// Use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn ( val +\n\t\t\taugmentWidthOrHeight(\n\t\t\t\telem,\n\t\t\t\tname,\n\t\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\t\tvalueIsBorderBox,\n\t\t\t\tstyles\n\t\t\t)\n\t\t) + \"px\";\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"animationIterationCount\": true,\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"flexGrow\": true,\n\t\t\t\"flexShrink\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\t\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t\"float\": \"cssFloat\"\n\t\t},\n\t\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function( elem, name, value, extra ) {\n\t\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret, type, hooks,\n\t\t\t\torigName = jQuery.camelCase( name ),\n\t\t\t\tstyle = elem.style;\n\t\n\t\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\t\n\t\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// Check if we're setting a value\n\t\t\tif ( value !== undefined ) {\n\t\t\t\ttype = typeof value;\n\t\n\t\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\t\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\t\n\t\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\t\tif ( value == null || value !== value ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t\tif ( type === \"number\" ) {\n\t\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t\t}\n\t\n\t\t\t\t// background-* props affect original clone's values\n\t\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t\t}\n\t\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\t\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\t\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[ name ];\n\t\t\t}\n\t\t},\n\t\n\t\tcss: function( elem, name, extra, styles ) {\n\t\t\tvar val, num, hooks,\n\t\t\t\torigName = jQuery.camelCase( name );\n\t\n\t\t\t// Make sure that we're working with the right name\n\t\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\t\n\t\t\t// Try prefixed name followed by the unprefixed name\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\t\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\t\tval = hooks.get( elem, true, extra );\n\t\t\t}\n\t\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif ( val === undefined ) {\n\t\t\t\tval = curCSS( elem, name, styles );\n\t\t\t}\n\t\n\t\t\t// Convert \"normal\" to computed value\n\t\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\t\tval = cssNormalTransform[ name ];\n\t\t\t}\n\t\n\t\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\t\tif ( extra === \"\" || extra ) {\n\t\t\t\tnum = parseFloat( val );\n\t\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\t\tjQuery.cssHooks[ name ] = {\n\t\t\tget: function( elem, computed, extra ) {\n\t\t\t\tif ( computed ) {\n\t\n\t\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\t\n\t\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t\t} ) :\n\t\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tset: function( elem, value, extra ) {\n\t\t\t\tvar matches,\n\t\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\t\tstyles\n\t\t\t\t\t);\n\t\n\t\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\t\n\t\t\t\t\telem.style[ name ] = value;\n\t\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t\t}\n\t\n\t\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t\t}\n\t\t};\n\t} );\n\t\n\tjQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t\t} )\n\t\t\t\t\t) + \"px\";\n\t\t\t}\n\t\t}\n\t);\n\t\n\t// These hooks are used by animate to expand properties\n\tjQuery.each( {\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function( prefix, suffix ) {\n\t\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\t\texpand: function( value ) {\n\t\t\t\tvar i = 0,\n\t\t\t\t\texpanded = {},\n\t\n\t\t\t\t\t// Assumes a single number if not a string\n\t\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\t\n\t\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t\t}\n\t\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\t\n\t\tif ( !rmargin.test( prefix ) ) {\n\t\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t\t}\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\tcss: function( name, value ) {\n\t\t\treturn access( this, function( elem, name, value ) {\n\t\t\t\tvar styles, len,\n\t\t\t\t\tmap = {},\n\t\t\t\t\ti = 0;\n\t\n\t\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\t\tstyles = getStyles( elem );\n\t\t\t\t\tlen = name.length;\n\t\n\t\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\n\t\t\t\treturn value !== undefined ?\n\t\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\t\tjQuery.css( elem, name );\n\t\t\t}, name, value, arguments.length > 1 );\n\t\t}\n\t} );\n\t\n\t\n\tfunction Tween( elem, options, prop, end, easing ) {\n\t\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n\t}\n\tjQuery.Tween = Tween;\n\t\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || jQuery.easing._default;\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t\t},\n\t\tcur: function() {\n\t\t\tvar hooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\treturn hooks && hooks.get ?\n\t\t\t\thooks.get( this ) :\n\t\t\t\tTween.propHooks._default.get( this );\n\t\t},\n\t\trun: function( percent ) {\n\t\t\tvar eased,\n\t\t\t\thooks = Tween.propHooks[ this.prop ];\n\t\n\t\t\tif ( this.options.duration ) {\n\t\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\t\n\t\t\tif ( this.options.step ) {\n\t\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t\t}\n\t\n\t\t\tif ( hooks && hooks.set ) {\n\t\t\t\thooks.set( this );\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set( this );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\t\n\tTween.prototype.init.prototype = Tween.prototype;\n\t\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function( tween ) {\n\t\t\t\tvar result;\n\t\n\t\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t\t// or when there is no matching style property that exists.\n\t\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t\t}\n\t\n\t\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function( tween ) {\n\t\n\t\t\t\t// Use step hook for back compat.\n\t\t\t\t// Use cssHook if its there.\n\t\t\t\t// Use .style if available and use plain properties where available.\n\t\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// Support: IE <=9 only\n\t// Panic based approach to setting things on disconnected nodes\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function( tween ) {\n\t\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.easing = {\n\t\tlinear: function( p ) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function( p ) {\n\t\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t\t},\n\t\t_default: \"swing\"\n\t};\n\t\n\tjQuery.fx = Tween.prototype.init;\n\t\n\t// Back compat <1.8 extension point\n\tjQuery.fx.step = {};\n\t\n\t\n\t\n\t\n\tvar\n\t\tfxNow, timerId,\n\t\trfxtypes = /^(?:toggle|show|hide)$/,\n\t\trrun = /queueHooks$/;\n\t\n\tfunction raf() {\n\t\tif ( timerId ) {\n\t\t\twindow.requestAnimationFrame( raf );\n\t\t\tjQuery.fx.tick();\n\t\t}\n\t}\n\t\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\twindow.setTimeout( function() {\n\t\t\tfxNow = undefined;\n\t\t} );\n\t\treturn ( fxNow = jQuery.now() );\n\t}\n\t\n\t// Generate parameters to create a standard animation\n\tfunction genFx( type, includeWidth ) {\n\t\tvar which,\n\t\t\ti = 0,\n\t\t\tattrs = { height: type };\n\t\n\t\t// If we include width, step value is 1 to do all cssExpand values,\n\t\t// otherwise step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\t\twhich = cssExpand[ i ];\n\t\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t\t}\n\t\n\t\tif ( includeWidth ) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\t\n\t\treturn attrs;\n\t}\n\t\n\tfunction createTween( value, prop, animation ) {\n\t\tvar tween,\n\t\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\t\n\t\t\t\t// We're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction defaultPrefilter( elem, props, opts ) {\n\t\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\t\tisBox = \"width\" in props || \"height\" in props,\n\t\t\tanim = this,\n\t\t\torig = {},\n\t\t\tstyle = elem.style,\n\t\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\t\n\t\t// Queue-skipping animations hijack the fx hooks\n\t\tif ( !opts.queue ) {\n\t\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\t\tif ( hooks.unqueued == null ) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function() {\n\t\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\t\n\t\t\tanim.always( function() {\n\t\n\t\t\t\t// Ensure the complete handler is called before this completes\n\t\t\t\tanim.always( function() {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\n\t\t// Detect show/hide animations\n\t\tfor ( prop in props ) {\n\t\t\tvalue = props[ prop ];\n\t\t\tif ( rfxtypes.test( value ) ) {\n\t\t\t\tdelete props[ prop ];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\t\n\t\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\t\thidden = true;\n\t\n\t\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t\t}\n\t\t}\n\t\n\t\t// Bail out if this is a no-op like .hide().hide()\n\t\tpropTween = !jQuery.isEmptyObject( props );\n\t\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// Restrict \"overflow\" and \"display\" styles during box animations\n\t\tif ( isBox && elem.nodeType === 1 ) {\n\t\n\t\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t\t// from identically-valued overflowX and overflowY\n\t\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\t\n\t\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\t\trestoreDisplay = dataShow && dataShow.display;\n\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t\t}\n\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tif ( restoreDisplay ) {\n\t\t\t\t\tdisplay = restoreDisplay;\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Animate inline elements as inline-block\n\t\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\n\t\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\t\tif ( !propTween ) {\n\t\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif ( opts.overflow ) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tanim.always( function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t} );\n\t\t}\n\t\n\t\t// Implement show/hide animations\n\t\tpropTween = false;\n\t\tfor ( prop in orig ) {\n\t\n\t\t\t// General show/hide setup for this element animation\n\t\t\tif ( !propTween ) {\n\t\t\t\tif ( dataShow ) {\n\t\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t\t}\n\t\n\t\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\t\tif ( toggle ) {\n\t\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t\t}\n\t\n\t\t\t\t// Show elements before animating them\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\t}\n\t\n\t\t\t\t/* eslint-disable no-loop-func */\n\t\n\t\t\t\tanim.done( function() {\n\t\n\t\t\t\t/* eslint-enable no-loop-func */\n\t\n\t\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\t\tif ( !hidden ) {\n\t\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\t// Per-property setup\n\t\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\t\tpropTween.start = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction propFilter( props, specialEasing ) {\n\t\tvar index, name, easing, value, hooks;\n\t\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor ( index in props ) {\n\t\t\tname = jQuery.camelCase( index );\n\t\t\teasing = specialEasing[ name ];\n\t\t\tvalue = props[ index ];\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\teasing = value[ 1 ];\n\t\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t\t}\n\t\n\t\t\tif ( index !== name ) {\n\t\t\t\tprops[ name ] = value;\n\t\t\t\tdelete props[ index ];\n\t\t\t}\n\t\n\t\t\thooks = jQuery.cssHooks[ name ];\n\t\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\t\tvalue = hooks.expand( value );\n\t\t\t\tdelete props[ name ];\n\t\n\t\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\t\tfor ( index in value ) {\n\t\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[ name ] = easing;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction Animation( elem, properties, options ) {\n\t\tvar result,\n\t\t\tstopped,\n\t\t\tindex = 0,\n\t\t\tlength = Animation.prefilters.length,\n\t\t\tdeferred = jQuery.Deferred().always( function() {\n\t\n\t\t\t\t// Don't match elem in the :animated selector\n\t\t\t\tdelete tick.elem;\n\t\t\t} ),\n\t\t\ttick = function() {\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\n\t\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\t\tpercent = 1 - temp,\n\t\t\t\t\tindex = 0,\n\t\t\t\t\tlength = animation.tweens.length;\n\t\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t\t}\n\t\n\t\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\t\n\t\t\t\tif ( percent < 1 && length ) {\n\t\t\t\t\treturn remaining;\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation = deferred.promise( {\n\t\t\t\telem: elem,\n\t\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\t\topts: jQuery.extend( true, {\n\t\t\t\t\tspecialEasing: {},\n\t\t\t\t\teasing: jQuery.easing._default\n\t\t\t\t}, options ),\n\t\t\t\toriginalProperties: properties,\n\t\t\t\toriginalOptions: options,\n\t\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\t\tduration: options.duration,\n\t\t\t\ttweens: [],\n\t\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\t\treturn tween;\n\t\t\t\t},\n\t\t\t\tstop: function( gotoEnd ) {\n\t\t\t\t\tvar index = 0,\n\t\n\t\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\t\tif ( stopped ) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\tstopped = true;\n\t\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} ),\n\t\t\tprops = animation.props;\n\t\n\t\tpropFilter( props, animation.opts.specialEasing );\n\t\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\t\tif ( result ) {\n\t\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\n\t\tjQuery.map( props, createTween, animation );\n\t\n\t\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\t\tanimation.opts.start.call( elem, animation );\n\t\t}\n\t\n\t\tjQuery.fx.timer(\n\t\t\tjQuery.extend( tick, {\n\t\t\t\telem: elem,\n\t\t\t\tanim: animation,\n\t\t\t\tqueue: animation.opts.queue\n\t\t\t} )\n\t\t);\n\t\n\t\t// attach callbacks from options\n\t\treturn animation.progress( animation.opts.progress )\n\t\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t\t.fail( animation.opts.fail )\n\t\t\t.always( animation.opts.always );\n\t}\n\t\n\tjQuery.Animation = jQuery.extend( Animation, {\n\t\n\t\ttweeners: {\n\t\t\t\"*\": [ function( prop, value ) {\n\t\t\t\tvar tween = this.createTween( prop, value );\n\t\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\t\treturn tween;\n\t\t\t} ]\n\t\t},\n\t\n\t\ttweener: function( props, callback ) {\n\t\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [ \"*\" ];\n\t\t\t} else {\n\t\t\t\tprops = props.match( rnothtmlwhite );\n\t\t\t}\n\t\n\t\t\tvar prop,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = props.length;\n\t\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tprop = props[ index ];\n\t\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t\t}\n\t\t},\n\t\n\t\tprefilters: [ defaultPrefilter ],\n\t\n\t\tprefilter: function( callback, prepend ) {\n\t\t\tif ( prepend ) {\n\t\t\t\tAnimation.prefilters.unshift( callback );\n\t\t\t} else {\n\t\t\t\tAnimation.prefilters.push( callback );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tjQuery.speed = function( speed, easing, fn ) {\n\t\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t\t};\n\t\n\t\t// Go to the end state if fx are off or if document is hidden\n\t\tif ( jQuery.fx.off || document.hidden ) {\n\t\t\topt.duration = 0;\n\t\n\t\t} else {\n\t\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\t\n\t\t\t\t} else {\n\t\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif ( opt.queue == null || opt.queue === true ) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\t\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\t\n\t\topt.complete = function() {\n\t\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\t\topt.old.call( this );\n\t\t\t}\n\t\n\t\t\tif ( opt.queue ) {\n\t\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t\t}\n\t\t};\n\t\n\t\treturn opt;\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tfadeTo: function( speed, to, easing, callback ) {\n\t\n\t\t\t// Show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\t\n\t\t\t\t// Animate to the value specified\n\t\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t\t},\n\t\tanimate: function( prop, speed, easing, callback ) {\n\t\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\t\tdoAnimation = function() {\n\t\n\t\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\t\n\t\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\t\tanim.stop( true );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tdoAnimation.finish = doAnimation;\n\t\n\t\t\treturn empty || optall.queue === false ?\n\t\t\t\tthis.each( doAnimation ) :\n\t\t\t\tthis.queue( optall.queue, doAnimation );\n\t\t},\n\t\tstop: function( type, clearQueue, gotoEnd ) {\n\t\t\tvar stopQueue = function( hooks ) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop( gotoEnd );\n\t\t\t};\n\t\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif ( clearQueue && type !== false ) {\n\t\t\t\tthis.queue( type || \"fx\", [] );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tdata = dataPriv.get( this );\n\t\n\t\t\t\tif ( index ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( index in data ) {\n\t\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\t\n\t\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\tfinish: function( type ) {\n\t\t\tif ( type !== false ) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tvar index,\n\t\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tlength = queue ? queue.length : 0;\n\t\n\t\t\t\t// Enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\t\n\t\t\t\t// Empty the queue first\n\t\t\t\tjQuery.queue( this, type, [] );\n\t\n\t\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\t\thooks.stop.call( this, true );\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any active animations, and finish them\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Look for any animations in the old queue and finish them\n\t\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\t\tvar cssFn = jQuery.fn[ name ];\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\t\tcssFn.apply( this, arguments ) :\n\t\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t\t};\n\t} );\n\t\n\t// Generate shortcuts for custom animations\n\tjQuery.each( {\n\t\tslideDown: genFx( \"show\" ),\n\t\tslideUp: genFx( \"hide\" ),\n\t\tslideToggle: genFx( \"toggle\" ),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function( name, props ) {\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn this.animate( props, speed, easing, callback );\n\t\t};\n\t} );\n\t\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function() {\n\t\tvar timer,\n\t\t\ti = 0,\n\t\t\ttimers = jQuery.timers;\n\t\n\t\tfxNow = jQuery.now();\n\t\n\t\tfor ( ; i < timers.length; i++ ) {\n\t\t\ttimer = timers[ i ];\n\t\n\t\t\t// Checks the timer has not already been removed\n\t\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\t\ttimers.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\t\n\t\tif ( !timers.length ) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\t\n\tjQuery.fx.timer = function( timer ) {\n\t\tjQuery.timers.push( timer );\n\t\tif ( timer() ) {\n\t\t\tjQuery.fx.start();\n\t\t} else {\n\t\t\tjQuery.timers.pop();\n\t\t}\n\t};\n\t\n\tjQuery.fx.interval = 13;\n\tjQuery.fx.start = function() {\n\t\tif ( !timerId ) {\n\t\t\ttimerId = window.requestAnimationFrame ?\n\t\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t\t}\n\t};\n\t\n\tjQuery.fx.stop = function() {\n\t\tif ( window.cancelAnimationFrame ) {\n\t\t\twindow.cancelAnimationFrame( timerId );\n\t\t} else {\n\t\t\twindow.clearInterval( timerId );\n\t\t}\n\t\n\t\ttimerId = null;\n\t};\n\t\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\t\n\t\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\t\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = window.setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\twindow.clearTimeout( timeout );\n\t\t\t};\n\t\t} );\n\t};\n\t\n\t\n\t( function() {\n\t\tvar input = document.createElement( \"input\" ),\n\t\t\tselect = document.createElement( \"select\" ),\n\t\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\t\n\t\tinput.type = \"checkbox\";\n\t\n\t\t// Support: Android <=4.3 only\n\t\t// Default value for a checkbox should be \"on\"\n\t\tsupport.checkOn = input.value !== \"\";\n\t\n\t\t// Support: IE <=11 only\n\t\t// Must access selectedIndex to make default options select\n\t\tsupport.optSelected = opt.selected;\n\t\n\t\t// Support: IE <=11 only\n\t\t// An input loses its value after becoming a radio\n\t\tinput = document.createElement( \"input\" );\n\t\tinput.value = \"t\";\n\t\tinput.type = \"radio\";\n\t\tsupport.radioValue = input.value === \"t\";\n\t} )();\n\t\n\t\n\tvar boolHook,\n\t\tattrHandle = jQuery.expr.attrHandle;\n\t\n\tjQuery.fn.extend( {\n\t\tattr: function( name, value ) {\n\t\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveAttr: function( name ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.removeAttr( this, name );\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tattr: function( elem, name, value ) {\n\t\t\tvar ret, hooks,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\t\treturn jQuery.prop( elem, name, value );\n\t\t\t}\n\t\n\t\t\t// Attribute hooks are determined by the lowercase version\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tif ( value === null ) {\n\t\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\t\n\t\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\n\t\t\tret = jQuery.find.attr( elem, name );\n\t\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ? undefined : ret;\n\t\t},\n\t\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tremoveAttr: function( elem, value ) {\n\t\t\tvar name,\n\t\t\t\ti = 0,\n\t\n\t\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\t\n\t\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\t\telem.removeAttribute( name );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Hooks for boolean attributes\n\tboolHook = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( value === false ) {\n\t\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, name );\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t};\n\t\n\tjQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\t\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\t\n\t\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\t\tvar ret, handle,\n\t\t\t\tlowercaseName = name.toLowerCase();\n\t\n\t\t\tif ( !isXML ) {\n\t\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\tlowercaseName :\n\t\t\t\t\tnull;\n\t\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t} );\n\t\n\t\n\t\n\t\n\tvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\t\trclickable = /^(?:a|area)$/i;\n\t\n\tjQuery.fn.extend( {\n\t\tprop: function( name, value ) {\n\t\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t\t},\n\t\n\t\tremoveProp: function( name ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tprop: function( elem, name, value ) {\n\t\t\tvar ret, hooks,\n\t\t\t\tnType = elem.nodeType;\n\t\n\t\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\t\thooks = jQuery.propHooks[ name ];\n\t\t\t}\n\t\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\n\t\t\t\treturn ( elem[ name ] = value );\n\t\t\t}\n\t\n\t\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\n\t\t\treturn elem[ name ];\n\t\t},\n\t\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function( elem ) {\n\t\n\t\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\t\n\t\t\t\t\tif ( tabindex ) {\n\t\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (\n\t\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\t\telem.href\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t}\n\t} );\n\t\n\t// Support: IE <=11 only\n\t// Accessing the selectedIndex property\n\t// forces the browser to respect setting selected\n\t// on the option\n\t// The getter ensures a default option is selected\n\t// when in an optgroup\n\t// eslint rule \"no-unused-expressions\" is disabled for this code\n\t// since it considers such accessions noop\n\tif ( !support.optSelected ) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function( elem ) {\n\t\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\t\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tset: function( elem ) {\n\t\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\t\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.selectedIndex;\n\t\n\t\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tjQuery.each( [\n\t\t\"tabIndex\",\n\t\t\"readOnly\",\n\t\t\"maxLength\",\n\t\t\"cellSpacing\",\n\t\t\"cellPadding\",\n\t\t\"rowSpan\",\n\t\t\"colSpan\",\n\t\t\"useMap\",\n\t\t\"frameBorder\",\n\t\t\"contentEditable\"\n\t], function() {\n\t\tjQuery.propFix[ this.toLowerCase() ] = this;\n\t} );\n\t\n\t\n\t\n\t\n\t\t// Strip and collapse whitespace according to HTML spec\n\t\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\t\tfunction stripAndCollapse( value ) {\n\t\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\t\treturn tokens.join( \" \" );\n\t\t}\n\t\n\t\n\tfunction getClass( elem ) {\n\t\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n\t}\n\t\n\tjQuery.fn.extend( {\n\t\taddClass: function( value ) {\n\t\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\t\ti = 0;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( j ) {\n\t\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tif ( typeof value === \"string\" && value ) {\n\t\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\t\tcurValue = getClass( elem );\n\t\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tremoveClass: function( value ) {\n\t\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\t\ti = 0;\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( j ) {\n\t\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tif ( !arguments.length ) {\n\t\t\t\treturn this.attr( \"class\", \"\" );\n\t\t\t}\n\t\n\t\t\tif ( typeof value === \"string\" && value ) {\n\t\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\t\tcurValue = getClass( elem );\n\t\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\t\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\ttoggleClass: function( value, stateVal ) {\n\t\t\tvar type = typeof value;\n\t\n\t\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each( function( i ) {\n\t\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\t\tstateVal\n\t\t\t\t\t);\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar className, i, self, classNames;\n\t\n\t\t\t\tif ( type === \"string\" ) {\n\t\n\t\t\t\t\t// Toggle individual class names\n\t\t\t\t\ti = 0;\n\t\t\t\t\tself = jQuery( this );\n\t\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\t\n\t\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\t\n\t\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\t\tclassName = getClass( this );\n\t\t\t\t\tif ( className ) {\n\t\n\t\t\t\t\t\t// Store className if set\n\t\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\thasClass: function( selector ) {\n\t\t\tvar className, elem,\n\t\t\t\ti = 0;\n\t\n\t\t\tclassName = \" \" + selector + \" \";\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tvar rreturn = /\\r/g;\n\t\n\tjQuery.fn.extend( {\n\t\tval: function( value ) {\n\t\t\tvar hooks, ret, isFunction,\n\t\t\t\telem = this[ 0 ];\n\t\n\t\t\tif ( !arguments.length ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\t\n\t\t\t\t\tif ( hooks &&\n\t\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tret = elem.value;\n\t\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t\t}\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tisFunction = jQuery.isFunction( value );\n\t\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tvar val;\n\t\n\t\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\t\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\tval = \"\";\n\t\n\t\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\t\tval += \"\";\n\t\n\t\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\n\t\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\t\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\tjQuery.extend( {\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function( elem ) {\n\t\n\t\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\t\treturn val != null ?\n\t\t\t\t\t\tval :\n\t\n\t\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar value, option, i,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\t\tmax = one ? index + 1 : options.length;\n\t\n\t\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\t\ti = max;\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\n\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\n\t\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\t\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery( option ).val();\n\t\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\t\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tvar optionSet, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\t\ti = options.length;\n\t\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\n\t\t\t\t\t\t/* eslint-disable no-cond-assign */\n\t\n\t\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Radios and checkboxes getter/setter\n\tjQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif ( !support.checkOn ) {\n\t\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Return jQuery for attributes-only inclusion\n\t\n\t\n\tvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\t\n\tjQuery.extend( jQuery.event, {\n\t\n\t\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\n\t\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\t\teventPath = [ elem || document ],\n\t\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\t\n\t\t\tcur = tmp = elem = elem || document;\n\t\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\t\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split( \".\" );\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\t\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[ jQuery.expando ] ?\n\t\t\t\tevent :\n\t\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\t\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join( \".\" );\n\t\t\tevent.rnamespace = event.namespace ?\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\t\tnull;\n\t\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\t\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ?\n\t\t\t\t[ event ] :\n\t\t\t\tjQuery.makeArray( data, [ event ] );\n\t\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\t\teventPath.push( cur );\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\t\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\n\t\t\t\tevent.type = i > 1 ?\n\t\t\t\t\tbubbleType :\n\t\t\t\t\tspecial.bindType || type;\n\t\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\t\tif ( handle ) {\n\t\t\t\t\thandle.apply( cur, data );\n\t\t\t\t}\n\t\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ ontype ];\n\t\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\t\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\t\n\t\t\t\tif ( ( !special._default ||\n\t\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\t\tacceptData( elem ) ) {\n\t\n\t\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ ontype ];\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\t\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn event.result;\n\t\t},\n\t\n\t\t// Piggyback on a donor event to simulate a different one\n\t\t// Used only for `focus(in | out)` events\n\t\tsimulate: function( type, elem, event ) {\n\t\t\tvar e = jQuery.extend(\n\t\t\t\tnew jQuery.Event(),\n\t\t\t\tevent,\n\t\t\t\t{\n\t\t\t\t\ttype: type,\n\t\t\t\t\tisSimulated: true\n\t\t\t\t}\n\t\t\t);\n\t\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t}\n\t\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\n\t\ttrigger: function( type, data ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.trigger( type, data, this );\n\t\t\t} );\n\t\t},\n\t\ttriggerHandler: function( type, data ) {\n\t\t\tvar elem = this[ 0 ];\n\t\t\tif ( elem ) {\n\t\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\t\tfunction( i, name ) {\n\t\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t} );\n\t\n\tjQuery.fn.extend( {\n\t\thover: function( fnOver, fnOut ) {\n\t\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tsupport.focusin = \"onfocusin\" in window;\n\t\n\t\n\t// Support: Firefox <=44\n\t// Firefox doesn't have focus(in | out) events\n\t// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n\t//\n\t// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n\t// focus(in | out) events fire after focus & blur events,\n\t// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n\t// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\tif ( !support.focusin ) {\n\t\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\t\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t\t};\n\t\n\t\t\tjQuery.event.special[ fix ] = {\n\t\t\t\tsetup: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\t\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\t\tdataPriv.remove( doc, fix );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t} );\n\t}\n\tvar location = window.location;\n\t\n\tvar nonce = jQuery.now();\n\t\n\tvar rquery = ( /\\?/ );\n\t\n\t\n\t\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function( data ) {\n\t\tvar xml;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Support: IE 9 - 11 only\n\t\t// IE throws on parseFromString with invalid input.\n\t\ttry {\n\t\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t\t} catch ( e ) {\n\t\t\txml = undefined;\n\t\t}\n\t\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t};\n\t\n\t\n\tvar\n\t\trbracket = /\\[\\]$/,\n\t\trCRLF = /\\r?\\n/g,\n\t\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\t\n\tfunction buildParams( prefix, obj, traditional, add ) {\n\t\tvar name;\n\t\n\t\tif ( jQuery.isArray( obj ) ) {\n\t\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each( obj, function( i, v ) {\n\t\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd( prefix, v );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams(\n\t\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\t\tv,\n\t\t\t\t\t\ttraditional,\n\t\t\t\t\t\tadd\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\n\t\t\t// Serialize object item.\n\t\t\tfor ( name in obj ) {\n\t\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t\t}\n\t\n\t\t} else {\n\t\n\t\t\t// Serialize scalar item.\n\t\t\tadd( prefix, obj );\n\t\t}\n\t}\n\t\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function( a, traditional ) {\n\t\tvar prefix,\n\t\t\ts = [],\n\t\t\tadd = function( key, valueOrFunction ) {\n\t\n\t\t\t\t// If value is a function, invoke it and use its return value\n\t\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\t\tvalueOrFunction() :\n\t\t\t\t\tvalueOrFunction;\n\t\n\t\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t\t};\n\t\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function() {\n\t\t\t\tadd( this.name, this.value );\n\t\t\t} );\n\t\n\t\t} else {\n\t\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor ( prefix in a ) {\n\t\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the resulting serialization\n\t\treturn s.join( \"&\" );\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\tserialize: function() {\n\t\t\treturn jQuery.param( this.serializeArray() );\n\t\t},\n\t\tserializeArray: function() {\n\t\t\treturn this.map( function() {\n\t\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t\t} )\n\t\t\t.filter( function() {\n\t\t\t\tvar type = this.type;\n\t\n\t\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t\t} )\n\t\t\t.map( function( i, elem ) {\n\t\t\t\tvar val = jQuery( this ).val();\n\t\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\n\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t} ).get();\n\t\t}\n\t} );\n\t\n\t\n\tvar\n\t\tr20 = /%20/g,\n\t\trhash = /#.*$/,\n\t\trantiCache = /([?&])_=[^&]*/,\n\t\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t\n\t\t// #7653, #8125, #8152: local protocol detection\n\t\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t\trnoContent = /^(?:GET|HEAD)$/,\n\t\trprotocol = /^\\/\\//,\n\t\n\t\t/* Prefilters\n\t\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t\t * 2) These are called:\n\t\t *    - BEFORE asking for a transport\n\t\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t\t * 3) key is the dataType\n\t\t * 4) the catchall symbol \"*\" can be used\n\t\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t\t */\n\t\tprefilters = {},\n\t\n\t\t/* Transports bindings\n\t\t * 1) key is the dataType\n\t\t * 2) the catchall symbol \"*\" can be used\n\t\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t\t */\n\t\ttransports = {},\n\t\n\t\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\t\tallTypes = \"*/\".concat( \"*\" ),\n\t\n\t\t// Anchor tag for parsing the document origin\n\t\toriginAnchor = document.createElement( \"a\" );\n\t\toriginAnchor.href = location.href;\n\t\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports( structure ) {\n\t\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function( dataTypeExpression, func ) {\n\t\n\t\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\t\n\t\t\tvar dataType,\n\t\t\t\ti = 0,\n\t\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\t\n\t\t\tif ( jQuery.isFunction( func ) ) {\n\t\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\t\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\t\n\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\t\n\t\tvar inspected = {},\n\t\t\tseekingTransport = ( structure === transports );\n\t\n\t\tfunction inspect( dataType ) {\n\t\t\tvar selected;\n\t\t\tinspected[ dataType ] = true;\n\t\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\n\t\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\t\treturn false;\n\t\t\t\t} else if ( seekingTransport ) {\n\t\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn selected;\n\t\t}\n\t\n\t\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n\t}\n\t\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend( target, src ) {\n\t\tvar key, deep,\n\t\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\t\n\t\tfor ( key in src ) {\n\t\t\tif ( src[ key ] !== undefined ) {\n\t\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t\t}\n\t\t}\n\t\tif ( deep ) {\n\t\t\tjQuery.extend( true, target, deep );\n\t\t}\n\t\n\t\treturn target;\n\t}\n\t\n\t/* Handles responses to an ajax request:\n\t * - finds the right dataType (mediates between content-type and expected dataType)\n\t * - returns the corresponding response\n\t */\n\tfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\t\n\t\tvar ct, type, finalDataType, firstDataType,\n\t\t\tcontents = s.contents,\n\t\t\tdataTypes = s.dataTypes;\n\t\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\t\tdataTypes.shift();\n\t\t\tif ( ct === undefined ) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t\t}\n\t\t}\n\t\n\t\t// Check if we're dealing with a known content-type\n\t\tif ( ct ) {\n\t\t\tfor ( type in contents ) {\n\t\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\t\tdataTypes.unshift( type );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif ( dataTypes[ 0 ] in responses ) {\n\t\t\tfinalDataType = dataTypes[ 0 ];\n\t\t} else {\n\t\n\t\t\t// Try convertible dataTypes\n\t\t\tfor ( type in responses ) {\n\t\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( !firstDataType ) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\t\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif ( finalDataType ) {\n\t\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\t\tdataTypes.unshift( finalDataType );\n\t\t\t}\n\t\t\treturn responses[ finalDataType ];\n\t\t}\n\t}\n\t\n\t/* Chain conversions given the request and the original response\n\t * Also sets the responseXXX fields on the jqXHR instance\n\t */\n\tfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\t\tvar conv2, current, conv, tmp, prev,\n\t\t\tconverters = {},\n\t\n\t\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\t\tdataTypes = s.dataTypes.slice();\n\t\n\t\t// Create converters map with lowercased keys\n\t\tif ( dataTypes[ 1 ] ) {\n\t\t\tfor ( conv in s.converters ) {\n\t\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t\t}\n\t\t}\n\t\n\t\tcurrent = dataTypes.shift();\n\t\n\t\t// Convert to each sequential dataType\n\t\twhile ( current ) {\n\t\n\t\t\tif ( s.responseFields[ current ] ) {\n\t\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t\t}\n\t\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t\t}\n\t\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\t\n\t\t\tif ( current ) {\n\t\n\t\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif ( current === \"*\" ) {\n\t\n\t\t\t\t\tcurrent = prev;\n\t\n\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\t\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\t\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif ( !conv ) {\n\t\t\t\t\t\tfor ( conv2 in converters ) {\n\t\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\t\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\t\tif ( conv ) {\n\t\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\t\n\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif ( conv !== true ) {\n\t\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn { state: \"success\", data: response };\n\t}\n\t\n\tjQuery.extend( {\n\t\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\t\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\t\n\t\tajaxSettings: {\n\t\t\turl: location.href,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\n\t\t\t/*\n\t\t\ttimeout: 0,\n\t\t\tdata: null,\n\t\t\tdataType: null,\n\t\t\tusername: null,\n\t\t\tpassword: null,\n\t\t\tcache: null,\n\t\t\tthrows: false,\n\t\t\ttraditional: false,\n\t\t\theaders: {},\n\t\t\t*/\n\t\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\t\n\t\t\tcontents: {\n\t\t\t\txml: /\\bxml\\b/,\n\t\t\t\thtml: /\\bhtml/,\n\t\t\t\tjson: /\\bjson\\b/\n\t\t\t},\n\t\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\t\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\t\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\t\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\t\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": JSON.parse,\n\t\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\t\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\t\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function( target, settings ) {\n\t\t\treturn settings ?\n\t\n\t\t\t\t// Building a settings object\n\t\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\t\n\t\t\t\t// Extending ajaxSettings\n\t\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t\t},\n\t\n\t\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\t\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\t\n\t\t// Main method\n\t\tajax: function( url, options ) {\n\t\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ( typeof url === \"object\" ) {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\t\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\t\n\t\t\tvar transport,\n\t\n\t\t\t\t// URL without anti-cache param\n\t\t\t\tcacheURL,\n\t\n\t\t\t\t// Response headers\n\t\t\t\tresponseHeadersString,\n\t\t\t\tresponseHeaders,\n\t\n\t\t\t\t// timeout handle\n\t\t\t\ttimeoutTimer,\n\t\n\t\t\t\t// Url cleanup var\n\t\t\t\turlAnchor,\n\t\n\t\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\t\tcompleted,\n\t\n\t\t\t\t// To know if global events are to be dispatched\n\t\t\t\tfireGlobals,\n\t\n\t\t\t\t// Loop variable\n\t\t\t\ti,\n\t\n\t\t\t\t// uncached part of the url\n\t\t\t\tuncached,\n\t\n\t\t\t\t// Create the final options object\n\t\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\n\t\t\t\t// Callbacks context\n\t\t\t\tcallbackContext = s.context || s,\n\t\n\t\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\t\tglobalEventContext = s.context &&\n\t\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\t\tjQuery.event,\n\t\n\t\t\t\t// Deferreds\n\t\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\t\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode = s.statusCode || {},\n\t\n\t\t\t\t// Headers (they are sent all at once)\n\t\t\t\trequestHeaders = {},\n\t\t\t\trequestHeadersNames = {},\n\t\n\t\t\t\t// Default abort message\n\t\t\t\tstrAbort = \"canceled\",\n\t\n\t\t\t\t// Fake xhr\n\t\t\t\tjqXHR = {\n\t\t\t\t\treadyState: 0,\n\t\n\t\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\t\tvar match;\n\t\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Raw string\n\t\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Caches the header\n\t\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Overrides response content-type header\n\t\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Status-dependent callbacks\n\t\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\t\tvar code;\n\t\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\t\tif ( completed ) {\n\t\n\t\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// Cancel the request\n\t\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise( jqXHR );\n\t\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\t\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\t\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\t\n\t\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\t\tif ( s.crossDomain == null ) {\n\t\t\t\turlAnchor = document.createElement( \"a\" );\n\t\n\t\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t\t// e.g. http://example.com:80x/\n\t\t\t\ttry {\n\t\t\t\t\turlAnchor.href = s.url;\n\t\n\t\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\t\ts.crossDomain = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Convert data if not already a string\n\t\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t\t}\n\t\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\t\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\t\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\t\n\t\t\t// Watch for a new set of requests\n\t\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t\t}\n\t\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\t\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test( s.type );\n\t\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\t// Remove hash to simplify url manipulation\n\t\t\tcacheURL = s.url.replace( rhash, \"\" );\n\t\n\t\t\t// More options handling for requests with no content\n\t\t\tif ( !s.hasContent ) {\n\t\n\t\t\t\t// Remember the hash so we can put it back\n\t\t\t\tuncached = s.url.slice( cacheURL.length );\n\t\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif ( s.data ) {\n\t\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\t\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\t\n\t\t\t\t// Add or update anti-cache param if needed\n\t\t\t\tif ( s.cache === false ) {\n\t\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t\t}\n\t\n\t\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\t\ts.url = cacheURL + uncached;\n\t\n\t\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t\t} else if ( s.data && s.processData &&\n\t\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t\t}\n\t\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif ( s.ifModified ) {\n\t\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t\t}\n\t\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t\t}\n\t\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\n\t\t\t\t\"Accept\",\n\t\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\t\ts.accepts[ \"*\" ]\n\t\t\t);\n\t\n\t\t\t// Check for headers option\n\t\t\tfor ( i in s.headers ) {\n\t\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t\t}\n\t\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif ( s.beforeSend &&\n\t\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\t\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\t\n\t\t\t// Aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\t\n\t\t\t// Install callbacks on deferreds\n\t\t\tcompleteDeferred.add( s.complete );\n\t\t\tjqXHR.done( s.success );\n\t\t\tjqXHR.fail( s.error );\n\t\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\t\n\t\t\t// If no transport, we auto-abort\n\t\t\tif ( !transport ) {\n\t\t\t\tdone( -1, \"No Transport\" );\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\t\n\t\t\t\t// Send global event\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t\t}\n\t\n\t\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn jqXHR;\n\t\t\t\t}\n\t\n\t\t\t\t// Timeout\n\t\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t\t}, s.timeout );\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\t\t\t\tcompleted = false;\n\t\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Propagate others as results\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\t\tstatusText = nativeStatusText;\n\t\n\t\t\t\t// Ignore repeat invocations\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tcompleted = true;\n\t\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif ( timeoutTimer ) {\n\t\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t\t}\n\t\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\t\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\t\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\t\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\t\n\t\t\t\t// Get response data\n\t\t\t\tif ( responses ) {\n\t\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t\t}\n\t\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\t\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif ( isSuccess ) {\n\t\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// if no content\n\t\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\t\n\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\t\n\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\t\n\t\t\t\t// Success/Error\n\t\t\t\tif ( isSuccess ) {\n\t\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode( statusCode );\n\t\t\t\tstatusCode = undefined;\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t\t}\n\t\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\t\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn jqXHR;\n\t\t},\n\t\n\t\tgetJSON: function( url, data, callback ) {\n\t\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t\t},\n\t\n\t\tgetScript: function( url, callback ) {\n\t\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t\t}\n\t} );\n\t\n\tjQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\t\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\n\t\t\t// The url can be an options object (which then must have .url)\n\t\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t\t};\n\t} );\n\t\n\t\n\tjQuery._evalUrl = function( url ) {\n\t\treturn jQuery.ajax( {\n\t\t\turl: url,\n\t\n\t\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tcache: true,\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t} );\n\t};\n\t\n\t\n\tjQuery.fn.extend( {\n\t\twrapAll: function( html ) {\n\t\t\tvar wrap;\n\t\n\t\t\tif ( this[ 0 ] ) {\n\t\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\t\n\t\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\twrap.map( function() {\n\t\t\t\t\tvar elem = this;\n\t\n\t\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn elem;\n\t\t\t\t} ).append( this );\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\twrapInner: function( html ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each( function( i ) {\n\t\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\treturn this.each( function() {\n\t\t\t\tvar self = jQuery( this ),\n\t\t\t\t\tcontents = self.contents();\n\t\n\t\t\t\tif ( contents.length ) {\n\t\t\t\t\tcontents.wrapAll( html );\n\t\n\t\t\t\t} else {\n\t\t\t\t\tself.append( html );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\t\n\t\twrap: function( html ) {\n\t\t\tvar isFunction = jQuery.isFunction( html );\n\t\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t\t} );\n\t\t},\n\t\n\t\tunwrap: function( selector ) {\n\t\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\t\n\t\n\tjQuery.expr.pseudos.hidden = function( elem ) {\n\t\treturn !jQuery.expr.pseudos.visible( elem );\n\t};\n\tjQuery.expr.pseudos.visible = function( elem ) {\n\t\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n\t};\n\t\n\t\n\t\n\t\n\tjQuery.ajaxSettings.xhr = function() {\n\t\ttry {\n\t\t\treturn new window.XMLHttpRequest();\n\t\t} catch ( e ) {}\n\t};\n\t\n\tvar xhrSuccessStatus = {\n\t\n\t\t\t// File protocol always yields status code 0, assume 200\n\t\t\t0: 200,\n\t\n\t\t\t// Support: IE <=9 only\n\t\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t\t1223: 204\n\t\t},\n\t\txhrSupported = jQuery.ajaxSettings.xhr();\n\t\n\tsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n\tsupport.ajax = xhrSupported = !!xhrSupported;\n\t\n\tjQuery.ajaxTransport( function( options ) {\n\t\tvar callback, errorCallback;\n\t\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t\txhr = options.xhr();\n\t\n\t\t\t\t\txhr.open(\n\t\t\t\t\t\toptions.type,\n\t\t\t\t\t\toptions.url,\n\t\t\t\t\t\toptions.async,\n\t\t\t\t\t\toptions.username,\n\t\t\t\t\t\toptions.password\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Callback\n\t\t\t\t\tcallback = function( type ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\t\n\t\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcomplete(\n\t\n\t\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\n\t\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// Listen to events\n\t\t\t\t\txhr.onload = callback();\n\t\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\t\n\t\t\t\t\t// Support: IE 9 only\n\t\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t\t// to handle uncaught aborts\n\t\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.onreadystatechange = function() {\n\t\n\t\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\t\n\t\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Create the abort callback\n\t\t\t\t\tcallback = callback( \"abort\" );\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\tjQuery.ajaxPrefilter( function( s ) {\n\t\tif ( s.crossDomain ) {\n\t\t\ts.contents.script = false;\n\t\t}\n\t} );\n\t\n\t// Install script dataType\n\tjQuery.ajaxSetup( {\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /\\b(?:java|ecma)script\\b/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function( text ) {\n\t\t\t\tjQuery.globalEval( text );\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t// Handle cache's special case and crossDomain\n\tjQuery.ajaxPrefilter( \"script\", function( s ) {\n\t\tif ( s.cache === undefined ) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif ( s.crossDomain ) {\n\t\t\ts.type = \"GET\";\n\t\t}\n\t} );\n\t\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport( \"script\", function( s ) {\n\t\n\t\t// This transport only deals with cross domain requests\n\t\tif ( s.crossDomain ) {\n\t\t\tvar script, callback;\n\t\t\treturn {\n\t\t\t\tsend: function( _, complete ) {\n\t\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\t\tsrc: s.url\n\t\t\t\t\t} ).on(\n\t\t\t\t\t\t\"load error\",\n\t\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t\t},\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\tvar oldCallbacks = [],\n\t\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\t\n\t// Default jsonp settings\n\tjQuery.ajaxSetup( {\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function() {\n\t\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\t\tthis[ callback ] = true;\n\t\t\treturn callback;\n\t\t}\n\t} );\n\t\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\t\n\t\tvar callbackName, overwritten, responseContainer,\n\t\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\t\"url\" :\n\t\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t\t);\n\t\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\t\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\t\ts.jsonpCallback() :\n\t\t\t\ts.jsonpCallback;\n\t\n\t\t\t// Insert callback into url or form data\n\t\t\tif ( jsonProp ) {\n\t\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t\t} else if ( s.jsonp !== false ) {\n\t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\t\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[ \"script json\" ] = function() {\n\t\t\t\tif ( !responseContainer ) {\n\t\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t\t}\n\t\t\t\treturn responseContainer[ 0 ];\n\t\t\t};\n\t\n\t\t\t// Force json dataType\n\t\t\ts.dataTypes[ 0 ] = \"json\";\n\t\n\t\t\t// Install callback\n\t\t\toverwritten = window[ callbackName ];\n\t\t\twindow[ callbackName ] = function() {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\t\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always( function() {\n\t\n\t\t\t\t// If previous value didn't exist - remove it\n\t\t\t\tif ( overwritten === undefined ) {\n\t\t\t\t\tjQuery( window ).removeProp( callbackName );\n\t\n\t\t\t\t// Otherwise restore preexisting value\n\t\t\t\t} else {\n\t\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t\t}\n\t\n\t\t\t\t// Save back as free\n\t\t\t\tif ( s[ callbackName ] ) {\n\t\n\t\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\t\n\t\t\t\t\t// Save the callback name for future use\n\t\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t\t}\n\t\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t\t}\n\t\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t} );\n\t\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t} );\n\t\n\t\n\t\n\t\n\t// Support: Safari 8 only\n\t// In Safari 8 documents created via document.implementation.createHTMLDocument\n\t// collapse sibling forms: the second one becomes a child of the first one.\n\t// Because of that, this security measure has to be disabled in Safari 8.\n\t// https://bugs.webkit.org/show_bug.cgi?id=137337\n\tsupport.createHTMLDocument = ( function() {\n\t\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\t\tbody.innerHTML = \"<form></form><form></form>\";\n\t\treturn body.childNodes.length === 2;\n\t} )();\n\t\n\t\n\t// Argument \"data\" should be string of html\n\t// context (optional): If specified, the fragment will be created in this context,\n\t// defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function( data, context, keepScripts ) {\n\t\tif ( typeof data !== \"string\" ) {\n\t\t\treturn [];\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\n\t\tvar base, parsed, scripts;\n\t\n\t\tif ( !context ) {\n\t\n\t\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t\t// by using document.implementation\n\t\t\tif ( support.createHTMLDocument ) {\n\t\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\t\n\t\t\t\t// Set the base href for the created document\n\t\t\t\t// so any parsed elements with URLs\n\t\t\t\t// are based on the document's URL (gh-2965)\n\t\t\t\tbase = context.createElement( \"base\" );\n\t\t\t\tbase.href = document.location.href;\n\t\t\t\tcontext.head.appendChild( base );\n\t\t\t} else {\n\t\t\t\tcontext = document;\n\t\t\t}\n\t\t}\n\t\n\t\tparsed = rsingleTag.exec( data );\n\t\tscripts = !keepScripts && [];\n\t\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t\t}\n\t\n\t\tparsed = buildFragment( [ data ], context, scripts );\n\t\n\t\tif ( scripts && scripts.length ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\t\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t};\n\t\n\t\n\t/**\n\t * Load a url into a page\n\t */\n\tjQuery.fn.load = function( url, params, callback ) {\n\t\tvar selector, type, response,\n\t\t\tself = this,\n\t\t\toff = url.indexOf( \" \" );\n\t\n\t\tif ( off > -1 ) {\n\t\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\t\turl = url.slice( 0, off );\n\t\t}\n\t\n\t\t// If it's a function\n\t\tif ( jQuery.isFunction( params ) ) {\n\t\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\t\n\t\t// Otherwise, build a param string\n\t\t} else if ( params && typeof params === \"object\" ) {\n\t\t\ttype = \"POST\";\n\t\t}\n\t\n\t\t// If we have elements to modify, make the request\n\t\tif ( self.length > 0 ) {\n\t\t\tjQuery.ajax( {\n\t\t\t\turl: url,\n\t\n\t\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t\t// Make value of this field explicit since\n\t\t\t\t// user can override it through ajaxSetup method\n\t\t\t\ttype: type || \"GET\",\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t} ).done( function( responseText ) {\n\t\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\t\n\t\t\t\tself.html( selector ?\n\t\n\t\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\t\n\t\t\t\t\t// Otherwise use the full result\n\t\t\t\t\tresponseText );\n\t\n\t\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t\t// but they are ignored because response was set above.\n\t\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\t\tself.each( function() {\n\t\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\n\t\treturn this;\n\t};\n\t\n\t\n\t\n\t\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each( [\n\t\t\"ajaxStart\",\n\t\t\"ajaxStop\",\n\t\t\"ajaxComplete\",\n\t\t\"ajaxError\",\n\t\t\"ajaxSuccess\",\n\t\t\"ajaxSend\"\n\t], function( i, type ) {\n\t\tjQuery.fn[ type ] = function( fn ) {\n\t\t\treturn this.on( type, fn );\n\t\t};\n\t} );\n\t\n\t\n\t\n\t\n\tjQuery.expr.pseudos.animated = function( elem ) {\n\t\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t} ).length;\n\t};\n\t\n\t\n\t\n\t\n\t/**\n\t * Gets a window from an element\n\t */\n\tfunction getWindow( elem ) {\n\t\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n\t}\n\t\n\tjQuery.offset = {\n\t\tsetOffset: function( elem, options, i ) {\n\t\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\t\tcurElem = jQuery( elem ),\n\t\t\t\tprops = {};\n\t\n\t\t\t// Set position first, in-case top/left are set even on static elem\n\t\t\tif ( position === \"static\" ) {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\t\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\t\n\t\t\t// Need to be able to calculate position if either\n\t\t\t// top or left is auto and position is either absolute or fixed\n\t\t\tif ( calculatePosition ) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t\t}\n\t\n\t\t\tif ( jQuery.isFunction( options ) ) {\n\t\n\t\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t\t}\n\t\n\t\t\tif ( options.top != null ) {\n\t\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t\t}\n\t\t\tif ( options.left != null ) {\n\t\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t\t}\n\t\n\t\t\tif ( \"using\" in options ) {\n\t\t\t\toptions.using.call( elem, props );\n\t\n\t\t\t} else {\n\t\t\t\tcurElem.css( props );\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjQuery.fn.extend( {\n\t\toffset: function( options ) {\n\t\n\t\t\t// Preserve chaining for setter\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn options === undefined ?\n\t\t\t\t\tthis :\n\t\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t\t} );\n\t\t\t}\n\t\n\t\t\tvar docElem, win, rect, doc,\n\t\t\t\telem = this[ 0 ];\n\t\n\t\t\tif ( !elem ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Support: IE <=11 only\n\t\t\t// Running getBoundingClientRect on a\n\t\t\t// disconnected node in IE throws an error\n\t\t\tif ( !elem.getClientRects().length ) {\n\t\t\t\treturn { top: 0, left: 0 };\n\t\t\t}\n\t\n\t\t\trect = elem.getBoundingClientRect();\n\t\n\t\t\t// Make sure element is not hidden (display: none)\n\t\t\tif ( rect.width || rect.height ) {\n\t\t\t\tdoc = elem.ownerDocument;\n\t\t\t\twin = getWindow( doc );\n\t\t\t\tdocElem = doc.documentElement;\n\t\n\t\t\t\treturn {\n\t\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\t\treturn rect;\n\t\t},\n\t\n\t\tposition: function() {\n\t\t\tif ( !this[ 0 ] ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar offsetParent, offset,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tparentOffset = { top: 0, left: 0 };\n\t\n\t\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t\t// because it is its only offset parent\n\t\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\n\t\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\t\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\t\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset = {\n\t\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// Subtract parent offsets and element margins\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t\t};\n\t\t},\n\t\n\t\t// This method will return documentElement in the following cases:\n\t\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t\t//    documentElement of the parent window\n\t\t// 2) For the hidden or detached element\n\t\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t\t//\n\t\t// but those exceptions were never presented as a real life use-cases\n\t\t// and might be considered as more preferable results.\n\t\t//\n\t\t// This logic, however, is not guaranteed and can change at any point in the future\n\t\toffsetParent: function() {\n\t\t\treturn this.map( function() {\n\t\t\t\tvar offsetParent = this.offsetParent;\n\t\n\t\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\t\n\t\t\t\treturn offsetParent || documentElement;\n\t\t\t} );\n\t\t}\n\t} );\n\t\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\t\tvar top = \"pageYOffset\" === prop;\n\t\n\t\tjQuery.fn[ method ] = function( val ) {\n\t\t\treturn access( this, function( elem, method, val ) {\n\t\t\t\tvar win = getWindow( elem );\n\t\n\t\t\t\tif ( val === undefined ) {\n\t\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t\t}\n\t\n\t\t\t\tif ( win ) {\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t\t);\n\t\n\t\t\t\t} else {\n\t\t\t\t\telem[ method ] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length );\n\t\t};\n\t} );\n\t\n\t// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n\t// getComputedStyle returns percent when specified for top/left/bottom/right;\n\t// rather than make the css module depend on the offset module, just check for it here\n\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\t\tfunction( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\n\t\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\tcomputed;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t} );\n\t\n\t\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\t\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\t\tfunction( defaultExtra, funcName ) {\n\t\n\t\t\t// Margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\t\n\t\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\t\tvar doc;\n\t\n\t\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\n\t\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\t\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn value === undefined ?\n\t\n\t\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\t\n\t\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t\t};\n\t\t} );\n\t} );\n\t\n\t\n\tjQuery.fn.extend( {\n\t\n\t\tbind: function( types, data, fn ) {\n\t\t\treturn this.on( types, null, data, fn );\n\t\t},\n\t\tunbind: function( types, fn ) {\n\t\t\treturn this.off( types, null, fn );\n\t\t},\n\t\n\t\tdelegate: function( selector, types, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn );\n\t\t},\n\t\tundelegate: function( selector, types, fn ) {\n\t\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ?\n\t\t\t\tthis.off( selector, \"**\" ) :\n\t\t\t\tthis.off( types, selector || \"**\", fn );\n\t\t}\n\t} );\n\t\n\tjQuery.parseJSON = JSON.parse;\n\t\n\t\n\t\n\t\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\t\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\t\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn jQuery;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t\n\t\n\t\n\t\n\tvar\n\t\n\t\t// Map over jQuery in case of overwrite\n\t\t_jQuery = window.jQuery,\n\t\n\t\t// Map over the $ in case of overwrite\n\t\t_$ = window.$;\n\t\n\tjQuery.noConflict = function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\t\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\t\n\t\treturn jQuery;\n\t};\n\t\n\t// Expose jQuery and $ identifiers, even in AMD\n\t// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif ( !noGlobal ) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\t\n\t\n\t\n\t\n\t\n\treturn jQuery;\n\t} );\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.THREE = global.THREE || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\t\t// Polyfills\n\t\n\t\tif ( Number.EPSILON === undefined ) {\n\t\n\t\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tif ( Math.sign === undefined ) {\n\t\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\t\n\t\t\tMath.sign = function ( x ) {\n\t\n\t\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tif ( Function.prototype.name === undefined ) {\n\t\n\t\t\t// Missing in IE9-11.\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\t\n\t\t\tObject.defineProperty( Function.prototype, 'name', {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tif ( Object.assign === undefined ) {\n\t\n\t\t\t// Missing in IE.\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t\n\t\t\t( function () {\n\t\n\t\t\t\tObject.assign = function ( target ) {\n\t\n\t\t\t\t\t'use strict';\n\t\n\t\t\t\t\tif ( target === undefined || target === null ) {\n\t\n\t\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar output = Object( target );\n\t\n\t\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\t\n\t\t\t\t\t\tvar source = arguments[ index ];\n\t\n\t\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\t\n\t\t\t\t\t\t\tfor ( var nextKey in source ) {\n\t\n\t\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\t\n\t\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn output;\n\t\n\t\t\t\t};\n\t\n\t\t\t} )();\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * https://github.com/mrdoob/eventdispatcher.js/\n\t\t */\n\t\n\t\tfunction EventDispatcher() {}\n\t\n\t\tObject.assign( EventDispatcher.prototype, {\n\t\n\t\t\taddEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\n\t\t\t\tif ( listeners[ type ] === undefined ) {\n\t\n\t\t\t\t\tlisteners[ type ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\t\n\t\t\t\t\tlisteners[ type ].push( listener );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\thasEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return false;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\n\t\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tremoveEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\t\t\tvar listenerArray = listeners[ type ];\n\t\n\t\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\t\tvar index = listenerArray.indexOf( listener );\n\t\n\t\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\t\tlistenerArray.splice( index, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tdispatchEvent: function ( event ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\t\t\tvar listenerArray = listeners[ event.type ];\n\t\n\t\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\t\tevent.target = this;\n\t\n\t\t\t\t\tvar array = [], i = 0;\n\t\t\t\t\tvar length = listenerArray.length;\n\t\n\t\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\t\tarray[ i ].call( this, event );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar REVISION = '82';\n\t\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\t\tvar CullFaceNone = 0;\n\t\tvar CullFaceBack = 1;\n\t\tvar CullFaceFront = 2;\n\t\tvar CullFaceFrontBack = 3;\n\t\tvar FrontFaceDirectionCW = 0;\n\t\tvar FrontFaceDirectionCCW = 1;\n\t\tvar BasicShadowMap = 0;\n\t\tvar PCFShadowMap = 1;\n\t\tvar PCFSoftShadowMap = 2;\n\t\tvar FrontSide = 0;\n\t\tvar BackSide = 1;\n\t\tvar DoubleSide = 2;\n\t\tvar FlatShading = 1;\n\t\tvar SmoothShading = 2;\n\t\tvar NoColors = 0;\n\t\tvar FaceColors = 1;\n\t\tvar VertexColors = 2;\n\t\tvar NoBlending = 0;\n\t\tvar NormalBlending = 1;\n\t\tvar AdditiveBlending = 2;\n\t\tvar SubtractiveBlending = 3;\n\t\tvar MultiplyBlending = 4;\n\t\tvar CustomBlending = 5;\n\t\tvar BlendingMode = {\n\t\t\tNoBlending: NoBlending,\n\t\t\tNormalBlending: NormalBlending,\n\t\t\tAdditiveBlending: AdditiveBlending,\n\t\t\tSubtractiveBlending: SubtractiveBlending,\n\t\t\tMultiplyBlending: MultiplyBlending,\n\t\t\tCustomBlending: CustomBlending\n\t\t};\n\t\tvar AddEquation = 100;\n\t\tvar SubtractEquation = 101;\n\t\tvar ReverseSubtractEquation = 102;\n\t\tvar MinEquation = 103;\n\t\tvar MaxEquation = 104;\n\t\tvar ZeroFactor = 200;\n\t\tvar OneFactor = 201;\n\t\tvar SrcColorFactor = 202;\n\t\tvar OneMinusSrcColorFactor = 203;\n\t\tvar SrcAlphaFactor = 204;\n\t\tvar OneMinusSrcAlphaFactor = 205;\n\t\tvar DstAlphaFactor = 206;\n\t\tvar OneMinusDstAlphaFactor = 207;\n\t\tvar DstColorFactor = 208;\n\t\tvar OneMinusDstColorFactor = 209;\n\t\tvar SrcAlphaSaturateFactor = 210;\n\t\tvar NeverDepth = 0;\n\t\tvar AlwaysDepth = 1;\n\t\tvar LessDepth = 2;\n\t\tvar LessEqualDepth = 3;\n\t\tvar EqualDepth = 4;\n\t\tvar GreaterEqualDepth = 5;\n\t\tvar GreaterDepth = 6;\n\t\tvar NotEqualDepth = 7;\n\t\tvar MultiplyOperation = 0;\n\t\tvar MixOperation = 1;\n\t\tvar AddOperation = 2;\n\t\tvar NoToneMapping = 0;\n\t\tvar LinearToneMapping = 1;\n\t\tvar ReinhardToneMapping = 2;\n\t\tvar Uncharted2ToneMapping = 3;\n\t\tvar CineonToneMapping = 4;\n\t\tvar UVMapping = 300;\n\t\tvar CubeReflectionMapping = 301;\n\t\tvar CubeRefractionMapping = 302;\n\t\tvar EquirectangularReflectionMapping = 303;\n\t\tvar EquirectangularRefractionMapping = 304;\n\t\tvar SphericalReflectionMapping = 305;\n\t\tvar CubeUVReflectionMapping = 306;\n\t\tvar CubeUVRefractionMapping = 307;\n\t\tvar TextureMapping = {\n\t\t\tUVMapping: UVMapping,\n\t\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t\t};\n\t\tvar RepeatWrapping = 1000;\n\t\tvar ClampToEdgeWrapping = 1001;\n\t\tvar MirroredRepeatWrapping = 1002;\n\t\tvar TextureWrapping = {\n\t\t\tRepeatWrapping: RepeatWrapping,\n\t\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t\t};\n\t\tvar NearestFilter = 1003;\n\t\tvar NearestMipMapNearestFilter = 1004;\n\t\tvar NearestMipMapLinearFilter = 1005;\n\t\tvar LinearFilter = 1006;\n\t\tvar LinearMipMapNearestFilter = 1007;\n\t\tvar LinearMipMapLinearFilter = 1008;\n\t\tvar TextureFilter = {\n\t\t\tNearestFilter: NearestFilter,\n\t\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\t\tLinearFilter: LinearFilter,\n\t\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t\t};\n\t\tvar UnsignedByteType = 1009;\n\t\tvar ByteType = 1010;\n\t\tvar ShortType = 1011;\n\t\tvar UnsignedShortType = 1012;\n\t\tvar IntType = 1013;\n\t\tvar UnsignedIntType = 1014;\n\t\tvar FloatType = 1015;\n\t\tvar HalfFloatType = 1016;\n\t\tvar UnsignedShort4444Type = 1017;\n\t\tvar UnsignedShort5551Type = 1018;\n\t\tvar UnsignedShort565Type = 1019;\n\t\tvar UnsignedInt248Type = 1020;\n\t\tvar AlphaFormat = 1021;\n\t\tvar RGBFormat = 1022;\n\t\tvar RGBAFormat = 1023;\n\t\tvar LuminanceFormat = 1024;\n\t\tvar LuminanceAlphaFormat = 1025;\n\t\tvar RGBEFormat = RGBAFormat;\n\t\tvar DepthFormat = 1026;\n\t\tvar DepthStencilFormat = 1027;\n\t\tvar RGB_S3TC_DXT1_Format = 2001;\n\t\tvar RGBA_S3TC_DXT1_Format = 2002;\n\t\tvar RGBA_S3TC_DXT3_Format = 2003;\n\t\tvar RGBA_S3TC_DXT5_Format = 2004;\n\t\tvar RGB_PVRTC_4BPPV1_Format = 2100;\n\t\tvar RGB_PVRTC_2BPPV1_Format = 2101;\n\t\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\n\t\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\n\t\tvar RGB_ETC1_Format = 2151;\n\t\tvar LoopOnce = 2200;\n\t\tvar LoopRepeat = 2201;\n\t\tvar LoopPingPong = 2202;\n\t\tvar InterpolateDiscrete = 2300;\n\t\tvar InterpolateLinear = 2301;\n\t\tvar InterpolateSmooth = 2302;\n\t\tvar ZeroCurvatureEnding = 2400;\n\t\tvar ZeroSlopeEnding = 2401;\n\t\tvar WrapAroundEnding = 2402;\n\t\tvar TrianglesDrawMode = 0;\n\t\tvar TriangleStripDrawMode = 1;\n\t\tvar TriangleFanDrawMode = 2;\n\t\tvar LinearEncoding = 3000;\n\t\tvar sRGBEncoding = 3001;\n\t\tvar GammaEncoding = 3007;\n\t\tvar RGBEEncoding = 3002;\n\t\tvar LogLuvEncoding = 3003;\n\t\tvar RGBM7Encoding = 3004;\n\t\tvar RGBM16Encoding = 3005;\n\t\tvar RGBDEncoding = 3006;\n\t\tvar BasicDepthPacking = 3200;\n\t\tvar RGBADepthPacking = 3201;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar _Math = {\n\t\n\t\t\tDEG2RAD: Math.PI / 180,\n\t\t\tRAD2DEG: 180 / Math.PI,\n\t\n\t\t\tgenerateUUID: function () {\n\t\n\t\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\t\n\t\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\t\tvar uuid = new Array( 36 );\n\t\t\t\tvar rnd = 0, r;\n\t\n\t\t\t\treturn function generateUUID() {\n\t\n\t\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\t\n\t\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\t\n\t\t\t\t\t\t\tuuid[ i ] = '-';\n\t\n\t\t\t\t\t\t} else if ( i === 14 ) {\n\t\n\t\t\t\t\t\t\tuuid[ i ] = '4';\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn uuid.join( '' );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclamp: function ( value, min, max ) {\n\t\n\t\t\t\treturn Math.max( min, Math.min( max, value ) );\n\t\n\t\t\t},\n\t\n\t\t\t// compute euclidian modulo of m % n\n\t\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\t\n\t\t\teuclideanModulo: function ( n, m ) {\n\t\n\t\t\t\treturn ( ( n % m ) + m ) % m;\n\t\n\t\t\t},\n\t\n\t\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\t\n\t\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\t\n\t\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\t\n\t\t\t},\n\t\n\t\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\t\n\t\t\tlerp: function ( x, y, t ) {\n\t\n\t\t\t\treturn ( 1 - t ) * x + t * y;\n\t\n\t\t\t},\n\t\n\t\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\t\n\t\t\tsmoothstep: function ( x, min, max ) {\n\t\n\t\t\t\tif ( x <= min ) return 0;\n\t\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\t\treturn x * x * ( 3 - 2 * x );\n\t\n\t\t\t},\n\t\n\t\t\tsmootherstep: function ( x, min, max ) {\n\t\n\t\t\t\tif ( x <= min ) return 0;\n\t\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\t\n\t\t\t},\n\t\n\t\t\trandom16: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\t\treturn Math.random();\n\t\n\t\t\t},\n\t\n\t\t\t// Random integer from <low, high> interval\n\t\n\t\t\trandInt: function ( low, high ) {\n\t\n\t\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\t\n\t\t\t},\n\t\n\t\t\t// Random float from <low, high> interval\n\t\n\t\t\trandFloat: function ( low, high ) {\n\t\n\t\t\t\treturn low + Math.random() * ( high - low );\n\t\n\t\t\t},\n\t\n\t\t\t// Random float from <-range/2, range/2> interval\n\t\n\t\t\trandFloatSpread: function ( range ) {\n\t\n\t\t\t\treturn range * ( 0.5 - Math.random() );\n\t\n\t\t\t},\n\t\n\t\t\tdegToRad: function ( degrees ) {\n\t\n\t\t\t\treturn degrees * _Math.DEG2RAD;\n\t\n\t\t\t},\n\t\n\t\t\tradToDeg: function ( radians ) {\n\t\n\t\t\t\treturn radians * _Math.RAD2DEG;\n\t\n\t\t\t},\n\t\n\t\t\tisPowerOfTwo: function ( value ) {\n\t\n\t\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\t\n\t\t\t},\n\t\n\t\t\tnearestPowerOfTwo: function ( value ) {\n\t\n\t\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\t\n\t\t\t},\n\t\n\t\t\tnextPowerOfTwo: function ( value ) {\n\t\n\t\t\t\tvalue --;\n\t\t\t\tvalue |= value >> 1;\n\t\t\t\tvalue |= value >> 2;\n\t\t\t\tvalue |= value >> 4;\n\t\t\t\tvalue |= value >> 8;\n\t\t\t\tvalue |= value >> 16;\n\t\t\t\tvalue ++;\n\t\n\t\t\t\treturn value;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tfunction Vector2( x, y ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\n\t\t}\n\t\n\t\tVector2.prototype = {\n\t\n\t\t\tconstructor: Vector2,\n\t\n\t\t\tisVector2: true,\n\t\n\t\t\tget width() {\n\t\n\t\t\t\treturn this.x;\n\t\n\t\t\t},\n\t\n\t\t\tset width( value ) {\n\t\n\t\t\t\tthis.x = value;\n\t\n\t\t\t},\n\t\n\t\t\tget height() {\n\t\n\t\t\t\treturn this.y;\n\t\n\t\t\t},\n\t\n\t\t\tset height( value ) {\n\t\n\t\t\t\tthis.y = value;\n\t\n\t\t\t},\n\t\n\t\t\t//\n\t\n\t\t\tset: function ( x, y ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( v ) {\n\t\n\t\t\t\tthis.x *= v.x;\n\t\t\t\tthis.y *= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\tthis.y *= scalar;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t\tthis.y = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivide: function ( v ) {\n\t\n\t\t\t\tthis.x /= v.x;\n\t\t\t\tthis.y /= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector2();\n\t\t\t\t\t\tmax = new Vector2();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclampLength: function ( min, max ) {\n\t\n\t\t\t\tvar length = this.length();\n\t\n\t\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t\t},\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\t\n\t\t\t},\n\t\n\t\t\tlengthManhattan: function() {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tangle: function () {\n\t\n\t\t\t\t// computes the angle in radians with respect to the positive x-axis\n\t\n\t\t\t\tvar angle = Math.atan2( this.y, this.x );\n\t\n\t\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\t\n\t\t\t\treturn angle;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\t\treturn dx * dx + dy * dy;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\t\tthis.x = attribute.array[ index ];\n\t\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateAround: function ( center, angle ) {\n\t\n\t\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\t\n\t\t\t\tvar x = this.x - center.x;\n\t\t\t\tvar y = this.y - center.y;\n\t\n\t\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\t\tthis.y = x * s + y * c + center.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author szimek / https://github.com/szimek/\n\t\t */\n\t\n\t\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: TextureIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.sourceFile = '';\n\t\n\t\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\t\tthis.mipmaps = [];\n\t\n\t\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\t\n\t\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\t\n\t\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\t\n\t\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\t\n\t\t\tthis.offset = new Vector2( 0, 0 );\n\t\t\tthis.repeat = new Vector2( 1, 1 );\n\t\n\t\t\tthis.generateMipmaps = true;\n\t\t\tthis.premultiplyAlpha = false;\n\t\t\tthis.flipY = true;\n\t\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\t\n\t\n\t\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t\t//\n\t\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\t\tthis.encoding = encoding !== undefined ? encoding :  LinearEncoding;\n\t\n\t\t\tthis.version = 0;\n\t\t\tthis.onUpdate = null;\n\t\n\t\t}\n\t\n\t\tTexture.DEFAULT_IMAGE = undefined;\n\t\tTexture.DEFAULT_MAPPING = UVMapping;\n\t\n\t\tTexture.prototype = {\n\t\n\t\t\tconstructor: Texture,\n\t\n\t\t\tisTexture: true,\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.image = source.image;\n\t\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\t\n\t\t\t\tthis.mapping = source.mapping;\n\t\n\t\t\t\tthis.wrapS = source.wrapS;\n\t\t\t\tthis.wrapT = source.wrapT;\n\t\n\t\t\t\tthis.magFilter = source.magFilter;\n\t\t\t\tthis.minFilter = source.minFilter;\n\t\n\t\t\t\tthis.anisotropy = source.anisotropy;\n\t\n\t\t\t\tthis.format = source.format;\n\t\t\t\tthis.type = source.type;\n\t\n\t\t\t\tthis.offset.copy( source.offset );\n\t\t\t\tthis.repeat.copy( source.repeat );\n\t\n\t\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\t\tthis.flipY = source.flipY;\n\t\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\t\tthis.encoding = source.encoding;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\t\n\t\t\t\t\treturn meta.textures[ this.uuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getDataURL( image ) {\n\t\n\t\t\t\t\tvar canvas;\n\t\n\t\t\t\t\tif ( image.toDataURL !== undefined ) {\n\t\n\t\t\t\t\t\tcanvas = image;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\t\tcanvas.height = image.height;\n\t\n\t\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\t\n\t\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar output = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t\t},\n\t\n\t\t\t\t\tuuid: this.uuid,\n\t\t\t\t\tname: this.name,\n\t\n\t\t\t\t\tmapping: this.mapping,\n\t\n\t\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\t\n\t\t\t\t\tminFilter: this.minFilter,\n\t\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\t\tanisotropy: this.anisotropy,\n\t\n\t\t\t\t\tflipY: this.flipY\n\t\t\t\t};\n\t\n\t\t\t\tif ( this.image !== undefined ) {\n\t\n\t\t\t\t\t// TODO: Move to THREE.Image\n\t\n\t\t\t\t\tvar image = this.image;\n\t\n\t\t\t\t\tif ( image.uuid === undefined ) {\n\t\n\t\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toutput.image = image.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmeta.textures[ this.uuid ] = output;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t},\n\t\n\t\t\ttransformUv: function ( uv ) {\n\t\n\t\t\t\tif ( this.mapping !== UVMapping )  return;\n\t\n\t\t\t\tuv.multiply( this.repeat );\n\t\t\t\tuv.add( this.offset );\n\t\n\t\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\t\n\t\t\t\t\tswitch ( this.wrapS ) {\n\t\n\t\t\t\t\t\tcase RepeatWrapping:\n\t\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\t\n\t\t\t\t\tswitch ( this.wrapT ) {\n\t\n\t\t\t\t\t\tcase RepeatWrapping:\n\t\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.flipY ) {\n\t\n\t\t\t\t\tuv.y = 1 - uv.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Texture.prototype, EventDispatcher.prototype );\n\t\n\t\tvar count = 0;\n\t\tfunction TextureIdCount() { return count++; }\n\t\n\t\t/**\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Vector4( x, y, z, w ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t\tthis.z = z || 0;\n\t\t\tthis.w = ( w !== undefined ) ? w : 1;\n\t\n\t\t}\n\t\n\t\tVector4.prototype = {\n\t\n\t\t\tconstructor: Vector4,\n\t\n\t\t\tisVector4: true,\n\t\n\t\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\t\t\tthis.w = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\t\t\tthis.z = scalar;\n\t\t\t\tthis.w = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( z ) {\n\t\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( w ) {\n\t\n\t\t\t\tthis.w = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tcase 2: return this.z;\n\t\t\t\t\tcase 3: return this.w;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\t\t\tthis.z = v.z;\n\t\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\t\t\tthis.z += v.z;\n\t\t\t\tthis.w += v.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\t\t\tthis.z += s;\n\t\t\t\tthis.w += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\tthis.z = a.z + b.z;\n\t\t\t\tthis.w = a.w + b.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\t\t\tthis.z += v.z * s;\n\t\t\t\tthis.w += v.w * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\t\t\tthis.z -= v.z;\n\t\t\t\tthis.w -= v.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\t\t\tthis.z -= s;\n\t\t\t\tthis.w -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\tthis.z = a.z - b.z;\n\t\t\t\tthis.w = a.w - b.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\tthis.y *= scalar;\n\t\t\t\t\tthis.z *= scalar;\n\t\t\t\t\tthis.w *= scalar;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t\tthis.z = 0;\n\t\t\t\t\tthis.w = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t\n\t\t\t\t// q is assumed to be normalized\n\t\n\t\t\t\tthis.w = 2 * Math.acos( q.w );\n\t\n\t\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\t\n\t\t\t\tif ( s < 0.0001 ) {\n\t\n\t\t\t\t\t this.x = 1;\n\t\t\t\t\t this.y = 0;\n\t\t\t\t\t this.z = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t this.x = q.x / s;\n\t\t\t\t\t this.y = q.y / s;\n\t\t\t\t\t this.z = q.z / s;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\t\n\t\t\t\t\tte = m.elements,\n\t\n\t\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\t\n\t\t\t\t\t// singularity found\n\t\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t\t// in leading diagonal and zero in other terms\n\t\n\t\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\t\n\t\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\t\n\t\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// otherwise this singularity is angle = 180\n\t\n\t\t\t\t\tangle = Math.PI;\n\t\n\t\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\t\n\t\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\t\n\t\t\t\t\t\t// m11 is the largest diagonal term\n\t\n\t\t\t\t\t\tif ( xx < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\t\tz = xz / x;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( yy > zz ) {\n\t\n\t\t\t\t\t\t// m22 is the largest diagonal term\n\t\n\t\t\t\t\t\tif ( yy < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\t\tz = yz / y;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\t\n\t\t\t\t\t\tif ( zz < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\tz = 0;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\t\ty = yz / z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.set( x, y, z, angle );\n\t\n\t\t\t\t\treturn this; // return 180 deg rotation\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// as we have reached here there are no singularities so we can handle normally\n\t\n\t\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\t\n\t\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\t\n\t\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t\t// caught by singularity test above, but I've left it in just in case\n\t\n\t\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\t\tthis.w = Math.min( this.w, v.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\t\tthis.w = Math.max( this.w, v.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\t\tmax = new Vector4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\t\t\tthis.z = Math.floor( this.z );\n\t\t\t\tthis.w = Math.floor( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\t\t\tthis.z = Math.ceil( this.z );\n\t\t\t\tthis.w = Math.ceil( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\t\t\tthis.z = Math.round( this.z );\n\t\t\t\tthis.w = Math.round( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\t\t\tthis.z = - this.z;\n\t\t\t\tthis.w = - this.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\t\n\t\t\t},\n\t\n\t\t\tlengthManhattan: function () {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\t\t\tthis.z = array[ offset + 2 ];\n\t\t\t\tthis.w = array[ offset + 3 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\t\tarray[ offset + 3 ] = this.w;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\t\tthis.x = attribute.array[ index ];\n\t\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\t\tthis.w = attribute.array[ index + 3 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author szimek / https://github.com/szimek/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author Marius Kintel / https://github.com/kintel\n\t\t */\n\t\n\t\t/*\n\t\t In options, we can specify:\n\t\t * Texture parameters for an auto-generated target texture\n\t\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t\t*/\n\t\tfunction WebGLRenderTarget( width, height, options ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\n\t\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\t\tthis.scissorTest = false;\n\t\n\t\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\t\n\t\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\t\n\t\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\t\n\t\t}\n\t\n\t\tObject.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisWebGLRenderTarget: true,\n\t\n\t\t\tsetSize: function ( width, height ) {\n\t\n\t\t\t\tif ( this.width !== width || this.height !== height ) {\n\t\n\t\t\t\t\tthis.width = width;\n\t\t\t\t\tthis.height = height;\n\t\n\t\t\t\t\tthis.dispose();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\t\tthis.scissor.set( 0, 0, width, height );\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.width = source.width;\n\t\t\t\tthis.height = source.height;\n\t\n\t\t\t\tthis.viewport.copy( source.viewport );\n\t\n\t\t\t\tthis.texture = source.texture.clone();\n\t\n\t\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\t\tthis.depthTexture = source.depthTexture;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com\n\t\t */\n\t\n\t\tfunction WebGLRenderTargetCube( width, height, options ) {\n\t\n\t\t\tWebGLRenderTarget.call( this, width, height, options );\n\t\n\t\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\t\tthis.activeMipMapLevel = 0;\n\t\n\t\t}\n\t\n\t\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\t\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\t\n\t\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Quaternion( x, y, z, w ) {\n\t\n\t\t\tthis._x = x || 0;\n\t\t\tthis._y = y || 0;\n\t\t\tthis._z = z || 0;\n\t\t\tthis._w = ( w !== undefined ) ? w : 1;\n\t\n\t\t}\n\t\n\t\tQuaternion.prototype = {\n\t\n\t\t\tconstructor: Quaternion,\n\t\n\t\t\tget x () {\n\t\n\t\t\t\treturn this._x;\n\t\n\t\t\t},\n\t\n\t\t\tset x ( value ) {\n\t\n\t\t\t\tthis._x = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget y () {\n\t\n\t\t\t\treturn this._y;\n\t\n\t\t\t},\n\t\n\t\t\tset y ( value ) {\n\t\n\t\t\t\tthis._y = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget z () {\n\t\n\t\t\t\treturn this._z;\n\t\n\t\t\t},\n\t\n\t\t\tset z ( value ) {\n\t\n\t\t\t\tthis._z = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget w () {\n\t\n\t\t\t\treturn this._w;\n\t\n\t\t\t},\n\t\n\t\t\tset w ( value ) {\n\t\n\t\t\t\tthis._w = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\tthis._w = w;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( quaternion ) {\n\t\n\t\t\t\tthis._x = quaternion.x;\n\t\t\t\tthis._y = quaternion.y;\n\t\t\t\tthis._z = quaternion.z;\n\t\t\t\tthis._w = quaternion.w;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromEuler: function ( euler, update ) {\n\t\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\t\n\t\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t\t//\tcontent/SpinCalc.m\n\t\n\t\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\t\n\t\t\t\tvar order = euler.order;\n\t\n\t\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\n\t\t\t\t// assumes axis is normalized\n\t\n\t\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\t\n\t\t\t\tthis._x = axis.x * s;\n\t\t\t\tthis._y = axis.y * s;\n\t\t\t\tthis._z = axis.z * s;\n\t\t\t\tthis._w = Math.cos( halfAngle );\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromRotationMatrix: function ( m ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar te = m.elements,\n\t\n\t\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\t\n\t\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\t\ts;\n\t\n\t\t\t\tif ( trace > 0 ) {\n\t\n\t\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\t\n\t\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\t\n\t\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\t\n\t\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\t\n\t\t\t\t} else if ( m22 > m33 ) {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\t\n\t\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\t\n\t\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\t\tthis._z = 0.25 * s;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromUnitVectors: function () {\n\t\n\t\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\t\n\t\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\t\n\t\t\t\tvar v1, r;\n\t\n\t\t\t\tvar EPS = 0.000001;\n\t\n\t\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\t\n\t\t\t\t\tif ( r < EPS ) {\n\t\n\t\t\t\t\t\tr = 0;\n\t\n\t\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\t\n\t\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._x = v1.x;\n\t\t\t\t\tthis._y = v1.y;\n\t\t\t\t\tthis._z = v1.z;\n\t\t\t\t\tthis._w = r;\n\t\n\t\t\t\t\treturn this.normalize();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tinverse: function () {\n\t\n\t\t\t\treturn this.conjugate().normalize();\n\t\n\t\t\t},\n\t\n\t\t\tconjugate: function () {\n\t\n\t\t\t\tthis._x *= - 1;\n\t\t\t\tthis._y *= - 1;\n\t\t\t\tthis._z *= - 1;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\tvar l = this.length();\n\t\n\t\t\t\tif ( l === 0 ) {\n\t\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = 0;\n\t\t\t\t\tthis._w = 1;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tl = 1 / l;\n\t\n\t\t\t\t\tthis._x = this._x * l;\n\t\t\t\t\tthis._y = this._y * l;\n\t\t\t\t\tthis._z = this._z * l;\n\t\t\t\t\tthis._w = this._w * l;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( q, p ) {\n\t\n\t\t\t\tif ( p !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyQuaternions( q, p );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.multiplyQuaternions( this, q );\n\t\n\t\t\t},\n\t\n\t\t\tpremultiply: function ( q ) {\n\t\n\t\t\t\treturn this.multiplyQuaternions( q, this );\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyQuaternions: function ( a, b ) {\n\t\n\t\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\n\t\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\t\n\t\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tslerp: function ( qb, t ) {\n\t\n\t\t\t\tif ( t === 0 ) return this;\n\t\t\t\tif ( t === 1 ) return this.copy( qb );\n\t\n\t\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\t\n\t\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\t\n\t\t\t\tif ( cosHalfTheta < 0 ) {\n\t\n\t\t\t\t\tthis._w = - qb._w;\n\t\t\t\t\tthis._x = - qb._x;\n\t\t\t\t\tthis._y = - qb._y;\n\t\t\t\t\tthis._z = - qb._z;\n\t\n\t\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.copy( qb );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\t\n\t\t\t\t\tthis._w = w;\n\t\t\t\t\tthis._x = x;\n\t\t\t\t\tthis._y = y;\n\t\t\t\t\tthis._z = z;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\t\n\t\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\t\n\t\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\t\n\t\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( quaternion ) {\n\t\n\t\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis._x = array[ offset ];\n\t\t\t\tthis._y = array[ offset + 1 ];\n\t\t\t\tthis._z = array[ offset + 2 ];\n\t\t\t\tthis._w = array[ offset + 3 ];\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this._x;\n\t\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\t\tarray[ offset + 3 ] = this._w;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tonChange: function ( callback ) {\n\t\n\t\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tonChangeCallback: function () {}\n\t\n\t\t};\n\t\n\t\tObject.assign( Quaternion, {\n\t\n\t\t\tslerp: function( qa, qb, qm, t ) {\n\t\n\t\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\t\n\t\t\t},\n\t\n\t\t\tslerpFlat: function(\n\t\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\t\n\t\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\t\n\t\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\t\n\t\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\t\n\t\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\t\n\t\t\t\t\tvar s = 1 - t,\n\t\n\t\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\n\t\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\t\tsqrSin = 1 - cos * cos;\n\t\n\t\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\t\n\t\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar tDir = t * dir;\n\t\n\t\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\t\tw0 = w0 * s + w1 * tDir;\n\t\n\t\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\t\tif ( s === 1 - t ) {\n\t\n\t\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\t\n\t\t\t\t\t\tx0 *= f;\n\t\t\t\t\t\ty0 *= f;\n\t\t\t\t\t\tz0 *= f;\n\t\t\t\t\t\tw0 *= f;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdst[ dstOffset ] = x0;\n\t\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author *kile / http://kile.stravaganza.org/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Vector3( x, y, z ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t\tthis.z = z || 0;\n\t\n\t\t}\n\t\n\t\tVector3.prototype = {\n\t\n\t\t\tconstructor: Vector3,\n\t\n\t\t\tisVector3: true,\n\t\n\t\t\tset: function ( x, y, z ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\t\t\tthis.z = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( z ) {\n\t\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tcase 2: return this.z;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\t\t\tthis.z = v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\t\t\tthis.z += v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\t\t\tthis.z += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\tthis.z = a.z + b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\t\t\tthis.z += v.z * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\t\t\tthis.z -= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\t\t\tthis.z -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\tthis.z = a.z - b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x *= v.x;\n\t\t\t\tthis.y *= v.y;\n\t\t\t\tthis.z *= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\tthis.y *= scalar;\n\t\t\t\t\tthis.z *= scalar;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t\tthis.z = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x * b.x;\n\t\t\t\tthis.y = a.y * b.y;\n\t\t\t\tthis.z = a.z * b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyEuler: function () {\n\t\n\t\t\t\tvar quaternion;\n\t\n\t\t\t\treturn function applyEuler( euler ) {\n\t\n\t\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\t\n\t\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyAxisAngle: function () {\n\t\n\t\t\t\tvar quaternion;\n\t\n\t\t\t\treturn function applyAxisAngle( axis, angle ) {\n\t\n\t\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\t\n\t\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyMatrix3: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 affine matrix\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyProjection: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 projection matrix\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\t\n\t\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyQuaternion: function ( q ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\t\n\t\t\t\t// calculate quat * vector\n\t\n\t\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\t\n\t\t\t\t// calculate result * inverse quat\n\t\n\t\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tproject: function () {\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\treturn function project( camera ) {\n\t\n\t\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\t\n\t\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tunproject: function () {\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\treturn function unproject( camera ) {\n\t\n\t\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\t\n\t\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttransformDirection: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t\t// vector interpreted as a direction\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\t\n\t\t\t\treturn this.normalize();\n\t\n\t\t\t},\n\t\n\t\t\tdivide: function ( v ) {\n\t\n\t\t\t\tthis.x /= v.x;\n\t\t\t\tthis.y /= v.y;\n\t\t\t\tthis.z /= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\t\tthis.z = Math.min( this.z, v.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\t\tthis.z = Math.max( this.z, v.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector3();\n\t\t\t\t\t\tmax = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclampLength: function ( min, max ) {\n\t\n\t\t\t\tvar length = this.length();\n\t\n\t\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t\t},\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\t\t\tthis.z = Math.floor( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\t\t\tthis.z = Math.ceil( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\t\t\tthis.z = Math.round( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\t\t\tthis.z = - this.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\t\n\t\t\t},\n\t\n\t\t\tlengthManhattan: function () {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tcross: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.crossVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\n\t\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\t\tthis.z = x * v.y - y * v.x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcrossVectors: function ( a, b ) {\n\t\n\t\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\t\n\t\t\t\tthis.x = ay * bz - az * by;\n\t\t\t\tthis.y = az * bx - ax * bz;\n\t\t\t\tthis.z = ax * by - ay * bx;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tprojectOnVector: function ( vector ) {\n\t\n\t\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t\t\t},\n\t\n\t\t\tprojectOnPlane: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function projectOnPlane( planeNormal ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\t\n\t\t\t\t\treturn this.sub( v1 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\treflect: function () {\n\t\n\t\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t\t// normal is assumed to have unit length\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function reflect( normal ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tangleTo: function ( v ) {\n\t\n\t\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\t\n\t\t\t\t// clamp, to handle numerical problems\n\t\n\t\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\t\n\t\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromSpherical: function( s ) {\n\t\n\t\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\t\n\t\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixPosition: function ( m ) {\n\t\n\t\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixScale: function ( m ) {\n\t\n\t\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\tthis.x = sx;\n\t\t\t\tthis.y = sy;\n\t\t\t\tthis.z = sz;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixColumn: function ( m, index ) {\n\t\n\t\t\t\tif ( typeof m === 'number' ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\t\tvar temp = m;\n\t\t\t\t\tm = index;\n\t\t\t\t\tindex = temp;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.fromArray( m.elements, index * 4 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\t\t\tthis.z = array[ offset + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\t\tarray[ offset + 2 ] = this.z;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\t\tthis.x = attribute.array[ index ];\n\t\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author jordi_ros / http://plattsoft.com\n\t\t * @author D1plo1d / http://github.com/D1plo1d\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author timknip / http://www.floorplanner.com/\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Matrix4() {\n\t\n\t\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t] );\n\t\n\t\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tMatrix4.prototype = {\n\t\n\t\t\tconstructor: Matrix4,\n\t\n\t\t\tisMatrix4: true,\n\t\n\t\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tidentity: function () {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0, 0,\n\t\t\t\t\t0, 1, 0, 0,\n\t\t\t\t\t0, 0, 1, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new Matrix4().fromArray( this.elements );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( m ) {\n\t\n\t\t\t\tthis.elements.set( m.elements );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyPosition: function ( m ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\t\tte[ 14 ] = me[ 14 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\t\tthis.set(\n\t\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t\t0,       0,       0,       1\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\textractRotation: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function extractRotation( m ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\n\t\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\n\t\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmakeRotationFromEuler: function ( euler ) {\n\t\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\t\n\t\t\t\tif ( euler.order === 'XYZ' ) {\n\t\n\t\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\t\tte[ 8 ] = d;\n\t\n\t\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\t\tte[ 9 ] = - b * c;\n\t\n\t\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'YXZ' ) {\n\t\n\t\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\t\tte[ 8 ] = a * d;\n\t\n\t\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = - b;\n\t\n\t\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'ZXY' ) {\n\t\n\t\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\t\tte[ 8 ] = de + cf * b;\n\t\n\t\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = df - ce * b;\n\t\n\t\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\t\tte[ 6 ] = b;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'ZYX' ) {\n\t\n\t\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\t\tte[ 8 ] = ae * d + bf;\n\t\n\t\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\t\tte[ 9 ] = af * d - be;\n\t\n\t\t\t\t\tte[ 2 ] = - d;\n\t\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'YZX' ) {\n\t\n\t\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\t\tte[ 8 ] = bc * f + ad;\n\t\n\t\t\t\t\tte[ 1 ] = f;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = - b * e;\n\t\n\t\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\t\tte[ 10 ] = ac - bd * f;\n\t\n\t\t\t\t} else if ( euler.order === 'XZY' ) {\n\t\n\t\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = - f;\n\t\t\t\t\tte[ 8 ] = d * e;\n\t\n\t\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = ad * f - bc;\n\t\n\t\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\t\tte[ 10 ] = bd * f + ac;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// last column\n\t\t\t\tte[ 3 ] = 0;\n\t\t\t\tte[ 7 ] = 0;\n\t\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t\t// bottom row\n\t\t\t\tte[ 12 ] = 0;\n\t\t\t\tte[ 13 ] = 0;\n\t\t\t\tte[ 14 ] = 0;\n\t\t\t\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\t\n\t\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\t\tte[ 4 ] = xy - wz;\n\t\t\t\tte[ 8 ] = xz + wy;\n\t\n\t\t\t\tte[ 1 ] = xy + wz;\n\t\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\t\tte[ 9 ] = yz - wx;\n\t\n\t\t\t\tte[ 2 ] = xz - wy;\n\t\t\t\tte[ 6 ] = yz + wx;\n\t\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\t\n\t\t\t\t// last column\n\t\t\t\tte[ 3 ] = 0;\n\t\t\t\tte[ 7 ] = 0;\n\t\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t\t// bottom row\n\t\t\t\tte[ 12 ] = 0;\n\t\t\t\tte[ 13 ] = 0;\n\t\t\t\tte[ 14 ] = 0;\n\t\t\t\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar x, y, z;\n\t\n\t\t\t\treturn function lookAt( eye, target, up ) {\n\t\n\t\t\t\t\tif ( x === undefined ) {\n\t\n\t\t\t\t\t\tx = new Vector3();\n\t\t\t\t\t\ty = new Vector3();\n\t\t\t\t\t\tz = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\t\tz.subVectors( eye, target ).normalize();\n\t\n\t\t\t\t\tif ( z.lengthSq() === 0 ) {\n\t\n\t\t\t\t\t\tz.z = 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\t\tif ( x.lengthSq() === 0 ) {\n\t\n\t\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ty.crossVectors( z, x );\n\t\n\t\n\t\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmultiply: function ( m, n ) {\n\t\n\t\t\t\tif ( n !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyMatrices( m, n );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.multiplyMatrices( this, m );\n\t\n\t\t\t},\n\t\n\t\t\tpremultiply: function ( m ) {\n\t\n\t\t\t\treturn this.multiplyMatrices( m, this );\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyMatrices: function ( a, b ) {\n\t\n\t\t\t\tvar ae = a.elements;\n\t\t\t\tvar be = b.elements;\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\t\n\t\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\t\n\t\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\t\n\t\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\t\n\t\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\t\n\t\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyToArray: function ( a, b, r ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tthis.multiplyMatrices( a, b );\n\t\n\t\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyToVector3Array: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn array;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyToBuffer: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\t\tv1.applyMatrix4( this );\n\t\n\t\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn buffer;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tdeterminant: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\t\n\t\t\t\t//TODO: make this more efficient\n\t\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\t\n\t\t\t\treturn (\n\t\t\t\t\tn41 * (\n\t\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t\t) +\n\t\t\t\t\tn42 * (\n\t\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t\t) +\n\t\t\t\t\tn43 * (\n\t\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t\t) +\n\t\t\t\t\tn44 * (\n\t\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t\t)\n\t\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\ttranspose: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar tmp;\n\t\n\t\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\t\n\t\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\t\treturn this.toArray( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tgetPosition: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function getPosition() {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\t\n\t\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetPosition: function ( v ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 12 ] = v.x;\n\t\t\t\tte[ 13 ] = v.y;\n\t\t\t\tte[ 14 ] = v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\t\n\t\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\t\tvar te = this.elements,\n\t\t\t\t\tme = m.elements,\n\t\n\t\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\t\n\t\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\t\n\t\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\t\n\t\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\t\tif ( throwOnDegenerate === true ) {\n\t\n\t\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this.identity();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar detInv = 1 / det;\n\t\n\t\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tscale: function ( v ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar x = v.x, y = v.y, z = v.z;\n\t\n\t\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetMaxScaleOnAxis: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\t\n\t\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\t\n\t\t\t},\n\t\n\t\t\tmakeTranslation: function ( x, y, z ) {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0, x,\n\t\t\t\t\t0, 1, 0, y,\n\t\t\t\t\t0, 0, 1, z,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationX: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0,  0, 0,\n\t\t\t\t\t0, c, - s, 0,\n\t\t\t\t\t0, s,  c, 0,\n\t\t\t\t\t0, 0,  0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationY: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t c, 0, s, 0,\n\t\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t\t- s, 0, c, 0,\n\t\t\t\t\t 0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationZ: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tc, - s, 0, 0,\n\t\t\t\t\ts,  c, 0, 0,\n\t\t\t\t\t0,  0, 1, 0,\n\t\t\t\t\t0,  0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationAxis: function ( axis, angle ) {\n\t\n\t\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\t\n\t\t\t\tvar c = Math.cos( angle );\n\t\t\t\tvar s = Math.sin( angle );\n\t\t\t\tvar t = 1 - c;\n\t\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\t\tvar tx = t * x, ty = t * y;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\t return this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeScale: function ( x, y, z ) {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tx, 0, 0, 0,\n\t\t\t\t\t0, y, 0, 0,\n\t\t\t\t\t0, 0, z, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcompose: function ( position, quaternion, scale ) {\n\t\n\t\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\t\tthis.scale( scale );\n\t\t\t\tthis.setPosition( position );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdecompose: function () {\n\t\n\t\t\t\tvar vector, matrix;\n\t\n\t\t\t\treturn function decompose( position, quaternion, scale ) {\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tvector = new Vector3();\n\t\t\t\t\t\tmatrix = new Matrix4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\t\n\t\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\t\tvar det = this.determinant();\n\t\t\t\t\tif ( det < 0 ) {\n\t\n\t\t\t\t\t\tsx = - sx;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\t\tposition.z = te[ 14 ];\n\t\n\t\t\t\t\t// scale the rotation part\n\t\n\t\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\t\n\t\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\t\tvar invSZ = 1 / sz;\n\t\n\t\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\t\n\t\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\t\n\t\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\t\n\t\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\t\n\t\t\t\t\tscale.x = sx;\n\t\t\t\t\tscale.y = sy;\n\t\t\t\t\tscale.z = sz;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar x = 2 * near / ( right - left );\n\t\t\t\tvar y = 2 * near / ( top - bottom );\n\t\n\t\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\t\tvar d = - 2 * far * near / ( far - near );\n\t\n\t\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\t\n\t\t\t\tvar ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );\n\t\t\t\tvar ymin = - ymax;\n\t\t\t\tvar xmin = ymin * aspect;\n\t\t\t\tvar xmax = ymax * aspect;\n\t\n\t\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\t\n\t\t\t},\n\t\n\t\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar w = 1.0 / ( right - left );\n\t\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\t\tvar p = 1.0 / ( far - near );\n\t\n\t\t\t\tvar x = ( right + left ) * w;\n\t\t\t\tvar y = ( top + bottom ) * h;\n\t\t\t\tvar z = ( far + near ) * p;\n\t\n\t\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( matrix ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = matrix.elements;\n\t\n\t\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tfor( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\n\t\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\n\t\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\t\n\t\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\t\timages = images !== undefined ? images : [];\n\t\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\t\n\t\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.flipY = false;\n\t\n\t\t}\n\t\n\t\tCubeTexture.prototype = Object.create( Texture.prototype );\n\t\tCubeTexture.prototype.constructor = CubeTexture;\n\t\n\t\tCubeTexture.prototype.isCubeTexture = true;\n\t\n\t\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\t\n\t\t\tget: function () {\n\t\n\t\t\t\treturn this.image;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tthis.image = value;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t *\n\t\t * Uniforms of a program.\n\t\t * Those form a tree structure with a special top-level container for the root,\n\t\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t\t *\n\t\t *\n\t\t * Properties of inner nodes including the top-level container:\n\t\t *\n\t\t * .seq - array of nested uniforms\n\t\t * .map - nested uniforms by name\n\t\t *\n\t\t *\n\t\t * Methods of all nodes except the top-level container:\n\t\t *\n\t\t * .setValue( gl, value, [renderer] )\n\t\t *\n\t\t * \t\tuploads a uniform value(s)\n\t\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t\t *\n\t\t *\n\t\t * Static methods of the top-level container (renderer factorizations):\n\t\t *\n\t\t * .upload( gl, seq, values, renderer )\n\t\t *\n\t\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t\t *\n\t\t * .seqWithValue( seq, values ) : filteredSeq\n\t\t *\n\t\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t\t *\n\t\t *\n\t\t * Methods of the top-level container (renderer factorizations):\n\t\t *\n\t\t * .setValue( gl, name, value )\n\t\t *\n\t\t * \t\tsets uniform with  name 'name' to 'value'\n\t\t *\n\t\t * .set( gl, obj, prop )\n\t\t *\n\t\t * \t\tsets uniform from object and property with same name than uniform\n\t\t *\n\t\t * .setOptional( gl, obj, prop )\n\t\t *\n\t\t * \t\tlike .set for an optional property of the object\n\t\t *\n\t\t */\n\t\n\t\tvar emptyTexture = new Texture();\n\t\tvar emptyCubeTexture = new CubeTexture();\n\t\n\t\t// --- Base for inner nodes (including the root) ---\n\t\n\t\tfunction UniformContainer() {\n\t\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\t\n\t\t}\n\t\n\t\t// --- Utilities ---\n\t\n\t\t// Array Caches (provide typed arrays for temporary by size)\n\t\n\t\tvar arrayCacheF32 = [];\n\t\tvar arrayCacheI32 = [];\n\t\n\t\t// Flattening for arrays of vectors and matrices\n\t\n\t\tfunction flatten( array, nBlocks, blockSize ) {\n\t\n\t\t\tvar firstElem = array[ 0 ];\n\t\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\t\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\t\n\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\t\n\t\t\t}\n\t\n\t\t\tif ( nBlocks !== 0 ) {\n\t\n\t\t\t\tfirstElem.toArray( r, 0 );\n\t\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\t\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t}\n\t\n\t\t// Texture unit allocation\n\t\n\t\tfunction allocTexUnits( renderer, n ) {\n\t\n\t\t\tvar r = arrayCacheI32[ n ];\n\t\n\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\t\n\t\t\treturn r;\n\t\n\t\t}\n\t\n\t\t// --- Setters ---\n\t\n\t\t// Note: Defining these methods externally, because they come in a bunch\n\t\t// and this way their names minify.\n\t\n\t\t// Single scalar\n\t\n\t\tfunction setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }\n\t\tfunction setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }\n\t\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\t\n\t\tfunction setValue2fv( gl, v ) {\n\t\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\t\n\t\t}\n\t\n\t\tfunction setValue3fv( gl, v ) {\n\t\n\t\t\tif ( v.x !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\telse if ( v.r !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\telse\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\t\n\t\t}\n\t\n\t\tfunction setValue4fv( gl, v ) {\n\t\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\t\n\t\t}\n\t\n\t\t// Single matrix (from flat array or MatrixN)\n\t\n\t\tfunction setValue2fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\tfunction setValue3fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\tfunction setValue4fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\t// Single texture (2D / Cube)\n\t\n\t\tfunction setValueT1( gl, v, renderer ) {\n\t\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\t\n\t\t}\n\t\n\t\tfunction setValueT6( gl, v, renderer ) {\n\t\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\t\n\t\t}\n\t\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\t\n\t\tfunction setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }\n\t\tfunction setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }\n\t\tfunction setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }\n\t\n\t\t// Helper to pick the right setter for the singular case\n\t\n\t\tfunction getSingularSetter( type ) {\n\t\n\t\t\tswitch ( type ) {\n\t\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\t\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\t\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\t\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Array of scalars\n\t\n\t\tfunction setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }\n\t\tfunction setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }\n\t\n\t\t// Array of vectors (flat or from THREE classes)\n\t\n\t\tfunction setValueV2a( gl, v ) {\n\t\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueV3a( gl, v ) {\n\t\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueV4a( gl, v ) {\n\t\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\t\n\t\t}\n\t\n\t\t// Array of matrices (flat or from THREE clases)\n\t\n\t\tfunction setValueM2a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueM3a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueM4a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\t\n\t\t}\n\t\n\t\t// Array of textures (2D / Cube)\n\t\n\t\tfunction setValueT1a( gl, v, renderer ) {\n\t\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setValueT6a( gl, v, renderer ) {\n\t\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\t\n\t\tfunction getPureArraySetter( type ) {\n\t\n\t\t\tswitch ( type ) {\n\t\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\t\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\t\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\t\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// --- Uniform Classes ---\n\t\n\t\tfunction SingleUniform( id, activeInfo, addr ) {\n\t\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\t\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t}\n\t\n\t\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\t\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\t\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t}\n\t\n\t\tfunction StructuredUniform( id ) {\n\t\n\t\t\tthis.id = id;\n\t\n\t\t\tUniformContainer.call( this ); // mix-in\n\t\n\t\t}\n\t\n\t\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\t\n\t\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t\t// are not allowed in structured uniforms.\n\t\n\t\t\tvar seq = this.seq;\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tu.setValue( gl, value[ u.id ] );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// --- Top-level ---\n\t\n\t\t// Parser - builds up the property tree from the path strings\n\t\n\t\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\t\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\t\n\t\tfunction addUniform( container, uniformObject ) {\n\t\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\t\n\t\t}\n\t\n\t\tfunction parseUniform( activeInfo, addr, container ) {\n\t\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\t\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\t\n\t\t\tfor (; ;) {\n\t\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\t\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\t\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\t\n\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\t\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\t\n\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\tnext = map[ id ];\n\t\n\t\t\t\t\tif ( next === undefined ) {\n\t\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontainer = next;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Root Container\n\t\n\t\tfunction WebGLUniforms( gl, program, renderer ) {\n\t\n\t\t\tUniformContainer.call( this );\n\t\n\t\t\tthis.renderer = renderer;\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\t\n\t\t\t\tparseUniform( info, addr, this );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\t\n\t\t\tvar v = object[ name ];\n\t\n\t\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\t\n\t\t};\n\t\n\t\n\t\t// Static interface\n\t\n\t\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ],\n\t\t\t\t\tv = values[ u.id ];\n\t\n\t\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\n\t\t\t\t\tu.setValue( gl, v.value, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\t\n\t\t\tvar r = [];\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tif ( u.id in values ) r.push( u );\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Uniform Utilities\n\t\t */\n\t\n\t\tvar UniformsUtils = {\n\t\n\t\t\tmerge: function ( uniforms ) {\n\t\n\t\t\t\tvar merged = {};\n\t\n\t\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\t\n\t\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\t\n\t\t\t\t\tfor ( var p in tmp ) {\n\t\n\t\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn merged;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function ( uniforms_src ) {\n\t\n\t\t\t\tvar uniforms_dst = {};\n\t\n\t\t\t\tfor ( var u in uniforms_src ) {\n\t\n\t\t\t\t\tuniforms_dst[ u ] = {};\n\t\n\t\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\t\n\t\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\t\n\t\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\t\n\t\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn uniforms_dst;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\t\n\t\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\t\n\t\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\t\n\t\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\t\n\t\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\t\n\t\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\t\n\t\tvar bsdfs = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\t\n\t\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\t\n\t\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\t\n\t\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\t\n\t\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\t\n\t\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\t\n\t\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\t\n\t\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\t\n\t\tvar defaultnormal_vertex = \"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\t\n\t\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\t\n\t\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\t\n\t\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\t\n\t\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\t\n\t\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\t\n\t\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\t\n\t\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\t#else\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\t#endif\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\t\n\t\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\t\n\t\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\t\n\t\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\t\n\t\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\\t\\t\\tdirectLight.color = pointLight.color;\\n\\t\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\t#include <normal_flip>\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\t#include <normal_flip>\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\t\n\t\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\t\n\t\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\t\n\t\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\t\n\t\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t \\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\t\\t\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\t\n\t\tvar logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\t\n\t\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\t\n\t\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\t\n\t\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\t\n\t\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\t\n\t\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\t\n\t\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\t\n\t\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\t\n\t\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar normal_flip = \"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\t\n\t\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\t\n\t\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\t\n\t\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\t\n\t\tvar project_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\t\n\t\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\t\n\t\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\t\n\t\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\t\n\t\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\t\n\t\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\t\n\t\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\t\n\t\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\t\n\t\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\t\n\t\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\t\n\t\tvar tonemapping_pars_fragment = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\t\n\t\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\t\n\t\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\t\n\t\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\t\n\t\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\t\n\t\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\t\n\t\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\t\n\t\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\t\n\t\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar distanceRGBA_frag = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\t\n\t\tvar distanceRGBA_vert = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\t\n\t\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\t\n\t\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\t\n\t\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight;\\n\\treflectedLight.directDiffuse = vec3( 0.0 );\\n\\treflectedLight.directSpecular = vec3( 0.0 );\\n\\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n}\\n\";\n\t\n\t\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar normal_frag = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\\t#include <logdepthbuf_fragment>\\n}\\n\";\n\t\n\t\tvar normal_vert = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvNormal = normalize( normalMatrix * normal );\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar shadow_frag = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\t\n\t\tvar shadow_vert = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t\tvar ShaderChunk = {\n\t\t\talphamap_fragment: alphamap_fragment,\n\t\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\t\talphatest_fragment: alphatest_fragment,\n\t\t\taomap_fragment: aomap_fragment,\n\t\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\t\tbegin_vertex: begin_vertex,\n\t\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\t\tbsdfs: bsdfs,\n\t\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\t\tcolor_fragment: color_fragment,\n\t\t\tcolor_pars_fragment: color_pars_fragment,\n\t\t\tcolor_pars_vertex: color_pars_vertex,\n\t\t\tcolor_vertex: color_vertex,\n\t\t\tcommon: common,\n\t\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\t\temissivemap_fragment: emissivemap_fragment,\n\t\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\t\tencodings_fragment: encodings_fragment,\n\t\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\t\tenvmap_fragment: envmap_fragment,\n\t\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\t\tenvmap_vertex: envmap_vertex,\n\t\t\tfog_fragment: fog_fragment,\n\t\t\tfog_pars_fragment: fog_pars_fragment,\n\t\t\tlightmap_fragment: lightmap_fragment,\n\t\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\t\tlights_pars: lights_pars,\n\t\t\tlights_phong_fragment: lights_phong_fragment,\n\t\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\t\tlights_physical_fragment: lights_physical_fragment,\n\t\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\t\tlights_template: lights_template,\n\t\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\t\tmap_fragment: map_fragment,\n\t\t\tmap_pars_fragment: map_pars_fragment,\n\t\t\tmap_particle_fragment: map_particle_fragment,\n\t\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\t\tnormal_flip: normal_flip,\n\t\t\tnormal_fragment: normal_fragment,\n\t\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\t\tpacking: packing,\n\t\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\t\tproject_vertex: project_vertex,\n\t\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\t\tshadowmap_vertex: shadowmap_vertex,\n\t\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\t\tskinbase_vertex: skinbase_vertex,\n\t\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\t\tskinning_vertex: skinning_vertex,\n\t\t\tskinnormal_vertex: skinnormal_vertex,\n\t\t\tspecularmap_fragment: specularmap_fragment,\n\t\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\t\ttonemapping_fragment: tonemapping_fragment,\n\t\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\t\tuv_pars_fragment: uv_pars_fragment,\n\t\t\tuv_pars_vertex: uv_pars_vertex,\n\t\t\tuv_vertex: uv_vertex,\n\t\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\t\tuv2_vertex: uv2_vertex,\n\t\t\tworldpos_vertex: worldpos_vertex,\n\t\n\t\t\tcube_frag: cube_frag,\n\t\t\tcube_vert: cube_vert,\n\t\t\tdepth_frag: depth_frag,\n\t\t\tdepth_vert: depth_vert,\n\t\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\t\tequirect_frag: equirect_frag,\n\t\t\tequirect_vert: equirect_vert,\n\t\t\tlinedashed_frag: linedashed_frag,\n\t\t\tlinedashed_vert: linedashed_vert,\n\t\t\tmeshbasic_frag: meshbasic_frag,\n\t\t\tmeshbasic_vert: meshbasic_vert,\n\t\t\tmeshlambert_frag: meshlambert_frag,\n\t\t\tmeshlambert_vert: meshlambert_vert,\n\t\t\tmeshphong_frag: meshphong_frag,\n\t\t\tmeshphong_vert: meshphong_vert,\n\t\t\tmeshphysical_frag: meshphysical_frag,\n\t\t\tmeshphysical_vert: meshphysical_vert,\n\t\t\tnormal_frag: normal_frag,\n\t\t\tnormal_vert: normal_vert,\n\t\t\tpoints_frag: points_frag,\n\t\t\tpoints_vert: points_vert,\n\t\t\tshadow_frag: shadow_frag,\n\t\t\tshadow_vert: shadow_vert\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Color( r, g, b ) {\n\t\n\t\t\tif ( g === undefined && b === undefined ) {\n\t\n\t\t\t\t// r is THREE.Color, hex or string\n\t\t\t\treturn this.set( r );\n\t\n\t\t\t}\n\t\n\t\t\treturn this.setRGB( r, g, b );\n\t\n\t\t}\n\t\n\t\tColor.prototype = {\n\t\n\t\t\tconstructor: Color,\n\t\n\t\t\tisColor: true,\n\t\n\t\t\tr: 1, g: 1, b: 1,\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tif ( (value && value.isColor) ) {\n\t\n\t\t\t\t\tthis.copy( value );\n\t\n\t\t\t\t} else if ( typeof value === 'number' ) {\n\t\n\t\t\t\t\tthis.setHex( value );\n\t\n\t\t\t\t} else if ( typeof value === 'string' ) {\n\t\n\t\t\t\t\tthis.setStyle( value );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.r = scalar;\n\t\t\t\tthis.g = scalar;\n\t\t\t\tthis.b = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetHex: function ( hex ) {\n\t\n\t\t\t\thex = Math.floor( hex );\n\t\n\t\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\t\tthis.b = ( hex & 255 ) / 255;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetRGB: function ( r, g, b ) {\n\t\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.g = g;\n\t\t\t\tthis.b = b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetHSL: function () {\n\t\n\t\t\t\tfunction hue2rgb( p, q, t ) {\n\t\n\t\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\t\treturn p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function setHSL( h, s, l ) {\n\t\n\t\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\t\n\t\t\t\t\tif ( s === 0 ) {\n\t\n\t\t\t\t\t\tthis.r = this.g = this.b = l;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\t\tvar q = ( 2 * l ) - p;\n\t\n\t\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetStyle: function ( style ) {\n\t\n\t\t\t\tfunction handleAlpha( string ) {\n\t\n\t\t\t\t\tif ( string === undefined ) return;\n\t\n\t\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tvar m;\n\t\n\t\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\t\n\t\t\t\t\t// rgb / hsl\n\t\n\t\t\t\t\tvar color;\n\t\t\t\t\tvar name = m[ 1 ];\n\t\t\t\t\tvar components = m[ 2 ];\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\t\tcase 'rgb':\n\t\t\t\t\t\tcase 'rgba':\n\t\n\t\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'hsl':\n\t\t\t\t\t\tcase 'hsla':\n\t\n\t\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\t\n\t\t\t\t\t// hex color\n\t\n\t\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\t\tvar size = hex.length;\n\t\n\t\t\t\t\tif ( size === 3 ) {\n\t\n\t\t\t\t\t\t// #ff0\n\t\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t} else if ( size === 6 ) {\n\t\n\t\t\t\t\t\t// #ff0000\n\t\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( style && style.length > 0 ) {\n\t\n\t\t\t\t\t// color keywords\n\t\t\t\t\tvar hex = ColorKeywords[ style ];\n\t\n\t\t\t\t\tif ( hex !== undefined ) {\n\t\n\t\t\t\t\t\t// red\n\t\t\t\t\t\tthis.setHex( hex );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// unknown color\n\t\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( color ) {\n\t\n\t\t\t\tthis.r = color.r;\n\t\t\t\tthis.g = color.g;\n\t\t\t\tthis.b = color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\t\n\t\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\t\n\t\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\t\n\t\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconvertGammaToLinear: function () {\n\t\n\t\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\t\tthis.r = r * r;\n\t\t\t\tthis.g = g * g;\n\t\t\t\tthis.b = b * b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconvertLinearToGamma: function () {\n\t\n\t\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\t\tthis.b = Math.sqrt( this.b );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetHex: function () {\n\t\n\t\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\t\n\t\t\t},\n\t\n\t\t\tgetHexString: function () {\n\t\n\t\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\t\n\t\t\t},\n\t\n\t\t\tgetHSL: function ( optionalTarget ) {\n\t\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\n\t\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\t\n\t\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\t\tvar max = Math.max( r, g, b );\n\t\t\t\tvar min = Math.min( r, g, b );\n\t\n\t\t\t\tvar hue, saturation;\n\t\t\t\tvar lightness = ( min + max ) / 2.0;\n\t\n\t\t\t\tif ( min === max ) {\n\t\n\t\t\t\t\thue = 0;\n\t\t\t\t\tsaturation = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar delta = max - min;\n\t\n\t\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\t\n\t\t\t\t\tswitch ( max ) {\n\t\n\t\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\thue /= 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t\thsl.h = hue;\n\t\t\t\thsl.s = saturation;\n\t\t\t\thsl.l = lightness;\n\t\n\t\t\t\treturn hsl;\n\t\n\t\t\t},\n\t\n\t\t\tgetStyle: function () {\n\t\n\t\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\t\n\t\t\t},\n\t\n\t\t\toffsetHSL: function ( h, s, l ) {\n\t\n\t\t\t\tvar hsl = this.getHSL();\n\t\n\t\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\t\n\t\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( color ) {\n\t\n\t\t\t\tthis.r += color.r;\n\t\t\t\tthis.g += color.g;\n\t\t\t\tthis.b += color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddColors: function ( color1, color2 ) {\n\t\n\t\t\t\tthis.r = color1.r + color2.r;\n\t\t\t\tthis.g = color1.g + color2.g;\n\t\t\t\tthis.b = color1.b + color2.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.r += s;\n\t\t\t\tthis.g += s;\n\t\t\t\tthis.b += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function( color ) {\n\t\n\t\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( color ) {\n\t\n\t\t\t\tthis.r *= color.r;\n\t\t\t\tthis.g *= color.g;\n\t\t\t\tthis.b *= color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tthis.r *= s;\n\t\t\t\tthis.g *= s;\n\t\t\t\tthis.b *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( color, alpha ) {\n\t\n\t\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( c ) {\n\t\n\t\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.r = array[ offset ];\n\t\t\t\tthis.g = array[ offset + 1 ];\n\t\t\t\tthis.b = array[ offset + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.r;\n\t\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\t\tarray[ offset + 2 ] = this.b;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\treturn this.getHex();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\t\n\t\t/**\n\t\t * Uniforms library for shared webgl shaders\n\t\t */\n\t\n\t\tvar UniformsLib = {\n\t\n\t\t\tcommon: {\n\t\n\t\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\t\topacity: { value: 1.0 },\n\t\n\t\t\t\tmap: { value: null },\n\t\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },\n\t\n\t\t\t\tspecularMap: { value: null },\n\t\t\t\talphaMap: { value: null },\n\t\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tflipEnvMap: { value: - 1 },\n\t\t\t\treflectivity: { value: 1.0 },\n\t\t\t\trefractionRatio: { value: 0.98 }\n\t\n\t\t\t},\n\t\n\t\t\taomap: {\n\t\n\t\t\t\taoMap: { value: null },\n\t\t\t\taoMapIntensity: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\tlightmap: {\n\t\n\t\t\t\tlightMap: { value: null },\n\t\t\t\tlightMapIntensity: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\temissivemap: {\n\t\n\t\t\t\temissiveMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tbumpmap: {\n\t\n\t\t\t\tbumpMap: { value: null },\n\t\t\t\tbumpScale: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\tnormalmap: {\n\t\n\t\t\t\tnormalMap: { value: null },\n\t\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\t\n\t\t\t},\n\t\n\t\t\tdisplacementmap: {\n\t\n\t\t\t\tdisplacementMap: { value: null },\n\t\t\t\tdisplacementScale: { value: 1 },\n\t\t\t\tdisplacementBias: { value: 0 }\n\t\n\t\t\t},\n\t\n\t\t\troughnessmap: {\n\t\n\t\t\t\troughnessMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tmetalnessmap: {\n\t\n\t\t\t\tmetalnessMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tfog: {\n\t\n\t\t\t\tfogDensity: { value: 0.00025 },\n\t\t\t\tfogNear: { value: 1 },\n\t\t\t\tfogFar: { value: 2000 },\n\t\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\t\n\t\t\t},\n\t\n\t\t\tlights: {\n\t\n\t\t\t\tambientLightColor: { value: [] },\n\t\n\t\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tcolor: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\t\tdirectionalShadowMatrix: { value: [] },\n\t\n\t\t\t\tspotLights: { value: [], properties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tdistance: {},\n\t\t\t\t\tconeCos: {},\n\t\t\t\t\tpenumbraCos: {},\n\t\t\t\t\tdecay: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tspotShadowMap: { value: [] },\n\t\t\t\tspotShadowMatrix: { value: [] },\n\t\n\t\t\t\tpointLights: { value: [], properties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdecay: {},\n\t\t\t\t\tdistance: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tpointShadowMap: { value: [] },\n\t\t\t\tpointShadowMatrix: { value: [] },\n\t\n\t\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tskyColor: {},\n\t\t\t\t\tgroundColor: {}\n\t\t\t\t} }\n\t\n\t\t\t},\n\t\n\t\t\tpoints: {\n\t\n\t\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\t\topacity: { value: 1.0 },\n\t\t\t\tsize: { value: 1.0 },\n\t\t\t\tscale: { value: 1.0 },\n\t\t\t\tmap: { value: null },\n\t\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t */\n\t\n\t\tvar ShaderLib = {\n\t\n\t\t\tbasic: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.fog\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\t\n\t\t\t},\n\t\n\t\t\tlambert: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\temissive : { value: new Color( 0x000000 ) }\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\t\n\t\t\t},\n\t\n\t\t\tphong: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\t\tUniformsLib.normalmap,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\t\tspecular : { value: new Color( 0x111111 ) },\n\t\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\t\n\t\t\t},\n\t\n\t\t\tstandard: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\t\tUniformsLib.normalmap,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\t\tmetalness: { value: 0 },\n\t\t\t\t\t\tenvMapIntensity : { value: 1 }, // temporary\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\n\t\t\t},\n\t\n\t\t\tpoints: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.points,\n\t\t\t\t\tUniformsLib.fog\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\t\tfragmentShader: ShaderChunk.points_frag\n\t\n\t\t\t},\n\t\n\t\t\tdashed: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.fog,\n\t\n\t\t\t\t\t{\n\t\t\t\t\t\tscale    : { value: 1 },\n\t\t\t\t\t\tdashSize : { value: 1 },\n\t\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t\t}\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\t\n\t\t\t},\n\t\n\t\t\tdepth: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.displacementmap\n\t\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\t\tfragmentShader: ShaderChunk.depth_frag\n\t\n\t\t\t},\n\t\n\t\t\tnormal: {\n\t\n\t\t\t\tuniforms: {\n\t\n\t\t\t\t\topacity : { value: 1.0 }\n\t\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\t\tfragmentShader: ShaderChunk.normal_frag\n\t\n\t\t\t},\n\t\n\t\t\t/* -------------------------------------------------------------------------\n\t\t\t//\tCube map shader\n\t\t\t ------------------------------------------------------------------------- */\n\t\n\t\t\tcube: {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\ttCube: { value: null },\n\t\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\t\tfragmentShader: ShaderChunk.cube_frag\n\t\n\t\t\t},\n\t\n\t\t\t/* -------------------------------------------------------------------------\n\t\t\t//\tCube map shader\n\t\t\t ------------------------------------------------------------------------- */\n\t\n\t\t\tequirect: {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\ttEquirect: { value: null },\n\t\t\t\t\ttFlip: { value: - 1 }\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\t\n\t\t\t},\n\t\n\t\t\tdistanceRGBA: {\n\t\n\t\t\t\tuniforms: {\n\t\n\t\t\t\t\tlightPos: { value: new Vector3() }\n\t\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tShaderLib.physical = {\n\t\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\n\t\t\t\tShaderLib.standard.uniforms,\n\t\n\t\t\t\t{\n\t\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Box2( min, max ) {\n\t\n\t\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\t\n\t\t}\n\t\n\t\tBox2.prototype = {\n\t\n\t\t\tconstructor: Box2,\n\t\n\t\t\tset: function ( min, max ) {\n\t\n\t\t\t\tthis.min.copy( min );\n\t\t\t\tthis.max.copy( max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\t\tvar v1 = new Vector2();\n\t\n\t\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( box ) {\n\t\n\t\t\t\tthis.min.copy( box.min );\n\t\t\t\tthis.max.copy( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeEmpty: function () {\n\t\n\t\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\t\tthis.max.x = this.max.y = - Infinity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tisEmpty: function () {\n\t\n\t\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tgetSize: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\t\n\t\t\t},\n\t\n\t\t\texpandByPoint: function ( point ) {\n\t\n\t\t\t\tthis.min.min( point );\n\t\t\t\tthis.max.max( point );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByVector: function ( vector ) {\n\t\n\t\t\t\tthis.min.sub( vector );\n\t\t\t\tthis.max.add( vector );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.min.addScalar( - scalar );\n\t\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsBox: function ( box ) {\n\t\n\t\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t\t// has a size dimension of 0.\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\n\t\t\t\treturn result.set(\n\t\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector2();\n\t\n\t\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersect: function ( box ) {\n\t\n\t\t\t\tthis.min.max( box.min );\n\t\t\t\tthis.max.min( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tunion: function ( box ) {\n\t\n\t\t\t\tthis.min.min( box.min );\n\t\t\t\tthis.max.max( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.min.add( offset );\n\t\t\t\tthis.max.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( box ) {\n\t\n\t\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction LensFlarePlugin( renderer, flares ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\t\tvar state = renderer.state;\n\t\n\t\t\tvar vertexBuffer, elementBuffer;\n\t\t\tvar shader, program, attributes, uniforms;\n\t\n\t\t\tvar tempTexture, occlusionTexture;\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t\t- 1,  1,  0, 1\n\t\t\t\t] );\n\t\n\t\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t0, 2, 3\n\t\t\t\t] );\n\t\n\t\t\t\t// buffers\n\t\n\t\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\t\telementBuffer    = gl.createBuffer();\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\t\t// textures\n\t\n\t\t\t\ttempTexture      = gl.createTexture();\n\t\t\t\tocclusionTexture = gl.createTexture();\n\t\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\t\tshader = {\n\t\n\t\t\t\t\tvertexShader: [\n\t\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\t\"uniform float rotation;\",\n\t\n\t\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\t\n\t\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\t\"attribute vec2 uv;\",\n\t\n\t\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t\t\"vUV = uv;\",\n\t\n\t\t\t\t\t\t\t\"vec2 pos = position;\",\n\t\n\t\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\t\n\t\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\t\n\t\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\t\n\t\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\t\n\t\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\t\n\t\t\t\t\t\t\"}\"\n\t\n\t\t\t\t\t].join( \"\\n\" ),\n\t\n\t\t\t\t\tfragmentShader: [\n\t\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\t\"uniform vec3 color;\",\n\t\n\t\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t\t// pink square\n\t\n\t\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\t\n\t\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\t\n\t\t\t\t\t\t\t// restore\n\t\n\t\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\t\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\t\n\t\t\t\t\t\t\t// flare\n\t\n\t\t\t\t\t\t\t\"} else {\",\n\t\n\t\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\t\n\t\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\t\"}\"\n\t\n\t\t\t\t\t].join( \"\\n\" )\n\t\n\t\t\t\t};\n\t\n\t\t\t\tprogram = createProgram( shader );\n\t\n\t\t\t\tattributes = {\n\t\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t\t};\n\t\n\t\t\t\tuniforms = {\n\t\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t/*\n\t\t\t * Render lens flares\n\t\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t\t *         reads these back and calculates occlusion.\n\t\t\t */\n\t\n\t\t\tthis.render = function ( scene, camera, viewport ) {\n\t\n\t\t\t\tif ( flares.length === 0 ) return;\n\t\n\t\t\t\tvar tempPosition = new Vector3();\n\t\n\t\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\t\n\t\t\t\tvar size = 16 / viewport.w,\n\t\t\t\t\tscale = new Vector2( size * invAspect, size );\n\t\n\t\t\t\tvar screenPosition = new Vector3( 1, 1, 0 ),\n\t\t\t\t\tscreenPositionPixels = new Vector2( 1, 1 );\n\t\n\t\t\t\tvar validArea = new Box2();\n\t\n\t\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tinit();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.useProgram( program );\n\t\n\t\t\t\tstate.initAttributes();\n\t\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t\t// setup gl and common used attribs/uniforms\n\t\n\t\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\t\tgl.uniform1i( uniforms.map, 1 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\t\tstate.setDepthWrite( false );\n\t\n\t\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\t\tscale.set( size * invAspect, size );\n\t\n\t\t\t\t\t// calc object screen position\n\t\n\t\t\t\t\tvar flare = flares[ i ];\n\t\n\t\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\t\n\t\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\t\n\t\t\t\t\t// setup arrays for gl programs\n\t\n\t\t\t\t\tscreenPosition.copy( tempPosition );\n\t\n\t\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\t\n\t\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\t\n\t\t\t\t\t// screen cull\n\t\n\t\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\t\n\t\t\t\t\t\t// save current RGB to temp texture\n\t\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t\t// render pink quad\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\n\t\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t\t// copy result to occlusionMap\n\t\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t\t// restore graphics\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t\t// update object positions\n\t\n\t\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\t\n\t\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\t\n\t\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tflare.updateLensFlares();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// render flares\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\t\n\t\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\t\n\t\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\t\n\t\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\t\n\t\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\t\tscale.y = size;\n\t\n\t\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\t\n\t\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\t\n\t\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\t\n\t\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore gl\n\t\n\t\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\t\tstate.setDepthWrite( true );\n\t\n\t\t\t\trenderer.resetGLState();\n\t\n\t\t\t};\n\t\n\t\t\tfunction createProgram( shader ) {\n\t\n\t\t\t\tvar program = gl.createProgram();\n\t\n\t\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\n\t\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\t\n\t\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\t\n\t\t\t\tgl.compileShader( fragmentShader );\n\t\t\t\tgl.compileShader( vertexShader );\n\t\n\t\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\t\tgl.attachShader( program, vertexShader );\n\t\n\t\t\t\tgl.linkProgram( program );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction SpritePlugin( renderer, sprites ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\t\tvar state = renderer.state;\n\t\n\t\t\tvar vertexBuffer, elementBuffer;\n\t\t\tvar program, attributes, uniforms;\n\t\n\t\t\tvar texture;\n\t\n\t\t\t// decompose matrixWorld\n\t\n\t\t\tvar spritePosition = new Vector3();\n\t\t\tvar spriteRotation = new Quaternion();\n\t\t\tvar spriteScale = new Vector3();\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t\t] );\n\t\n\t\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t0, 2, 3\n\t\t\t\t] );\n\t\n\t\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\t\telementBuffer = gl.createBuffer();\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\t\tprogram = createProgram();\n\t\n\t\t\t\tattributes = {\n\t\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t\t};\n\t\n\t\t\t\tuniforms = {\n\t\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\t\n\t\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\t\n\t\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\t\n\t\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\t\n\t\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\t\n\t\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t\t};\n\t\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = 8;\n\t\t\t\tcanvas.height = 8;\n\t\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\t\n\t\t\t\ttexture = new Texture( canvas );\n\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\t\tif ( sprites.length === 0 ) return;\n\t\n\t\t\t\t// setup gl\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tinit();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.useProgram( program );\n\t\n\t\t\t\tstate.initAttributes();\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\t\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tgl.uniform1i( uniforms.map, 0 );\n\t\n\t\t\t\tvar oldFogType = 0;\n\t\t\t\tvar sceneFogType = 0;\n\t\t\t\tvar fog = scene.fog;\n\t\n\t\t\t\tif ( fog ) {\n\t\n\t\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\t\n\t\t\t\t\tif ( (fog && fog.isFog) ) {\n\t\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\t\toldFogType = 1;\n\t\t\t\t\t\tsceneFogType = 1;\n\t\n\t\t\t\t\t} else if ( (fog && fog.isFogExp2) ) {\n\t\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\t\toldFogType = 2;\n\t\t\t\t\t\tsceneFogType = 2;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\t\toldFogType = 0;\n\t\t\t\t\tsceneFogType = 0;\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// update positions and sort\n\t\n\t\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar sprite = sprites[ i ];\n\t\n\t\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tsprites.sort( painterSortStable );\n\t\n\t\t\t\t// render all sprites\n\t\n\t\t\t\tvar scale = [];\n\t\n\t\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\t\tvar material = sprite.material;\n\t\n\t\t\t\t\tif ( material.visible === false ) continue;\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\t\n\t\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\t\n\t\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\t\tscale[ 1 ] = spriteScale.y;\n\t\n\t\t\t\t\tvar fogType = 0;\n\t\n\t\t\t\t\tif ( scene.fog && material.fog ) {\n\t\n\t\t\t\t\t\tfogType = sceneFogType;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( oldFogType !== fogType ) {\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\t\toldFogType = fogType;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\t\n\t\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\n\t\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore gl\n\t\n\t\t\t\tstate.enable( gl.CULL_FACE );\n\t\n\t\t\t\trenderer.resetGLState();\n\t\n\t\t\t};\n\t\n\t\t\tfunction createProgram() {\n\t\n\t\t\t\tvar program = gl.createProgram();\n\t\n\t\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\n\t\t\t\tgl.shaderSource( vertexShader, [\n\t\n\t\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform float rotation;',\n\t\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t\t'uniform vec2 uvScale;',\n\t\n\t\t\t\t\t'attribute vec2 position;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\t\n\t\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\t\n\t\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\t\n\t\t\t\t\t\t'vec4 finalPosition;',\n\t\n\t\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\t\n\t\t\t\t\t\t'gl_Position = finalPosition;',\n\t\n\t\t\t\t\t'}'\n\t\n\t\t\t\t].join( '\\n' ) );\n\t\n\t\t\t\tgl.shaderSource( fragmentShader, [\n\t\n\t\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t\t'uniform vec3 color;',\n\t\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t\t'uniform float opacity;',\n\t\n\t\t\t\t\t'uniform int fogType;',\n\t\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t\t'uniform float fogNear;',\n\t\t\t\t\t'uniform float fogFar;',\n\t\t\t\t\t'uniform float alphaTest;',\n\t\n\t\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\t\n\t\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\t\n\t\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\t\n\t\t\t\t\t\t'if ( fogType > 0 ) {',\n\t\n\t\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t\t'float fogFactor = 0.0;',\n\t\n\t\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\t\n\t\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\t\n\t\t\t\t\t\t\t'} else {',\n\t\n\t\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\t\n\t\t\t\t\t\t\t'}',\n\t\n\t\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\t\n\t\t\t\t\t\t'}',\n\t\n\t\t\t\t\t'}'\n\t\n\t\t\t\t].join( '\\n' ) );\n\t\n\t\t\t\tgl.compileShader( vertexShader );\n\t\t\t\tgl.compileShader( fragmentShader );\n\t\n\t\t\t\tgl.attachShader( program, vertexShader );\n\t\t\t\tgl.attachShader( program, fragmentShader );\n\t\n\t\t\t\tgl.linkProgram( program );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t\tfunction painterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\t\n\t\t\t\t\treturn a.renderOrder - b.renderOrder;\n\t\n\t\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn b.id - a.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Material() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: MaterialIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Material';\n\t\n\t\t\tthis.fog = true;\n\t\t\tthis.lights = true;\n\t\n\t\t\tthis.blending = NormalBlending;\n\t\t\tthis.side = FrontSide;\n\t\t\tthis.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\t\n\t\t\tthis.opacity = 1;\n\t\t\tthis.transparent = false;\n\t\n\t\t\tthis.blendSrc = SrcAlphaFactor;\n\t\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\t\tthis.blendEquation = AddEquation;\n\t\t\tthis.blendSrcAlpha = null;\n\t\t\tthis.blendDstAlpha = null;\n\t\t\tthis.blendEquationAlpha = null;\n\t\n\t\t\tthis.depthFunc = LessEqualDepth;\n\t\t\tthis.depthTest = true;\n\t\t\tthis.depthWrite = true;\n\t\n\t\t\tthis.clippingPlanes = null;\n\t\t\tthis.clipIntersection = false;\n\t\t\tthis.clipShadows = false;\n\t\n\t\t\tthis.colorWrite = true;\n\t\n\t\t\tthis.precision = null; // override the renderer's default precision for this material\n\t\n\t\t\tthis.polygonOffset = false;\n\t\t\tthis.polygonOffsetFactor = 0;\n\t\t\tthis.polygonOffsetUnits = 0;\n\t\n\t\t\tthis.alphaTest = 0;\n\t\t\tthis.premultipliedAlpha = false;\n\t\n\t\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\t\n\t\t\tthis.visible = true;\n\t\n\t\t\tthis._needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tMaterial.prototype = {\n\t\n\t\t\tconstructor: Material,\n\t\n\t\t\tisMaterial: true,\n\t\n\t\t\tget needsUpdate() {\n\t\n\t\t\t\treturn this._needsUpdate;\n\t\n\t\t\t},\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.update();\n\t\t\t\tthis._needsUpdate = value;\n\t\n\t\t\t},\n\t\n\t\t\tsetValues: function ( values ) {\n\t\n\t\t\t\tif ( values === undefined ) return;\n\t\n\t\t\t\tfor ( var key in values ) {\n\t\n\t\t\t\t\tvar newValue = values[ key ];\n\t\n\t\t\t\t\tif ( newValue === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar currentValue = this[ key ];\n\t\n\t\t\t\t\tif ( currentValue === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( (currentValue && currentValue.isColor) ) {\n\t\n\t\t\t\t\t\tcurrentValue.set( newValue );\n\t\n\t\t\t\t\t} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {\n\t\n\t\t\t\t\t\tcurrentValue.copy( newValue );\n\t\n\t\t\t\t\t} else if ( key === 'overdraw' ) {\n\t\n\t\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\t\tthis[ key ] = Number( newValue );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis[ key ] = newValue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar isRoot = meta === undefined;\n\t\n\t\t\t\tif ( isRoot ) {\n\t\n\t\t\t\t\tmeta = {\n\t\t\t\t\t\ttextures: {},\n\t\t\t\t\t\timages: {}\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Material',\n\t\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard Material serialization\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( (this.color && this.color.isColor) ) data.color = this.color.getHex();\n\t\n\t\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\t\n\t\t\t\tif ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();\n\t\t\t\tif ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();\n\t\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\n\t\t\t\tif ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.bumpMap && this.bumpMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.bumpScale = this.bumpScale;\n\t\n\t\t\t\t}\n\t\t\t\tif ( (this.normalMap && this.normalMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\t\n\t\t\t\t}\n\t\t\t\tif ( (this.displacementMap && this.displacementMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\t\tdata.displacementBias = this.displacementBias;\n\t\n\t\t\t\t}\n\t\t\t\tif ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\t\n\t\t\t\tif ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\t\tif ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\n\t\t\t\tif ( (this.envMap && this.envMap.isTexture) ) {\n\t\n\t\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\t\n\t\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\t\tif ( this.shading !== SmoothShading ) data.shading = this.shading;\n\t\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\t\n\t\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\n\t\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\t\tdata.depthTest = this.depthTest;\n\t\t\t\tdata.depthWrite = this.depthWrite;\n\t\n\t\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\t\n\t\t\t\tdata.skinning = this.skinning;\n\t\t\t\tdata.morphTargets = this.morphTargets;\n\t\n\t\t\t\t// TODO: Copied from Object3D.toJSON\n\t\n\t\t\t\tfunction extractFromCache( cache ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn values;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isRoot ) {\n\t\n\t\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\t\tif ( images.length > 0 ) data.images = images;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\tthis.fog = source.fog;\n\t\t\t\tthis.lights = source.lights;\n\t\n\t\t\t\tthis.blending = source.blending;\n\t\t\t\tthis.side = source.side;\n\t\t\t\tthis.shading = source.shading;\n\t\t\t\tthis.vertexColors = source.vertexColors;\n\t\n\t\t\t\tthis.opacity = source.opacity;\n\t\t\t\tthis.transparent = source.transparent;\n\t\n\t\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\t\tthis.blendDst = source.blendDst;\n\t\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\n\t\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\t\tthis.depthTest = source.depthTest;\n\t\t\t\tthis.depthWrite = source.depthWrite;\n\t\n\t\t\t\tthis.colorWrite = source.colorWrite;\n\t\n\t\t\t\tthis.precision = source.precision;\n\t\n\t\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\t\n\t\t\t\tthis.alphaTest = source.alphaTest;\n\t\n\t\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\n\t\t\t\tthis.overdraw = source.overdraw;\n\t\n\t\t\t\tthis.visible = source.visible;\n\t\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\t\tthis.clipIntersection = source.clipIntersection;\n\t\n\t\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\t\tdstPlanes = null;\n\t\n\t\t\t\tif ( srcPlanes !== null ) {\n\t\n\t\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\t\tdstPlanes = new Array( n );\n\t\n\t\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.clippingPlanes = dstPlanes;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'update' } );\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Material.prototype, EventDispatcher.prototype );\n\t\n\t\tvar count$1 = 0;\n\t\tfunction MaterialIdCount() { return count$1++; }\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  defines: { \"label\" : \"value\" },\n\t\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t\t *\n\t\t *  fragmentShader: <string>,\n\t\t *  vertexShader: <string>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  lights: <bool>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction ShaderMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'ShaderMaterial';\n\t\n\t\t\tthis.defines = {};\n\t\t\tthis.uniforms = {};\n\t\n\t\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\t\n\t\t\tthis.linewidth = 1;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false; // set to use scene fog\n\t\t\tthis.lights = false; // set to use scene lights\n\t\t\tthis.clipping = false; // set to use user-defined clipping planes\n\t\n\t\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\t\tthis.morphTargets = false; // set to use morph targets\n\t\t\tthis.morphNormals = false; // set to use morph normals\n\t\n\t\t\tthis.extensions = {\n\t\t\t\tderivatives: false, // set to use derivatives\n\t\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t\t};\n\t\n\t\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\t\tthis.defaultAttributeValues = {\n\t\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t\t'uv': [ 0, 0 ],\n\t\t\t\t'uv2': [ 0, 0 ]\n\t\t\t};\n\t\n\t\t\tthis.index0AttributeName = undefined;\n\t\n\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\tif ( parameters.attributes !== undefined ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setValues( parameters );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tShaderMaterial.prototype = Object.create( Material.prototype );\n\t\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\t\n\t\tShaderMaterial.prototype.isShaderMaterial = true;\n\t\n\t\tShaderMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.fragmentShader = source.fragmentShader;\n\t\t\tthis.vertexShader = source.vertexShader;\n\t\n\t\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\t\n\t\t\tthis.defines = source.defines;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\tthis.lights = source.lights;\n\t\t\tthis.clipping = source.clipping;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\tthis.extensions = source.extensions;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\t\n\t\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.uniforms = this.uniforms;\n\t\t\tdata.vertexShader = this.vertexShader;\n\t\t\tdata.fragmentShader = this.fragmentShader;\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author bhouston / https://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshDepthMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshDepthMaterial';\n\t\n\t\t\tthis.depthPacking = BasicDepthPacking;\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\t\n\t\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\t\n\t\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.depthPacking = source.depthPacking;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Box3( min, max ) {\n\t\n\t\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\t\n\t\t}\n\t\n\t\tBox3.prototype = {\n\t\n\t\t\tconstructor: Box3,\n\t\n\t\t\tisBox3: true,\n\t\n\t\t\tset: function ( min, max ) {\n\t\n\t\t\t\tthis.min.copy( min );\n\t\t\t\tthis.max.copy( max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromArray: function ( array ) {\n\t\n\t\t\t\tvar minX = + Infinity;\n\t\t\t\tvar minY = + Infinity;\n\t\t\t\tvar minZ = + Infinity;\n\t\n\t\t\t\tvar maxX = - Infinity;\n\t\t\t\tvar maxY = - Infinity;\n\t\t\t\tvar maxZ = - Infinity;\n\t\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\tvar x = array[ i ];\n\t\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\t\tvar z = array[ i + 2 ];\n\t\n\t\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\t\tif ( z < minZ ) minZ = z;\n\t\n\t\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\t\tif ( z > maxZ ) maxZ = z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\t\tthis.max.set( maxX, maxY, maxZ );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\n\t\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetFromObject: function () {\n\t\n\t\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t\t// accounting for both the object's, and children's, world transforms\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function setFromObject( object ) {\n\t\n\t\t\t\t\tvar scope = this;\n\t\n\t\t\t\t\tobject.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\t\tobject.traverse( function ( node ) {\n\t\n\t\t\t\t\t\tvar geometry = node.geometry;\n\t\n\t\t\t\t\t\tif ( geometry !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\t\n\t\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tvar array, offset, stride;\n\t\n\t\t\t\t\t\t\t\t\tif ( (attribute && attribute.isInterleavedBufferAttribute) ) {\n\t\n\t\t\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\t\t\tstride = 3;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\t\n\t\t\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( box ) {\n\t\n\t\t\t\tthis.min.copy( box.min );\n\t\t\t\tthis.max.copy( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeEmpty: function () {\n\t\n\t\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tisEmpty: function () {\n\t\n\t\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tgetSize: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\t\n\t\t\t},\n\t\n\t\t\texpandByPoint: function ( point ) {\n\t\n\t\t\t\tthis.min.min( point );\n\t\t\t\tthis.max.max( point );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByVector: function ( vector ) {\n\t\n\t\t\t\tthis.min.sub( vector );\n\t\t\t\tthis.max.add( vector );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.min.addScalar( - scalar );\n\t\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsBox: function ( box ) {\n\t\n\t\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t\t// has a size dimension of 0.\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.set(\n\t\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: ( function () {\n\t\n\t\t\t\tvar closestPoint;\n\t\n\t\t\t\treturn function intersectsSphere( sphere ) {\n\t\n\t\t\t\t\tif ( closestPoint === undefined ) closestPoint = new Vector3();\n\t\n\t\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\t\n\t\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\tif ( plane.normal.x > 0 ) {\n\t\n\t\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( plane.normal.y > 0 ) {\n\t\n\t\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( plane.normal.z > 0 ) {\n\t\n\t\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetBoundingSphere: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Sphere();\n\t\n\t\t\t\t\tthis.getCenter( result.center );\n\t\n\t\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersect: function ( box ) {\n\t\n\t\t\t\tthis.min.max( box.min );\n\t\t\t\tthis.max.min( box.max );\n\t\n\t\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tunion: function ( box ) {\n\t\n\t\t\t\tthis.min.min( box.min );\n\t\t\t\tthis.max.max( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function () {\n\t\n\t\t\t\tvar points = [\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3()\n\t\t\t\t];\n\t\n\t\t\t\treturn function applyMatrix4( matrix ) {\n\t\n\t\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\t\tif( this.isEmpty() ) return this;\n\t\n\t\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\t\n\t\t\t\t\tthis.setFromPoints( points );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.min.add( offset );\n\t\t\t\tthis.max.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( box ) {\n\t\n\t\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Sphere( center, radius ) {\n\t\n\t\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\t\n\t\t}\n\t\n\t\tSphere.prototype = {\n\t\n\t\t\tconstructor: Sphere,\n\t\n\t\t\tset: function ( center, radius ) {\n\t\n\t\t\t\tthis.center.copy( center );\n\t\t\t\tthis.radius = radius;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function () {\n\t\n\t\t\t\tvar box = new Box3();\n\t\n\t\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\t\n\t\t\t\t\tvar center = this.center;\n\t\n\t\t\t\t\tif ( optionalCenter !== undefined ) {\n\t\n\t\t\t\t\t\tcenter.copy( optionalCenter );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( sphere ) {\n\t\n\t\t\t\tthis.center.copy( sphere.center );\n\t\t\t\tthis.radius = sphere.radius;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tempty: function () {\n\t\n\t\t\t\treturn ( this.radius <= 0 );\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\tvar radiusSum = this.radius + sphere.radius;\n\t\n\t\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\treturn box.intersectsSphere( this );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t\t// the center of the sphere to the plane.\n\t\t\t\t//\n\t\t\t\t// distance = q * n - d\n\t\t\t\t//\n\t\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t\t// then there is no intersection.\n\t\n\t\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tresult.copy( point );\n\t\n\t\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\t\n\t\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\tgetBoundingBox: function ( optionalTarget ) {\n\t\n\t\t\t\tvar box = optionalTarget || new Box3();\n\t\n\t\t\t\tbox.set( this.center, this.center );\n\t\t\t\tbox.expandByScalar( this.radius );\n\t\n\t\t\t\treturn box;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.center.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( sphere ) {\n\t\n\t\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction Matrix3() {\n\t\n\t\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\t\n\t\t\t] );\n\t\n\t\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tMatrix3.prototype = {\n\t\n\t\t\tconstructor: Matrix3,\n\t\n\t\t\tisMatrix3: true,\n\t\n\t\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tidentity: function () {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().fromArray( this.elements );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( m ) {\n\t\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrix4: function( m ) {\n\t\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyToVector3Array: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn array;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyToBuffer: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\t\tv1.applyMatrix3( this );\n\t\n\t\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn buffer;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdeterminant: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\t\n\t\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\n\t\t\t},\n\t\n\t\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\t\n\t\t\t\tif ( (matrix && matrix.isMatrix4) ) {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar me = matrix.elements,\n\t\t\t\t\tte = this.elements,\n\t\n\t\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\t\n\t\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\t\n\t\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\t\n\t\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\t\tif ( throwOnDegenerate === true ) {\n\t\n\t\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this.identity();\n\t\t\t\t}\n\t\n\t\t\t\tvar detInv = 1 / det;\n\t\n\t\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\t\n\t\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\t\n\t\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranspose: function () {\n\t\n\t\t\t\tvar tmp, m = this.elements;\n\t\n\t\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\t\treturn this.toArray( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tgetNormalMatrix: function ( matrix4 ) {\n\t\n\t\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\t\n\t\t\t},\n\t\n\t\t\ttransposeIntoArray: function ( r ) {\n\t\n\t\t\t\tvar m = this.elements;\n\t\n\t\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\t\tr[ 8 ] = m[ 8 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tfor( var i = 0; i < 9; i ++ ) {\n\t\n\t\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\n\t\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\n\t\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Plane( normal, constant ) {\n\t\n\t\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\t\n\t\t}\n\t\n\t\tPlane.prototype = {\n\t\n\t\t\tconstructor: Plane,\n\t\n\t\t\tset: function ( normal, constant ) {\n\t\n\t\t\t\tthis.normal.copy( normal );\n\t\t\t\tthis.constant = constant;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponents: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis.normal.set( x, y, z );\n\t\t\t\tthis.constant = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\t\n\t\t\t\tthis.normal.copy( normal );\n\t\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCoplanarPoints: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\t\n\t\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\t\n\t\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\t\n\t\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( plane ) {\n\t\n\t\t\t\tthis.normal.copy( plane.normal );\n\t\t\t\tthis.constant = plane.constant;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\t\n\t\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\t\tthis.constant *= inverseNormalLength;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.constant *= - 1;\n\t\t\t\tthis.normal.negate();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn this.normal.dot( point ) + this.constant;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSphere: function ( sphere ) {\n\t\n\t\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\t\n\t\t\t},\n\t\n\t\t\tprojectPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\t\n\t\t\t},\n\t\n\t\t\torthoPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\t\n\t\t\t},\n\t\n\t\t\tintersectLine: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function intersectLine( line, optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tvar direction = line.delta( v1 );\n\t\n\t\t\t\t\tvar denominator = this.normal.dot( direction );\n\t\n\t\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\t\n\t\t\t\t\t\t\treturn result.copy( line.start );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\t\n\t\t\t\t\tif ( t < 0 || t > 1 ) {\n\t\n\t\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsLine: function ( line ) {\n\t\n\t\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\t\n\t\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\t\tvar endSign = this.distanceToPoint( line.end );\n\t\n\t\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\treturn box.intersectsPlane( this );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\treturn sphere.intersectsPlane( this );\n\t\n\t\t\t},\n\t\n\t\t\tcoplanarPoint: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar m1 = new Matrix3();\n\t\n\t\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\t\n\t\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\t\n\t\t\t\t\t// transform normal based on theory here:\n\t\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( plane ) {\n\t\n\t\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\tthis.planes = [\n\t\n\t\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\t\n\t\t\t];\n\t\n\t\t}\n\t\n\t\tFrustum.prototype = {\n\t\n\t\t\tconstructor: Frustum,\n\t\n\t\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\t\tplanes[ 5 ].copy( p5 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( frustum ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrix: function ( m ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\t\t\tvar me = m.elements;\n\t\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\t\n\t\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsObject: function () {\n\t\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function intersectsObject( object ) {\n\t\n\t\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSprite: function () {\n\t\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function intersectsSprite( sprite ) {\n\t\n\t\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\t\t\tvar center = sphere.center;\n\t\t\t\tvar negRadius = - sphere.radius;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\t\n\t\t\t\t\tif ( distance < negRadius ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function () {\n\t\n\t\t\t\tvar p1 = new Vector3(),\n\t\t\t\t\tp2 = new Vector3();\n\t\n\t\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\t\n\t\t\t\t\t\tvar plane = planes[ i ];\n\t\n\t\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\t\n\t\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\t\n\t\t\t\t\t\t// if both outside plane, no intersection\n\t\n\t\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\t\n\t\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {\n\t\n\t\t\tvar _gl = _renderer.context,\n\t\t\t_state = _renderer.state,\n\t\t\t_frustum = new Frustum(),\n\t\t\t_projScreenMatrix = new Matrix4(),\n\t\n\t\t\t_lightShadows = _lights.shadows,\n\t\n\t\t\t_shadowMapSize = new Vector2(),\n\t\t\t_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\t\n\t\t\t_lookTarget = new Vector3(),\n\t\t\t_lightPositionWorld = new Vector3(),\n\t\n\t\t\t_renderList = [],\n\t\n\t\t\t_MorphingFlag = 1,\n\t\t\t_SkinningFlag = 2,\n\t\n\t\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\t\n\t\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\t\n\t\t\t_materialCache = {};\n\t\n\t\t\tvar cubeDirections = [\n\t\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t\t];\n\t\n\t\t\tvar cubeUps = [\n\t\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t\t];\n\t\n\t\t\tvar cube2DViewPorts = [\n\t\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t\t];\n\t\n\t\t\t// init\n\t\n\t\t\tvar depthMaterialTemplate = new MeshDepthMaterial();\n\t\t\tdepthMaterialTemplate.depthPacking = RGBADepthPacking;\n\t\t\tdepthMaterialTemplate.clipping = true;\n\t\n\t\t\tvar distanceShader = ShaderLib[ \"distanceRGBA\" ];\n\t\t\tvar distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );\n\t\n\t\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\t\n\t\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\t\n\t\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\t\tdepthMaterial.skinning = useSkinning;\n\t\n\t\t\t\t_depthMaterials[ i ] = depthMaterial;\n\t\n\t\t\t\tvar distanceMaterial = new ShaderMaterial( {\n\t\t\t\t\tdefines: {\n\t\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t\t},\n\t\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\t\tskinning: useSkinning,\n\t\t\t\t\tclipping: true\n\t\t\t\t} );\n\t\n\t\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.enabled = false;\n\t\n\t\t\tthis.autoUpdate = true;\n\t\t\tthis.needsUpdate = false;\n\t\n\t\t\tthis.type = PCFShadowMap;\n\t\n\t\t\tthis.renderReverseSided = true;\n\t\t\tthis.renderSingleSided = true;\n\t\n\t\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\t\n\t\t\t\tif ( _lightShadows.length === 0 ) return;\n\t\n\t\t\t\t// Set GL state for depth map.\n\t\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t\t_state.disable( _gl.BLEND );\n\t\t\t\t_state.setDepthTest( true );\n\t\t\t\t_state.setScissorTest( false );\n\t\n\t\t\t\t// render depth map\n\t\n\t\t\t\tvar faceCount, isPointLight;\n\t\n\t\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\t\tvar shadow = light.shadow;\n\t\n\t\t\t\t\tif ( shadow === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar shadowCamera = shadow.camera;\n\t\n\t\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\t\n\t\t\t\t\tif ( (light && light.isPointLight) ) {\n\t\n\t\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\t\tisPointLight = true;\n\t\n\t\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\t\n\t\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t\t// following orientation:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//  xzXZ\n\t\t\t\t\t\t//   y Y\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t\t// z - Negative z direction\n\t\n\t\t\t\t\t\t// positive X\n\t\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative X\n\t\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// positive Z\n\t\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative Z\n\t\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// positive Y\n\t\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative Y\n\t\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\t\n\t\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\t\tisPointLight = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( shadow.map === null ) {\n\t\n\t\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\t\n\t\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\n\t\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( (shadow && shadow.isSpotLightShadow) ) {\n\t\n\t\t\t\t\t\tshadow.update( light );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\t\tvar shadowMatrix = shadow.matrix;\n\t\n\t\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\t\n\t\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t\t_renderer.clear();\n\t\n\t\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t\t// run a single pass if not\n\t\n\t\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\t\n\t\t\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t\t_state.viewport( vpDimensions );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\t\n\t\t\t\t\t\t// compute shadow matrix\n\t\n\t\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\t\n\t\t\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\t\t\t// set object matrices & frustum culling\n\t\n\t\t\t\t\t\t_renderList.length = 0;\n\t\n\t\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\t\n\t\t\t\t\t\t// render shadow map\n\t\t\t\t\t\t// render regular objects\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\t\tif ( (material && material.isMultiMaterial) ) {\n\t\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Restore GL state.\n\t\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\t\n\t\t\t\tscope.needsUpdate = false;\n\t\n\t\t\t};\n\t\n\t\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tvar result = null;\n\t\n\t\t\t\tvar materialVariants = _depthMaterials;\n\t\t\t\tvar customMaterial = object.customDepthMaterial;\n\t\n\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ! customMaterial ) {\n\t\n\t\t\t\t\tvar useMorphing = false;\n\t\n\t\t\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\t\n\t\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\t\n\t\t\t\t\tvar variantIndex = 0;\n\t\n\t\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\t\n\t\t\t\t\tresult = materialVariants[ variantIndex ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tresult = customMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\t\n\t\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t\t// appropriate state\n\t\n\t\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\t\n\t\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\t\n\t\t\t\t\tif ( materialsForVariant === undefined ) {\n\t\n\t\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\t\n\t\t\t\t\tif ( cachedMaterial === undefined ) {\n\t\n\t\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresult = cachedMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tresult.visible = material.visible;\n\t\t\t\tresult.wireframe = material.wireframe;\n\t\n\t\t\t\tvar side = material.side;\n\t\n\t\t\t\tif ( scope.renderSingleSided && side == DoubleSide ) {\n\t\n\t\t\t\t\tside = FrontSide;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( scope.renderReverseSided ) {\n\t\n\t\t\t\t\tif ( side === FrontSide ) side = BackSide;\n\t\t\t\t\telse if ( side === BackSide ) side = FrontSide;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tresult.side = side;\n\t\n\t\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\n\t\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\t\tresult.linewidth = material.linewidth;\n\t\n\t\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\t\n\t\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectObject( object, camera, shadowCamera ) {\n\t\n\t\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\t\n\t\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\t\n\t\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\t\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t\t_renderList.push( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Ray( origin, direction ) {\n\t\n\t\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\t\n\t\t}\n\t\n\t\tRay.prototype = {\n\t\n\t\t\tconstructor: Ray,\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\tthis.origin.copy( origin );\n\t\t\t\tthis.direction.copy( direction );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( ray ) {\n\t\n\t\t\t\tthis.origin.copy( ray.origin );\n\t\t\t\tthis.direction.copy( ray.direction );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\t\n\t\t\t},\n\t\n\t\t\tlookAt: function ( v ) {\n\t\n\t\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trecast: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function recast( t ) {\n\t\n\t\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tresult.subVectors( point, this.origin );\n\t\t\t\tvar directionDistance = result.dot( this.direction );\n\t\n\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\treturn result.copy( this.origin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceSqToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function distanceSqToPoint( point ) {\n\t\n\t\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\t\n\t\t\t\t\t// point behind the ray\n\t\n\t\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t\t\treturn v1.distanceToSquared( point );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tdistanceSqToSegment: function () {\n\t\n\t\t\t\tvar segCenter = new Vector3();\n\t\t\t\tvar segDir = new Vector3();\n\t\t\t\tvar diff = new Vector3();\n\t\n\t\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\t\n\t\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t\t// defined by v0 and v1\n\t\t\t\t\t// It can also set two optional targets :\n\t\t\t\t\t// - The closest point on the ray\n\t\t\t\t\t// - The closest point on the segment\n\t\n\t\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\t\n\t\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\t\tvar s0, s1, sqrDist, extDet;\n\t\n\t\t\t\t\tif ( det > 0 ) {\n\t\n\t\t\t\t\t\t// The ray and segment are not parallel.\n\t\n\t\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\t\textDet = segExtent * det;\n\t\n\t\t\t\t\t\tif ( s0 >= 0 ) {\n\t\n\t\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\t\n\t\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\t\n\t\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t// region 1\n\t\n\t\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 5\n\t\n\t\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 4\n\t\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 3\n\t\n\t\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 2\n\t\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// Ray and segment are parallel.\n\t\n\t\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( optionalPointOnRay ) {\n\t\n\t\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( optionalPointOnSegment ) {\n\t\n\t\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn sqrDist;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectSphere: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\t\n\t\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\t\n\t\t\t\t\tif ( d2 > radius2 ) return null;\n\t\n\t\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\t\n\t\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\t\tvar t0 = tca - thc;\n\t\n\t\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\t\tvar t1 = tca + thc;\n\t\n\t\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\t\n\t\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\t\n\t\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\t\treturn this.at( t0, optionalTarget );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPlane: function ( plane ) {\n\t\n\t\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\t\n\t\t\t\t\t\treturn 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\t\n\t\t\t\t// Return if the ray never intersects the plane\n\t\n\t\t\t\treturn t >= 0 ? t :  null;\n\t\n\t\t\t},\n\t\n\t\t\tintersectPlane: function ( plane, optionalTarget ) {\n\t\n\t\t\t\tvar t = this.distanceToPlane( plane );\n\t\n\t\t\t\tif ( t === null ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.at( t, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// check if the ray lies on the plane first\n\t\n\t\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\t\n\t\t\t\tif ( distToPoint === 0 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\t\tif ( denominator * distToPoint < 0 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tintersectBox: function ( box, optionalTarget ) {\n\t\n\t\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\t\n\t\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\t\tinvdirz = 1 / this.direction.z;\n\t\n\t\t\t\tvar origin = this.origin;\n\t\n\t\t\t\tif ( invdirx >= 0 ) {\n\t\n\t\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( invdiry >= 0 ) {\n\t\n\t\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\t\n\t\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\t\n\t\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\t\n\t\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\t\n\t\t\t\tif ( invdirz >= 0 ) {\n\t\n\t\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\t\n\t\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\t\n\t\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\t\n\t\t\t\t//return point closest to the ray (positive side)\n\t\n\t\t\t\tif ( tmax < 0 ) return null;\n\t\n\t\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: ( function () {\n\t\n\t\t\t\tvar v = new Vector3();\n\t\n\t\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tintersectTriangle: function () {\n\t\n\t\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\t\tvar diff = new Vector3();\n\t\t\t\tvar edge1 = new Vector3();\n\t\t\t\tvar edge2 = new Vector3();\n\t\t\t\tvar normal = new Vector3();\n\t\n\t\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\t\n\t\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\t\n\t\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\t\n\t\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\t\tvar sign;\n\t\n\t\t\t\t\tif ( DdN > 0 ) {\n\t\n\t\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\t\tsign = 1;\n\t\n\t\t\t\t\t} else if ( DdN < 0 ) {\n\t\n\t\t\t\t\t\tsign = - 1;\n\t\t\t\t\t\tDdN = - DdN;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\t\n\t\t\t\t\t// b1 < 0, no intersection\n\t\t\t\t\tif ( DdQxE2 < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\t\n\t\t\t\t\t// b2 < 0, no intersection\n\t\t\t\t\tif ( DdE1xQ < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\t\n\t\t\t\t\t// t < 0, no intersection\n\t\t\t\t\tif ( QdN < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Ray intersects triangle.\n\t\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyMatrix4: function ( matrix4 ) {\n\t\n\t\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\t\tthis.direction.sub( this.origin );\n\t\t\t\tthis.direction.normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( ray ) {\n\t\n\t\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Euler( x, y, z, order ) {\n\t\n\t\t\tthis._x = x || 0;\n\t\t\tthis._y = y || 0;\n\t\t\tthis._z = z || 0;\n\t\t\tthis._order = order || Euler.DefaultOrder;\n\t\n\t\t}\n\t\n\t\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\t\n\t\tEuler.DefaultOrder = 'XYZ';\n\t\n\t\tEuler.prototype = {\n\t\n\t\t\tconstructor: Euler,\n\t\n\t\t\tisEuler: true,\n\t\n\t\t\tget x () {\n\t\n\t\t\t\treturn this._x;\n\t\n\t\t\t},\n\t\n\t\t\tset x ( value ) {\n\t\n\t\t\t\tthis._x = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget y () {\n\t\n\t\t\t\treturn this._y;\n\t\n\t\t\t},\n\t\n\t\t\tset y ( value ) {\n\t\n\t\t\t\tthis._y = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget z () {\n\t\n\t\t\t\treturn this._z;\n\t\n\t\t\t},\n\t\n\t\t\tset z ( value ) {\n\t\n\t\t\t\tthis._z = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tget order () {\n\t\n\t\t\t\treturn this._order;\n\t\n\t\t\t},\n\t\n\t\t\tset order ( value ) {\n\t\n\t\t\t\tthis._order = value;\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( x, y, z, order ) {\n\t\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\tthis._order = order || this._order;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( euler ) {\n\t\n\t\t\t\tthis._x = euler._x;\n\t\t\t\tthis._y = euler._y;\n\t\t\t\tthis._z = euler._z;\n\t\t\t\tthis._order = euler._order;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\t\n\t\t\t\tvar clamp = _Math.clamp;\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar te = m.elements;\n\t\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\t\torder = order || this._order;\n\t\n\t\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._y = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._order = order;\n\t\n\t\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromQuaternion: function () {\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\treturn function setFromQuaternion( q, order, update ) {\n\t\n\t\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\t\n\t\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\t\n\t\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetFromVector3: function ( v, order ) {\n\t\n\t\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\t\n\t\t\t},\n\t\n\t\t\treorder: function () {\n\t\n\t\t\t\t// WARNING: this discards revolution information -bhouston\n\t\n\t\t\t\tvar q = new Quaternion();\n\t\n\t\t\t\treturn function reorder( newOrder ) {\n\t\n\t\t\t\t\tq.setFromEuler( this );\n\t\n\t\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tequals: function ( euler ) {\n\t\n\t\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array ) {\n\t\n\t\t\t\tthis._x = array[ 0 ];\n\t\t\t\tthis._y = array[ 1 ];\n\t\t\t\tthis._z = array[ 2 ];\n\t\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this._x;\n\t\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\t\tarray[ offset + 3 ] = this._order;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\ttoVector3: function ( optionalResult ) {\n\t\n\t\t\t\tif ( optionalResult ) {\n\t\n\t\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tonChange: function ( callback ) {\n\t\n\t\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tonChangeCallback: function () {}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Layers() {\n\t\n\t\t\tthis.mask = 1;\n\t\n\t\t}\n\t\n\t\tLayers.prototype = {\n\t\n\t\t\tconstructor: Layers,\n\t\n\t\t\tset: function ( channel ) {\n\t\n\t\t\t\tthis.mask = 1 << channel;\n\t\n\t\t\t},\n\t\n\t\t\tenable: function ( channel ) {\n\t\n\t\t\t\tthis.mask |= 1 << channel;\n\t\n\t\t\t},\n\t\n\t\t\ttoggle: function ( channel ) {\n\t\n\t\t\t\tthis.mask ^= 1 << channel;\n\t\n\t\t\t},\n\t\n\t\t\tdisable: function ( channel ) {\n\t\n\t\t\t\tthis.mask &= ~ ( 1 << channel );\n\t\n\t\t\t},\n\t\n\t\t\ttest: function ( layers ) {\n\t\n\t\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author elephantatwork / www.elephantatwork.ch\n\t\t */\n\t\n\t\tfunction Object3D() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: Object3DIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Object3D';\n\t\n\t\t\tthis.parent = null;\n\t\t\tthis.children = [];\n\t\n\t\t\tthis.up = Object3D.DefaultUp.clone();\n\t\n\t\t\tvar position = new Vector3();\n\t\t\tvar rotation = new Euler();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3( 1, 1, 1 );\n\t\n\t\t\tfunction onRotationChange() {\n\t\n\t\t\t\tquaternion.setFromEuler( rotation, false );\n\t\n\t\t\t}\n\t\n\t\t\tfunction onQuaternionChange() {\n\t\n\t\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\t\n\t\t\t}\n\t\n\t\t\trotation.onChange( onRotationChange );\n\t\t\tquaternion.onChange( onQuaternionChange );\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\tposition: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: position\n\t\t\t\t},\n\t\t\t\trotation: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: rotation\n\t\t\t\t},\n\t\t\t\tquaternion: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: quaternion\n\t\t\t\t},\n\t\t\t\tscale: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: scale\n\t\t\t\t},\n\t\t\t\tmodelViewMatrix: {\n\t\t\t\t\tvalue: new Matrix4()\n\t\t\t\t},\n\t\t\t\tnormalMatrix: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.matrixWorld = new Matrix4();\n\t\n\t\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.visible = true;\n\t\n\t\t\tthis.castShadow = false;\n\t\t\tthis.receiveShadow = false;\n\t\n\t\t\tthis.frustumCulled = true;\n\t\t\tthis.renderOrder = 0;\n\t\n\t\t\tthis.userData = {};\n\t\n\t\t\tthis.onBeforeRender = function(){}; \n\t\t\tthis.onAfterRender = function(){};\n\t\n\t\t}\n\t\n\t\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\t\tObject3D.DefaultMatrixAutoUpdate = true;\n\t\n\t\tObject.assign( Object3D.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisObject3D: true,\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\t\n\t\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t\t// assumes axis is normalized\n\t\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromEuler: function ( euler ) {\n\t\n\t\t\t\tthis.quaternion.setFromEuler( euler, true );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromMatrix: function ( m ) {\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t\t// assumes q is normalized\n\t\n\t\t\t\tthis.quaternion.copy( q );\n\t\n\t\t\t},\n\t\n\t\t\trotateOnAxis: function () {\n\t\n\t\t\t\t// rotate object on axis in object space\n\t\t\t\t// axis is assumed to be normalized\n\t\n\t\t\t\tvar q1 = new Quaternion();\n\t\n\t\t\t\treturn function rotateOnAxis( axis, angle ) {\n\t\n\t\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\t\n\t\t\t\t\tthis.quaternion.multiply( q1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateOnAxis: function () {\n\t\n\t\t\t\t// translate object by distance along axis in object space\n\t\t\t\t// axis is assumed to be normalized\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function translateOnAxis( axis, distance ) {\n\t\n\t\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\t\n\t\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateX: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\t\n\t\t\t\treturn function translateX( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateY: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\t\n\t\t\t\treturn function translateY( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateZ: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\t\n\t\t\t\treturn function translateZ( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlocalToWorld: function ( vector ) {\n\t\n\t\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\t\n\t\t\t},\n\t\n\t\t\tworldToLocal: function () {\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function worldToLocal( vector ) {\n\t\n\t\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\t\n\t\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tadd: function ( object ) {\n\t\n\t\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\t\tthis.add( arguments[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object === this ) {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( (object && object.isObject3D) ) {\n\t\n\t\t\t\t\tif ( object.parent !== null ) {\n\t\n\t\t\t\t\t\tobject.parent.remove( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.parent = this;\n\t\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\t\n\t\t\t\t\tthis.children.push( object );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tremove: function ( object ) {\n\t\n\t\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\t\tthis.remove( arguments[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar index = this.children.indexOf( object );\n\t\n\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\tobject.parent = null;\n\t\n\t\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\t\n\t\t\t\t\tthis.children.splice( index, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectById: function ( id ) {\n\t\n\t\t\t\treturn this.getObjectByProperty( 'id', id );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectByName: function ( name ) {\n\t\n\t\t\t\treturn this.getObjectByProperty( 'name', name );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectByProperty: function ( name, value ) {\n\t\n\t\t\t\tif ( this[ name ] === value ) return this;\n\t\n\t\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar child = this.children[ i ];\n\t\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\t\n\t\t\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\t\t\treturn object;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn undefined;\n\t\n\t\t\t},\n\t\n\t\t\tgetWorldPosition: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t},\n\t\n\t\t\tgetWorldQuaternion: function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar scale = new Vector3();\n\t\n\t\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Quaternion();\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldRotation: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldRotation( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Euler();\n\t\n\t\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldScale: function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldScale( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldDirection: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\traycast: function () {},\n\t\n\t\t\ttraverse: function ( callback ) {\n\t\n\t\t\t\tcallback( this );\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].traverse( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttraverseVisible: function ( callback ) {\n\t\n\t\t\t\tif ( this.visible === false ) return;\n\t\n\t\t\t\tcallback( this );\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].traverseVisible( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttraverseAncestors: function ( callback ) {\n\t\n\t\t\t\tvar parent = this.parent;\n\t\n\t\t\t\tif ( parent !== null ) {\n\t\n\t\t\t\t\tcallback( parent );\n\t\n\t\t\t\t\tparent.traverseAncestors( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrix: function () {\n\t\n\t\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\t\n\t\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: function ( force ) {\n\t\n\t\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\t\n\t\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\t\n\t\t\t\t\tif ( this.parent === null ) {\n\t\n\t\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\t\t\tforce = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update children\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\t// meta is '' when called from JSON.stringify\n\t\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\t\n\t\t\t\tvar output = {};\n\t\n\t\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t\t// not providing it implies that this is the root object\n\t\t\t\t// being serialized.\n\t\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t\t// initialize meta obj\n\t\t\t\t\tmeta = {\n\t\t\t\t\t\tgeometries: {},\n\t\t\t\t\t\tmaterials: {},\n\t\t\t\t\t\ttextures: {},\n\t\t\t\t\t\timages: {}\n\t\t\t\t\t};\n\t\n\t\t\t\t\toutput.metadata = {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Object',\n\t\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// standard Object3D serialization\n\t\n\t\t\t\tvar object = {};\n\t\n\t\t\t\tobject.uuid = this.uuid;\n\t\t\t\tobject.type = this.type;\n\t\n\t\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\t\tif ( this.visible === false ) object.visible = false;\n\t\n\t\t\t\tobject.matrix = this.matrix.toArray();\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( this.geometry !== undefined ) {\n\t\n\t\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.geometry = this.geometry.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.material !== undefined ) {\n\t\n\t\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.material = this.material.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( this.children.length > 0 ) {\n\t\n\t\t\t\t\tobject.children = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\t\n\t\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\t\tif ( images.length > 0 ) output.images = images;\n\t\n\t\t\t\t}\n\t\n\t\t\t\toutput.object = object;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t\t// extract data from the cache hash\n\t\t\t\t// remove metadata on each item\n\t\t\t\t// and return as array\n\t\t\t\tfunction extractFromCache( cache ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function ( recursive ) {\n\t\n\t\t\t\treturn new this.constructor().copy( this, recursive );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\t\tif ( recursive === undefined ) recursive = true;\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\tthis.up.copy( source.up );\n\t\n\t\t\t\tthis.position.copy( source.position );\n\t\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\t\tthis.scale.copy( source.scale );\n\t\n\t\t\t\tthis.matrix.copy( source.matrix );\n\t\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\t\n\t\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\t\n\t\t\t\tthis.visible = source.visible;\n\t\n\t\t\t\tthis.castShadow = source.castShadow;\n\t\t\t\tthis.receiveShadow = source.receiveShadow;\n\t\n\t\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\t\tthis.renderOrder = source.renderOrder;\n\t\n\t\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\t\n\t\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\t\tthis.add( child.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar count$2 = 0;\n\t\tfunction Object3DIdCount() { return count$2++; }\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Line3( start, end ) {\n\t\n\t\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\t\n\t\t}\n\t\n\t\tLine3.prototype = {\n\t\n\t\t\tconstructor: Line3,\n\t\n\t\t\tset: function ( start, end ) {\n\t\n\t\t\t\tthis.start.copy( start );\n\t\t\t\tthis.end.copy( end );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( line ) {\n\t\n\t\t\t\tthis.start.copy( line.start );\n\t\t\t\tthis.end.copy( line.end );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tdelta: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.subVectors( this.end, this.start );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceSq: function () {\n\t\n\t\t\t\treturn this.start.distanceToSquared( this.end );\n\t\n\t\t\t},\n\t\n\t\t\tdistance: function () {\n\t\n\t\t\t\treturn this.start.distanceTo( this.end );\n\t\n\t\t\t},\n\t\n\t\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t\t},\n\t\n\t\t\tclosestPointToPointParameter: function () {\n\t\n\t\t\t\tvar startP = new Vector3();\n\t\t\t\tvar startEnd = new Vector3();\n\t\n\t\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\t\n\t\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\t\n\t\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\t\n\t\t\t\t\tvar t = startEnd_startP / startEnd2;\n\t\n\t\t\t\t\tif ( clampToLine ) {\n\t\n\t\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn t;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\t\n\t\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\t\tthis.end.applyMatrix4( matrix );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( line ) {\n\t\n\t\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Triangle( a, b, c ) {\n\t\n\t\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\t\n\t\t}\n\t\n\t\tTriangle.normal = function () {\n\t\n\t\t\tvar v0 = new Vector3();\n\t\n\t\t\treturn function normal( a, b, c, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tresult.subVectors( c, b );\n\t\t\t\tv0.subVectors( a, b );\n\t\t\t\tresult.cross( v0 );\n\t\n\t\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\t\tif ( resultLengthSq > 0 ) {\n\t\n\t\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result.set( 0, 0, 0 );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t// static/instance method to calculate barycentric coordinates\n\t\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\t\tTriangle.barycoordFromPoint = function () {\n\t\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\n\t\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\t\n\t\t\t\tv0.subVectors( c, a );\n\t\t\t\tv1.subVectors( b, a );\n\t\t\t\tv2.subVectors( point, a );\n\t\n\t\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\t\tvar dot12 = v1.dot( v2 );\n\t\n\t\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t// collinear or singular triangle\n\t\t\t\tif ( denom === 0 ) {\n\t\n\t\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar invDenom = 1 / denom;\n\t\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\t\n\t\t\t\t// barycentric coordinates must always sum to 1\n\t\t\t\treturn result.set( 1 - u - v, v, u );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tTriangle.containsPoint = function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\n\t\t\treturn function containsPoint( point, a, b, c ) {\n\t\n\t\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\t\n\t\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tTriangle.prototype = {\n\t\n\t\t\tconstructor: Triangle,\n\t\n\t\t\tset: function ( a, b, c ) {\n\t\n\t\t\t\tthis.a.copy( a );\n\t\t\t\tthis.b.copy( b );\n\t\t\t\tthis.c.copy( c );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\t\n\t\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\t\tthis.c.copy( points[ i2 ] );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( triangle ) {\n\t\n\t\t\t\tthis.a.copy( triangle.a );\n\t\t\t\tthis.b.copy( triangle.b );\n\t\t\t\tthis.c.copy( triangle.c );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tarea: function () {\n\t\n\t\t\t\tvar v0 = new Vector3();\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function area() {\n\t\n\t\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\t\tv1.subVectors( this.a, this.b );\n\t\n\t\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmidpoint: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\t\n\t\t\t},\n\t\n\t\t\tnormal: function ( optionalTarget ) {\n\t\n\t\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tplane: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Plane();\n\t\n\t\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\n\t\t\t},\n\t\n\t\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\t\n\t\t\t},\n\t\n\t\t\tclosestPointToPoint: function () {\n\t\n\t\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\t\n\t\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\t\n\t\t\t\t\tif ( plane === undefined ) {\n\t\n\t\t\t\t\t\tplane = new Plane();\n\t\t\t\t\t\tedgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\t\t\t\tprojectedPoint = new Vector3();\n\t\t\t\t\t\tclosestPoint = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\t\tvar minDistance = Infinity;\n\t\n\t\t\t\t\t// project the point onto the plane of the triangle\n\t\n\t\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\t\tplane.projectPoint( point, projectedPoint );\n\t\n\t\t\t\t\t// check if the projection lies within the triangle\n\t\n\t\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\t\n\t\t\t\t\t\t// if so, this is the closest point\n\t\n\t\t\t\t\t\tresult.copy( projectedPoint );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\t\n\t\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\t\n\t\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\t\n\t\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\t\n\t\t\t\t\t\t\tif( distance < minDistance ) {\n\t\n\t\t\t\t\t\t\t\tminDistance = distance;\n\t\n\t\t\t\t\t\t\t\tresult.copy( closestPoint );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tequals: function ( triangle ) {\n\t\n\t\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\t\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\n\t\t\tthis.normal = (normal && normal.isVector3) ? normal : new Vector3();\n\t\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\t\n\t\t\tthis.color = (color && color.isColor) ? color : new Color();\n\t\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\t\n\t\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\t\n\t\t}\n\t\n\t\tFace3.prototype = {\n\t\n\t\t\tconstructor: Face3,\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.a = source.a;\n\t\t\t\tthis.b = source.b;\n\t\t\t\tthis.c = source.c;\n\t\n\t\t\t\tthis.normal.copy( source.normal );\n\t\t\t\tthis.color.copy( source.color );\n\t\n\t\t\t\tthis.materialIndex = source.materialIndex;\n\t\n\t\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  shading: THREE.SmoothShading,\n\t\t *  depthTest: <bool>,\n\t\t *  depthWrite: <bool>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshBasicMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshBasicMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // emissive\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\t\n\t\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\t\n\t\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t}\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.array = array;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\t\tthis.normalized = normalized === true;\n\t\n\t\t\tthis.dynamic = false;\n\t\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\t\tthis.version = 0;\n\t\n\t\t}\n\t\n\t\tBufferAttribute.prototype = {\n\t\n\t\t\tconstructor: BufferAttribute,\n\t\n\t\t\tisBufferAttribute: true,\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t},\n\t\n\t\t\tsetArray: function ( array ) {\n\t\n\t\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\t\tthis.array = array;\n\t\n\t\t\t},\n\t\n\t\t\tsetDynamic: function ( value ) {\n\t\n\t\t\t\tthis.dynamic = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\t\tthis.itemSize = source.itemSize;\n\t\t\t\tthis.count = source.count;\n\t\t\t\tthis.normalized = source.normalized;\n\t\n\t\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\t\tindex1 *= this.itemSize;\n\t\t\t\tindex2 *= attribute.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyArray: function ( array ) {\n\t\n\t\t\t\tthis.array.set( array );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyColorsArray: function ( colors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar color = colors[ i ];\n\t\n\t\t\t\t\tif ( color === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\t\tcolor = new Color();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\t\tarray[ offset ++ ] = color.b;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyIndicesArray: function ( indices ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar index = indices[ i ];\n\t\n\t\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\t\tarray[ offset ++ ] = index.c;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector2sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector2();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector3sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector4sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\t\tarray[ offset ++ ] = vector.w;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.array.set( value, offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetX: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize ];\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( index, x ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize ] = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetY: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( index, y ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetZ: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( index, z ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetW: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( index, w ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\t\t\tthis.array[ index + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\t\t\tthis.array[ index + 2 ] = z;\n\t\t\t\tthis.array[ index + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction Int8Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Int8Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint8Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint8Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Int16Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Int16Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint16Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint16Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Int32Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Int32Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint32Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Uint32Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Float32Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Float32Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Float64Attribute( array, itemSize ) {\n\t\n\t\t\treturn new BufferAttribute( new Float64Array( array ), itemSize );\n\t\n\t\t}\n\t\n\t\t// Deprecated\n\t\n\t\tfunction DynamicBufferAttribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author kile / http://kile.stravaganza.org/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Geometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Geometry';\n\t\n\t\t\tthis.vertices = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\n\t\t\tthis.morphTargets = [];\n\t\t\tthis.morphNormals = [];\n\t\n\t\t\tthis.skinWeights = [];\n\t\t\tthis.skinIndices = [];\n\t\n\t\t\tthis.lineDistances = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t// update flags\n\t\n\t\t\tthis.elementsNeedUpdate = false;\n\t\t\tthis.verticesNeedUpdate = false;\n\t\t\tthis.uvsNeedUpdate = false;\n\t\t\tthis.normalsNeedUpdate = false;\n\t\t\tthis.colorsNeedUpdate = false;\n\t\t\tthis.lineDistancesNeedUpdate = false;\n\t\t\tthis.groupsNeedUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( Geometry.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisGeometry: true,\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\t\tvertex.applyMatrix4( matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.verticesNeedUpdate = true;\n\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function () {\n\t\n\t\t\t\t// translate geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tscale: function () {\n\t\n\t\t\t\t// scale geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar obj;\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\t\n\t\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tfromBufferGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\tvar positions = attributes.position.array;\n\t\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\t\n\t\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\t\n\t\t\t\tvar tempNormals = [];\n\t\t\t\tvar tempUVs = [];\n\t\t\t\tvar tempUVs2 = [];\n\t\n\t\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\t\n\t\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\t\n\t\t\t\t\tif ( normals !== undefined ) {\n\t\n\t\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( colors !== undefined ) {\n\t\n\t\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\t\n\t\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\t\n\t\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\t\n\t\t\t\t\tscope.faces.push( face );\n\t\n\t\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( indices !== undefined ) {\n\t\n\t\t\t\t\tvar groups = geometry.groups;\n\t\n\t\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\t\n\t\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\t\n\t\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcenter: function () {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\t\n\t\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\t\treturn offset;\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\tvar center = this.boundingSphere.center;\n\t\t\t\tvar radius = this.boundingSphere.radius;\n\t\n\t\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\t\t\tmatrix.set(\n\t\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t);\n\t\n\t\t\t\tthis.applyMatrix( matrix );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\t\n\t\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ f ];\n\t\n\t\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\t\tvar vC = this.vertices[ face.c ];\n\t\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\tcb.normalize();\n\t\n\t\t\t\t\tface.normal.copy( cb );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\t\n\t\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\t\n\t\t\t\tvar v, vl, f, fl, face, vertices;\n\t\n\t\t\t\tvertices = new Array( this.vertices.length );\n\t\n\t\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\tvertices[ v ] = new Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( areaWeighted ) {\n\t\n\t\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\t\n\t\t\t\t\tvar vA, vB, vC;\n\t\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\t\tvC = this.vertices[ face.c ];\n\t\n\t\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\t\tvertices[ face.c ].add( cb );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\tvertices[ v ].normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFlatVertexNormals: function () {\n\t\n\t\t\t\tvar f, fl, face;\n\t\n\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeMorphNormals: function () {\n\t\n\t\t\t\tvar i, il, f, fl, face;\n\t\n\t\t\t\t// save original normals\n\t\t\t\t// - create temp variables on first access\n\t\t\t\t//   otherwise just copy (for faster repeated calls)\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\t\n\t\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\t\n\t\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\t\n\t\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\t\n\t\t\t\tvar tmpGeo = new Geometry();\n\t\t\t\ttmpGeo.faces = this.faces;\n\t\n\t\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t// create on first access\n\t\n\t\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\t\n\t\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\t\n\t\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\t\n\t\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\t\n\t\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\t\n\t\t\t\t\t// set vertices to morph target\n\t\n\t\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t// compute morph normals\n\t\n\t\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\t\ttmpGeo.computeVertexNormals();\n\t\n\t\t\t\t\t// store morph normals\n\t\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\t\n\t\t\t\t\t\tfaceNormal.copy( face.normal );\n\t\n\t\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore original normals\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeTangents: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeLineDistances: function () {\n\t\n\t\t\t\tvar d = 0;\n\t\t\t\tvar vertices = this.vertices;\n\t\n\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tif ( i > 0 ) {\n\t\n\t\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.lineDistances[ i ] = d;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingBox: function () {\n\t\n\t\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\t\tthis.boundingBox = new Box3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\t\n\t\t\t},\n\t\n\t\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\t\n\t\t\t\tif ( (geometry && geometry.isGeometry) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normalMatrix,\n\t\t\t\tvertexOffset = this.vertices.length,\n\t\t\t\tvertices1 = this.vertices,\n\t\t\t\tvertices2 = geometry.vertices,\n\t\t\t\tfaces1 = this.faces,\n\t\t\t\tfaces2 = geometry.faces,\n\t\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\t\tcolors1 = this.colors,\n\t\t\t\tcolors2 = geometry.colors;\n\t\n\t\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\t\n\t\t\t\tif ( matrix !== undefined ) {\n\t\n\t\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// vertices\n\t\n\t\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = vertices2[ i ];\n\t\n\t\t\t\t\tvar vertexCopy = vertex.clone();\n\t\n\t\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\t\n\t\t\t\t\tvertices1.push( vertexCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// colors\n\t\n\t\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// faces\n\t\n\t\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\t\tfaceVertexColors = face.vertexColors;\n\t\n\t\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\t\tfaceCopy.normal.copy( face.normal );\n\t\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\t\n\t\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.color.copy( face.color );\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\t\n\t\t\t\t\tfaces1.push( faceCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// uvs\n\t\n\t\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\t\n\t\t\t\t\tif ( uv === undefined ) {\n\t\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuvs1.push( uvCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmergeMesh: function ( mesh ) {\n\t\n\t\t\t\tif ( (mesh && mesh.isMesh) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\t\n\t\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\t\n\t\t\t},\n\t\n\t\t\t/*\n\t\t\t * Checks for duplicate vertices with hashmap.\n\t\t\t * Duplicated vertices are removed\n\t\t\t * and faces' vertices are updated.\n\t\t\t */\n\t\n\t\t\tmergeVertices: function () {\n\t\n\t\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\t\tvar unique = [], changes = [];\n\t\n\t\t\t\tvar v, key;\n\t\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\t\tvar i, il, face;\n\t\t\t\tvar indices, j, jl;\n\t\n\t\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tv = this.vertices[ i ];\n\t\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\t\n\t\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\t\n\t\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t\t// have to remove them from the geometry.\n\t\t\t\tvar faceIndicesToRemove = [];\n\t\n\t\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ i ];\n\t\n\t\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\t\tface.c = changes[ face.c ];\n\t\n\t\t\t\t\tindices = [ face.a, face.b, face.c ];\n\t\n\t\t\t\t\tvar dupIndex = - 1;\n\t\n\t\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\t\n\t\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\t\n\t\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\t\n\t\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\t\n\t\t\t\t\tthis.faces.splice( idx, 1 );\n\t\n\t\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Use unique set of vertices\n\t\n\t\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\t\tthis.vertices = unique;\n\t\t\t\treturn diff;\n\t\n\t\t\t},\n\t\n\t\t\tsortFacesByMaterialIndex: function () {\n\t\n\t\t\t\tvar faces = this.faces;\n\t\t\t\tvar length = faces.length;\n\t\n\t\t\t\t// tag faces\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tfaces[ i ]._id = i;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// sort faces\n\t\n\t\t\t\tfunction materialIndexSort( a, b ) {\n\t\n\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfaces.sort( materialIndexSort );\n\t\n\t\t\t\t// sort uvs\n\t\n\t\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\t\n\t\t\t\tvar newUvs1, newUvs2;\n\t\n\t\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tvar id = faces[ i ]._id;\n\t\n\t\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard Geometry serialization\n\t\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar vertices = [];\n\t\n\t\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar faces = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar normalsHash = {};\n\t\t\t\tvar colors = [];\n\t\t\t\tvar colorsHash = {};\n\t\t\t\tvar uvs = [];\n\t\t\t\tvar uvsHash = {};\n\t\n\t\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ i ];\n\t\n\t\t\t\t\tvar hasMaterial = true;\n\t\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\t\n\t\t\t\t\tvar faceType = 0;\n\t\n\t\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\t\n\t\t\t\t\tfaces.push( faceType );\n\t\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\t\tfaces.push( face.materialIndex );\n\t\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction setBit( value, position, enabled ) {\n\t\n\t\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getNormalIndex( normal ) {\n\t\n\t\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\t\n\t\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getColorIndex( color ) {\n\t\n\t\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\t\n\t\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\t\tcolors.push( color.getHex() );\n\t\n\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getUvIndex( uv ) {\n\t\n\t\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\t\n\t\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdata.data = {};\n\t\n\t\t\t\tdata.data.vertices = vertices;\n\t\t\t\tdata.data.normals = normals;\n\t\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\t\tdata.data.faces = faces;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\t/*\n\t\t\t\t// Handle primitives\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\t\treturn geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\t\t\t*/\n\t\n\t\t\t\treturn new Geometry().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.vertices = [];\n\t\t\t\tthis.faces = [];\n\t\t\t\tthis.faceVertexUvs = [ [] ];\n\t\t\t\tthis.colors = [];\n\t\n\t\t\t\tvar vertices = source.vertices;\n\t\n\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar colors = source.colors;\n\t\n\t\t\t\tfor ( var i = 0, il = colors.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar faces = source.faces;\n\t\n\t\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\t\n\t\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\t\n\t\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\tvar uv = uvs[ k ];\n\t\n\t\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar count$3 = 0;\n\t\tfunction GeometryIdCount() { return count$3++; }\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction DirectGeometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'DirectGeometry';\n\t\n\t\t\tthis.indices = [];\n\t\t\tthis.vertices = [];\n\t\t\tthis.normals = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.uvs = [];\n\t\t\tthis.uvs2 = [];\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t\tthis.morphTargets = {};\n\t\n\t\t\tthis.skinWeights = [];\n\t\t\tthis.skinIndices = [];\n\t\n\t\t\t// this.lineDistances = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t// update flags\n\t\n\t\t\tthis.verticesNeedUpdate = false;\n\t\t\tthis.normalsNeedUpdate = false;\n\t\t\tthis.colorsNeedUpdate = false;\n\t\t\tthis.uvsNeedUpdate = false;\n\t\t\tthis.groupsNeedUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( DirectGeometry.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tcomputeBoundingBox: Geometry.prototype.computeBoundingBox,\n\t\t\tcomputeBoundingSphere: Geometry.prototype.computeBoundingSphere,\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeGroups: function ( geometry ) {\n\t\n\t\t\t\tvar group;\n\t\t\t\tvar groups = [];\n\t\t\t\tvar materialIndex;\n\t\n\t\t\t\tvar faces = geometry.faces;\n\t\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\t// materials\n\t\n\t\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\t\n\t\t\t\t\t\tmaterialIndex = face.materialIndex;\n\t\n\t\t\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgroup = {\n\t\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.groups = groups;\n\t\n\t\t\t},\n\t\n\t\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\t\n\t\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\tvar morphTargetsLength = morphTargets.length;\n\t\n\t\t\t\tvar morphTargetsPosition;\n\t\n\t\t\t\tif ( morphTargetsLength > 0 ) {\n\t\n\t\t\t\t\tmorphTargetsPosition = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\t\n\t\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\t\tvar morphNormalsLength = morphNormals.length;\n\t\n\t\t\t\tvar morphTargetsNormal;\n\t\n\t\t\t\tif ( morphNormalsLength > 0 ) {\n\t\n\t\t\t\t\tmorphTargetsNormal = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\t\n\t\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skins\n\t\n\t\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\t\tvar skinWeights = geometry.skinWeights;\n\t\n\t\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\tif ( vertexColors.length === 3 ) {\n\t\n\t\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar color = face.color;\n\t\n\t\t\t\t\t\tthis.colors.push( color, color, color );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexUv === true ) {\n\t\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\t\n\t\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\t\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\t\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\t\n\t\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// morphs\n\t\n\t\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\t\n\t\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\t\n\t\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\t\n\t\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\t\n\t\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// skins\n\t\n\t\t\t\t\tif ( hasSkinIndices ) {\n\t\n\t\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasSkinWeights ) {\n\t\n\t\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.computeGroups( geometry );\n\t\n\t\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferGeometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'BufferGeometry';\n\t\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\n\t\t\tthis.morphAttributes = {};\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\tthis.drawRange = { start: 0, count: Infinity };\n\t\n\t\t}\n\t\n\t\tObject.assign( BufferGeometry.prototype, EventDispatcher.prototype, {\n\t\n\t\t\tisBufferGeometry: true,\n\t\n\t\t\tgetIndex: function () {\n\t\n\t\t\t\treturn this.index;\n\t\n\t\t\t},\n\t\n\t\t\tsetIndex: function ( index ) {\n\t\n\t\t\t\tthis.index = index;\n\t\n\t\t\t},\n\t\n\t\t\taddAttribute: function ( name, attribute ) {\n\t\n\t\t\t\tif ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\t\n\t\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( name === 'index' ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\t\tthis.setIndex( attribute );\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.attributes[ name ] = attribute;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetAttribute: function ( name ) {\n\t\n\t\t\t\treturn this.attributes[ name ];\n\t\n\t\t\t},\n\t\n\t\t\tremoveAttribute: function ( name ) {\n\t\n\t\t\t\tdelete this.attributes[ name ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddGroup: function ( start, count, materialIndex ) {\n\t\n\t\t\t\tthis.groups.push( {\n\t\n\t\t\t\t\tstart: start,\n\t\t\t\t\tcount: count,\n\t\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\t\n\t\t\t\t} );\n\t\n\t\t\t},\n\t\n\t\t\tclearGroups: function () {\n\t\n\t\t\t\tthis.groups = [];\n\t\n\t\t\t},\n\t\n\t\t\tsetDrawRange: function ( start, count ) {\n\t\n\t\t\t\tthis.drawRange.start = start;\n\t\t\t\tthis.drawRange.count = count;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tvar position = this.attributes.position;\n\t\n\t\t\t\tif ( position !== undefined ) {\n\t\n\t\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normal = this.attributes.normal;\n\t\n\t\t\t\tif ( normal !== undefined ) {\n\t\n\t\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\t\tnormal.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function () {\n\t\n\t\t\t\t// translate geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tscale: function () {\n\t\n\t\t\t\t// scale geometry\n\t\n\t\t\t\tvar m1;\n\t\n\t\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\t\n\t\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar obj;\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\t\n\t\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcenter: function () {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\t\n\t\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\t\treturn offset;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromObject: function ( object ) {\n\t\n\t\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( (object && object.isPoints) || (object && object.isLine) ) {\n\t\n\t\t\t\t\tvar positions = new Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\t\tvar colors = new Float32Attribute( geometry.colors.length * 3, 3 );\n\t\n\t\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\t\n\t\t\t\t\t\tvar lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );\n\t\n\t\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (object && object.isMesh) ) {\n\t\n\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\tthis.fromGeometry( geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdateFromObject: function ( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( (object && object.isMesh) ) {\n\t\n\t\t\t\t\tvar direct = geometry.__directGeometry;\n\t\n\t\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\t\n\t\t\t\t\t\tdirect = undefined;\n\t\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( direct === undefined ) {\n\t\n\t\t\t\t\t\treturn this.fromGeometry( geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\t\tgeometry = direct;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attribute;\n\t\n\t\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.position;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.normal;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.color;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvsNeedUpdate ) {\n\t\n\t\t\t\t\tattribute = this.attributes.uv;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\t\n\t\t\t\t\tattribute = this.attributes.lineDistance;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.groupsNeedUpdate ) {\n\t\n\t\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\t\n\t\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\t\n\t\t\t},\n\t\n\t\t\tfromDirectGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\t\n\t\t\t\tif ( geometry.normals.length > 0 ) {\n\t\n\t\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.colors.length > 0 ) {\n\t\n\t\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvs.length > 0 ) {\n\t\n\t\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvs2.length > 0 ) {\n\t\n\t\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.indices.length > 0 ) {\n\t\n\t\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// groups\n\t\n\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tfor ( var name in geometry.morphTargets ) {\n\t\n\t\t\t\t\tvar array = [];\n\t\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\t\n\t\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\n\t\t\t\t\t\tvar attribute = new Float32Attribute( morphTarget.length * 3, 3 );\n\t\n\t\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphAttributes[ name ] = array;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skinning\n\t\n\t\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\t\n\t\t\t\t\tvar skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\t\n\t\t\t\t\tvar skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingBox: function () {\n\t\n\t\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\t\tthis.boundingBox = new Box3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar positions = this.attributes.position.array;\n\t\n\t\t\t\tif ( positions !== undefined ) {\n\t\n\t\t\t\t\tthis.boundingBox.setFromArray( positions );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.boundingBox.makeEmpty();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\t\tvar box = new Box3();\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\treturn function computeBoundingSphere() {\n\t\n\t\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar positions = this.attributes.position;\n\t\n\t\t\t\t\tif ( positions ) {\n\t\n\t\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\t\tvar center = this.boundingSphere.center;\n\t\n\t\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\t\tbox.getCenter( center );\n\t\n\t\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\t\n\t\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\t// backwards compatibility\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function () {\n\t\n\t\t\t\tvar index = this.index;\n\t\t\t\tvar attributes = this.attributes;\n\t\t\t\tvar groups = this.groups;\n\t\n\t\t\t\tif ( attributes.position ) {\n\t\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( attributes.normal === undefined ) {\n\t\n\t\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// reset existing normals to zero\n\t\n\t\t\t\t\t\tvar array = attributes.normal.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tarray[ i ] = 0;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar normals = attributes.normal.array;\n\t\n\t\t\t\t\tvar vA, vB, vC,\n\t\n\t\t\t\t\tpA = new Vector3(),\n\t\t\t\t\tpB = new Vector3(),\n\t\t\t\t\tpC = new Vector3(),\n\t\n\t\t\t\t\tcb = new Vector3(),\n\t\t\t\t\tab = new Vector3();\n\t\n\t\t\t\t\t// indexed elements\n\t\n\t\t\t\t\tif ( index ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar group = groups[ j ];\n\t\n\t\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\t\n\t\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\t\n\t\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\t\n\t\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\t\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.normalizeNormals();\n\t\n\t\t\t\t\tattributes.normal.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmerge: function ( geometry, offset ) {\n\t\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\t\n\t\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\t\tvar attributeArray1 = attribute1.array;\n\t\n\t\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\t\tvar attributeArray2 = attribute2.array;\n\t\n\t\t\t\t\tvar attributeSize = attribute2.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnormalizeNormals: function () {\n\t\n\t\t\t\tvar normals = this.attributes.normal.array;\n\t\n\t\t\t\tvar x, y, z, n;\n\t\n\t\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\t\n\t\t\t\t\tx = normals[ i ];\n\t\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\t\tz = normals[ i + 2 ];\n\t\n\t\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\t\n\t\t\t\t\tnormals[ i ] *= n;\n\t\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\t\tnormals[ i + 2 ] *= n;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoNonIndexed: function () {\n\t\n\t\t\t\tif ( this.index === null ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar geometry2 = new BufferGeometry();\n\t\n\t\t\t\tvar indices = this.index.array;\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ name ];\n\t\n\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\n\t\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\t\n\t\t\t\t\tvar index = 0, index2 = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tindex = indices[ i ] * itemSize;\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\t\n\t\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry2;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.4,\n\t\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard BufferGeometry serialization\n\t\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdata.data = { attributes: {} };\n\t\n\t\t\t\tvar index = this.index;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\t\n\t\t\t\t\tdata.data.index = {\n\t\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\t\tarray: array\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ key ];\n\t\n\t\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\t\n\t\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\t\tarray: array,\n\t\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = this.groups;\n\t\n\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingSphere = this.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== null ) {\n\t\n\t\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\t/*\n\t\t\t\t// Handle primitives\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\t\treturn geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\t\t\t*/\n\t\n\t\t\t\treturn new BufferGeometry().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tvar index = source.index;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = source.attributes;\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = source.groups;\n\t\n\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tBufferGeometry.MaxIndex = 65535;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author jonobr1 / http://jonobr1.com/\n\t\t */\n\t\n\t\tfunction Mesh( geometry, material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Mesh';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t\tthis.drawMode = TrianglesDrawMode;\n\t\n\t\t\tthis.updateMorphTargets();\n\t\n\t\t}\n\t\n\t\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Mesh,\n\t\n\t\t\tisMesh: true,\n\t\n\t\t\tsetDrawMode: function ( value ) {\n\t\n\t\t\t\tthis.drawMode = value;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.drawMode = source.drawMode;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMorphTargets: function () {\n\t\n\t\t\t\tvar morphTargets = this.geometry.morphTargets;\n\t\n\t\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\t\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\t\n\t\t\t\t\tfor ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\t\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ morphTargets[ m ].name ] = m;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\tvar vA = new Vector3();\n\t\t\t\tvar vB = new Vector3();\n\t\t\t\tvar vC = new Vector3();\n\t\n\t\t\t\tvar tempA = new Vector3();\n\t\t\t\tvar tempB = new Vector3();\n\t\t\t\tvar tempC = new Vector3();\n\t\n\t\t\t\tvar uvA = new Vector2();\n\t\t\t\tvar uvB = new Vector2();\n\t\t\t\tvar uvC = new Vector2();\n\t\n\t\t\t\tvar barycoord = new Vector3();\n\t\n\t\t\t\tvar intersectionPoint = new Vector3();\n\t\t\t\tvar intersectionPointWorld = new Vector3();\n\t\n\t\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\t\n\t\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\t\n\t\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\t\n\t\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\t\n\t\t\t\t\treturn uv1.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\t\n\t\t\t\t\tvar intersect;\n\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\tif ( material.side === BackSide ) {\n\t\n\t\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( intersect === null ) return null;\n\t\n\t\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\t\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\t\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\t\tobject: object\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\t\n\t\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\t\tvC.fromArray( positions, c * 3 );\n\t\n\t\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\t\n\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\t\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\t\tintersection.faceIndex = a;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn intersection;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar material = this.material;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t\tif ( material === undefined ) return;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\t// Check boundingBox before continuing\n\t\n\t\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar uvs, intersection;\n\t\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\tvar a, b, c;\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\t\n\t\t\t\t\t\t\tuvs = attributes.uv.array;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\t\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\t\tc = a + 2;\n\t\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\t\tvar isFaceMaterial = (material && material.isMultiMaterial);\n\t\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\t\n\t\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\t\n\t\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\t\n\t\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\t\tfvC = vertices[ face.c ];\n\t\n\t\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\t\n\t\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\t\n\t\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\t\n\t\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\t\n\t\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\t\n\t\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\t\n\t\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\t\tvC.add( fvC );\n\t\n\t\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\t\tfvC = vC;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\t\n\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\t\n\t\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'BoxBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\t// segments\n\t\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\t\n\t\t\t// these are used to calculate buffer length\n\t\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t\t// offset variables\n\t\t\tvar vertexBufferOffset = 0;\n\t\t\tvar uvBufferOffset = 0;\n\t\t\tvar indexBufferOffset = 0;\n\t\t\tvar numberOfVertices = 0;\n\t\n\t\t\t// group variables\n\t\t\tvar groupStart = 0;\n\t\n\t\t\t// build each side of the box geometry\n\t\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\t\n\t\t\t// build geometry\n\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction calculateVertexCount( w, h, d ) {\n\t\n\t\t\t\tvar vertices = 0;\n\t\n\t\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\t\n\t\t\t\treturn vertices;\n\t\n\t\t\t}\n\t\n\t\t\tfunction calculateIndexCount( w, h, d ) {\n\t\n\t\t\t\tvar index = 0;\n\t\n\t\t\t\t// calculate the amount of squares for each side\n\t\t\t\tindex += w * h * 2; // xy\n\t\t\t\tindex += w * d * 2; // xz\n\t\t\t\tindex += d * h * 2; // zy\n\t\n\t\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\t\n\t\t\t}\n\t\n\t\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\t\n\t\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\t\tvar segmentHeight = height / gridY;\n\t\n\t\t\t\tvar widthHalf = width / 2;\n\t\t\t\tvar heightHalf = height / 2;\n\t\t\t\tvar depthHalf = depth / 2;\n\t\n\t\t\t\tvar gridX1 = gridX + 1;\n\t\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\t\tvar vertexCounter = 0;\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\t\n\t\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\t\n\t\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\t\tvector[ w ] = depthHalf;\n\t\n\t\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\t\n\t\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t\t// uvs\n\t\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\t\t\t// update offsets and counters\n\t\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\t\tvertexCounter += 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// 1. you need three indices to draw a single face\n\t\t\t\t// 2. a single segment consists of two faces\n\t\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\t\n\t\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\t\t// indices\n\t\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\t\t// face one\n\t\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t\t\t// face two\n\t\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t\t\t// update offsets and counters\n\t\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t\t// update total number of vertices\n\t\t\t\tnumberOfVertices += vertexCounter;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t\t */\n\t\n\t\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'PlaneBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\n\t\t\tvar width_half = width / 2;\n\t\t\tvar height_half = height / 2;\n\t\n\t\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\t\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\tvar segment_width = width / gridX;\n\t\t\tvar segment_height = height / gridY;\n\t\n\t\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\t\n\t\t\tvar offset = 0;\n\t\t\tvar offset2 = 0;\n\t\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\tvar y = iy * segment_height - height_half;\n\t\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\tvar x = ix * segment_width - width_half;\n\t\n\t\t\t\t\tvertices[ offset ] = x;\n\t\t\t\t\tvertices[ offset + 1 ] = - y;\n\t\n\t\t\t\t\tnormals[ offset + 2 ] = 1;\n\t\n\t\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\t\toffset += 3;\n\t\t\t\t\toffset2 += 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\toffset = 0;\n\t\n\t\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\t\n\t\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\tindices[ offset ] = a;\n\t\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\t\tindices[ offset + 2 ] = d;\n\t\n\t\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\t\tindices[ offset + 5 ] = d;\n\t\n\t\t\t\t\toffset += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction Camera() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Camera';\n\t\n\t\t\tthis.matrixWorldInverse = new Matrix4();\n\t\t\tthis.projectionMatrix = new Matrix4();\n\t\n\t\t}\n\t\n\t\tCamera.prototype = Object.create( Object3D.prototype );\n\t\tCamera.prototype.constructor = Camera;\n\t\n\t\tCamera.prototype.isCamera = true;\n\t\n\t\tCamera.prototype.getWorldDirection = function () {\n\t\n\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tCamera.prototype.lookAt = function () {\n\t\n\t\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\t\n\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\tm1.lookAt( this.position, vector, this.up );\n\t\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\tCamera.prototype.clone = function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t};\n\t\n\t\tCamera.prototype.copy = function ( source ) {\n\t\n\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author greggman / http://games.greggman.com/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\t\n\t\t\tCamera.call( this );\n\t\n\t\t\tthis.type = 'PerspectiveCamera';\n\t\n\t\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\t\tthis.zoom = 1;\n\t\n\t\t\tthis.near = near !== undefined ? near : 0.1;\n\t\t\tthis.far = far !== undefined ? far : 2000;\n\t\t\tthis.focus = 10;\n\t\n\t\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\t\tthis.view = null;\n\t\n\t\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t}\n\t\n\t\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\t\n\t\t\tconstructor: PerspectiveCamera,\n\t\n\t\t\tisPerspectiveCamera: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tCamera.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.fov = source.fov;\n\t\t\t\tthis.zoom = source.zoom;\n\t\n\t\t\t\tthis.near = source.near;\n\t\t\t\tthis.far = source.far;\n\t\t\t\tthis.focus = source.focus;\n\t\n\t\t\t\tthis.aspect = source.aspect;\n\t\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\t\tthis.filmOffset = source.filmOffset;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t\t *\n\t\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t\t * a 35mm (full frame) camera.\n\t\t\t *\n\t\t\t * Values for focal length and film gauge must have the same unit.\n\t\t\t */\n\t\t\tsetFocalLength: function ( focalLength ) {\n\t\n\t\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\t\n\t\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t\t */\n\t\t\tgetFocalLength: function () {\n\t\n\t\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\t\n\t\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\t\n\t\t\t},\n\t\n\t\t\tgetEffectiveFOV: function () {\n\t\n\t\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\t\n\t\t\t},\n\t\n\t\t\tgetFilmWidth: function () {\n\t\n\t\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\t\n\t\t\t},\n\t\n\t\t\tgetFilmHeight: function () {\n\t\n\t\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t\t * multi-monitor/multi-machine setups.\n\t\t\t *\n\t\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t\t * the monitors are in grid like this\n\t\t\t *\n\t\t\t *   +---+---+---+\n\t\t\t *   | A | B | C |\n\t\t\t *   +---+---+---+\n\t\t\t *   | D | E | F |\n\t\t\t *   +---+---+---+\n\t\t\t *\n\t\t\t * then for each monitor you would call it like this\n\t\t\t *\n\t\t\t *   var w = 1920;\n\t\t\t *   var h = 1080;\n\t\t\t *   var fullWidth = w * 3;\n\t\t\t *   var fullHeight = h * 2;\n\t\t\t *\n\t\t\t *   --A--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t\t *   --B--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t\t *   --C--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t\t *   --D--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t\t *   --E--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t\t *   --F--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t\t *\n\t\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t\t */\n\t\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\t\tthis.aspect = fullWidth / fullHeight;\n\t\n\t\t\t\tthis.view = {\n\t\t\t\t\tfullWidth: fullWidth,\n\t\t\t\t\tfullHeight: fullHeight,\n\t\t\t\t\toffsetX: x,\n\t\t\t\t\toffsetY: y,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t};\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tclearViewOffset: function() {\n\t\n\t\t\t\tthis.view = null;\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\t\tvar near = this.near,\n\t\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\t\theight = 2 * top,\n\t\t\t\t\twidth = this.aspect * height,\n\t\t\t\t\tleft = - 0.5 * width,\n\t\t\t\t\tview = this.view;\n\t\n\t\t\t\tif ( view !== null ) {\n\t\n\t\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\t\tfullHeight = view.fullHeight;\n\t\n\t\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\t\theight *= view.height / fullHeight;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar skew = this.filmOffset;\n\t\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\t\n\t\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.fov = this.fov;\n\t\t\t\tdata.object.zoom = this.zoom;\n\t\n\t\t\t\tdata.object.near = this.near;\n\t\t\t\tdata.object.far = this.far;\n\t\t\t\tdata.object.focus = this.focus;\n\t\n\t\t\t\tdata.object.aspect = this.aspect;\n\t\n\t\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\t\tdata.object.filmOffset = this.filmOffset;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author arose / http://github.com/arose\n\t\t */\n\t\n\t\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\t\n\t\t\tCamera.call( this );\n\t\n\t\t\tthis.type = 'OrthographicCamera';\n\t\n\t\t\tthis.zoom = 1;\n\t\t\tthis.view = null;\n\t\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bottom;\n\t\n\t\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t}\n\t\n\t\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\t\n\t\t\tconstructor: OrthographicCamera,\n\t\n\t\t\tisOrthographicCamera: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tCamera.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.left = source.left;\n\t\t\t\tthis.right = source.right;\n\t\t\t\tthis.top = source.top;\n\t\t\t\tthis.bottom = source.bottom;\n\t\t\t\tthis.near = source.near;\n\t\t\t\tthis.far = source.far;\n\t\n\t\t\t\tthis.zoom = source.zoom;\n\t\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\t\tthis.view = {\n\t\t\t\t\tfullWidth: fullWidth,\n\t\t\t\t\tfullHeight: fullHeight,\n\t\t\t\t\toffsetX: x,\n\t\t\t\t\toffsetY: y,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t};\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tclearViewOffset: function() {\n\t\n\t\t\t\tthis.view = null;\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\t\n\t\t\t\tvar left = cx - dx;\n\t\t\t\tvar right = cx + dx;\n\t\t\t\tvar top = cy + dy;\n\t\t\t\tvar bottom = cy - dy;\n\t\n\t\t\t\tif ( this.view !== null ) {\n\t\n\t\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\t\n\t\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.zoom = this.zoom;\n\t\t\t\tdata.object.left = this.left;\n\t\t\t\tdata.object.right = this.right;\n\t\t\t\tdata.object.top = this.top;\n\t\t\t\tdata.object.bottom = this.bottom;\n\t\t\t\tdata.object.near = this.near;\n\t\t\t\tdata.object.far = this.far;\n\t\n\t\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\t\n\t\t\tvar mode;\n\t\n\t\t\tfunction setMode( value ) {\n\t\n\t\t\t\tmode = value;\n\t\n\t\t\t}\n\t\n\t\t\tvar type, size;\n\t\n\t\t\tfunction setIndex( index ) {\n\t\n\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t\t\tsize = 4;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\t\tsize = 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction render( start, count ) {\n\t\n\t\t\t\tgl.drawElements( mode, count, type, start * size );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderInstances( geometry, start, count ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tsetMode: setMode,\n\t\t\t\tsetIndex: setIndex,\n\t\t\t\trender: render,\n\t\t\t\trenderInstances: renderInstances\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\t\n\t\t\tvar mode;\n\t\n\t\t\tfunction setMode( value ) {\n\t\n\t\t\t\tmode = value;\n\t\n\t\t\t}\n\t\n\t\t\tfunction render( start, count ) {\n\t\n\t\t\t\tgl.drawArrays( mode, start, count );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderInstances( geometry ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar position = geometry.attributes.position;\n\t\n\t\t\t\tvar count = 0;\n\t\n\t\t\t\tif ( (position && position.isInterleavedBufferAttribute) ) {\n\t\n\t\t\t\t\tcount = position.data.count;\n\t\n\t\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tcount = position.count;\n\t\n\t\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tsetMode: setMode,\n\t\t\t\trender: render,\n\t\t\t\trenderInstances: renderInstances\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLLights() {\n\t\n\t\t\tvar lights = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( light ) {\n\t\n\t\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn lights[ light.id ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar uniforms;\n\t\n\t\t\t\t\tswitch ( light.type ) {\n\t\n\t\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlights[ light.id ] = uniforms;\n\t\n\t\t\t\t\treturn uniforms;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction addLineNumbers( string ) {\n\t\n\t\t\tvar lines = string.split( '\\n' );\n\t\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\t\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn lines.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction WebGLShader( gl, type, string ) {\n\t\n\t\t\tvar shader = gl.createShader( type );\n\t\n\t\t\tgl.shaderSource( shader, string );\n\t\t\tgl.compileShader( shader );\n\t\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\t\n\t\t\t}\n\t\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\t\n\t\t\t}\n\t\n\t\t\t// --enable-privileged-webgl-extension\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\t\n\t\t\treturn shader;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar programIdCount = 0;\n\t\n\t\tfunction getEncodingComponents( encoding ) {\n\t\n\t\t\tswitch ( encoding ) {\n\t\n\t\t\t\tcase LinearEncoding:\n\t\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\t\tcase sRGBEncoding:\n\t\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\t\tcase RGBEEncoding:\n\t\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\t\tcase RGBM7Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\t\tcase RGBM16Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\t\tcase RGBDEncoding:\n\t\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\t\tcase GammaEncoding:\n\t\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\t\n\t\t\tvar toneMappingName;\n\t\n\t\t\tswitch ( toneMapping ) {\n\t\n\t\t\t\tcase LinearToneMapping:\n\t\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase ReinhardToneMapping:\n\t\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase CineonToneMapping:\n\t\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\t\n\t\t\t}\n\t\n\t\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\t\n\t\t}\n\t\n\t\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\t\n\t\t\textensions = extensions || {};\n\t\n\t\t\tvar chunks = [\n\t\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t\t];\n\t\n\t\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction generateDefines( defines ) {\n\t\n\t\t\tvar chunks = [];\n\t\n\t\t\tfor ( var name in defines ) {\n\t\n\t\t\t\tvar value = defines[ name ];\n\t\n\t\t\t\tif ( value === false ) continue;\n\t\n\t\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\t\n\t\t\t}\n\t\n\t\t\treturn chunks.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\t\n\t\t\tvar attributes = {};\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\t\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\n\t\n\t\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\t\tvar name = info.name;\n\t\n\t\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\t\n\t\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\t\n\t\t\t}\n\t\n\t\t\treturn attributes;\n\t\n\t\t}\n\t\n\t\tfunction filterEmptyLine( string ) {\n\t\n\t\t\treturn string !== '';\n\t\n\t\t}\n\t\n\t\tfunction replaceLightNums( string, parameters ) {\n\t\n\t\t\treturn string\n\t\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\t\n\t\t}\n\t\n\t\tfunction parseIncludes( string ) {\n\t\n\t\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\t\n\t\t\tfunction replace( match, include ) {\n\t\n\t\t\t\tvar replace = ShaderChunk[ include ];\n\t\n\t\t\t\tif ( replace === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn parseIncludes( replace );\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction unrollLoops( string ) {\n\t\n\t\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\t\n\t\t\tfunction replace( match, start, end, snippet ) {\n\t\n\t\t\t\tvar unroll = '';\n\t\n\t\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\t\n\t\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn unroll;\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction WebGLProgram( renderer, code, material, parameters ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\n\t\t\tvar extensions = material.extensions;\n\t\t\tvar defines = material.defines;\n\t\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\t\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\t\n\t\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\t\n\t\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\t\n\t\t\t}\n\t\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\n\t\t\tif ( parameters.envMap ) {\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.combine ) {\n\t\n\t\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase MixOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase AddOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\t\n\t\t\t// console.log( 'building new program ' );\n\t\n\t\t\t//\n\t\n\t\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\t\n\t\t\tvar customDefines = generateDefines( defines );\n\t\n\t\t\t//\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar prefixVertex, prefixFragment;\n\t\n\t\t\tif ( material.isRawShaderMaterial ) {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\t\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t'attribute vec3 position;',\n\t\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'#ifdef USE_COLOR',\n\t\n\t\t\t\t\t'\tattribute vec3 color;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\t\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\n\t\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\t\n\t\t\t\t\t'\t#else',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\t\n\t\t\t\t\t'\t#endif',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_SKINNING',\n\t\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\t\t\t\t'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\t\n\t\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\t\n\t\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\t\n\t\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t}\n\t\n\t\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\t\n\t\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\t\n\t\t\tif ( ! material.isShaderMaterial ) {\n\t\n\t\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\t\n\t\t\t}\n\t\n\t\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\t\n\t\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\t\n\t\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\t\n\t\t\tgl.attachShader( program, glVertexShader );\n\t\t\tgl.attachShader( program, glFragmentShader );\n\t\n\t\t\t// Force a particular attribute to index 0.\n\t\n\t\t\tif ( material.index0AttributeName !== undefined ) {\n\t\n\t\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\t\n\t\t\t} else if ( parameters.morphTargets === true ) {\n\t\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\t\n\t\t\t}\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\t\n\t\t\tvar runnable = true;\n\t\t\tvar haveDiagnostics = true;\n\t\n\t\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\t\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\t\n\t\t\t\trunnable = false;\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\t\n\t\t\t} else if ( programLog !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\t\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\t\n\t\t\t\thaveDiagnostics = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( haveDiagnostics ) {\n\t\n\t\t\t\tthis.diagnostics = {\n\t\n\t\t\t\t\trunnable: runnable,\n\t\t\t\t\tmaterial: material,\n\t\n\t\t\t\t\tprogramLog: programLog,\n\t\n\t\t\t\t\tvertexShader: {\n\t\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfragmentShader: {\n\t\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t// clean up\n\t\n\t\t\tgl.deleteShader( glVertexShader );\n\t\t\tgl.deleteShader( glFragmentShader );\n\t\n\t\t\t// set up caching for uniform locations\n\t\n\t\t\tvar cachedUniforms;\n\t\n\t\t\tthis.getUniforms = function() {\n\t\n\t\t\t\tif ( cachedUniforms === undefined ) {\n\t\n\t\t\t\t\tcachedUniforms =\n\t\t\t\t\t\t\tnew WebGLUniforms( gl, program, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedUniforms;\n\t\n\t\t\t};\n\t\n\t\t\t// set up caching for attribute locations\n\t\n\t\t\tvar cachedAttributes;\n\t\n\t\t\tthis.getAttributes = function() {\n\t\n\t\t\t\tif ( cachedAttributes === undefined ) {\n\t\n\t\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedAttributes;\n\t\n\t\t\t};\n\t\n\t\t\t// free resource\n\t\n\t\t\tthis.destroy = function() {\n\t\n\t\t\t\tgl.deleteProgram( program );\n\t\t\t\tthis.program = undefined;\n\t\n\t\t\t};\n\t\n\t\t\t// DEPRECATED\n\t\n\t\t\tObject.defineProperties( this, {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\t\treturn this.getUniforms();\n\t\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tattributes: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\t\treturn this.getAttributes();\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\n\t\t\t//\n\t\n\t\t\tthis.id = programIdCount ++;\n\t\t\tthis.code = code;\n\t\t\tthis.usedTimes = 1;\n\t\t\tthis.program = program;\n\t\t\tthis.vertexShader = glVertexShader;\n\t\t\tthis.fragmentShader = glFragmentShader;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLPrograms( renderer, capabilities ) {\n\t\n\t\t\tvar programs = [];\n\t\n\t\t\tvar shaderIDs = {\n\t\t\t\tMeshDepthMaterial: 'depth',\n\t\t\t\tMeshNormalMaterial: 'normal',\n\t\t\t\tMeshBasicMaterial: 'basic',\n\t\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\t\tMeshPhongMaterial: 'phong',\n\t\t\t\tMeshStandardMaterial: 'physical',\n\t\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\t\tLineBasicMaterial: 'basic',\n\t\t\t\tLineDashedMaterial: 'dashed',\n\t\t\t\tPointsMaterial: 'points'\n\t\t\t};\n\t\n\t\t\tvar parameterNames = [\n\t\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\"\n\t\t\t];\n\t\n\t\n\t\t\tfunction allocateBones( object ) {\n\t\n\t\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\t\n\t\t\t\t\treturn 1024;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// default for when object is not specified\n\t\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t\t//\n\t\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t\t//    (up to 54 should be safe)\n\t\n\t\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\t\n\t\t\t\t\tvar maxBones = nVertexMatrices;\n\t\n\t\t\t\t\tif ( object !== undefined && (object && object.isSkinnedMesh) ) {\n\t\n\t\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\t\n\t\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn maxBones;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\t\n\t\t\t\tvar encoding;\n\t\n\t\t\t\tif ( ! map ) {\n\t\n\t\t\t\t\tencoding = LinearEncoding;\n\t\n\t\t\t\t} else if ( (map && map.isTexture) ) {\n\t\n\t\t\t\t\tencoding = map.encoding;\n\t\n\t\t\t\t} else if ( (map && map.isWebGLRenderTarget) ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\tencoding = map.texture.encoding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\t\n\t\t\t\t\tencoding = GammaEncoding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn encoding;\n\t\n\t\t\t}\n\t\n\t\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {\n\t\n\t\t\t\tvar shaderID = shaderIDs[ material.type ];\n\t\n\t\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t\t// (not to blow over maxLights budget)\n\t\n\t\t\t\tvar maxBones = allocateBones( object );\n\t\t\t\tvar precision = renderer.getPrecision();\n\t\n\t\t\t\tif ( material.precision !== null ) {\n\t\n\t\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\t\n\t\t\t\t\tif ( precision !== material.precision ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\t\n\t\t\t\tvar parameters = {\n\t\n\t\t\t\t\tshaderID: shaderID,\n\t\n\t\t\t\t\tprecision: precision,\n\t\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\t\tmap: !! material.map,\n\t\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\t\talphaMap: !! material.alphaMap,\n\t\n\t\t\t\t\tcombine: material.combine,\n\t\n\t\t\t\t\tvertexColors: material.vertexColors,\n\t\n\t\t\t\t\tfog: !! fog,\n\t\t\t\t\tuseFog: material.fog,\n\t\t\t\t\tfogExp: (fog && fog.isFogExp2),\n\t\n\t\t\t\t\tflatShading: material.shading === FlatShading,\n\t\n\t\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\t\n\t\t\t\t\tskinning: material.skinning,\n\t\t\t\t\tmaxBones: maxBones,\n\t\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\t\n\t\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\t\n\t\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\t\tnumHemiLights: lights.hemi.length,\n\t\n\t\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\t\tnumClipIntersection: nClipIntersection,\n\t\n\t\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\t\n\t\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\t\n\t\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\t\n\t\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\t\tflipSided: material.side === BackSide,\n\t\n\t\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\t\n\t\t\t\t};\n\t\n\t\t\t\treturn parameters;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getProgramCode = function ( material, parameters ) {\n\t\n\t\t\t\tvar array = [];\n\t\n\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\tarray.push( parameters.shaderID );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\t\tarray.push( material.vertexShader );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.defines !== undefined ) {\n\t\n\t\t\t\t\tfor ( var name in material.defines ) {\n\t\n\t\t\t\t\t\tarray.push( name );\n\t\t\t\t\t\tarray.push( material.defines[ name ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\t\n\t\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array.join();\n\t\n\t\t\t};\n\t\n\t\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\t\n\t\t\t\tvar program;\n\t\n\t\t\t\t// Check if code has been already compiled\n\t\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\t\n\t\t\t\t\tvar programInfo = programs[ p ];\n\t\n\t\t\t\t\tif ( programInfo.code === code ) {\n\t\n\t\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t\t++ program.usedTimes;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tprogram = new WebGLProgram( renderer, code, material, parameters );\n\t\t\t\t\tprograms.push( program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t};\n\t\n\t\t\tthis.releaseProgram = function( program ) {\n\t\n\t\t\t\tif ( -- program.usedTimes === 0 ) {\n\t\n\t\t\t\t\t// Remove from unordered set\n\t\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\t\tprograms.pop();\n\t\n\t\t\t\t\t// Free WebGL resources\n\t\t\t\t\tprogram.destroy();\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\t\tthis.programs = programs;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLGeometries( gl, properties, info ) {\n\t\n\t\t\tvar geometries = {};\n\t\n\t\t\tfunction onGeometryDispose( event ) {\n\t\n\t\t\t\tvar geometry = event.target;\n\t\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\t\n\t\t\t\tif ( buffergeometry.index !== null ) {\n\t\n\t\t\t\t\tdeleteAttribute( buffergeometry.index );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdeleteAttributes( buffergeometry.attributes );\n\t\n\t\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\t\tdelete geometries[ geometry.id ];\n\t\n\t\t\t\t// TODO\n\t\n\t\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\t\tif ( property.wireframe ) {\n\t\n\t\t\t\t\tdeleteAttribute( property.wireframe );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.delete( geometry );\n\t\n\t\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\t\n\t\t\t\tif ( bufferproperty.wireframe ) {\n\t\n\t\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.delete( buffergeometry );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinfo.memory.geometries --;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\tfunction deleteAttribute( attribute ) {\n\t\n\t\t\t\tvar buffer = getAttributeBuffer( attribute );\n\t\n\t\t\t\tif ( buffer !== undefined ) {\n\t\n\t\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\t\tremoveAttributeBuffer( attribute );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction deleteAttributes( attributes ) {\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tdeleteAttribute( attributes[ name ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction removeAttributeBuffer( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\tproperties.delete( attribute.data );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tproperties.delete( attribute );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( object ) {\n\t\n\t\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn geometries[ geometry.id ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\t\t\tvar buffergeometry;\n\t\n\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\tbuffergeometry = geometry;\n\t\n\t\t\t\t\t} else if ( geometry.isGeometry ) {\n\t\n\t\t\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\t\n\t\t\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\t\n\t\t\t\t\tinfo.memory.geometries ++;\n\t\n\t\t\t\t\treturn buffergeometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLObjects( gl, properties, info ) {\n\t\n\t\t\tvar geometries = new WebGLGeometries( gl, properties, info );\n\t\n\t\t\t//\n\t\n\t\t\tfunction update( object ) {\n\t\n\t\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\t\n\t\t\t\tvar geometry = geometries.get( object );\n\t\n\t\t\t\tif ( object.geometry.isGeometry ) {\n\t\n\t\t\t\t\tgeometry.updateFromObject( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph targets\n\t\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\t\tfor ( var name in morphAttributes ) {\n\t\n\t\t\t\t\tvar array = morphAttributes[ name ];\n\t\n\t\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateAttribute( attribute, bufferType ) {\n\t\n\t\t\t\tvar data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;\n\t\n\t\t\t\tvar attributeProperties = properties.get( data );\n\t\n\t\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\t\n\t\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\t\n\t\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\t\n\t\t\t\tgl.bufferData( bufferType, data.array, usage );\n\t\n\t\t\t\tattributeProperties.version = data.version;\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\t\tif ( data.dynamic === false ) {\n\t\n\t\t\t\t\tgl.bufferData( bufferType, data.array, gl.STATIC_DRAW );\n\t\n\t\t\t\t} else if ( data.updateRange.count === - 1 ) {\n\t\n\t\t\t\t\t// Not using update ranges\n\t\n\t\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\t\n\t\t\t\t} else if ( data.updateRange.count === 0 ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\t\n\t\t\t\t\tdata.updateRange.count = 0; // reset range\n\t\n\t\t\t\t}\n\t\n\t\t\t\tattributeProperties.version = data.version;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getWireframeAttribute( geometry ) {\n\t\n\t\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\t\tif ( property.wireframe !== undefined ) {\n\t\n\t\t\t\t\treturn property.wireframe;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar indices = [];\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar position = attributes.position;\n\t\n\t\t\t\t// console.time( 'wireframe' );\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tvar edges = {};\n\t\t\t\t\tvar array = index.array;\n\t\n\t\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\t\tvar c = array[ i + 2 ];\n\t\n\t\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar array = attributes.position.array;\n\t\n\t\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\t\tvar c = i + 2;\n\t\n\t\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// console.timeEnd( 'wireframe' );\n\t\n\t\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar attribute = new BufferAttribute( new TypeArray( indices ), 1 );\n\t\n\t\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t\tproperty.wireframe = attribute;\n\t\n\t\t\t\treturn attribute;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tgetAttributeBuffer: getAttributeBuffer,\n\t\t\t\tgetWireframeAttribute: getWireframeAttribute,\n\t\n\t\t\t\tupdate: update\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\t\n\t\t\tvar _infoMemory = info.memory;\n\t\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\t\n\t\t\t//\n\t\n\t\t\tfunction clampToMaxSize( image, maxSize ) {\n\t\n\t\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\t\n\t\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t\t// premultiplied alpha.\n\t\n\t\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\t\n\t\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\t\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\t\treturn canvas;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t}\n\t\n\t\t\tfunction isPowerOfTwo( image ) {\n\t\n\t\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\t\n\t\t\t}\n\t\n\t\t\tfunction makePowerOfTwo( image ) {\n\t\n\t\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\t\n\t\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = _Math.nearestPowerOfTwo( image.width );\n\t\t\t\t\tcanvas.height = _Math.nearestPowerOfTwo( image.height );\n\t\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\t\treturn canvas;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t}\n\t\n\t\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\t\n\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;\n\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\t// Fallback filters for non-power-of-2 textures\n\t\n\t\t\tfunction filterFallback( f ) {\n\t\n\t\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\t\n\t\t\t\t\treturn _gl.NEAREST;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn _gl.LINEAR;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction onTextureDispose( event ) {\n\t\n\t\t\t\tvar texture = event.target;\n\t\n\t\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\tdeallocateTexture( texture );\n\t\n\t\t\t\t_infoMemory.textures --;\n\t\n\t\n\t\t\t}\n\t\n\t\t\tfunction onRenderTargetDispose( event ) {\n\t\n\t\t\t\tvar renderTarget = event.target;\n\t\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\t\tdeallocateRenderTarget( renderTarget );\n\t\n\t\t\t\t_infoMemory.textures --;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction deallocateTexture( texture ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t// cube texture\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// 2D texture\n\t\n\t\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// remove all webgl properties\n\t\t\t\tproperties.delete( texture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction deallocateRenderTarget( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\t\tif ( ! renderTarget ) return;\n\t\n\t\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\t\trenderTarget.depthTexture.dispose();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.delete( renderTarget.texture );\n\t\t\t\tproperties.delete( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\n\t\n\t\t\tfunction setTexture2D( texture, slot ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\tvar image = texture.image;\n\t\n\t\t\t\t\tif ( image === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\t\n\t\t\t\t\t} else if ( image.complete === false ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureCube( texture, slot ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.image.length === 6 ) {\n\t\n\t\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\t\n\t\t\t\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\n\t\t\t\t\t\tvar isCompressed = (texture && texture.isCompressedTexture);\n\t\t\t\t\t\tvar isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);\n\t\n\t\t\t\t\t\tvar cubeImage = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( ! isCompressed ) {\n\t\n\t\t\t\t\t\t\t\tif ( isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\t\n\t\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\n\t\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\n\t\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\t\n\t\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\t\tif ( extension ) {\n\t\n\t\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\t\n\t\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\t\n\t\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\t\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\t\n\t\t\t\t\ttextureProperties.__webglInit = true;\n\t\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\n\t\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\t\n\t\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\t\n\t\t\t\t\timage = makePowerOfTwo( image );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\t\n\t\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\t\n\t\t\t\tif ( (texture && texture.isDepthTexture) ) {\n\t\n\t\t\t\t\t// populate depth texture with dummy data\n\t\n\t\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\t\n\t\t\t\t\tif ( texture.type === FloatType ) {\n\t\n\t\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\n\t\t\t\t\t} else if ( _isWebGL2 ) {\n\t\n\t\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\t\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\t\n\t\t\t\t} else if ( (texture && texture.isDataTexture) ) {\n\t\n\t\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (texture && texture.isCompressedTexture) ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\t\n\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// regular Texture (image, video, canvas)\n\t\n\t\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\n\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t}\n\t\n\t\t\t// Render targets\n\t\n\t\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\t\n\t\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\t\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\t\n\t\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\tif ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {\n\t\n\t\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t\t}\n\t\n\t\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\t\n\t\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\n\t\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\t\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\t\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthrow new Error('Unknown depthTexture format')\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Setup GL resources for a non-texture depth buffer\n\t\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\n\t\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\t\n\t\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Set up GL resources for the render target\n\t\t\tfunction setupRenderTarget( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\t\n\t\t\t\t// Setup framebuffer\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Setup color buffer\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\t\n\t\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Setup depth and stencil buffers\n\t\n\t\t\t\tif ( renderTarget.depthBuffer ) {\n\t\n\t\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\t\n\t\t\t\tvar texture = renderTarget.texture;\n\t\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\t\ttexture.minFilter !== NearestFilter &&\n\t\t\t\t\t\ttexture.minFilter !== LinearFilter ) {\n\t\n\t\t\t\t\tvar target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\t\n\t\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\t\tstate.bindTexture( target, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setTexture2D = setTexture2D;\n\t\t\tthis.setTextureCube = setTextureCube;\n\t\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author fordacious / fordacious.github.io\n\t\t */\n\t\n\t\tfunction WebGLProperties() {\n\t\n\t\t\tvar properties = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( object ) {\n\t\n\t\t\t\t\tvar uuid = object.uuid;\n\t\t\t\t\tvar map = properties[ uuid ];\n\t\n\t\t\t\t\tif ( map === undefined ) {\n\t\n\t\t\t\t\t\tmap = {};\n\t\t\t\t\t\tproperties[ uuid ] = map;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn map;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tdelete: function ( object ) {\n\t\n\t\t\t\t\tdelete properties[ object.uuid ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tclear: function () {\n\t\n\t\t\t\t\tproperties = {};\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLState( gl, extensions, paramThreeToGL ) {\n\t\n\t\t\tfunction ColorBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar color = new Vector4();\n\t\t\t\tvar currentColorMask = null;\n\t\t\t\tvar currentColorClear = new Vector4();\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetMask: function ( colorMask ) {\n\t\n\t\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\t\tcurrentColorMask = colorMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( r, g, b, a ) {\n\t\n\t\t\t\t\t\tcolor.set( r, g, b, a );\n\t\n\t\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\t\n\t\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\t\tcurrentColorClear.copy( color );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\t\tcurrentColorClear.set( 0, 0, 0, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction DepthBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar currentDepthMask = null;\n\t\t\t\tvar currentDepthFunc = null;\n\t\t\t\tvar currentDepthClear = null;\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetTest: function ( depthTest ) {\n\t\n\t\t\t\t\t\tif ( depthTest ) {\n\t\n\t\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetMask: function ( depthMask ) {\n\t\n\t\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetFunc: function ( depthFunc ) {\n\t\n\t\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\t\n\t\t\t\t\t\t\tif ( depthFunc ) {\n\t\n\t\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\t\n\t\t\t\t\t\t\t\t\tcase NeverDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase LessDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase EqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase GreaterDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( depth ) {\n\t\n\t\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\t\n\t\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\t\tcurrentDepthClear = depth;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\t\tcurrentDepthClear = null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction StencilBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar currentStencilMask = null;\n\t\t\t\tvar currentStencilFunc = null;\n\t\t\t\tvar currentStencilRef = null;\n\t\t\t\tvar currentStencilFuncMask = null;\n\t\t\t\tvar currentStencilFail  = null;\n\t\t\t\tvar currentStencilZFail = null;\n\t\t\t\tvar currentStencilZPass = null;\n\t\t\t\tvar currentStencilClear = null;\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetTest: function ( stencilTest ) {\n\t\n\t\t\t\t\t\tif ( stencilTest ) {\n\t\n\t\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetMask: function ( stencilMask ) {\n\t\n\t\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\t\n\t\t\t\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\t\n\t\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\t\n\t\t\t\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\t\n\t\t\t\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( stencil ) {\n\t\n\t\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\t\n\t\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\t\tcurrentStencilClear = stencil;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\t\tcurrentStencilClear = null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar colorBuffer = new ColorBuffer();\n\t\t\tvar depthBuffer = new DepthBuffer();\n\t\t\tvar stencilBuffer = new StencilBuffer();\n\t\n\t\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\t\n\t\t\tvar capabilities = {};\n\t\n\t\t\tvar compressedTextureFormats = null;\n\t\n\t\t\tvar currentBlending = null;\n\t\t\tvar currentBlendEquation = null;\n\t\t\tvar currentBlendSrc = null;\n\t\t\tvar currentBlendDst = null;\n\t\t\tvar currentBlendEquationAlpha = null;\n\t\t\tvar currentBlendSrcAlpha = null;\n\t\t\tvar currentBlendDstAlpha = null;\n\t\t\tvar currentPremultipledAlpha = false;\n\t\n\t\t\tvar currentFlipSided = null;\n\t\t\tvar currentCullFace = null;\n\t\n\t\t\tvar currentLineWidth = null;\n\t\n\t\t\tvar currentPolygonOffsetFactor = null;\n\t\t\tvar currentPolygonOffsetUnits = null;\n\t\n\t\t\tvar currentScissorTest = null;\n\t\n\t\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\n\t\t\tvar currentTextureSlot = null;\n\t\t\tvar currentBoundTextures = {};\n\t\n\t\t\tvar currentScissor = new Vector4();\n\t\t\tvar currentViewport = new Vector4();\n\t\n\t\t\tfunction createTexture( type, target, count ) {\n\t\n\t\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\t\tvar texture = gl.createTexture();\n\t\n\t\t\t\tgl.bindTexture( type, texture );\n\t\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\n\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\t\n\t\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t}\n\t\n\t\t\tvar emptyTextures = {};\n\t\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\t\n\t\t\t//\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tclearColor( 0, 0, 0, 1 );\n\t\t\t\tclearDepth( 1 );\n\t\t\t\tclearStencil( 0 );\n\t\n\t\t\t\tenable( gl.DEPTH_TEST );\n\t\t\t\tsetDepthFunc( LessEqualDepth );\n\t\n\t\t\t\tsetFlipSided( false );\n\t\t\t\tsetCullFace( CullFaceBack );\n\t\t\t\tenable( gl.CULL_FACE );\n\t\n\t\t\t\tenable( gl.BLEND );\n\t\t\t\tsetBlending( NormalBlending );\n\t\n\t\t\t}\n\t\n\t\t\tfunction initAttributes() {\n\t\n\t\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tnewAttributes[ i ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enableAttribute( attribute ) {\n\t\n\t\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\t\n\t\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\t\tattributeDivisors[ attribute ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {\n\t\n\t\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\t\n\t\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction disableUnusedAttributes() {\n\t\n\t\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\t\n\t\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\t\n\t\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enable( id ) {\n\t\n\t\t\t\tif ( capabilities[ id ] !== true ) {\n\t\n\t\t\t\t\tgl.enable( id );\n\t\t\t\t\tcapabilities[ id ] = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction disable( id ) {\n\t\n\t\t\t\tif ( capabilities[ id ] !== false ) {\n\t\n\t\t\t\t\tgl.disable( id );\n\t\t\t\t\tcapabilities[ id ] = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getCompressedTextureFormats() {\n\t\n\t\t\t\tif ( compressedTextureFormats === null ) {\n\t\n\t\t\t\t\tcompressedTextureFormats = [];\n\t\n\t\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\t\n\t\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn compressedTextureFormats;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\t\n\t\t\t\tif ( blending !== NoBlending ) {\n\t\n\t\t\t\t\tenable( gl.BLEND );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.BLEND );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\t\n\t\t\t\t\tif ( blending === AdditiveBlending ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( blending === SubtractiveBlending ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( blending === MultiplyBlending ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentBlending = blending;\n\t\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( blending === CustomBlending ) {\n\t\n\t\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\t\n\t\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\t\n\t\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\t\n\t\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\t\tcurrentBlendDst = null;\n\t\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\t\tcurrentBlendDstAlpha = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// TODO Deprecate\n\t\n\t\t\tfunction setColorWrite( colorWrite ) {\n\t\n\t\t\t\tcolorBuffer.setMask( colorWrite );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDepthTest( depthTest ) {\n\t\n\t\t\t\tdepthBuffer.setTest( depthTest );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDepthWrite( depthWrite ) {\n\t\n\t\t\t\tdepthBuffer.setMask( depthWrite );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDepthFunc( depthFunc ) {\n\t\n\t\t\t\tdepthBuffer.setFunc( depthFunc );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilTest( stencilTest ) {\n\t\n\t\t\t\tstencilBuffer.setTest( stencilTest );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilWrite( stencilWrite ) {\n\t\n\t\t\t\tstencilBuffer.setMask( stencilWrite );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\t\tstencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\t\tstencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction setFlipSided( flipSided ) {\n\t\n\t\t\t\tif ( currentFlipSided !== flipSided ) {\n\t\n\t\t\t\t\tif ( flipSided ) {\n\t\n\t\t\t\t\t\tgl.frontFace( gl.CW );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.frontFace( gl.CCW );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentFlipSided = flipSided;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setCullFace( cullFace ) {\n\t\n\t\t\t\tif ( cullFace !== CullFaceNone ) {\n\t\n\t\t\t\t\tenable( gl.CULL_FACE );\n\t\n\t\t\t\t\tif ( cullFace !== currentCullFace ) {\n\t\n\t\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\t\n\t\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.CULL_FACE );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentCullFace = cullFace;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setLineWidth( width ) {\n\t\n\t\t\t\tif ( width !== currentLineWidth ) {\n\t\n\t\t\t\t\tgl.lineWidth( width );\n\t\n\t\t\t\t\tcurrentLineWidth = width;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\t\n\t\t\t\tif ( polygonOffset ) {\n\t\n\t\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\t\n\t\t\t\t\t\tgl.polygonOffset( factor, units );\n\t\n\t\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getScissorTest() {\n\t\n\t\t\t\treturn currentScissorTest;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setScissorTest( scissorTest ) {\n\t\n\t\t\t\tcurrentScissorTest = scissorTest;\n\t\n\t\t\t\tif ( scissorTest ) {\n\t\n\t\t\t\t\tenable( gl.SCISSOR_TEST );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.SCISSOR_TEST );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// texture\n\t\n\t\t\tfunction activeTexture( webglSlot ) {\n\t\n\t\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\t\n\t\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\t\n\t\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\t\tcurrentTextureSlot = webglSlot;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction bindTexture( webglType, webglTexture ) {\n\t\n\t\t\t\tif ( currentTextureSlot === null ) {\n\t\n\t\t\t\t\tactiveTexture();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\t\n\t\t\t\tif ( boundTexture === undefined ) {\n\t\n\t\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\t\n\t\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\t\n\t\t\t\t\tboundTexture.type = webglType;\n\t\t\t\t\tboundTexture.texture = webglTexture;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction compressedTexImage2D() {\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\t\n\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\tconsole.error( error );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction texImage2D() {\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\t\n\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\tconsole.error( error );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// TODO Deprecate\n\t\n\t\t\tfunction clearColor( r, g, b, a ) {\n\t\n\t\t\t\tcolorBuffer.setClear( r, g, b, a );\n\t\n\t\t\t}\n\t\n\t\t\tfunction clearDepth( depth ) {\n\t\n\t\t\t\tdepthBuffer.setClear( depth );\n\t\n\t\t\t}\n\t\n\t\t\tfunction clearStencil( stencil ) {\n\t\n\t\t\t\tstencilBuffer.setClear( stencil );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction scissor( scissor ) {\n\t\n\t\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\t\n\t\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\t\tcurrentScissor.copy( scissor );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction viewport( viewport ) {\n\t\n\t\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\t\n\t\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\t\tcurrentViewport.copy( viewport );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction reset() {\n\t\n\t\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\t\n\t\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\t\n\t\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcapabilities = {};\n\t\n\t\t\t\tcompressedTextureFormats = null;\n\t\n\t\t\t\tcurrentTextureSlot = null;\n\t\t\t\tcurrentBoundTextures = {};\n\t\n\t\t\t\tcurrentBlending = null;\n\t\n\t\t\t\tcurrentFlipSided = null;\n\t\t\t\tcurrentCullFace = null;\n\t\n\t\t\t\tcolorBuffer.reset();\n\t\t\t\tdepthBuffer.reset();\n\t\t\t\tstencilBuffer.reset();\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tbuffers: {\n\t\t\t\t\tcolor: colorBuffer,\n\t\t\t\t\tdepth: depthBuffer,\n\t\t\t\t\tstencil: stencilBuffer\n\t\t\t\t},\n\t\n\t\t\t\tinit: init,\n\t\t\t\tinitAttributes: initAttributes,\n\t\t\t\tenableAttribute: enableAttribute,\n\t\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\t\tenable: enable,\n\t\t\t\tdisable: disable,\n\t\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\t\n\t\t\t\tsetBlending: setBlending,\n\t\n\t\t\t\tsetColorWrite: setColorWrite,\n\t\t\t\tsetDepthTest: setDepthTest,\n\t\t\t\tsetDepthWrite: setDepthWrite,\n\t\t\t\tsetDepthFunc: setDepthFunc,\n\t\t\t\tsetStencilTest: setStencilTest,\n\t\t\t\tsetStencilWrite: setStencilWrite,\n\t\t\t\tsetStencilFunc: setStencilFunc,\n\t\t\t\tsetStencilOp: setStencilOp,\n\t\n\t\t\t\tsetFlipSided: setFlipSided,\n\t\t\t\tsetCullFace: setCullFace,\n\t\n\t\t\t\tsetLineWidth: setLineWidth,\n\t\t\t\tsetPolygonOffset: setPolygonOffset,\n\t\n\t\t\t\tgetScissorTest: getScissorTest,\n\t\t\t\tsetScissorTest: setScissorTest,\n\t\n\t\t\t\tactiveTexture: activeTexture,\n\t\t\t\tbindTexture: bindTexture,\n\t\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\t\ttexImage2D: texImage2D,\n\t\n\t\t\t\tclearColor: clearColor,\n\t\t\t\tclearDepth: clearDepth,\n\t\t\t\tclearStencil: clearStencil,\n\t\n\t\t\t\tscissor: scissor,\n\t\t\t\tviewport: viewport,\n\t\n\t\t\t\treset: reset\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\t\n\t\t\tvar maxAnisotropy;\n\t\n\t\t\tfunction getMaxAnisotropy() {\n\t\n\t\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\t\n\t\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmaxAnisotropy = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn maxAnisotropy;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getMaxPrecision( precision ) {\n\t\n\t\t\t\tif ( precision === 'highp' ) {\n\t\n\t\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\t\treturn 'highp';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprecision = 'mediump';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( precision === 'mediump' ) {\n\t\n\t\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\t\treturn 'mediump';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn 'lowp';\n\t\n\t\t\t}\n\t\n\t\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\t\tvar maxPrecision = getMaxPrecision( precision );\n\t\n\t\t\tif ( maxPrecision !== precision ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\t\tprecision = maxPrecision;\n\t\n\t\t\t}\n\t\n\t\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );\n\t\n\t\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\t\n\t\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\t\n\t\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\t\n\t\t\treturn {\n\t\n\t\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\t\tgetMaxPrecision: getMaxPrecision,\n\t\n\t\t\t\tprecision: precision,\n\t\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\n\t\t\t\tmaxTextures: maxTextures,\n\t\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\t\tmaxCubemapSize: maxCubemapSize,\n\t\n\t\t\t\tmaxAttributes: maxAttributes,\n\t\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\t\tmaxVaryings: maxVaryings,\n\t\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\t\n\t\t\t\tvertexTextures: vertexTextures,\n\t\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\t\tfloatVertexTextures: floatVertexTextures\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLExtensions( gl ) {\n\t\n\t\t\tvar extensions = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( name ) {\n\t\n\t\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn extensions[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar extension;\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\textension = gl.getExtension( name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\textensions[ name ] = extension;\n\t\n\t\t\t\t\treturn extension;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction WebGLClipping() {\n\t\n\t\t\tvar scope = this,\n\t\n\t\t\t\tglobalState = null,\n\t\t\t\tnumGlobalPlanes = 0,\n\t\t\t\tlocalClippingEnabled = false,\n\t\t\t\trenderingShadows = false,\n\t\n\t\t\t\tplane = new Plane(),\n\t\t\t\tviewNormalMatrix = new Matrix3(),\n\t\n\t\t\t\tuniform = { value: null, needsUpdate: false };\n\t\n\t\t\tthis.uniform = uniform;\n\t\t\tthis.numPlanes = 0;\n\t\t\tthis.numIntersection = 0;\n\t\n\t\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\t\n\t\t\t\tvar enabled =\n\t\t\t\t\tplanes.length !== 0 ||\n\t\t\t\t\tenableLocalClipping ||\n\t\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\t\tlocalClippingEnabled;\n\t\n\t\t\t\tlocalClippingEnabled = enableLocalClipping;\n\t\n\t\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\t\tnumGlobalPlanes = planes.length;\n\t\n\t\t\t\treturn enabled;\n\t\n\t\t\t};\n\t\n\t\t\tthis.beginShadows = function() {\n\t\n\t\t\t\trenderingShadows = true;\n\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t};\n\t\n\t\t\tthis.endShadows = function() {\n\t\n\t\t\t\trenderingShadows = false;\n\t\t\t\tresetGlobalState();\n\t\n\t\t\t};\n\t\n\t\t\tthis.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\t\n\t\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t\t// there's no local clipping\n\t\n\t\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t\t// there's no global clipping\n\t\n\t\t\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tresetGlobalState();\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\t\tlGlobal = nGlobal * 4,\n\t\n\t\t\t\t\t\tdstArray = cache.clippingState || null;\n\t\n\t\t\t\t\tuniform.value = dstArray; // ensure unique state\n\t\n\t\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\t\n\t\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\t\n\t\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\t\tthis.numPlanes += nGlobal;\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t};\n\t\n\t\t\tfunction resetGlobalState() {\n\t\n\t\t\t\tif ( uniform.value !== globalState ) {\n\t\n\t\t\t\t\tuniform.value = globalState;\n\t\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\t\tscope.numIntersection = 0;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\t\n\t\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\t\tdstArray = null;\n\t\n\t\t\t\tif ( nPlanes !== 0 ) {\n\t\n\t\t\t\t\tdstArray = uniform.value;\n\t\n\t\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\t\n\t\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\t\n\t\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\t\n\t\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\t\n\t\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\t\n\t\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\t\n\t\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuniform.value = dstArray;\n\t\t\t\t\tuniform.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.numPlanes = nPlanes;\n\t\t\t\t\n\t\t\t\treturn dstArray;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author szimek / https://github.com/szimek/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction WebGLRenderer( parameters ) {\n\t\n\t\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\t\n\t\t\tparameters = parameters || {};\n\t\n\t\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\t\n\t\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\t\n\t\t\tvar lights = [];\n\t\n\t\t\tvar opaqueObjects = [];\n\t\t\tvar opaqueObjectsLastIndex = - 1;\n\t\t\tvar transparentObjects = [];\n\t\t\tvar transparentObjectsLastIndex = - 1;\n\t\n\t\t\tvar morphInfluences = new Float32Array( 8 );\n\t\n\t\t\tvar sprites = [];\n\t\t\tvar lensFlares = [];\n\t\n\t\t\t// public properties\n\t\n\t\t\tthis.domElement = _canvas;\n\t\t\tthis.context = null;\n\t\n\t\t\t// clearing\n\t\n\t\t\tthis.autoClear = true;\n\t\t\tthis.autoClearColor = true;\n\t\t\tthis.autoClearDepth = true;\n\t\t\tthis.autoClearStencil = true;\n\t\n\t\t\t// scene graph\n\t\n\t\t\tthis.sortObjects = true;\n\t\n\t\t\t// user-defined clipping\n\t\n\t\t\tthis.clippingPlanes = [];\n\t\t\tthis.localClippingEnabled = false;\n\t\n\t\t\t// physically based shading\n\t\n\t\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\t\tthis.gammaInput = false;\n\t\t\tthis.gammaOutput = false;\n\t\n\t\t\t// physical lights\n\t\n\t\t\tthis.physicallyCorrectLights = false;\n\t\n\t\t\t// tone mapping\n\t\n\t\t\tthis.toneMapping = LinearToneMapping;\n\t\t\tthis.toneMappingExposure = 1.0;\n\t\t\tthis.toneMappingWhitePoint = 1.0;\n\t\n\t\t\t// morphs\n\t\n\t\t\tthis.maxMorphTargets = 8;\n\t\t\tthis.maxMorphNormals = 4;\n\t\n\t\t\t// internal properties\n\t\n\t\t\tvar _this = this,\n\t\n\t\t\t// internal state cache\n\t\n\t\t\t_currentProgram = null,\n\t\t\t_currentRenderTarget = null,\n\t\t\t_currentFramebuffer = null,\n\t\t\t_currentMaterialId = - 1,\n\t\t\t_currentGeometryProgram = '',\n\t\t\t_currentCamera = null,\n\t\n\t\t\t_currentScissor = new Vector4(),\n\t\t\t_currentScissorTest = null,\n\t\n\t\t\t_currentViewport = new Vector4(),\n\t\n\t\t\t//\n\t\n\t\t\t_usedTextureUnits = 0,\n\t\n\t\t\t//\n\t\n\t\t\t_clearColor = new Color( 0x000000 ),\n\t\t\t_clearAlpha = 0,\n\t\n\t\t\t_width = _canvas.width,\n\t\t\t_height = _canvas.height,\n\t\n\t\t\t_pixelRatio = 1,\n\t\n\t\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t\t_scissorTest = false,\n\t\n\t\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\t\n\t\t\t// frustum\n\t\n\t\t\t_frustum = new Frustum(),\n\t\n\t\t\t// clipping\n\t\n\t\t\t_clipping = new WebGLClipping(),\n\t\t\t_clippingEnabled = false,\n\t\t\t_localClippingEnabled = false,\n\t\n\t\t\t_sphere = new Sphere(),\n\t\n\t\t\t// camera matrices cache\n\t\n\t\t\t_projScreenMatrix = new Matrix4(),\n\t\n\t\t\t_vector3 = new Vector3(),\n\t\n\t\t\t// light arrays cache\n\t\n\t\t\t_lights = {\n\t\n\t\t\t\thash: '',\n\t\n\t\t\t\tambient: [ 0, 0, 0 ],\n\t\t\t\tdirectional: [],\n\t\t\t\tdirectionalShadowMap: [],\n\t\t\t\tdirectionalShadowMatrix: [],\n\t\t\t\tspot: [],\n\t\t\t\tspotShadowMap: [],\n\t\t\t\tspotShadowMatrix: [],\n\t\t\t\tpoint: [],\n\t\t\t\tpointShadowMap: [],\n\t\t\t\tpointShadowMatrix: [],\n\t\t\t\themi: [],\n\t\n\t\t\t\tshadows: []\n\t\n\t\t\t},\n\t\n\t\t\t// info\n\t\n\t\t\t_infoRender = {\n\t\n\t\t\t\tcalls: 0,\n\t\t\t\tvertices: 0,\n\t\t\t\tfaces: 0,\n\t\t\t\tpoints: 0\n\t\n\t\t\t};\n\t\n\t\t\tthis.info = {\n\t\n\t\t\t\trender: _infoRender,\n\t\t\t\tmemory: {\n\t\n\t\t\t\t\tgeometries: 0,\n\t\t\t\t\ttextures: 0\n\t\n\t\t\t\t},\n\t\t\t\tprograms: null\n\t\n\t\t\t};\n\t\n\t\n\t\t\t// initialize\n\t\n\t\t\tvar _gl;\n\t\n\t\t\ttry {\n\t\n\t\t\t\tvar attributes = {\n\t\t\t\t\talpha: _alpha,\n\t\t\t\t\tdepth: _depth,\n\t\t\t\t\tstencil: _stencil,\n\t\t\t\t\tantialias: _antialias,\n\t\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t\t};\n\t\n\t\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\t\n\t\t\t\tif ( _gl === null ) {\n\t\n\t\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\t\n\t\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthrow 'Error creating WebGL context.';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\t\n\t\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\t\n\t\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\t\n\t\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t\t} catch ( error ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\t\n\t\t\t}\n\t\n\t\t\tvar extensions = new WebGLExtensions( _gl );\n\t\n\t\t\textensions.get( 'WEBGL_depth_texture' );\n\t\t\textensions.get( 'OES_texture_float' );\n\t\t\textensions.get( 'OES_texture_float_linear' );\n\t\t\textensions.get( 'OES_texture_half_float' );\n\t\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\t\textensions.get( 'OES_standard_derivatives' );\n\t\t\textensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\t\tBufferGeometry.MaxIndex = 4294967296;\n\t\n\t\t\t}\n\t\n\t\t\tvar capabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\t\n\t\t\tvar state = new WebGLState( _gl, extensions, paramThreeToGL );\n\t\t\tvar properties = new WebGLProperties();\n\t\t\tvar textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\t\tvar objects = new WebGLObjects( _gl, properties, this.info );\n\t\t\tvar programCache = new WebGLPrograms( this, capabilities );\n\t\t\tvar lightCache = new WebGLLights();\n\t\n\t\t\tthis.info.programs = programCache.programs;\n\t\n\t\t\tvar bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\t\tvar indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\t\n\t\t\t//\n\t\n\t\t\tvar backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\t\tvar backgroundCamera2 = new PerspectiveCamera();\n\t\t\tvar backgroundPlaneMesh = new Mesh(\n\t\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t\t);\n\t\t\tvar backgroundBoxShader = ShaderLib[ 'cube' ];\n\t\t\tvar backgroundBoxMesh = new Mesh(\n\t\t\t\tnew BoxBufferGeometry( 5, 5, 5 ),\n\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\t\tside: BackSide,\n\t\t\t\t\tdepthTest: false,\n\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\tfog: false\n\t\t\t\t} )\n\t\t\t);\n\t\n\t\t\t//\n\t\n\t\t\tfunction getTargetPixelRatio() {\n\t\n\t\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\t\n\t\t\t}\n\t\n\t\t\tfunction glClearColor( r, g, b, a ) {\n\t\n\t\t\t\tif ( _premultipliedAlpha === true ) {\n\t\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.clearColor( r, g, b, a );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setDefaultGLState() {\n\t\n\t\t\t\tstate.init();\n\t\n\t\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t}\n\t\n\t\t\tfunction resetGLState() {\n\t\n\t\t\t\t_currentProgram = null;\n\t\t\t\t_currentCamera = null;\n\t\n\t\t\t\t_currentGeometryProgram = '';\n\t\t\t\t_currentMaterialId = - 1;\n\t\n\t\t\t\tstate.reset();\n\t\n\t\t\t}\n\t\n\t\t\tsetDefaultGLState();\n\t\n\t\t\tthis.context = _gl;\n\t\t\tthis.capabilities = capabilities;\n\t\t\tthis.extensions = extensions;\n\t\t\tthis.properties = properties;\n\t\t\tthis.state = state;\n\t\n\t\t\t// shadow map\n\t\n\t\t\tvar shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );\n\t\n\t\t\tthis.shadowMap = shadowMap;\n\t\n\t\n\t\t\t// Plugins\n\t\n\t\t\tvar spritePlugin = new SpritePlugin( this, sprites );\n\t\t\tvar lensFlarePlugin = new LensFlarePlugin( this, lensFlares );\n\t\n\t\t\t// API\n\t\n\t\t\tthis.getContext = function () {\n\t\n\t\t\t\treturn _gl;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getContextAttributes = function () {\n\t\n\t\t\t\treturn _gl.getContextAttributes();\n\t\n\t\t\t};\n\t\n\t\t\tthis.forceContextLoss = function () {\n\t\n\t\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\t\n\t\t\t};\n\t\n\t\t\tthis.getMaxAnisotropy = function () {\n\t\n\t\t\t\treturn capabilities.getMaxAnisotropy();\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPrecision = function () {\n\t\n\t\t\t\treturn capabilities.precision;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPixelRatio = function () {\n\t\n\t\t\t\treturn _pixelRatio;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setPixelRatio = function ( value ) {\n\t\n\t\t\t\tif ( value === undefined ) return;\n\t\n\t\t\t\t_pixelRatio = value;\n\t\n\t\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getSize = function () {\n\t\n\t\t\t\treturn {\n\t\t\t\t\twidth: _width,\n\t\t\t\t\theight: _height\n\t\t\t\t};\n\t\n\t\t\t};\n\t\n\t\t\tthis.setSize = function ( width, height, updateStyle ) {\n\t\n\t\t\t\t_width = width;\n\t\t\t\t_height = height;\n\t\n\t\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t\t_canvas.height = height * _pixelRatio;\n\t\n\t\t\t\tif ( updateStyle !== false ) {\n\t\n\t\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t\t_canvas.style.height = height + 'px';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setViewport( 0, 0, width, height );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setViewport = function ( x, y, width, height ) {\n\t\n\t\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setScissor = function ( x, y, width, height ) {\n\t\n\t\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setScissorTest = function ( boolean ) {\n\t\n\t\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\t\n\t\t\t};\n\t\n\t\t\t// Clearing\n\t\n\t\t\tthis.getClearColor = function () {\n\t\n\t\t\t\treturn _clearColor;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setClearColor = function ( color, alpha ) {\n\t\n\t\t\t\t_clearColor.set( color );\n\t\n\t\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getClearAlpha = function () {\n\t\n\t\t\t\treturn _clearAlpha;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setClearAlpha = function ( alpha ) {\n\t\n\t\t\t\t_clearAlpha = alpha;\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clear = function ( color, depth, stencil ) {\n\t\n\t\t\t\tvar bits = 0;\n\t\n\t\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\t\n\t\t\t\t_gl.clear( bits );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearColor = function () {\n\t\n\t\t\t\tthis.clear( true, false, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearDepth = function () {\n\t\n\t\t\t\tthis.clear( false, true, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearStencil = function () {\n\t\n\t\t\t\tthis.clear( false, false, true );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\t\n\t\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\t\tthis.clear( color, depth, stencil );\n\t\n\t\t\t};\n\t\n\t\t\t// Reset\n\t\n\t\t\tthis.resetGLState = resetGLState;\n\t\n\t\t\tthis.dispose = function() {\n\t\n\t\t\t\ttransparentObjects = [];\n\t\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\t\topaqueObjects = [];\n\t\t\t\topaqueObjectsLastIndex = -1;\n\t\n\t\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t\t};\n\t\n\t\t\t// Events\n\t\n\t\t\tfunction onContextLost( event ) {\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t\tresetGLState();\n\t\t\t\tsetDefaultGLState();\n\t\n\t\t\t\tproperties.clear();\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMaterialDispose( event ) {\n\t\n\t\t\t\tvar material = event.target;\n\t\n\t\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t\tdeallocateMaterial( material );\n\t\n\t\t\t}\n\t\n\t\t\t// Buffer deallocation\n\t\n\t\t\tfunction deallocateMaterial( material ) {\n\t\n\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t\tproperties.delete( material );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction releaseMaterialProgramReference( material ) {\n\t\n\t\t\t\tvar programInfo = properties.get( material ).program;\n\t\n\t\t\t\tmaterial.program = undefined;\n\t\n\t\t\t\tif ( programInfo !== undefined ) {\n\t\n\t\t\t\t\tprogramCache.releaseProgram( programInfo );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Buffer rendering\n\t\n\t\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\t\n\t\t\t\tstate.initAttributes();\n\t\n\t\t\t\tvar buffers = properties.get( object );\n\t\n\t\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\t\n\t\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\t\tif ( object.hasPositions ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasNormals ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\t\n\t\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t\t     ! material.isMeshStandardMaterial &&\n\t\t\t\t\t       material.shading === FlatShading ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\t\tvar array = object.normalArray;\n\t\n\t\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\t\n\t\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\t\n\t\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\t\n\t\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.normal );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasUvs && material.map ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( attributes.color );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\t\n\t\t\t\tobject.count = 0;\n\t\n\t\t\t};\n\t\n\t\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\t\n\t\t\t\tsetMaterial( material );\n\t\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\t\n\t\t\t\tvar updateBuffers = false;\n\t\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\t\n\t\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\t\n\t\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph targets\n\t\n\t\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\t\n\t\t\t\tif ( morphTargetInfluences !== undefined ) {\n\t\n\t\t\t\t\tvar activeInfluences = [];\n\t\n\t\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\t\n\t\t\t\t\tif ( activeInfluences.length > 8 ) {\n\t\n\t\t\t\t\t\tactiveInfluences.length = 8;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\t\n\t\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\t\n\t\t\t\t\t\t\tvar index = influence[ 1 ];\n\t\n\t\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmorphInfluences[ i ] = 0.0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\t\n\t\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar position = geometry.attributes.position;\n\t\t\t\tvar rangeFactor = 1;\n\t\n\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\t\t\t\trangeFactor = 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar renderer;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\t\trenderer.setIndex( index );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer = bufferRenderer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( updateBuffers ) {\n\t\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar dataCount = 0;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tdataCount = index.count;\n\t\n\t\t\t\t} else if ( position !== undefined ) {\n\t\n\t\t\t\t\tdataCount = position.count;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\t\n\t\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\t\n\t\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\t\n\t\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\t\n\t\t\t\tif ( drawCount === 0 ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( object.isMesh ) {\n\t\n\t\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tswitch ( object.drawMode ) {\n\t\n\t\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t} else if ( object.isLine ) {\n\t\n\t\t\t\t\tvar lineWidth = material.linewidth;\n\t\n\t\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\t\n\t\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\t\n\t\t\t\t\tif ( object.isLineSegments ) {\n\t\n\t\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object.isPoints ) {\n\t\n\t\t\t\t\trenderer.setMode( _gl.POINTS );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\t\n\t\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\t\n\t\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer.render( drawStart, drawCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\t\n\t\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\t\n\t\t\t\tstate.initAttributes();\n\t\n\t\t\t\tvar geometryAttributes = geometry.attributes;\n\t\n\t\t\t\tvar programAttributes = program.getAttributes();\n\t\n\t\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\t\n\t\t\t\tfor ( var name in programAttributes ) {\n\t\n\t\t\t\t\tvar programAttribute = programAttributes[ name ];\n\t\n\t\t\t\t\tif ( programAttribute >= 0 ) {\n\t\n\t\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\t\n\t\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\t\n\t\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\t\n\t\t\t\t\t\t\t\tconsole.warn( \"Unsupported data buffer format: Float64Array\" );\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.SHORT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.INT;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.BYTE;\n\t\n\t\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\t\n\t\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\t\n\t\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\t\n\t\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\t\n\t\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tswitch ( value.length ) {\n\t\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t}\n\t\n\t\t\t// Sorting\n\t\n\t\t\tfunction absNumericalSort( a, b ) {\n\t\n\t\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\t\n\t\t\t}\n\t\n\t\t\tfunction painterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\t\n\t\t\t\t\treturn a.material.program.id - b.material.program.id;\n\t\n\t\t\t\t} else if ( a.material.id !== b.material.id ) {\n\t\n\t\t\t\t\treturn a.material.id - b.material.id;\n\t\n\t\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn a.z - b.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction reversePainterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t\t} if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Rendering\n\t\n\t\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\t\n\t\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// reset caching for this frame\n\t\n\t\t\t\t_currentGeometryProgram = '';\n\t\t\t\t_currentMaterialId = - 1;\n\t\t\t\t_currentCamera = null;\n\t\n\t\t\t\t// update scene graph\n\t\n\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\n\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\t\n\t\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\t\n\t\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\tlights.length = 0;\n\t\n\t\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\t\ttransparentObjectsLastIndex = - 1;\n\t\n\t\t\t\tsprites.length = 0;\n\t\t\t\tlensFlares.length = 0;\n\t\n\t\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\t\n\t\t\t\tprojectObject( scene, camera );\n\t\n\t\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\t\n\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\t\n\t\t\t\tsetupShadows( lights );\n\t\n\t\t\t\tshadowMap.render( scene, camera );\n\t\n\t\t\t\tsetupLights( lights, camera );\n\t\n\t\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\t\n\t\t\t\t//\n\t\n\t\t\t\t_infoRender.calls = 0;\n\t\t\t\t_infoRender.vertices = 0;\n\t\t\t\t_infoRender.faces = 0;\n\t\t\t\t_infoRender.points = 0;\n\t\n\t\t\t\tif ( renderTarget === undefined ) {\n\t\n\t\t\t\t\trenderTarget = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setRenderTarget( renderTarget );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar background = scene.background;\n\t\n\t\t\t\tif ( background === null ) {\n\t\n\t\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t\t} else if ( background && background.isColor ) {\n\t\n\t\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\t\t\t\tforceClear = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClear || forceClear ) {\n\t\n\t\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( background && background.isCubeTexture ) {\n\t\n\t\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\t\n\t\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\t\n\t\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\t\n\t\t\t\t\tobjects.update( backgroundBoxMesh );\n\t\n\t\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\t\n\t\t\t\t} else if ( background && background.isTexture ) {\n\t\n\t\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\t\n\t\t\t\t\tobjects.update( backgroundPlaneMesh );\n\t\n\t\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( scene.overrideMaterial ) {\n\t\n\t\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\t\n\t\t\t\t\trenderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\t\trenderObjects( transparentObjects, scene, camera, overrideMaterial );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// opaque pass (front-to-back order)\n\t\n\t\t\t\t\tstate.setBlending( NoBlending );\n\t\t\t\t\trenderObjects( opaqueObjects, scene, camera );\n\t\n\t\t\t\t\t// transparent pass (back-to-front order)\n\t\n\t\t\t\t\trenderObjects( transparentObjects, scene, camera );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// custom render plugins (post pass)\n\t\n\t\t\t\tspritePlugin.render( scene, camera );\n\t\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\t\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\t\n\t\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\t\n\t\t\t\tstate.setDepthTest( true );\n\t\t\t\tstate.setDepthWrite( true );\n\t\t\t\tstate.setColorWrite( true );\n\t\n\t\t\t\t// _gl.finish();\n\t\n\t\t\t};\n\t\n\t\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\t\n\t\t\t\tvar array, index;\n\t\n\t\t\t\t// allocate the next position in the appropriate array\n\t\n\t\t\t\tif ( material.transparent ) {\n\t\n\t\t\t\t\tarray = transparentObjects;\n\t\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tarray = opaqueObjects;\n\t\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// recycle existing render item or grow the array\n\t\n\t\t\t\tvar renderItem = array[ index ];\n\t\n\t\t\t\tif ( renderItem !== undefined ) {\n\t\n\t\t\t\t\trenderItem.id = object.id;\n\t\t\t\t\trenderItem.object = object;\n\t\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\t\trenderItem.material = material;\n\t\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\t\trenderItem.group = group;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderItem = {\n\t\t\t\t\t\tid: object.id,\n\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\t\tgroup: group\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// assert( index === array.length );\n\t\t\t\t\tarray.push( renderItem );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// TODO Duplicated code (Frustum)\n\t\n\t\t\tfunction isObjectViewable( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\t\tapplyMatrix4( object.matrixWorld );\n\t\n\t\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t\t}\n\t\n\t\t\tfunction isSpriteViewable( sprite ) {\n\t\n\t\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t\t}\n\t\n\t\t\tfunction isSphereViewable( sphere ) {\n\t\n\t\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\t\n\t\t\t\tvar numPlanes = _clipping.numPlanes;\n\t\n\t\t\t\tif ( numPlanes === 0 ) return true;\n\t\n\t\t\t\tvar planes = _this.clippingPlanes,\n\t\n\t\t\t\t\tcenter = sphere.center,\n\t\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\t\ti = 0;\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\t\n\t\t\t\t} while ( ++ i !== numPlanes );\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectObject( object, camera ) {\n\t\n\t\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\t\n\t\t\t\tif ( visible ) {\n\t\n\t\t\t\t\tif ( object.isLight ) {\n\t\n\t\t\t\t\t\tlights.push( object );\n\t\n\t\t\t\t\t} else if ( object.isSprite ) {\n\t\n\t\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\t\n\t\t\t\t\t\t\tsprites.push( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( object.isLensFlare ) {\n\t\n\t\t\t\t\t\tlensFlares.push( object );\n\t\n\t\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\t\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\t\n\t\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\t\n\t\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\t\n\t\t\t\t\t\t\tobject.skeleton.update();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\t\n\t\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\t\n\t\t\t\t\t\t\t\tif ( material.isMultiMaterial ) {\n\t\n\t\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tprojectObject( children[ i ], camera );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\t\n\t\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar renderItem = renderList[ i ];\n\t\n\t\t\t\t\tvar object = renderItem.object;\n\t\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\t\tvar group = renderItem.group;\n\t\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\t\n\t\t\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\t\n\t\t\t\t\tif ( object.isImmediateRenderObject ) {\n\t\n\t\t\t\t\t\tsetMaterial( material );\n\t\n\t\t\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\t\n\t\t\t\t\t\t_currentGeometryProgram = '';\n\t\n\t\t\t\t\t\tobject.render( function ( object ) {\n\t\n\t\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\t\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\t\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction initMaterial( material, fog, object ) {\n\t\n\t\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\t\n\t\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\t\n\t\t\t\tvar program = materialProperties.program;\n\t\t\t\tvar programChange = true;\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\t// new material\n\t\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t\t} else if ( program.code !== code ) {\n\t\n\t\t\t\t\t// changed glsl or parameters\n\t\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\t\n\t\t\t\t\t// same glsl and uniform list\n\t\t\t\t\treturn;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// only rebuild uniform list\n\t\t\t\t\tprogramChange = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( programChange ) {\n\t\n\t\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\t\n\t\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\t\n\t\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\t\n\t\t\t\t\tmaterialProperties.program = program;\n\t\t\t\t\tmaterial.program = program;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\t\n\t\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\t\n\t\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.morphNormals ) {\n\t\n\t\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\t\n\t\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\t\n\t\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t\t     ! material.isRawShaderMaterial ||\n\t\t\t\t       material.clipping === true ) {\n\t\n\t\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterialProperties.fog = fog;\n\t\n\t\t\t\t// store the light setup it was created for\n\t\n\t\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\t\n\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t// wire up the material to this renderer's lighting state\n\t\n\t\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\t\n\t\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\t\tuniformsList =\n\t\t\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\t\n\t\t\t\tmaterialProperties.uniformsList = uniformsList;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setMaterial( material ) {\n\t\n\t\t\t\tmaterial.side === DoubleSide\n\t\t\t\t\t? state.disable( _gl.CULL_FACE )\n\t\t\t\t\t: state.enable( _gl.CULL_FACE );\n\t\n\t\t\t\tstate.setFlipSided( material.side === BackSide );\n\t\n\t\t\t\tmaterial.transparent === true\n\t\t\t\t\t? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t\t: state.setBlending( NoBlending );\n\t\n\t\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setProgram( camera, fog, material, object ) {\n\t\n\t\t\t\t_usedTextureUnits = 0;\n\t\n\t\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\t\tif ( _clippingEnabled ) {\n\t\n\t\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\t\n\t\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\t\n\t\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.needsUpdate === false ) {\n\t\n\t\t\t\t\tif ( materialProperties.program === undefined ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes || \n\t\t \t\t\t\t  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.needsUpdate ) {\n\t\n\t\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\t\tmaterial.needsUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar refreshProgram = false;\n\t\t\t\tvar refreshMaterial = false;\n\t\t\t\tvar refreshLights = false;\n\t\n\t\t\t\tvar program = materialProperties.program,\n\t\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\t\tif ( program.id !== _currentProgram ) {\n\t\n\t\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t\t_currentProgram = program.id;\n\t\n\t\t\t\t\trefreshProgram = true;\n\t\t\t\t\trefreshMaterial = true;\n\t\t\t\t\trefreshLights = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.id !== _currentMaterialId ) {\n\t\n\t\t\t\t\t_currentMaterialId = material.id;\n\t\n\t\t\t\t\trefreshMaterial = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\t\n\t\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\t\n\t\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\t\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\tif ( camera !== _currentCamera ) {\n\t\n\t\t\t\t\t\t_currentCamera = camera;\n\t\n\t\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t\t// the next material that does gets activated:\n\t\n\t\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// load material specific uniforms\n\t\t\t\t\t// (shader material also gets them for the sake of genericity)\n\t\n\t\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t\t     material.envMap ) {\n\t\n\t\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\t\n\t\t\t\t\t\tif ( uCamPos !== undefined ) {\n\t\n\t\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t\t     material.isMeshBasicMaterial ||\n\t\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t\t     material.isShaderMaterial ||\n\t\t\t\t\t     material.skinning ) {\n\t\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t\t// not sure why, but otherwise weird things happen\n\t\n\t\t\t\tif ( material.skinning ) {\n\t\n\t\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\t\n\t\t\t\t\tvar skeleton = object.skeleton;\n\t\n\t\t\t\t\tif ( skeleton ) {\n\t\n\t\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\t\n\t\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( refreshMaterial ) {\n\t\n\t\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t\t// the current material requires lighting info\n\t\n\t\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t\t// values\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t\t// the GL state when required\n\t\n\t\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// refresh uniforms common to several materials\n\t\n\t\t\t\t\tif ( fog && material.fog ) {\n\t\n\t\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.isMeshBasicMaterial ||\n\t\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t\t     material.isMeshDepthMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// refresh single material specific uniforms\n\t\n\t\t\t\t\tif ( material.isLineBasicMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isLineDashedMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isPointsMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshPhysicalMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\t\n\t\t\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\t\n\t\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tWebGLUniforms.upload(\n\t\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// common matrices\n\t\n\t\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t\t// Uniforms (refresh uniforms objects)\n\t\n\t\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\t\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\n\t\t\t\tif ( material.emissive ) {\n\t\n\t\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\n\t\t\t\tif ( material.aoMap ) {\n\t\n\t\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\t\n\t\t\t\tvar uvScaleMap;\n\t\n\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\tuvScaleMap = material.map;\n\t\n\t\t\t\t} else if ( material.specularMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\t\n\t\t\t\t} else if ( material.displacementMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\t\n\t\t\t\t} else if ( material.normalMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\t\n\t\t\t\t} else if ( material.bumpMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\t\n\t\t\t\t} else if ( material.roughnessMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.roughnessMap;\n\t\n\t\t\t\t} else if ( material.metalnessMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.metalnessMap;\n\t\n\t\t\t\t} else if ( material.alphaMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\t\n\t\t\t\t} else if ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvScaleMap !== undefined ) {\n\t\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\t\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\t\tvar repeat = uvScaleMap.repeat;\n\t\n\t\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\n\t\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\t\n\t\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsLine( uniforms, material ) {\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsDash( uniforms, material ) {\n\t\n\t\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\t\tuniforms.scale.value = material.scale;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\t\tuniforms.scale.value = _height * 0.5;\n\t\n\t\t\t\tuniforms.map.value = material.map;\n\t\n\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\tvar offset = material.map.offset;\n\t\t\t\t\tvar repeat = material.map.repeat;\n\t\n\t\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\t\n\t\t\t\tuniforms.fogColor.value = fog.color;\n\t\n\t\t\t\tif ( fog.isFog ) {\n\t\n\t\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\t\tuniforms.fogFar.value = fog.far;\n\t\n\t\t\t\t} else if ( fog.isFogExp2 ) {\n\t\n\t\t\t\t\tuniforms.fogDensity.value = fog.density;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\t\n\t\t\t\tuniforms.specular.value = material.specular;\n\t\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\t\n\t\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\t\tuniforms.metalness.value = material.metalness;\n\t\n\t\t\t\tif ( material.roughnessMap ) {\n\t\n\t\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.metalnessMap ) {\n\t\n\t\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.envMap ) {\n\t\n\t\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\t\n\t\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\t\n\t\t\t\trefreshUniformsStandard( uniforms, material );\n\t\n\t\t\t}\n\t\n\t\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\t\n\t\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\t\n\t\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\n\t\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\t\n\t\t\t}\n\t\n\t\t\t// Lighting\n\t\n\t\t\tfunction setupShadows( lights ) {\n\t\n\t\t\t\tvar lightShadowsLength = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar light = lights[ i ];\n\t\n\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_lights.shadows.length = lightShadowsLength;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setupLights( lights, camera ) {\n\t\n\t\t\t\tvar l, ll, light,\n\t\t\t\tr = 0, g = 0, b = 0,\n\t\t\t\tcolor,\n\t\t\t\tintensity,\n\t\t\t\tdistance,\n\t\t\t\tshadowMap,\n\t\n\t\t\t\tviewMatrix = camera.matrixWorldInverse,\n\t\n\t\t\t\tdirectionalLength = 0,\n\t\t\t\tpointLength = 0,\n\t\t\t\tspotLength = 0,\n\t\t\t\themiLength = 0;\n\t\n\t\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\t\n\t\t\t\t\tlight = lights[ l ];\n\t\n\t\t\t\t\tcolor = light.color;\n\t\t\t\t\tintensity = light.intensity;\n\t\t\t\t\tdistance = light.distance;\n\t\n\t\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\t\n\t\t\t\t\tif ( light.isAmbientLight ) {\n\t\n\t\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\t\tb += color.b * intensity;\n\t\n\t\t\t\t\t} else if ( light.isDirectionalLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\t\n\t\t\t\t\t} else if ( light.isSpotLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\t\tuniforms.distance = distance;\n\t\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\t\n\t\t\t\t\t} else if ( light.isPointLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\t\n\t\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\t\n\t\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new Matrix4();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\t\n\t\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\t\n\t\t\t\t\t} else if ( light.isHemisphereLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\t\tuniforms.direction.normalize();\n\t\n\t\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\t\n\t\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t\t_lights.ambient[ 2 ] = b;\n\t\n\t\t\t\t_lights.directional.length = directionalLength;\n\t\t\t\t_lights.spot.length = spotLength;\n\t\t\t\t_lights.point.length = pointLength;\n\t\t\t\t_lights.hemi.length = hemiLength;\n\t\n\t\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\t\n\t\t\t}\n\t\n\t\t\t// GL state setting\n\t\n\t\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\t\n\t\t\t\tstate.setCullFace( cullFace );\n\t\t\t\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\n\t\n\t\t\t};\n\t\n\t\t\t// Textures\n\t\n\t\t\tfunction allocTextureUnit() {\n\t\n\t\t\t\tvar textureUnit = _usedTextureUnits;\n\t\n\t\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\t\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_usedTextureUnits += 1;\n\t\n\t\t\t\treturn textureUnit;\n\t\n\t\t\t}\n\t\n\t\t\tthis.allocTextureUnit = allocTextureUnit;\n\t\n\t\t\t// this.setTexture2D = setTexture2D;\n\t\t\tthis.setTexture2D = ( function() {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\treturn function setTexture2D( texture, slot ) {\n\t\n\t\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\t\n\t\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.setTexture = ( function() {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\treturn function setTexture( texture, slot ) {\n\t\n\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.setTextureCube = ( function() {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\treturn function setTextureCube( texture, slot ) {\n\t\n\t\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\t\n\t\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t\t// TODO: unify these code paths\n\t\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\t\n\t\t\t\t\t\t// CompressedTexture can have Array in image :/\n\t\n\t\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\t\n\t\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.getCurrentRenderTarget = function() {\n\t\n\t\t\t\treturn _currentRenderTarget;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setRenderTarget = function ( renderTarget ) {\n\t\n\t\t\t\t_currentRenderTarget = renderTarget;\n\t\n\t\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\t\n\t\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\t\tvar framebuffer;\n\t\n\t\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\t\n\t\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tframebuffer = null;\n\t\n\t\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t\t_currentScissorTest = _scissorTest;\n\t\n\t\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\t\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t\t_currentFramebuffer = framebuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.scissor( _currentScissor );\n\t\t\t\tstate.setScissorTest( _currentScissorTest );\n\t\n\t\t\t\tstate.viewport( _currentViewport );\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\t\n\t\t\t\tif ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\n\t\t\t\tif ( framebuffer ) {\n\t\n\t\t\t\t\tvar restore = false;\n\t\n\t\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\t\t\trestore = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\t\tvar textureType = texture.type;\n\t\n\t\t\t\t\t\tif ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t\t     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t\t     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\t\n\t\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\n\t\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\t\n\t\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} finally {\n\t\n\t\t\t\t\t\tif ( restore ) {\n\t\n\t\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\t// Map three.js constants to WebGL constants\n\t\n\t\t\tfunction paramThreeToGL( p ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( p === RepeatWrapping ) return _gl.REPEAT;\n\t\t\t\tif ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\t\tif ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\t\n\t\t\t\tif ( p === NearestFilter ) return _gl.NEAREST;\n\t\t\t\tif ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\t\tif ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\t\n\t\t\t\tif ( p === LinearFilter ) return _gl.LINEAR;\n\t\t\t\tif ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\t\tif ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\t\n\t\t\t\tif ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\t\tif ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\t\tif ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\t\tif ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\t\n\t\t\t\tif ( p === ByteType ) return _gl.BYTE;\n\t\t\t\tif ( p === ShortType ) return _gl.SHORT;\n\t\t\t\tif ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\t\tif ( p === IntType ) return _gl.INT;\n\t\t\t\tif ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\t\tif ( p === FloatType ) return _gl.FLOAT;\n\t\n\t\t\t\tif ( p === HalfFloatType ) {\n\t\n\t\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === AlphaFormat ) return _gl.ALPHA;\n\t\t\t\tif ( p === RGBFormat ) return _gl.RGB;\n\t\t\t\tif ( p === RGBAFormat ) return _gl.RGBA;\n\t\t\t\tif ( p === LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\t\tif ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\t\tif ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\t\t\tif ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;\n\t\n\t\t\t\tif ( p === AddEquation ) return _gl.FUNC_ADD;\n\t\t\t\tif ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\t\tif ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\t\n\t\t\t\tif ( p === ZeroFactor ) return _gl.ZERO;\n\t\t\t\tif ( p === OneFactor ) return _gl.ONE;\n\t\t\t\tif ( p === SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\t\tif ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\t\tif ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\t\tif ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\t\tif ( p === DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\t\tif ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\t\n\t\t\t\tif ( p === DstColorFactor ) return _gl.DST_COLOR;\n\t\t\t\tif ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\t\tif ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\t\n\t\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\t\t p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === RGB_ETC1_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\t\n\t\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === UnsignedInt248Type ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn 0;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction FogExp2 ( color, density ) {\n\t\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.color = new Color( color );\n\t\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\t\n\t\t}\n\t\n\t\tFogExp2.prototype.isFogExp2 = true;\n\t\n\t\tFogExp2.prototype.clone = function () {\n\t\n\t\t\treturn new FogExp2( this.color.getHex(), this.density );\n\t\n\t\t};\n\t\n\t\tFogExp2.prototype.toJSON = function ( meta ) {\n\t\n\t\t\treturn {\n\t\t\t\ttype: 'FogExp2',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tdensity: this.density\n\t\t\t};\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Fog ( color, near, far ) {\n\t\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.color = new Color( color );\n\t\n\t\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\t\n\t\t}\n\t\n\t\tFog.prototype.isFog = true;\n\t\n\t\tFog.prototype.clone = function () {\n\t\n\t\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\t\n\t\t};\n\t\n\t\tFog.prototype.toJSON = function ( meta ) {\n\t\n\t\t\treturn {\n\t\t\t\ttype: 'Fog',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tnear: this.near,\n\t\t\t\tfar: this.far\n\t\t\t};\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Scene () {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Scene';\n\t\n\t\t\tthis.background = null;\n\t\t\tthis.fog = null;\n\t\t\tthis.overrideMaterial = null;\n\t\n\t\t\tthis.autoUpdate = true; // checked by the renderer\n\t\n\t\t}\n\t\n\t\tScene.prototype = Object.create( Object3D.prototype );\n\t\n\t\tScene.prototype.constructor = Scene;\n\t\n\t\tScene.prototype.copy = function ( source, recursive ) {\n\t\n\t\t\tObject3D.prototype.copy.call( this, source, recursive );\n\t\n\t\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\t\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tScene.prototype.toJSON = function ( meta ) {\n\t\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction LensFlare( texture, size, distance, blending, color ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.lensFlares = [];\n\t\n\t\t\tthis.positionScreen = new Vector3();\n\t\t\tthis.customUpdateCallback = undefined;\n\t\n\t\t\tif ( texture !== undefined ) {\n\t\n\t\t\t\tthis.add( texture, size, distance, blending, color );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: LensFlare,\n\t\n\t\t\tisLensFlare: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\t\n\t\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\t\n\t\t\t\tif ( size === undefined ) size = - 1;\n\t\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\t\tif ( color === undefined ) color = new Color( 0xffffff );\n\t\t\t\tif ( blending === undefined ) blending = NormalBlending;\n\t\n\t\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\t\n\t\t\t\tthis.lensFlares.push( {\n\t\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\t\tcolor: color,\t\t// color\n\t\t\t\t\tblending: blending\t// blending\n\t\t\t\t} );\n\t\n\t\t\t},\n\t\n\t\t\t/*\n\t\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t\t */\n\t\n\t\t\tupdateLensFlares: function () {\n\t\n\t\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\t\tvar flare;\n\t\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\t\tvar vecY = - this.positionScreen.y * 2;\n\t\n\t\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\t\n\t\t\t\t\tflare = this.lensFlares[ f ];\n\t\n\t\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\t\n\t\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *\tuvOffset: new THREE.Vector2(),\n\t\t *\tuvScale: new THREE.Vector2()\n\t\t * }\n\t\t */\n\t\n\t\tfunction SpriteMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'SpriteMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.rotation = 0;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\t\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\t\n\t\tSpriteMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.rotation = source.rotation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Sprite( material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Sprite';\n\t\n\t\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\t\n\t\t}\n\t\n\t\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Sprite,\n\t\n\t\t\tisSprite: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar matrixPosition = new Vector3();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\t\n\t\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\t\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\t\tpoint: this.position,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LOD() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'LOD';\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\tlevels: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: []\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\n\t\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: LOD,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source, false );\n\t\n\t\t\t\tvar levels = source.levels;\n\t\n\t\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddLevel: function ( object, distance ) {\n\t\n\t\t\t\tif ( distance === undefined ) distance = 0;\n\t\n\t\t\t\tdistance = Math.abs( distance );\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\tif ( distance < levels[ l ].distance ) {\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\t\n\t\t\t\tthis.add( object );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectForDistance: function ( distance ) {\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tif ( distance < levels[ i ].distance ) {\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn levels[ i - 1 ].object;\n\t\n\t\t\t},\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar matrixPosition = new Vector3();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\t\n\t\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\treturn function update( camera ) {\n\t\n\t\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\t\tif ( levels.length > 1 ) {\n\t\n\t\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\t\n\t\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\t\n\t\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\t\n\t\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.levels = [];\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\t\tdistance: level.distance\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.image = { data: data, width: width, height: height };\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\n\t\t\tthis.generateMipmaps  = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\n\t\t}\n\t\n\t\tDataTexture.prototype = Object.create( Texture.prototype );\n\t\tDataTexture.prototype.constructor = DataTexture;\n\t\n\t\tDataTexture.prototype.isDataTexture = true;\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author michael guerrero / http://realitymeltdown.com\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction Skeleton( bones, boneInverses, useVertexTexture ) {\n\t\n\t\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\t\n\t\t\tthis.identityMatrix = new Matrix4();\n\t\n\t\t\t// copy the bone array\n\t\n\t\t\tbones = bones || [];\n\t\n\t\t\tthis.bones = bones.slice( 0 );\n\t\n\t\t\t// create a bone texture or an array of floats\n\t\n\t\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\t\n\t\n\t\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\t\tsize = _Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\t\tsize = Math.max( size, 4 );\n\t\n\t\t\t\tthis.boneTextureWidth = size;\n\t\t\t\tthis.boneTextureHeight = size;\n\t\n\t\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\t\tthis.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\t\n\t\t\t}\n\t\n\t\t\t// use the supplied bone inverses or calculate the inverses\n\t\n\t\t\tif ( boneInverses === undefined ) {\n\t\n\t\t\t\tthis.calculateInverses();\n\t\n\t\t\t} else {\n\t\n\t\t\t\tif ( this.bones.length === boneInverses.length ) {\n\t\n\t\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\t\n\t\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tObject.assign( Skeleton.prototype, {\n\t\n\t\t\tcalculateInverses: function () {\n\t\n\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tvar inverse = new Matrix4();\n\t\n\t\t\t\t\tif ( this.bones[ b ] ) {\n\t\n\t\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.boneInverses.push( inverse );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tpose: function () {\n\t\n\t\t\t\tvar bone;\n\t\n\t\t\t\t// recover the bind-time world matrices\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// compute the local matrices, positions, rotations and scales\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\t\n\t\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdate: ( function () {\n\t\n\t\t\t\tvar offsetMatrix = new Matrix4();\n\t\n\t\t\t\treturn function update() {\n\t\n\t\t\t\t\t// flatten bone matrices to array\n\t\n\t\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\t\t// compute the offset between the current and the original transform\n\t\n\t\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\t\n\t\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction Bone( skin ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Bone';\n\t\n\t\t\tthis.skin = skin;\n\t\n\t\t}\n\t\n\t\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Bone,\n\t\n\t\t\tisBone: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.skin = source.skin;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction SkinnedMesh( geometry, material, useVertexTexture ) {\n\t\n\t\t\tMesh.call( this, geometry, material );\n\t\n\t\t\tthis.type = 'SkinnedMesh';\n\t\n\t\t\tthis.bindMode = \"attached\";\n\t\t\tthis.bindMatrix = new Matrix4();\n\t\t\tthis.bindMatrixInverse = new Matrix4();\n\t\n\t\t\t// init bones\n\t\n\t\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t\t// convenience) for THREE.SkinnedMesh to do this.\n\t\n\t\t\tvar bones = [];\n\t\n\t\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\t\n\t\t\t\tvar bone, gbone;\n\t\n\t\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\t\tbone = new Bone( this );\n\t\t\t\t\tbones.push( bone );\n\t\n\t\t\t\t\tbone.name = gbone.name;\n\t\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\t\n\t\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis.add( bones[ b ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.normalizeSkinWeights();\n\t\n\t\t\tthis.updateMatrixWorld( true );\n\t\t\tthis.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\t\n\t\t}\n\t\n\t\n\t\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\t\n\t\t\tconstructor: SkinnedMesh,\n\t\n\t\t\tisSkinnedMesh: true,\n\t\n\t\t\tbind: function( skeleton, bindMatrix ) {\n\t\n\t\t\t\tthis.skeleton = skeleton;\n\t\n\t\t\t\tif ( bindMatrix === undefined ) {\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.skeleton.calculateInverses();\n\t\n\t\t\t\t\tbindMatrix = this.matrixWorld;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\t\n\t\t\t},\n\t\n\t\t\tpose: function () {\n\t\n\t\t\t\tthis.skeleton.pose();\n\t\n\t\t\t},\n\t\n\t\t\tnormalizeSkinWeights: function () {\n\t\n\t\t\t\tif ( (this.geometry && this.geometry.isGeometry) ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\t\n\t\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\t\n\t\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\t\tsw.multiplyScalar( scale );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\tvar vec = new Vector4();\n\t\n\t\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\t\n\t\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\t\n\t\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\t\tvec.w = skinWeight.getW( i );\n\t\n\t\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\t\n\t\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\t\tvec.multiplyScalar( scale );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: function( force ) {\n\t\n\t\t\t\tMesh.prototype.updateMatrixWorld.call( this, true );\n\t\n\t\t\t\tif ( this.bindMode === \"attached\" ) {\n\t\n\t\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\t\n\t\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\t\n\t\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function() {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  linewidth: <float>,\n\t\t *  linecap: \"round\",\n\t\t *  linejoin: \"round\"\n\t\t * }\n\t\t */\n\t\n\t\tfunction LineBasicMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'LineBasicMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.linecap = 'round';\n\t\t\tthis.linejoin = 'round';\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\t\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\t\n\t\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\t\n\t\tLineBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.linewidth = source.linewidth;\n\t\t\tthis.linecap = source.linecap;\n\t\t\tthis.linejoin = source.linejoin;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Line( geometry, material, mode ) {\n\t\n\t\t\tif ( mode === 1 ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\t\treturn new LineSegments( geometry, material );\n\t\n\t\t\t}\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Line';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t}\n\t\n\t\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Line,\n\t\n\t\t\tisLine: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\t\tvar precisionSq = precision * precision;\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\tvar vStart = new Vector3();\n\t\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\t\tvar interRay = new Vector3();\n\t\t\t\t\tvar step = (this && this.isLineSegments) ? 2 : 1;\n\t\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\t\n\t\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\t\n\t\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\t\n\t\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar nbVertices = vertices.length;\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\t\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\t\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LineSegments( geometry, material ) {\n\t\n\t\t\tLine.call( this, geometry, material );\n\t\n\t\t\tthis.type = 'LineSegments';\n\t\n\t\t}\n\t\n\t\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\t\n\t\t\tconstructor: LineSegments,\n\t\n\t\t\tisLineSegments: true\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  size: <float>,\n\t\t *  sizeAttenuation: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction PointsMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'PointsMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.size = 1;\n\t\t\tthis.sizeAttenuation = true;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tPointsMaterial.prototype = Object.create( Material.prototype );\n\t\tPointsMaterial.prototype.constructor = PointsMaterial;\n\t\n\t\tPointsMaterial.prototype.isPointsMaterial = true;\n\t\n\t\tPointsMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.size = source.size;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Points( geometry, material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Points';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t}\n\t\n\t\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Points,\n\t\n\t\t\tisPoints: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar object = this;\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\t\tvar position = new Vector3();\n\t\n\t\t\t\t\tfunction testPoint( point, index ) {\n\t\n\t\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\t\n\t\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\t\n\t\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tobject: object\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\n\t\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\t\n\t\t\t\t\t\t\t\ttestPoint( position, a );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\t\n\t\t\t\t\t\t\t\ttestPoint( position, i );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Group() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Group';\n\t\n\t\t}\n\t\n\t\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Group\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.generateMipmaps = false;\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tfunction update() {\n\t\n\t\t\t\trequestAnimationFrame( update );\n\t\n\t\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\t\n\t\t\t\t\tscope.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tupdate();\n\t\n\t\t}\n\t\n\t\tVideoTexture.prototype = Object.create( Texture.prototype );\n\t\tVideoTexture.prototype.constructor = VideoTexture;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.image = { width: width, height: height };\n\t\t\tthis.mipmaps = mipmaps;\n\t\n\t\t\t// no flipping for cube textures\n\t\t\t// (also flipping doesn't work for compressed textures )\n\t\n\t\t\tthis.flipY = false;\n\t\n\t\t\t// can't generate mipmaps for compressed textures\n\t\t\t// mips must be embedded in DDS files\n\t\n\t\t\tthis.generateMipmaps = false;\n\t\n\t\t}\n\t\n\t\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\t\tCompressedTexture.prototype.constructor = CompressedTexture;\n\t\n\t\tCompressedTexture.prototype.isCompressedTexture = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\t\tCanvasTexture.prototype.constructor = CanvasTexture;\n\t\n\t\t/**\n\t\t * @author Matt DesLauriers / @mattdesl\n\t\t * @author atix / arthursilber.de\n\t\t */\n\t\n\t\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\t\n\t\t\tformat = format !== undefined ? format : DepthFormat;\n\t\n\t\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\t\n\t\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )\n\t\n\t\t\t}\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.image = { width: width, height: height };\n\t\n\t\t\tthis.type = type !== undefined ? type : UnsignedShortType;\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\n\t\t\tthis.flipY = false;\n\t\t\tthis.generateMipmaps\t= false;\n\t\n\t\t}\n\t\n\t\tDepthTexture.prototype = Object.create( Texture.prototype );\n\t\tDepthTexture.prototype.constructor = DepthTexture;\n\t\tDepthTexture.prototype.isDepthTexture = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WireframeGeometry( geometry ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\t\treturn a - b;\n\t\n\t\t\t}\n\t\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\t\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar numEdges = 0;\n\t\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\t\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\t\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\t\n\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\tif ( geometry.index !== null ) {\n\t\n\t\t\t\t\t// Indexed BufferGeometry\n\t\n\t\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\tvar numEdges = 0;\n\t\n\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// allocate maximal size\n\t\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\t\n\t\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\t\n\t\t\t\t\t\tvar group = groups[ o ];\n\t\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\t\n\t\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// non-indexed BufferGeometry\n\t\n\t\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\t\tvar numTris = numEdges / 3;\n\t\n\t\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\t\n\t\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\t\n\t\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * Parametric Surfaces Geometry\n\t\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t\t */\n\t\n\t\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'ParametricBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t};\n\t\n\t\t\t// generate vertices and uvs\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\tvar i, j, p;\n\t\t\tvar u, v;\n\t\n\t\t\tvar sliceCount = slices + 1;\n\t\n\t\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\t\n\t\t\t\tv = i / stacks;\n\t\n\t\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\t\n\t\t\t\t\tu = j / slices;\n\t\n\t\t\t\t\tp = func( u, v );\n\t\t\t\t\tvertices.push( p.x, p.y, p.z );\n\t\n\t\t\t\t\tuvs.push( u, v );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tvar indices = [];\n\t\t\tvar a, b, c, d;\n\t\n\t\t\tfor ( i = 0; i < stacks; i ++ ) {\n\t\n\t\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\t\n\t\t\t\t\ta = i * sliceCount + j;\n\t\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\t\n\t\t\t\t\t// faces one and two\n\t\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\t\n\t\t\t// generate normals\n\t\n\t\t\tthis.computeVertexNormals();\n\t\n\t\t}\n\t\n\t\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\t\n\t\t/**\n\t\t * @author zz85 / https://github.com/zz85\n\t\t *\n\t\t * Parametric Surfaces Geometry\n\t\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t\t */\n\t\n\t\tfunction ParametricGeometry( func, slices, stacks ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ParametricGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\t\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'PolyhedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tradius = radius || 1;\n\t\t\tdetail = detail || 0;\n\t\n\t\t\t// default buffer data\n\t\n\t\t\tvar vertexBuffer = [];\n\t\t\tvar uvBuffer = [];\n\t\n\t\t\t// the subdivision creates the vertex buffer data\n\t\n\t\t\tsubdivide( detail );\n\t\n\t\t\t// all vertices should lie on a conceptual sphere with a given radius\n\t\n\t\t\tappplyRadius( radius );\n\t\n\t\t\t// finally, create the uv data\n\t\n\t\t\tgenerateUVs();\n\t\n\t\t\t// build non-indexed geometry\n\t\n\t\t\tthis.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );\n\t\t\tthis.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );\n\t\t\tthis.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );\n\t\t\tthis.normalizeNormals();\n\t\n\t\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction subdivide( detail ) {\n\t\n\t\t\t\tvar a = new Vector3();\n\t\t\t\tvar b = new Vector3();\n\t\t\t\tvar c = new Vector3();\n\t\n\t\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\t\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t// get the vertices of the face\n\t\n\t\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\t\n\t\t\t\t\t// perform subdivision\n\t\n\t\t\t\t\tsubdivideFace( a, b, c, detail );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction subdivideFace( a, b, c, detail ) {\n\t\n\t\t\t\tvar cols = Math.pow( 2, detail );\n\t\n\t\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\t\n\t\t\t\tvar v = [];\n\t\n\t\t\t\tvar i, j;\n\t\n\t\t\t\t// construct all of the vertices for this subdivision\n\t\n\t\t\t\tfor ( i = 0 ; i <= cols; i ++ ) {\n\t\n\t\t\t\t\tv[ i ] = [];\n\t\n\t\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\t\n\t\t\t\t\tvar rows = cols - i;\n\t\n\t\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\t\n\t\t\t\t\t\tif ( j === 0 && i === cols ) {\n\t\n\t\t\t\t\t\t\tv[ i ][ j ] = aj;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// construct all of the faces\n\t\n\t\t\t\tfor ( i = 0; i < cols ; i ++ ) {\n\t\n\t\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\t\n\t\t\t\t\t\tvar k = Math.floor( j / 2 );\n\t\n\t\t\t\t\t\tif ( j % 2 === 0 ) {\n\t\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction appplyRadius( radius ) {\n\t\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\t\n\t\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\t\n\t\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\t\n\t\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\t\n\t\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateUVs() {\n\t\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\t\n\t\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\t\n\t\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\t\tuvBuffer.push( u, 1 - v );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcorrectUVs();\n\t\n\t\t\t\tcorrectSeam();\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctSeam() {\n\t\n\t\t\t\t// handle case when face straddles the seam, see #3269\n\t\n\t\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\t\n\t\t\t\t\t// uv data of a single face\n\t\n\t\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\t\n\t\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\t\n\t\t\t\t\t// 0.9 is somewhat arbitrary\n\t\n\t\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\t\n\t\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushVertex( vertex ) {\n\t\n\t\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t}\n\t\n\t\t\tfunction getVertexByIndex( index, vertex ) {\n\t\n\t\t\t\tvar stride = index * 3;\n\t\n\t\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\t\tvertex.z = vertices[ stride + 2 ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctUVs() {\n\t\n\t\t\t\tvar a = new Vector3();\n\t\t\t\tvar b = new Vector3();\n\t\t\t\tvar c = new Vector3();\n\t\n\t\t\t\tvar centroid = new Vector3();\n\t\n\t\t\t\tvar uvA = new Vector2();\n\t\t\t\tvar uvB = new Vector2();\n\t\t\t\tvar uvC = new Vector2();\n\t\n\t\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\t\n\t\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\t\n\t\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\t\n\t\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\t\n\t\t\t\t\tvar azi = azimuth( centroid );\n\t\n\t\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctUV( uv, stride, vector, azimuth  ) {\n\t\n\t\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\t\n\t\t\t\t\tuvBuffer[ stride ] =  uv.x - 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\t\n\t\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\t\n\t\t\tfunction azimuth( vector ) {\n\t\n\t\t\t\treturn Math.atan2( vector.z, - vector.x );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Angle above the XZ plane.\n\t\n\t\t\tfunction inclination( vector ) {\n\t\n\t\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar vertices = [\n\t\t\t\t1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'TetrahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t */\n\t\n\t\tfunction TetrahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TetrahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction OctahedronBufferGeometry( radius,detail ) {\n\t\n\t\t\tvar vertices = [\n\t\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'OctahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t */\n\t\n\t\tfunction OctahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'OctahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\n\t\t\tvar vertices = [\n\t\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'IcosahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t */\n\t\n\t\tfunction IcosahedronGeometry( radius, detail ) {\n\t\n\t\t \tGeometry.call( this );\n\t\n\t\t\tthis.type = 'IcosahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\t\tvar r = 1 / t;\n\t\n\t\t\tvar vertices = [\n\t\n\t\t\t\t// (1, 1, 1)\n\t\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t\t 1,  1, - 1,     1,  1,  1,\n\t\n\t\t\t\t// (0, 1/, )\n\t\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t\t 0,  r, - t,     0,  r,  t,\n\t\n\t\t\t\t// (1/, , 0)\n\t\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t\t r, - t,  0,     r,  t,  0,\n\t\n\t\t\t\t// (, 0, 1/)\n\t\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t\t- t,  0,  r,     t,  0,  r\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'DodecahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Abe Pazos / https://hamoid.com\n\t\t */\n\t\n\t\tfunction DodecahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'DodecahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\t\n\t\t/**\n\t\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'PolyhedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * Creates a tube which extrudes along a 3d spline.\n\t\t *\n\t\t */\n\t\n\t\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TubeBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\n\t\t\ttubularSegments = tubularSegments || 64;\n\t\t\tradius = radius || 1;\n\t\t\tradialSegments = radialSegments || 8;\n\t\t\tclosed = closed || false;\n\t\n\t\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\t\n\t\t\t// expose internals\n\t\n\t\t\tthis.tangents = frames.tangents;\n\t\t\tthis.normals = frames.normals;\n\t\t\tthis.binormals = frames.binormals;\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\n\t\t\tvar i, j;\n\t\n\t\t\t// buffer\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\t\tvar indices = [];\n\t\n\t\t\t// create buffer data\n\t\n\t\t\tgenerateBufferData();\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', Float32Attribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\t\n\t\t\t// functions\n\t\n\t\t\tfunction generateBufferData() {\n\t\n\t\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tgenerateSegment( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t\t// at the regular position on the given path\n\t\t\t\t//\n\t\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\t\n\t\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\t\n\t\t\t\t// uvs are generated in a separate function.\n\t\t\t\t// this makes it easy compute correct values for closed geometries\n\t\n\t\t\t\tgenerateUVs();\n\t\n\t\t\t\t// finally create faces\n\t\n\t\t\t\tgenerateIndices();\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateSegment( i ) {\n\t\n\t\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\t\n\t\t\t\tvar P = path.getPointAt( i / tubularSegments );\n\t\n\t\t\t\t// retrieve corresponding normal and binormal\n\t\n\t\t\t\tvar N = frames.normals[ i ];\n\t\t\t\tvar B = frames.binormals[ i ];\n\t\n\t\t\t\t// generate normals and vertices for the current segment\n\t\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t\tvar sin =   Math.sin( v );\n\t\t\t\t\tvar cos = - Math.cos( v );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\t\tnormal.normalize();\n\t\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\t\tvertex.z = P.z + radius * normal.z;\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateIndices() {\n\t\n\t\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t\t\t// faces\n\t\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateUVs() {\n\t\n\t\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\t\tuv.y = j / radialSegments;\n\t\n\t\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t\t * @author WestLangley / https://github.com/WestLangley\n\t\t * @author zz85 / https://github.com/zz85\n\t\t * @author miningold / https://github.com/miningold\n\t\t * @author jonobr1 / https://github.com/jonobr1\n\t\t *\n\t\t * Creates a tube which extrudes along a 3d spline.\n\t\t */\n\t\n\t\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TubeGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\n\t\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\t\n\t\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\t\n\t\t\t// expose internals\n\t\n\t\t\tthis.tangents = bufferGeometry.tangents;\n\t\t\tthis.normals = bufferGeometry.normals;\n\t\t\tthis.binormals = bufferGeometry.binormals;\n\t\n\t\t\t// create geometry\n\t\n\t\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTubeGeometry.prototype.constructor = TubeGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t\t */\n\t\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusKnotBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\n\t\t\tradius = radius || 100;\n\t\t\ttube = tube || 40;\n\t\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\tp = p || 2;\n\t\t\tq = q || 3;\n\t\n\t\t\t// used to calculate buffer length\n\t\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// helper variables\n\t\t\tvar i, j, index = 0, indexOffset = 0;\n\t\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\n\t\t\tvar P1 = new Vector3();\n\t\t\tvar P2 = new Vector3();\n\t\n\t\t\tvar B = new Vector3();\n\t\t\tvar T = new Vector3();\n\t\t\tvar N = new Vector3();\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\t\n\t\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\t\n\t\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\t\n\t\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\t\n\t\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\t\n\t\t\t\t// calculate orthonormal basis\n\t\n\t\t\t\tT.subVectors( P2, P1 );\n\t\t\t\tN.addVectors( P2, P1 );\n\t\t\t\tB.crossVectors( T, N );\n\t\t\t\tN.crossVectors( B, T );\n\t\n\t\t\t\t// normalize B, N. T can be ignored, we don't use it\n\t\n\t\t\t\tB.normalize();\n\t\t\t\tN.normalize();\n\t\n\t\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\t\n\t\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\t\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\t\tvar cy = tube * Math.sin( v );\n\t\n\t\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\t\n\t\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\t// this function calculates the current position on the torus curve\n\t\n\t\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\t\n\t\t\t\tvar cu = Math.cos( u );\n\t\t\t\tvar su = Math.sin( u );\n\t\t\t\tvar quOverP = q / p * u;\n\t\t\t\tvar cs = Math.cos( quOverP );\n\t\n\t\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode\n\t\t */\n\t\n\t\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusKnotGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\n\t\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\t\n\t\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\n\t\t\tradius = radius || 100;\n\t\t\ttube = tube || 40;\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\t\tarc = arc || Math.PI * 2;\n\t\n\t\t\t// used to calculate buffer length\n\t\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t\t// offset variables\n\t\t\tvar vertexBufferOffset = 0;\n\t\t\tvar uvBufferOffset = 0;\n\t\t\tvar indexBufferOffset = 0;\n\t\n\t\t\t// helper variables\n\t\t\tvar center = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\n\t\t\tvar j, i;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\t\tvertex.z = tube * Math.sin( v );\n\t\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\t\n\t\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\t\n\t\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\t\n\t\t\t\t\t// update offsets\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t\t// update offset\n\t\t\t\t\tindexBufferOffset += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t\t */\n\t\n\t\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\t\n\t\t}\n\t\n\t\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTorusGeometry.prototype.constructor = TorusGeometry;\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tvar ShapeUtils = {\n\t\n\t\t\t// calculate area of the contour polygon\n\t\n\t\t\tarea: function ( contour ) {\n\t\n\t\t\t\tvar n = contour.length;\n\t\t\t\tvar a = 0.0;\n\t\n\t\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\t\n\t\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn a * 0.5;\n\t\n\t\t\t},\n\t\n\t\t\ttriangulate: ( function () {\n\t\n\t\t\t\t/**\n\t\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t\t * See original code and more information here:\n\t\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t\t *\n\t\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t\t * www.actionsnippet.com\n\t\t\t\t *\n\t\t\t\t * ported to javascript by Joshua Koo\n\t\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t\t *\n\t\t\t\t */\n\t\n\t\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\t\n\t\t\t\t\tvar p;\n\t\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\t\tvar cx, cy, px, py;\n\t\n\t\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\t\tay = contour[ verts[ u ] ].y;\n\t\n\t\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\t\tby = contour[ verts[ v ] ].y;\n\t\n\t\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\t\tcy = contour[ verts[ w ] ].y;\n\t\n\t\t\t\t\tif ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;\n\t\n\t\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\t\n\t\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\t\tcX = bx - ax;  cY = by - ay;\n\t\n\t\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\t\n\t\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\t\n\t\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\t\n\t\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\t\n\t\t\t\t\t\t// see if p is inside triangle abc\n\t\n\t\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\t\n\t\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// takes in an contour array and returns\n\t\n\t\t\t\treturn function triangulate( contour, indices ) {\n\t\n\t\t\t\t\tvar n = contour.length;\n\t\n\t\t\t\t\tif ( n < 3 ) return null;\n\t\n\t\t\t\t\tvar result = [],\n\t\t\t\t\t\tverts = [],\n\t\t\t\t\t\tvertIndices = [];\n\t\n\t\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\t\n\t\t\t\t\tvar u, v, w;\n\t\n\t\t\t\t\tif ( ShapeUtils.area( contour ) > 0.0 ) {\n\t\n\t\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar nv = n;\n\t\n\t\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\t\n\t\t\t\t\tvar count = 2 * nv;   /* error detection */\n\t\n\t\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\t\n\t\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\t\n\t\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\t\n\t\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\t\n\t\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\t\n\t\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\t\treturn result;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\t\n\t\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\t\n\t\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\t\n\t\t\t\t\t\t\tvar a, b, c, s, t;\n\t\n\t\t\t\t\t\t\t/* true names of the vertices */\n\t\n\t\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\t\tc = verts[ w ];\n\t\n\t\t\t\t\t\t\t/* output Triangle */\n\t\n\t\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\t\tcontour[ c ] ] );\n\t\n\t\n\t\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\t\n\t\t\t\t\t\t\t/* remove v from the remaining polygon */\n\t\n\t\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\t\n\t\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tnv --;\n\t\n\t\t\t\t\t\t\t/* reset error detection counter */\n\t\n\t\t\t\t\t\t\tcount = 2 * nv;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t}\n\t\n\t\t\t} )(),\n\t\n\t\t\ttriangulateShape: function ( contour, holes ) {\n\t\n\t\t\t\tfunction removeDupEndPts(points) {\n\t\n\t\t\t\t\tvar l = points.length;\n\t\n\t\t\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\t\t\tpoints.pop();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tremoveDupEndPts( contour );\n\t\t\t\tholes.forEach( removeDupEndPts );\n\t\n\t\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\t\n\t\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\t\n\t\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\t\n\t\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\t\n\t\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\t\n\t\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\t\n\t\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t// not parallel\n\t\n\t\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\t\tif ( limit > 0 ) {\n\t\n\t\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\t\n\t\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( perpSeg2 === limit ) {\n\t\n\t\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\t\n\t\t\t\t\t\t// return real intersection point\n\t\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\t\n\t\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t\t// both segments are points\n\t\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\t\n\t\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\t\tif ( seg1Pt ) {\n\t\n\t\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\t\tif ( seg2Pt ) {\n\t\n\t\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\t\tif ( seg1dx !== 0 ) {\n\t\n\t\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\t\n\t\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\t\n\t\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\t\treturn [ seg2min ];\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\t\n\t\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\t\treturn [ seg1min ];\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\t\n\t\t\t\t\t// The order of legs is important\n\t\n\t\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\t\n\t\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\t\n\t\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t// angle != 180 deg.\n\t\n\t\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\t\n\t\t\t\t\t\tif ( from2toAngle > 0 ) {\n\t\n\t\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tfunction removeHoles( contour, holes ) {\n\t\n\t\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\t\tvar hole;\n\t\n\t\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\t\n\t\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\t\n\t\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\t\n\t\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\t\n\t\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\t\n\t\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\t\n\t\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\t\n\t\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn\ttrue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\t\n\t\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar indepHoles = [];\n\t\n\t\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\t\n\t\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\t\ttmpHole1, tmpHole2;\n\t\n\t\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\t\tindepHoles.push( h );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\t\twhile ( indepHoles.length > 0 ) {\n\t\n\t\t\t\t\t\tcounter --;\n\t\t\t\t\t\tif ( counter < 0 ) {\n\t\n\t\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\t\n\t\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\t\tholeIndex\t= - 1;\n\t\n\t\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\t\n\t\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\t\n\t\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\t\n\t\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\t\n\t\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\t\n\t\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\t\n\t\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\t\n\t\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\t\n\t\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tvar i, il, f, face,\n\t\t\t\t\tkey, index,\n\t\t\t\t\tallPointsMap = {};\n\t\n\t\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\t\n\t\t\t\tvar allpoints = contour.concat();\n\t\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\t\n\t\t\t\t// prepare all points map\n\t\n\t\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\t\n\t\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tallPointsMap[ key ] = i;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\t\n\t\t\t\tvar triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\t\n\t\t\t\t// check all face vertices against all points map\n\t\n\t\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tface = triangles[ i ];\n\t\n\t\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\t\n\t\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\t\n\t\t\t\t\t\tindex = allPointsMap[ key ];\n\t\n\t\t\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\t\t\tface[ f ] = index;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn triangles.concat();\n\t\n\t\t\t},\n\t\n\t\t\tisClockWise: function ( pts ) {\n\t\n\t\t\t\treturn ShapeUtils.area( pts ) < 0;\n\t\n\t\t\t},\n\t\n\t\t\t// Bezier Curves formulas obtained from\n\t\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\t\n\t\t\t// Quad Bezier Functions\n\t\n\t\t\tb2: ( function () {\n\t\n\t\t\t\tfunction b2p0( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn k * k * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b2p1( t, p ) {\n\t\n\t\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b2p2( t, p ) {\n\t\n\t\t\t\t\treturn t * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function b2( t, p0, p1, p2 ) {\n\t\n\t\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\t// Cubic Bezier Functions\n\t\n\t\t\tb3: ( function () {\n\t\n\t\t\t\tfunction b3p0( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn k * k * k * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b3p1( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn 3 * k * k * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b3p2( t, p ) {\n\t\n\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\treturn 3 * k * t * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction b3p3( t, p ) {\n\t\n\t\t\t\t\treturn t * t * t * p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t * Creates extruded geometry from a path shape.\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *  curveSegments: <int>, // number of points on the curves\n\t\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t\t *  amount: <int>, // Depth to extrude the shape\n\t\t *\n\t\t *  bevelEnabled: <bool>, // turn on bevel\n\t\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t\t *  bevelSegments: <int>, // number of bevel layers\n\t\t *\n\t\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t\t *\n\t\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t\t *\n\t\t * }\n\t\t **/\n\t\n\t\tfunction ExtrudeGeometry( shapes, options ) {\n\t\n\t\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\t\n\t\t\t\tshapes = [];\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ExtrudeGeometry';\n\t\n\t\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\t\n\t\t\tthis.addShapeList( shapes, options );\n\t\n\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t// can't really use automatic vertex normals\n\t\t\t// as then front and back sides get smoothed too\n\t\t\t// should do separate smoothing just for sides\n\t\n\t\t\t//this.computeVertexNormals();\n\t\n\t\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\t\n\t\t}\n\t\n\t\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\t\n\t\tExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\t\tvar sl = shapes.length;\n\t\n\t\t\tfor ( var s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\tvar shape = shapes[ s ];\n\t\t\t\tthis.addShape( shape, options );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\t\n\t\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\t\n\t\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\t\n\t\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\n\t\t\tvar extrudePath = options.extrudePath;\n\t\t\tvar extrudePts, extrudeByPath = false;\n\t\n\t\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\t\n\t\t\tvar splineTube, binormal, normal, position2;\n\t\t\tif ( extrudePath ) {\n\t\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\t\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\t\n\t\t\t\t// SETUP TNB variables\n\t\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\t\n\t\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\t\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\t\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\t\n\t\t\t}\n\t\n\t\t\t// Safeguards if bevels are not enabled\n\t\n\t\t\tif ( ! bevelEnabled ) {\n\t\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\n\t\t\t}\n\t\n\t\t\t// Variables initialization\n\t\n\t\t\tvar ahole, h, hl; // looping of holes\n\t\t\tvar scope = this;\n\t\n\t\t\tvar shapesOffset = this.vertices.length;\n\t\n\t\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\t\tvar vertices = shapePoints.shape;\n\t\t\tvar holes = shapePoints.holes;\n\t\n\t\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\t\n\t\t\tif ( reverse ) {\n\t\n\t\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\t\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t\t/* Vertices */\n\t\n\t\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\tvertices = vertices.concat( ahole );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\t\n\t\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\t\n\t\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\t\n\t\t\t}\n\t\n\t\t\tvar b, bs, t, z,\n\t\t\t\tvert, vlen = vertices.length,\n\t\t\t\tface, flen = faces.length;\n\t\n\t\n\t\t\t// Find directions for point movement\n\t\n\t\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\t\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\t\n\t\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\t\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\t\n\t\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\t\n\t\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\t\n\t\t\t\t// check for collinear edges\n\t\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t// not collinear\n\t\n\t\t\t\t\t// length of vectors for normalizing\n\t\n\t\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\t\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\t\n\t\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\t\n\t\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\t\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\t\n\t\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\t\t// vector from inPt to intersection point\n\t\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\t\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\t\n\t\t\t\t\t\treturn\tnew Vector2( v_trans_x, v_trans_y );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// handle special case of collinear edges\n\t\n\t\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\t\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( direction_eq ) {\n\t\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn\tnew Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar contourMovements = [];\n\t\n\t\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\t\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\t\n\t\t\t}\n\t\n\t\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\toneHoleMovements = [];\n\t\n\t\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\t\n\t\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\t\n\t\t\t\tt = b / bevelSegments;\n\t\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\t\n\t\t\t\t// contract shape\n\t\n\t\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// expand holes\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tbs = bevelSize;\n\t\n\t\t\t// Back facing vertices\n\t\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\t\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\t\n\t\t\tvar s;\n\t\n\t\t\tfor ( s = 1; s <= steps; s ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\t\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Add bevel segments planes\n\t\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\t\n\t\t\t\tt = b / bevelSegments;\n\t\t\t\tz = bevelThickness * Math.cos ( t * Math.PI / 2 );\n\t\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\t\n\t\t\t\t// contract shape\n\t\n\t\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// expand holes\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t/* Faces */\n\t\n\t\t\t// Top and bottom faces\n\t\n\t\t\tbuildLidFaces();\n\t\n\t\t\t// Sides faces\n\t\n\t\t\tbuildSideFaces();\n\t\n\t\n\t\t\t/////  Internal functions\n\t\n\t\t\tfunction buildLidFaces() {\n\t\n\t\t\t\tif ( bevelEnabled ) {\n\t\n\t\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\t\tvar offset = vlen * layer;\n\t\n\t\t\t\t\t// Bottom faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\t\n\t\t\t\t\t// Top faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Bottom faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Top faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Create faces for the z-sides of the shape\n\t\n\t\t\tfunction buildSideFaces() {\n\t\n\t\t\t\tvar layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\t\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\t\n\t\t\t\tvar j, k;\n\t\t\t\ti = contour.length;\n\t\n\t\t\t\twhile ( -- i >= 0 ) {\n\t\n\t\t\t\t\tj = i;\n\t\t\t\t\tk = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\t\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\t\n\t\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\t\n\t\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\t\n\t\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\t\n\t\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction v( x, y, z ) {\n\t\n\t\t\t\tscope.vertices.push( new Vector3( x, y, z ) );\n\t\n\t\t\t}\n\t\n\t\t\tfunction f3( a, b, c ) {\n\t\n\t\t\t\ta += shapesOffset;\n\t\t\t\tb += shapesOffset;\n\t\t\t\tc += shapesOffset;\n\t\n\t\t\t\tscope.faces.push( new Face3( a, b, c, null, null, 0 ) );\n\t\n\t\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\t\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\t\n\t\t\t}\n\t\n\t\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\t\n\t\t\t\ta += shapesOffset;\n\t\t\t\tb += shapesOffset;\n\t\t\t\tc += shapesOffset;\n\t\t\t\td += shapesOffset;\n\t\n\t\t\t\tscope.faces.push( new Face3( a, b, d, null, null, 1 ) );\n\t\t\t\tscope.faces.push( new Face3( b, c, d, null, null, 1 ) );\n\t\n\t\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\t\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tExtrudeGeometry.WorldUVGenerator = {\n\t\n\t\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\t\n\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\tvar a = vertices[ indexA ];\n\t\t\t\tvar b = vertices[ indexB ];\n\t\t\t\tvar c = vertices[ indexC ];\n\t\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.x, a.y ),\n\t\t\t\t\tnew Vector2( b.x, b.y ),\n\t\t\t\t\tnew Vector2( c.x, c.y )\n\t\t\t\t];\n\t\n\t\t\t},\n\t\n\t\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\t\n\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\tvar a = vertices[ indexA ];\n\t\t\t\tvar b = vertices[ indexB ];\n\t\t\t\tvar c = vertices[ indexC ];\n\t\t\t\tvar d = vertices[ indexD ];\n\t\n\t\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\t\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew Vector2( a.x, 1 - a.z ),\n\t\t\t\t\t\tnew Vector2( b.x, 1 - b.z ),\n\t\t\t\t\t\tnew Vector2( c.x, 1 - c.z ),\n\t\t\t\t\t\tnew Vector2( d.x, 1 - d.z )\n\t\t\t\t\t];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew Vector2( a.y, 1 - a.z ),\n\t\t\t\t\t\tnew Vector2( b.y, 1 - b.z ),\n\t\t\t\t\t\tnew Vector2( c.y, 1 - c.z ),\n\t\t\t\t\t\tnew Vector2( d.y, 1 - d.z )\n\t\t\t\t\t];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * Text = 3D Text\n\t\t *\n\t\t * parameters = {\n\t\t *  font: <THREE.Font>, // font\n\t\t *\n\t\t *  size: <float>, // size of the text\n\t\t *  height: <float>, // thickness to extrude text\n\t\t *  curveSegments: <int>, // number of points on the curves\n\t\t *\n\t\t *  bevelEnabled: <bool>, // turn on bevel\n\t\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t\t *  bevelSize: <float> // how far from text outline is bevel\n\t\t * }\n\t\t */\n\t\n\t\tfunction TextGeometry( text, parameters ) {\n\t\n\t\t\tparameters = parameters || {};\n\t\n\t\t\tvar font = parameters.font;\n\t\n\t\t\tif ( (font && font.isFont) === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\t\treturn new Geometry();\n\t\n\t\t\t}\n\t\n\t\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\t\n\t\t\t// translate parameters to ExtrudeGeometry API\n\t\n\t\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\t\n\t\t\t// defaults\n\t\n\t\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\t\n\t\t\tExtrudeGeometry.call( this, shapes, parameters );\n\t\n\t\t\tthis.type = 'TextGeometry';\n\t\n\t\t}\n\t\n\t\tTextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );\n\t\tTextGeometry.prototype.constructor = TextGeometry;\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t * based on THREE.SphereGeometry\n\t\t */\n\t\n\t\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'SphereBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tradius = radius || 50;\n\t\n\t\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\t\n\t\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\t\n\t\t\tvar thetaEnd = thetaStart + thetaLength;\n\t\n\t\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\t\n\t\t\tvar positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\tvar index = 0, vertices = [], normal = new Vector3();\n\t\n\t\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\t\tvar verticesRow = [];\n\t\n\t\t\t\tvar v = y / heightSegments;\n\t\n\t\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\t\n\t\t\t\t\tvar u = x / widthSegments;\n\t\n\t\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\n\t\t\t\t\tnormal.set( px, py, pz ).normalize();\n\t\n\t\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\t\tverticesRow.push( index );\n\t\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvertices.push( verticesRow );\n\t\n\t\t\t}\n\t\n\t\t\tvar indices = [];\n\t\n\t\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\t\n\t\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\t\n\t\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\t\tthis.addAttribute( 'position', positions );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\t\n\t\t}\n\t\n\t\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'SphereGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\t\n\t\t}\n\t\n\t\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\t\tSphereGeometry.prototype.constructor = SphereGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'RingBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tinnerRadius = innerRadius || 20;\n\t\t\touterRadius = outerRadius || 50;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\t\n\t\t\t// these are used to calculate buffer length\n\t\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// some helper variables\n\t\t\tvar index = 0, indexOffset = 0, segment;\n\t\t\tvar radius = innerRadius;\n\t\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\t\tvar j, i;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t// values are generate from the inside of the ring to the outside\n\t\n\t\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\t\n\t\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// increase the radius for next row of vertices\n\t\t\t\tradius += radiusStep;\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\t\n\t\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\t\n\t\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\t\n\t\t\t\t\tsegment = i + thetaSegmentLevel;\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = segment;\n\t\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\t\tvar d = segment + 1;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t}\n\t\n\t\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Kaleb Murphy\n\t\t */\n\t\n\t\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'RingGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\t\n\t\t}\n\t\n\t\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\t\tRingGeometry.prototype.constructor = RingGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t\t */\n\t\n\t\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'PlaneGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\t\n\t\t}\n\t\n\t\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\t\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t // points - to create a closed torus, one must use a set of points\n\t\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t\t // segments - the number of circumference segments to create\n\t\t // phiStart - the starting radian\n\t\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t\t //    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\t\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'LatheBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\n\t\t\tsegments = Math.floor( segments ) || 12;\n\t\t\tphiStart = phiStart || 0;\n\t\t\tphiLength = phiLength || Math.PI * 2;\n\t\n\t\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\t\n\t\t\t// these are used to calculate buffer length\n\t\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\t\tvar indexCount = segments * points.length * 2 * 3;\n\t\n\t\t\t// buffers\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// helper variables\n\t\t\tvar index = 0, indexOffset = 0, base;\n\t\t\tvar inverseSegments = 1.0 / segments;\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\t\tvar i, j;\n\t\n\t\t\t// generate vertices and uvs\n\t\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\t\n\t\t\t\tvar sin = Math.sin( phi );\n\t\t\t\tvar cos = Math.cos( phi );\n\t\n\t\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = i / segments;\n\t\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( i = 0; i < segments; i ++ ) {\n\t\n\t\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t\tbase = j + i * points.length;\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = base;\n\t\t\t\t\tvar b = base + points.length;\n\t\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\t\tvar d = base + 1;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\t// generate normals\n\t\n\t\t\tthis.computeVertexNormals();\n\t\n\t\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t\t// because the corresponding vertices are identical (but still have different UVs).\n\t\n\t\t\tif( phiLength === Math.PI * 2 ) {\n\t\n\t\t\t\tvar normals = this.attributes.normal.array;\n\t\t\t\tvar n1 = new Vector3();\n\t\t\t\tvar n2 = new Vector3();\n\t\t\t\tvar n = new Vector3();\n\t\n\t\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\t\tbase = segments * points.length * 3;\n\t\n\t\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\t\n\t\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\t\tn1.z = normals[ j + 2 ];\n\t\n\t\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\t\tn2.z = normals[ base + j + 2 ];\n\t\n\t\t\t\t\t// average normals\n\t\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\t\n\t\t\t\t\t// assign the new values to both normals\n\t\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\t\n\t\t\t\t} // next row\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\t\n\t\t/**\n\t\t * @author astrodud / http://astrodud.isgreat.org/\n\t\t * @author zz85 / https://github.com/zz85\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\t// points - to create a closed torus, one must use a set of points\n\t\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t\t// segments - the number of circumference segments to create\n\t\t// phiStart - the starting radian\n\t\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t\t//    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\t\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'LatheGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\t\tLatheGeometry.prototype.constructor = LatheGeometry;\n\t\n\t\t/**\n\t\t * @author jonobr1 / http://jonobr1.com\n\t\t *\n\t\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t\t * ExtrudeGeometry.\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t\t *\n\t\t *\tmaterial: <int> // material index for front and back faces\n\t\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t\t *\n\t\t * }\n\t\t **/\n\t\n\t\tfunction ShapeGeometry( shapes, options ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ShapeGeometry';\n\t\n\t\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\t\n\t\t\tthis.addShapeList( shapes, options );\n\t\n\t\t\tthis.computeFaceNormals();\n\t\n\t\t}\n\t\n\t\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\t\n\t\t/**\n\t\t * Add an array of shapes to THREE.ShapeGeometry.\n\t\t */\n\t\tShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\t\n\t\t\t\tthis.addShape( shapes[ i ], options );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t\t */\n\t\tShapeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\t\tif ( options === undefined ) options = {};\n\t\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\t\tvar material = options.material;\n\t\t\tvar uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\t\n\t\t\t//\n\t\n\t\t\tvar i, l, hole;\n\t\n\t\t\tvar shapesOffset = this.vertices.length;\n\t\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\t\tvar vertices = shapePoints.shape;\n\t\t\tvar holes = shapePoints.holes;\n\t\n\t\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\t\n\t\t\tif ( reverse ) {\n\t\n\t\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\t\n\t\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\thole = holes[ i ];\n\t\n\t\t\t\t\tif ( ShapeUtils.isClockWise( hole ) ) {\n\t\n\t\t\t\t\t\tholes[ i ] = hole.reverse();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treverse = false;\n\t\n\t\t\t}\n\t\n\t\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t\t// Vertices\n\t\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\t\thole = holes[ i ];\n\t\t\t\tvertices = vertices.concat( hole );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar vert, vlen = vertices.length;\n\t\t\tvar face, flen = faces.length;\n\t\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\tvert = vertices[ i ];\n\t\n\t\t\t\tthis.vertices.push( new Vector3( vert.x, vert.y, 0 ) );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\tface = faces[ i ];\n\t\n\t\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\t\tvar c = face[ 2 ] + shapesOffset;\n\t\n\t\t\t\tthis.faces.push( new Face3( a, b, c, null, null, material ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\t\n\t\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\t\n\t\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\t\treturn a - b;\n\t\n\t\t\t}\n\t\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\tvar geometry2;\n\t\n\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\t\n\t\t\t\tgeometry2 = new Geometry();\n\t\t\t\tgeometry2.fromBufferGeometry( geometry );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgeometry2 = geometry.clone();\n\t\n\t\t\t}\n\t\n\t\t\tgeometry2.mergeVertices();\n\t\t\tgeometry2.computeFaceNormals();\n\t\n\t\t\tvar vertices = geometry2.vertices;\n\t\t\tvar faces = geometry2.faces;\n\t\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\thash[ key ].face2 = i;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar coords = [];\n\t\n\t\t\tfor ( var key in hash ) {\n\t\n\t\t\t\tvar h = hash[ key ];\n\t\n\t\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\t\n\t\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\t\tcoords.push( vertex.x );\n\t\t\t\t\tcoords.push( vertex.y );\n\t\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\t\tcoords.push( vertex.x );\n\t\t\t\t\tcoords.push( vertex.y );\n\t\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );\n\t\n\t\t}\n\t\n\t\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'CylinderBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\t\theight = height !== undefined ? height : 100;\n\t\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\n\t\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\t\n\t\t\t// used to calculate buffer length\n\t\n\t\t\tvar nbCap = 0;\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\t\n\t\t\t}\n\t\n\t\t\tvar vertexCount = calculateVertexCount();\n\t\t\tvar indexCount = calculateIndexCount();\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar index = 0,\n\t\t\t    indexOffset = 0,\n\t\t\t    indexArray = [],\n\t\t\t    halfHeight = height / 2;\n\t\n\t\t\t// group variables\n\t\t\tvar groupStart = 0;\n\t\n\t\t\t// generate geometry\n\t\n\t\t\tgenerateTorso();\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', vertices );\n\t\t\tthis.addAttribute( 'normal', normals );\n\t\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction calculateVertexCount() {\n\t\n\t\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\t\n\t\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn count;\n\t\n\t\t\t}\n\t\n\t\t\tfunction calculateIndexCount() {\n\t\n\t\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\t\n\t\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\t\tcount += radialSegments * nbCap * 3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn count;\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateTorso() {\n\t\n\t\t\t\tvar x, y;\n\t\t\t\tvar normal = new Vector3();\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\t// this will be used to calculate the normal\n\t\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\t\n\t\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\t\t\tvar indexRow = [];\n\t\n\t\t\t\t\tvar v = y / heightSegments;\n\t\n\t\t\t\t\t// calculate the radius of the current row\n\t\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\t\n\t\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\t\tvar u = x / radialSegments;\n\t\n\t\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\n\t\t\t\t\t\t// vertex\n\t\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t\t// uv\n\t\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\t\tindexRow.push( index );\n\t\n\t\t\t\t\t\t// increase index\n\t\t\t\t\t\tindex ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\t\tindexArray.push( indexRow );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// generate indices\n\t\n\t\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\t\n\t\t\t\t\t\t// face one\n\t\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t\t// face two\n\t\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t\t// update counters\n\t\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateCap( top ) {\n\t\n\t\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\t\n\t\t\t\tvar uv = new Vector2();\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\t\n\t\t\t\t// save the index of the first center vertex\n\t\t\t\tcenterIndexStart = index;\n\t\n\t\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t\t// we must generate a center vertex per face/segment\n\t\n\t\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = 0.5;\n\t\t\t\t\tuv.y = 0.5;\n\t\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// save the index of the last center vertex\n\t\t\t\tcenterIndexEnd = index;\n\t\n\t\t\t\t// now we generate the surrounding vertices, normals and uvs\n\t\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar u = x / radialSegments;\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// generate indices\n\t\n\t\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\t\tvar i = centerIndexEnd + x;\n\t\n\t\t\t\t\tif ( top === true ) {\n\t\n\t\t\t\t\t\t// face top\n\t\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// face bottom\n\t\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'CylinderGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\t\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\t\n\t\t/**\n\t\t * @author abelnation / http://github.com/abelnation\n\t\t */\n\t\n\t\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\t\n\t\t\tthis.type = 'ConeGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\t\tConeGeometry.prototype.constructor = ConeGeometry;\n\t\n\t\t/**\n\t\t * @author: abelnation / http://github.com/abelnation\n\t\t */\n\t\n\t\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\t\n\t\t\tthis.type = 'ConeBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\t\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'CircleBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tradius = radius || 50;\n\t\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\t\tvar vertices = segments + 2;\n\t\n\t\t\tvar positions = new Float32Array( vertices * 3 );\n\t\t\tvar normals = new Float32Array( vertices * 3 );\n\t\t\tvar uvs = new Float32Array( vertices * 2 );\n\t\n\t\t\t// center data is already zero, but need to set a few extras\n\t\t\tnormals[ 2 ] = 1.0;\n\t\t\tuvs[ 0 ] = 0.5;\n\t\t\tuvs[ 1 ] = 0.5;\n\t\n\t\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\t\n\t\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\t\n\t\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\t\n\t\t\t\tnormals[ i + 2 ] = 1; // normal z\n\t\n\t\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\t\n\t\t\t}\n\t\n\t\t\tvar indices = [];\n\t\n\t\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\tindices.push( i, i + 1, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\t\n\t\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\t\n\t\t}\n\t\n\t\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\t\n\t\t/**\n\t\t * @author hughes\n\t\t */\n\t\n\t\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'CircleGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\t\n\t\t}\n\t\n\t\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\t\tCircleGeometry.prototype.constructor = CircleGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t\t */\n\t\n\t\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'BoxGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\t\tBoxGeometry.prototype.constructor = BoxGeometry;\n\t\n\t\n\t\n\t\tvar Geometries = Object.freeze({\n\t\t\tWireframeGeometry: WireframeGeometry,\n\t\t\tParametricGeometry: ParametricGeometry,\n\t\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\t\tOctahedronGeometry: OctahedronGeometry,\n\t\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\t\tTubeGeometry: TubeGeometry,\n\t\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\t\tTorusGeometry: TorusGeometry,\n\t\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\t\tTextGeometry: TextGeometry,\n\t\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\t\tSphereGeometry: SphereGeometry,\n\t\t\tRingGeometry: RingGeometry,\n\t\t\tRingBufferGeometry: RingBufferGeometry,\n\t\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\t\tPlaneGeometry: PlaneGeometry,\n\t\t\tLatheGeometry: LatheGeometry,\n\t\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\t\tShapeGeometry: ShapeGeometry,\n\t\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\t\tEdgesGeometry: EdgesGeometry,\n\t\t\tConeGeometry: ConeGeometry,\n\t\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\t\tCylinderGeometry: CylinderGeometry,\n\t\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\t\tCircleGeometry: CircleGeometry,\n\t\t\tBoxBufferGeometry: BoxBufferGeometry,\n\t\t\tBoxGeometry: BoxGeometry\n\t\t});\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ShadowMaterial() {\n\t\n\t\t\tShaderMaterial.call( this, {\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib[ \"lights\" ],\n\t\t\t\t\t{\n\t\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t\t}\n\t\t\t\t] ),\n\t\t\t\tvertexShader: ShaderChunk[ 'shadow_vert' ],\n\t\t\t\tfragmentShader: ShaderChunk[ 'shadow_frag' ]\n\t\t\t} );\n\t\n\t\t\tthis.lights = true;\n\t\t\tthis.transparent = true;\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\topacity: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t\t},\n\t\t\t\t\tset: function ( value ) {\n\t\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\t\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\t\n\t\tShadowMaterial.prototype.isShadowMaterial = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction RawShaderMaterial( parameters ) {\n\t\n\t\t\tShaderMaterial.call( this, parameters );\n\t\n\t\t\tthis.type = 'RawShaderMaterial';\n\t\n\t\t}\n\t\n\t\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\t\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\t\n\t\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction MultiMaterial( materials ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.type = 'MultiMaterial';\n\t\n\t\t\tthis.materials = materials instanceof Array ? materials : [];\n\t\n\t\t\tthis.visible = true;\n\t\n\t\t}\n\t\n\t\tMultiMaterial.prototype = {\n\t\n\t\t\tconstructor: MultiMaterial,\n\t\n\t\t\tisMultiMaterial: true,\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar output = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.2,\n\t\t\t\t\t\ttype: 'material',\n\t\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t\t},\n\t\t\t\t\tuuid: this.uuid,\n\t\t\t\t\ttype: this.type,\n\t\t\t\t\tmaterials: []\n\t\t\t\t};\n\t\n\t\t\t\tvar materials = this.materials;\n\t\n\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\t\tdelete material.metadata;\n\t\n\t\t\t\t\toutput.materials.push( material );\n\t\n\t\t\t\t}\n\t\n\t\t\t\toutput.visible = this.visible;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\tvar material = new this.constructor();\n\t\n\t\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\t\n\t\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterial.visible = this.visible;\n\t\n\t\t\t\treturn material;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  roughness: <float>,\n\t\t *  metalness: <float>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  bumpMap: new THREE.Texture( <Image> ),\n\t\t *  bumpScale: <float>,\n\t\t *\n\t\t *  normalMap: new THREE.Texture( <Image> ),\n\t\t *  normalScale: <Vector2>,\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  envMapIntensity: <float>\n\t\t *\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshStandardMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\t\tthis.type = 'MeshStandardMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\t\tthis.roughness = 0.5;\n\t\t\tthis.metalness = 0.5;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalScale = new Vector2( 1, 1 );\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.roughnessMap = null;\n\t\n\t\t\tthis.metalnessMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.envMapIntensity = 1.0;\n\t\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\t\n\t\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\t\n\t\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.roughness = source.roughness;\n\t\t\tthis.metalness = source.metalness;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.roughnessMap = source.roughnessMap;\n\t\n\t\t\tthis.metalnessMap = source.metalnessMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.envMapIntensity = source.envMapIntensity;\n\t\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *  reflectivity: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshPhysicalMaterial( parameters ) {\n\t\n\t\t\tMeshStandardMaterial.call( this );\n\t\n\t\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\t\tthis.type = 'MeshPhysicalMaterial';\n\t\n\t\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\t\n\t\t\tthis.clearCoat = 0.0;\n\t\t\tthis.clearCoatRoughness = 0.0;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\t\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\t\n\t\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\t\n\t\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\n\t\t\tthis.clearCoat = source.clearCoat;\n\t\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  specular: <hex>,\n\t\t *  shininess: <float>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  bumpMap: new THREE.Texture( <Image> ),\n\t\t *  bumpScale: <float>,\n\t\t *\n\t\t *  normalMap: new THREE.Texture( <Image> ),\n\t\t *  normalScale: <Vector2>,\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshPhongMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshPhongMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\t\tthis.specular = new Color( 0x111111 );\n\t\t\tthis.shininess = 30;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalScale = new Vector2( 1, 1 );\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\t\n\t\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\t\n\t\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.specular.copy( source.specular );\n\t\t\tthis.shininess = source.shininess;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshNormalMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this, parameters );\n\t\n\t\t\tthis.type = 'MeshNormalMaterial';\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\t\n\t\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\t\n\t\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshLambertMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshLambertMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\t\n\t\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\t\n\t\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  linewidth: <float>,\n\t\t *\n\t\t *  scale: <float>,\n\t\t *  dashSize: <float>,\n\t\t *  gapSize: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction LineDashedMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'LineDashedMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.linewidth = 1;\n\t\n\t\t\tthis.scale = 1;\n\t\t\tthis.dashSize = 3;\n\t\t\tthis.gapSize = 1;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tLineDashedMaterial.prototype = Object.create( Material.prototype );\n\t\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\t\n\t\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\t\n\t\tLineDashedMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.linewidth = source.linewidth;\n\t\n\t\t\tthis.scale = source.scale;\n\t\t\tthis.dashSize = source.dashSize;\n\t\t\tthis.gapSize = source.gapSize;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\n\t\n\t\tvar Materials = Object.freeze({\n\t\t\tShadowMaterial: ShadowMaterial,\n\t\t\tSpriteMaterial: SpriteMaterial,\n\t\t\tRawShaderMaterial: RawShaderMaterial,\n\t\t\tShaderMaterial: ShaderMaterial,\n\t\t\tPointsMaterial: PointsMaterial,\n\t\t\tMultiMaterial: MultiMaterial,\n\t\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\t\tLineDashedMaterial: LineDashedMaterial,\n\t\t\tLineBasicMaterial: LineBasicMaterial,\n\t\t\tMaterial: Material\n\t\t});\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar Cache = {\n\t\n\t\t\tenabled: false,\n\t\n\t\t\tfiles: {},\n\t\n\t\t\tadd: function ( key, file ) {\n\t\n\t\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\t\n\t\t\t\tthis.files[ key ] = file;\n\t\n\t\t\t},\n\t\n\t\t\tget: function ( key ) {\n\t\n\t\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\t\n\t\t\t\treturn this.files[ key ];\n\t\n\t\t\t},\n\t\n\t\t\tremove: function ( key ) {\n\t\n\t\t\t\tdelete this.files[ key ];\n\t\n\t\t\t},\n\t\n\t\t\tclear: function () {\n\t\n\t\t\t\tthis.files = {};\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\t\n\t\t\tthis.onStart = undefined;\n\t\t\tthis.onLoad = onLoad;\n\t\t\tthis.onProgress = onProgress;\n\t\t\tthis.onError = onError;\n\t\n\t\t\tthis.itemStart = function ( url ) {\n\t\n\t\t\t\titemsTotal ++;\n\t\n\t\t\t\tif ( isLoading === false ) {\n\t\n\t\t\t\t\tif ( scope.onStart !== undefined ) {\n\t\n\t\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tisLoading = true;\n\t\n\t\t\t};\n\t\n\t\t\tthis.itemEnd = function ( url ) {\n\t\n\t\t\t\titemsLoaded ++;\n\t\n\t\t\t\tif ( scope.onProgress !== undefined ) {\n\t\n\t\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( itemsLoaded === itemsTotal ) {\n\t\n\t\t\t\t\tisLoading = false;\n\t\n\t\t\t\t\tif ( scope.onLoad !== undefined ) {\n\t\n\t\t\t\t\t\tscope.onLoad();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.itemError = function ( url ) {\n\t\n\t\t\t\tif ( scope.onError !== undefined ) {\n\t\n\t\t\t\t\tscope.onError( url );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tvar DefaultLoadingManager = new LoadingManager();\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction XHRLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( XHRLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( url === undefined ) url = '';\n\t\n\t\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar cached = Cache.get( url );\n\t\n\t\t\t\tif ( cached !== undefined ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\tsetTimeout( function () {\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, 0 );\n\t\n\t\t\t\t\treturn cached;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Check for data: URI\n\t\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\t\n\t\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\t\tif ( dataUriRegexResult ) {\n\t\n\t\t\t\t\tvar mimeType = dataUriRegexResult[1];\n\t\t\t\t\tvar isBase64 = !!dataUriRegexResult[2];\n\t\t\t\t\tvar data = dataUriRegexResult[3];\n\t\n\t\t\t\t\tdata = window.decodeURIComponent(data);\n\t\n\t\t\t\t\tif( isBase64 ) {\n\t\t\t\t\t\tdata = window.atob(data);\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tvar response;\n\t\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\t\n\t\t\t\t\t\tswitch ( responseType ) {\n\t\n\t\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\t\tcase 'blob':\n\t\n\t\t\t\t\t\t\t \tresponse = new ArrayBuffer( data.length );\n\t\t\t\t\t\t\t\tvar view = new Uint8Array( response );\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\t\n\t\t\t\t\t\t\t\t\tresponse = new Blob( [ response ], { \"type\" : mimeType } );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'document':\n\t\n\t\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'json':\n\t\n\t\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tdefault: // 'text' or other\n\t\n\t\t\t\t\t\t\t\tresponse = data;\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\t\twindow.setTimeout( function() {\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t}, 0);\n\t\n\t\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\t\twindow.setTimeout( function() {\n\t\n\t\t\t\t\t\t\tif ( onError ) onError( error );\n\t\n\t\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t\t}, 0);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\t\trequest.open( 'GET', url, true );\n\t\n\t\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\t\n\t\t\t\t\t\tvar response = event.target.response;\n\t\n\t\t\t\t\t\tCache.add( url, response );\n\t\n\t\t\t\t\t\tif ( this.status === 200 ) {\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t} else if ( this.status === 0 ) {\n\t\n\t\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, false );\n\t\n\t\t\t\t\tif ( onProgress !== undefined ) {\n\t\n\t\t\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\t\n\t\t\t\t\t\t\tonProgress( event );\n\t\n\t\t\t\t\t\t}, false );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\t\n\t\t\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t}, false );\n\t\n\t\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\t\n\t\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );\n\t\n\t\t\t\t\trequest.send( null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\treturn request;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetResponseType: function ( value ) {\n\t\n\t\t\t\tthis.responseType = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t *\n\t\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t\t */\n\t\n\t\tfunction CompressedTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\t// override in sub classes\n\t\t\tthis._parser = null;\n\t\n\t\t}\n\t\n\t\tObject.assign( CompressedTextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar images = [];\n\t\n\t\t\t\tvar texture = new CompressedTexture();\n\t\t\t\ttexture.image = images;\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\t\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\tloaded += 1;\n\t\n\t\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( Array.isArray( url ) ) {\n\t\n\t\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\t\n\t\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\t\n\t\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\t\tif ( texDatas.isCubemap ) {\n\t\n\t\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\t\n\t\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\t\n\t\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\t\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author Nikos M. / https://github.com/foo123/\n\t\t *\n\t\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t\t */\n\t\n\t\tvar DataTextureLoader = BinaryTextureLoader;\n\t\tfunction BinaryTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\t// override in sub classes\n\t\t\tthis._parser = null;\n\t\n\t\t}\n\t\n\t\tObject.assign( BinaryTextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar texture = new DataTexture();\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar texData = scope._parser( buffer );\n\t\n\t\t\t\t\tif ( ! texData ) return;\n\t\n\t\t\t\t\tif ( undefined !== texData.image ) {\n\t\n\t\t\t\t\t\ttexture.image = texData.image;\n\t\n\t\t\t\t\t} else if ( undefined !== texData.data ) {\n\t\n\t\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\t\ttexture.image.data = texData.data;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\t\n\t\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\t\n\t\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\t\n\t\t\t\t\tif ( undefined !== texData.format ) {\n\t\n\t\t\t\t\t\ttexture.format = texData.format;\n\t\n\t\t\t\t\t}\n\t\t\t\t\tif ( undefined !== texData.type ) {\n\t\n\t\t\t\t\t\ttexture.type = texData.type;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\t\n\t\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\t\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ImageLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( ImageLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\t\timage.onload = function () {\n\t\n\t\t\t\t\timage.onload = null;\n\t\n\t\t\t\t\tURL.revokeObjectURL( image.src );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( image );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t};\n\t\t\t\timage.onerror = onError;\n\t\n\t\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\t\n\t\t\t\t\timage.src = url;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar loader = new XHRLoader();\n\t\t\t\t\tloader.setPath( this.path );\n\t\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\t\tloader.load( url, function ( blob ) {\n\t\n\t\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CubeTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( CubeTextureLoader.prototype, {\n\t\n\t\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar texture = new CubeTexture();\n\t\n\t\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\t\tloader.setPath( this.path );\n\t\n\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\t\n\t\t\t\t\t\ttexture.images[ i ] = image;\n\t\n\t\t\t\t\t\tloaded ++;\n\t\n\t\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, undefined, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\t\n\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction TextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( TextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar texture = new Texture();\n\t\n\t\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.load( url, function ( image ) {\n\t\n\t\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\t\n\t\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\t\ttexture.image = image;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) {\n\t\n\t\t\t\t\t\tonLoad( texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Light( color, intensity ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Light';\n\t\n\t\t\tthis.color = new Color( color );\n\t\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\t\n\t\t\tthis.receiveShadow = undefined;\n\t\n\t\t}\n\t\n\t\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Light,\n\t\n\t\t\tisLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.color.copy( source.color );\n\t\t\t\tthis.intensity = source.intensity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.color = this.color.getHex();\n\t\t\t\tdata.object.intensity = this.intensity;\n\t\n\t\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\t\n\t\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\t\n\t\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\t\n\t\t\tLight.call( this, skyColor, intensity );\n\t\n\t\t\tthis.type = 'HemisphereLight';\n\t\n\t\t\tthis.castShadow = undefined;\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.groundColor = new Color( groundColor );\n\t\n\t\t}\n\t\n\t\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: HemisphereLight,\n\t\n\t\t\tisHemisphereLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.groundColor.copy( source.groundColor );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LightShadow( camera ) {\n\t\n\t\t\tthis.camera = camera;\n\t\n\t\t\tthis.bias = 0;\n\t\t\tthis.radius = 1;\n\t\n\t\t\tthis.mapSize = new Vector2( 512, 512 );\n\t\n\t\t\tthis.map = null;\n\t\t\tthis.matrix = new Matrix4();\n\t\n\t\t}\n\t\n\t\tObject.assign( LightShadow.prototype, {\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.camera = source.camera.clone();\n\t\n\t\t\t\tthis.bias = source.bias;\n\t\t\t\tthis.radius = source.radius;\n\t\n\t\t\t\tthis.mapSize.copy( source.mapSize );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar object = {};\n\t\n\t\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\t\n\t\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\t\tdelete object.camera.matrix;\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction SpotLightShadow() {\n\t\n\t\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\t\n\t\t\tconstructor: SpotLightShadow,\n\t\n\t\t\tisSpotLightShadow: true,\n\t\n\t\t\tupdate: function ( light ) {\n\t\n\t\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\t\tvar far = light.distance || 500;\n\t\n\t\t\t\tvar camera = this.camera;\n\t\n\t\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\t\n\t\t\t\t\tcamera.fov = fov;\n\t\t\t\t\tcamera.aspect = aspect;\n\t\t\t\t\tcamera.far = far;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'SpotLight';\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.target = new Object3D();\n\t\n\t\t\tObject.defineProperty( this, 'power', {\n\t\t\t\tget: function () {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t\t},\n\t\t\t\tset: function ( power ) {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\t\tthis.shadow = new SpotLightShadow();\n\t\n\t\t}\n\t\n\t\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: SpotLight,\n\t\n\t\t\tisSpotLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.distance = source.distance;\n\t\t\t\tthis.angle = source.angle;\n\t\t\t\tthis.penumbra = source.penumbra;\n\t\t\t\tthis.decay = source.decay;\n\t\n\t\t\t\tthis.target = source.target.clone();\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\n\t\tfunction PointLight( color, intensity, distance, decay ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'PointLight';\n\t\n\t\t\tObject.defineProperty( this, 'power', {\n\t\t\t\tget: function () {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\treturn this.intensity * 4 * Math.PI;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( power ) {\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: PointLight,\n\t\n\t\t\tisPointLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.distance = source.distance;\n\t\t\t\tthis.decay = source.decay;\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction DirectionalLightShadow( light ) {\n\t\n\t\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\t\n\t\t\tconstructor: DirectionalLightShadow\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction DirectionalLight( color, intensity ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'DirectionalLight';\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.target = new Object3D();\n\t\n\t\t\tthis.shadow = new DirectionalLightShadow();\n\t\n\t\t}\n\t\n\t\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: DirectionalLight,\n\t\n\t\t\tisDirectionalLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.target = source.target.clone();\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AmbientLight( color, intensity ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'AmbientLight';\n\t\n\t\t\tthis.castShadow = undefined;\n\t\n\t\t}\n\t\n\t\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: AmbientLight,\n\t\n\t\t\tisAmbientLight: true,\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t */\n\t\n\t\tvar AnimationUtils = {\n\t\n\t\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\t\tarraySlice: function( array, from, to ) {\n\t\n\t\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\t\n\t\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array.slice( from, to );\n\t\n\t\t\t},\n\t\n\t\t\t// converts an array to a specific type\n\t\t\tconvertArray: function( array, type, forceClone ) {\n\t\n\t\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\t\n\t\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\t\n\t\t\t\t\treturn new type( array ); // create typed array\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\t\n\t\t\t},\n\t\n\t\t\tisTypedArray: function( object ) {\n\t\n\t\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t\t! ( object instanceof DataView );\n\t\n\t\t\t},\n\t\n\t\t\t// returns an array by which times and values can be sorted\n\t\t\tgetKeyframeOrder: function( times ) {\n\t\n\t\t\t\tfunction compareTime( i, j ) {\n\t\n\t\t\t\t\treturn times[ i ] - times[ j ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar n = times.length;\n\t\t\t\tvar result = new Array( n );\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\t\n\t\t\t\tresult.sort( compareTime );\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\t\tsortedArray: function( values, stride, order ) {\n\t\n\t\t\t\tvar nValues = values.length;\n\t\t\t\tvar result = new values.constructor( nValues );\n\t\n\t\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\t\n\t\t\t\t\tvar srcOffset = order[ i ] * stride;\n\t\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// function for parsing AOS keyframe formats\n\t\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\t\n\t\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\t\n\t\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( key === undefined ) return; // no data\n\t\n\t\t\t\tvar value = key[ valuePropertyName ];\n\t\t\t\tif ( value === undefined ) return; // no data\n\t\n\t\t\t\tif ( Array.isArray( value ) ) {\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t\t// ...assume THREE.Math-ish\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalue.toArray( values, values.length );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise push as-is\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalues.push( value );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Abstract base class of interpolants over parametric samples.\n\t\t *\n\t\t * The parameter domain is one dimensional, typically the time or a path\n\t\t * along a curve defined by the data.\n\t\t *\n\t\t * The sample values can have any dimensionality and derived classes may\n\t\t * apply special interpretations to the data.\n\t\t *\n\t\t * This class provides the interval seek in a Template Method, deferring\n\t\t * the actual interpolation to derived classes.\n\t\t *\n\t\t * Time complexity is O(1) for linear access crossing at most two points\n\t\t * and O(log N) for random access, where N is the number of positions.\n\t\t *\n\t\t * References:\n\t\t *\n\t\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction Interpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tthis.parameterPositions = parameterPositions;\n\t\t\tthis._cachedIndex = 0;\n\t\n\t\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\t\tthis.sampleValues = sampleValues;\n\t\t\tthis.valueSize = sampleSize;\n\t\n\t\t}\n\t\n\t\tInterpolant.prototype = {\n\t\n\t\t\tconstructor: Interpolant,\n\t\n\t\t\tevaluate: function( t ) {\n\t\n\t\t\t\tvar pp = this.parameterPositions,\n\t\t\t\t\ti1 = this._cachedIndex,\n\t\n\t\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\tvalidate_interval: {\n\t\n\t\t\t\t\tseek: {\n\t\n\t\t\t\t\t\tvar right;\n\t\n\t\t\t\t\t\tlinear_scan: {\n\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t//- slower code:\n\t\t//-\n\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\t\n\t\t\t\t\t\t\t\t\t\t// after end\n\t\n\t\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t//- slower code:\n\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\t\n\t\t\t\t\t\t\t\t// looping?\n\t\n\t\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( t < t1global ) {\n\t\n\t\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\t\tt0 = t1global;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// linear reverse scan\n\t\n\t\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// before start\n\t\n\t\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// the interval is valid\n\t\n\t\t\t\t\t\t\tbreak validate_interval;\n\t\n\t\t\t\t\t\t} // linear scan\n\t\n\t\t\t\t\t\t// binary search\n\t\n\t\t\t\t\t\twhile ( i1 < right ) {\n\t\n\t\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\t\n\t\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\t\n\t\t\t\t\t\t\t\tright = mid;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\ti1 = mid + 1;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\t\t\t// check boundary cases, again\n\t\n\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} // seek\n\t\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\n\t\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\t\n\t\t\t\t} // validate_interval\n\t\n\t\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\t\n\t\t\t},\n\t\n\t\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t\t// Note: The indirection allows central control of many interpolants.\n\t\n\t\t\t// --- Protected interface\n\t\n\t\t\tDefaultSettings_: {},\n\t\n\t\t\tgetSettings_: function() {\n\t\n\t\t\t\treturn this.settings || this.DefaultSettings_;\n\t\n\t\t\t},\n\t\n\t\t\tcopySampleValue_: function( index ) {\n\t\n\t\t\t\t// copies a sample value to the result buffer\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\toffset = index * stride;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] = values[ offset + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// Template methods for derived classes:\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t\t// implementations shall return this.resultBuffer\n\t\n\t\t\t},\n\t\n\t\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\t\t// empty\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Interpolant.prototype, {\n\t\n\t\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\t\tInterpolant.prototype.copySampleValue_,\n\t\n\t\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\t\tInterpolant.prototype.copySampleValue_\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Fast and simple cubic spline interpolant.\n\t\t *\n\t\t * It was derived from a Hermitian construction setting the first derivative\n\t\t * at each sample position to the linear slope between neighboring positions\n\t\t * over their parameter interval.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction CubicInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t\tthis._weightPrev = -0;\n\t\t\tthis._offsetPrev = -0;\n\t\t\tthis._weightNext = -0;\n\t\t\tthis._offsetNext = -0;\n\t\n\t\t}\n\t\n\t\tCubicInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: CubicInterpolant,\n\t\n\t\t\tDefaultSettings_: {\n\t\n\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\n\t\t\t},\n\t\n\t\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\t\tvar pp = this.parameterPositions,\n\t\t\t\t\tiPrev = i1 - 2,\n\t\t\t\t\tiNext = i1 + 1,\n\t\n\t\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\t\ttNext = pp[ iNext ];\n\t\n\t\t\t\tif ( tPrev === undefined ) {\n\t\n\t\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\t\n\t\t\t\t\t\tcase ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase WrapAroundEnding:\n\t\n\t\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\t\ttPrev = t1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tNext === undefined ) {\n\t\n\t\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\t\n\t\t\t\t\t\tcase ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase WrapAroundEnding:\n\t\n\t\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\t\ttNext = t0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\t\tstride = this.valueSize;\n\t\n\t\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\t\tthis._offsetNext = iNext * stride;\n\t\n\t\t\t},\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\t\n\t\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\t\tpp = p * p,\n\t\t\t\t\tppp = pp * p;\n\t\n\t\t\t\t// evaluate polynomials\n\t\n\t\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\t\n\t\t\t\t// combine data linearly\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] =\n\t\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\t\tsN * values[ oN + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction LinearInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tLinearInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: LinearInterpolant,\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toffset1 = i1 * stride,\n\t\t\t\t\toffset0 = offset1 - stride,\n\t\n\t\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\t\tweight0 = 1 - weight1;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] =\n\t\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Interpolant that evaluates to the sample value at the position preceeding\n\t\t * the parameter.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction DiscreteInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tDiscreteInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: DiscreteInterpolant,\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar KeyframeTrackPrototype;\n\t\n\t\tKeyframeTrackPrototype = {\n\t\n\t\t\tTimeBufferType: Float32Array,\n\t\t\tValueBufferType: Float32Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateLinear,\n\t\n\t\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\t\n\t\t\t\treturn new DiscreteInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\t\treturn new LinearInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\t\n\t\t\t\treturn new CubicInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tsetInterpolation: function( interpolation ) {\n\t\n\t\t\t\tvar factoryMethod;\n\t\n\t\t\t\tswitch ( interpolation ) {\n\t\n\t\t\t\t\tcase InterpolateDiscrete:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase InterpolateLinear:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase InterpolateSmooth:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( factoryMethod === undefined ) {\n\t\n\t\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\t\n\t\t\t\t\tif ( this.createInterpolant === undefined ) {\n\t\n\t\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tconsole.warn( message );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.createInterpolant = factoryMethod;\n\t\n\t\t\t},\n\t\n\t\t\tgetInterpolation: function() {\n\t\n\t\t\t\tswitch ( this.createInterpolant ) {\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\t\n\t\t\t\t\t\treturn InterpolateDiscrete;\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\t\n\t\t\t\t\t\treturn InterpolateLinear;\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\t\n\t\t\t\t\t\treturn InterpolateSmooth;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetValueSize: function() {\n\t\n\t\t\t\treturn this.values.length / this.times.length;\n\t\n\t\t\t},\n\t\n\t\t\t// move all keyframes either forwards or backwards in time\n\t\t\tshift: function( timeOffset ) {\n\t\n\t\t\t\tif( timeOffset !== 0.0 ) {\n\t\n\t\t\t\t\tvar times = this.times;\n\t\n\t\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\ttimes[ i ] += timeOffset;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\t\tscale: function( timeScale ) {\n\t\n\t\t\t\tif( timeScale !== 1.0 ) {\n\t\n\t\t\t\t\tvar times = this.times;\n\t\n\t\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\ttimes[ i ] *= timeScale;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\t\ttrim: function( startTime, endTime ) {\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tnKeys = times.length,\n\t\t\t\t\tfrom = 0,\n\t\t\t\t\tto = nKeys - 1;\n\t\n\t\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\t\n\t\t\t\t++ to; // inclusive -> exclusive bound\n\t\n\t\t\t\tif( from !== 0 || to !== nKeys ) {\n\t\n\t\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\t\n\t\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\t\tthis.values = AnimationUtils.\n\t\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\t\tvalidate: function() {\n\t\n\t\t\t\tvar valid = true;\n\t\n\t\t\t\tvar valueSize = this.getValueSize();\n\t\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\t\n\t\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\t\tvalid = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tvalues = this.values,\n\t\n\t\t\t\t\tnKeys = times.length;\n\t\n\t\t\t\tif( nKeys === 0 ) {\n\t\n\t\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\t\tvalid = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar prevTime = null;\n\t\n\t\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\t\n\t\t\t\t\tvar currTime = times[ i ];\n\t\n\t\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\t\n\t\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\t\n\t\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprevTime = currTime;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( values !== undefined ) {\n\t\n\t\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tvar value = values[ i ];\n\t\n\t\t\t\t\t\t\tif ( isNaN( value ) ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn valid;\n\t\n\t\t\t},\n\t\n\t\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\t\toptimize: function() {\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tvalues = this.values,\n\t\t\t\t\tstride = this.getValueSize(),\n\t\n\t\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\t\n\t\t\t\t\twriteIndex = 1,\n\t\t\t\t\tlastIndex = times.length - 1;\n\t\n\t\t\t\tfor( var i = 1; i < lastIndex; ++ i ) {\n\t\n\t\t\t\t\tvar keep = false;\n\t\n\t\t\t\t\tvar time = times[ i ];\n\t\t\t\t\tvar timeNext = times[ i + 1 ];\n\t\n\t\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\t\n\t\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\t\n\t\t\t\t\t\tif ( ! smoothInterpolation ) {\n\t\n\t\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\n\t\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\t\toffsetN = offset + stride;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\t\n\t\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\t\n\t\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else keep = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// in-place compaction\n\t\n\t\t\t\t\tif ( keep ) {\n\t\n\t\t\t\t\t\tif ( i !== writeIndex ) {\n\t\n\t\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\t\n\t\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j )\n\t\n\t\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// flush last keyframe (compaction looks ahead)\n\t\n\t\t\t\tif ( lastIndex > 0 ) {\n\t\n\t\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\t\n\t\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )\n\t\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( writeIndex !== times.length ) {\n\t\n\t\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tfunction KeyframeTrackConstructor( name, times, values, interpolation ) {\n\t\n\t\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\t\n\t\t\tif( times === undefined || times.length === 0 ) {\n\t\n\t\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\t\n\t\t\t}\n\t\n\t\t\tthis.name = name;\n\t\n\t\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\t\n\t\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\t\n\t\t\tthis.validate();\n\t\t\tthis.optimize();\n\t\n\t\t}\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of vectored keyframe values.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tVectorKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: VectorKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'vector'\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Spherical linear unit quaternion interpolant.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction QuaternionLinearInterpolant(\n\t\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call(\n\t\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tQuaternionLinearInterpolant.prototype =\n\t\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: QuaternionLinearInterpolant,\n\t\n\t\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toffset = i1 * stride,\n\t\n\t\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\t\n\t\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\t\n\t\t\t\t\tQuaternion.slerpFlat( result, 0,\n\t\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of quaternion keyframe values.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tQuaternionKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: QuaternionKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'quaternion',\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\tDefaultInterpolation: InterpolateLinear,\n\t\n\t\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\t\treturn new QuaternionLinearInterpolant(\n\t\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of numeric keyframe values.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tNumberKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: NumberKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'number',\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track that interpolates Strings\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tStringKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: StringKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'string',\n\t\t\tValueBufferType: Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateDiscrete,\n\t\n\t\t\tInterpolantFactoryMethodLinear: undefined,\n\t\n\t\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of Boolean keyframe values.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction BooleanKeyframeTrack( name, times, values ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values );\n\t\n\t\t}\n\t\n\t\tBooleanKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: BooleanKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'bool',\n\t\t\tValueBufferType: Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateDiscrete,\n\t\n\t\t\tInterpolantFactoryMethodLinear: undefined,\n\t\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t\t// Note: Actually this track could have a optimized / compressed\n\t\t\t// representation of a single value and a custom interpolant that\n\t\t\t// computes \"firstValue ^ isOdd( index )\".\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of keyframe values that represent color.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tColorKeyframeTrack.prototype =\n\t\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\t\n\t\t\tconstructor: ColorKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'color'\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\n\t\t\t// Note: Very basic implementation and nothing special yet.\n\t\t\t// However, this is the place for color space parameterization.\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A timed sequence of keyframes for a specific property.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrackConstructor.apply( this, arguments );\n\t\n\t\t}\n\t\n\t\tKeyframeTrack.prototype = KeyframeTrackPrototype;\n\t\tKeyframeTrackPrototype.constructor = KeyframeTrack;\n\t\n\t\t// Static methods:\n\t\n\t\tObject.assign( KeyframeTrack, {\n\t\n\t\t\t// Serialization (in static context, because of constructor invocation\n\t\t\t// and automatic invocation of .toJSON):\n\t\n\t\t\tparse: function( json ) {\n\t\n\t\t\t\tif( json.type === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\t\n\t\t\t\tif ( json.times === undefined ) {\n\t\n\t\t\t\t\tvar times = [], values = [];\n\t\n\t\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\t\n\t\t\t\t\tjson.times = times;\n\t\t\t\t\tjson.values = values;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// derived classes can define a static parse method\n\t\t\t\tif ( trackType.parse !== undefined ) {\n\t\n\t\t\t\t\treturn trackType.parse( json );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\t\treturn new trackType(\n\t\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function( track ) {\n\t\n\t\t\t\tvar trackType = track.constructor;\n\t\n\t\t\t\tvar json;\n\t\n\t\t\t\t// derived classes can define a static toJSON method\n\t\t\t\tif ( trackType.toJSON !== undefined ) {\n\t\n\t\t\t\t\tjson = trackType.toJSON( track );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\t\tjson = {\n\t\n\t\t\t\t\t\t'name': track.name,\n\t\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t\tvar interpolation = track.getInterpolation();\n\t\n\t\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\tjson.interpolation = interpolation;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tjson.type = track.ValueTypeName; // mandatory\n\t\n\t\t\t\treturn json;\n\t\n\t\t\t},\n\t\n\t\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\t\n\t\t\t\tswitch( typeName.toLowerCase() ) {\n\t\n\t\t\t\t\tcase \"scalar\":\n\t\t\t\t\tcase \"double\":\n\t\t\t\t\tcase \"float\":\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\tcase \"integer\":\n\t\n\t\t\t\t\t\treturn NumberKeyframeTrack;\n\t\n\t\t\t\t\tcase \"vector\":\n\t\t\t\t\tcase \"vector2\":\n\t\t\t\t\tcase \"vector3\":\n\t\t\t\t\tcase \"vector4\":\n\t\n\t\t\t\t\t\treturn VectorKeyframeTrack;\n\t\n\t\t\t\t\tcase \"color\":\n\t\n\t\t\t\t\t\treturn ColorKeyframeTrack;\n\t\n\t\t\t\t\tcase \"quaternion\":\n\t\n\t\t\t\t\t\treturn QuaternionKeyframeTrack;\n\t\n\t\t\t\t\tcase \"bool\":\n\t\t\t\t\tcase \"boolean\":\n\t\n\t\t\t\t\t\treturn BooleanKeyframeTrack;\n\t\n\t\t\t\t\tcase \"string\":\n\t\n\t\t\t\t\t\treturn StringKeyframeTrack;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Reusable set of Tracks that represent an animation.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t */\n\t\n\t\tfunction AnimationClip( name, duration, tracks ) {\n\t\n\t\t\tthis.name = name;\n\t\t\tthis.tracks = tracks;\n\t\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\t// this means it should figure out its duration by scanning the tracks\n\t\t\tif ( this.duration < 0 ) {\n\t\n\t\t\t\tthis.resetDuration();\n\t\n\t\t\t}\n\t\n\t\t\tthis.optimize();\n\t\n\t\t}\n\t\n\t\tAnimationClip.prototype = {\n\t\n\t\t\tconstructor: AnimationClip,\n\t\n\t\t\tresetDuration: function() {\n\t\n\t\t\t\tvar tracks = this.tracks,\n\t\t\t\t\tduration = 0;\n\t\n\t\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar track = this.tracks[ i ];\n\t\n\t\t\t\t\tduration = Math.max(\n\t\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.duration = duration;\n\t\n\t\t\t},\n\t\n\t\t\ttrim: function() {\n\t\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\toptimize: function() {\n\t\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\t\tthis.tracks[ i ].optimize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// Static methods:\n\t\n\t\tObject.assign( AnimationClip, {\n\t\n\t\t\tparse: function( json ) {\n\t\n\t\t\t\tvar tracks = [],\n\t\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\t\n\t\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\t\n\t\t\t},\n\t\n\t\n\t\t\ttoJSON: function( clip ) {\n\t\n\t\t\t\tvar tracks = [],\n\t\t\t\t\tclipTracks = clip.tracks;\n\t\n\t\t\t\tvar json = {\n\t\n\t\t\t\t\t'name': clip.name,\n\t\t\t\t\t'duration': clip.duration,\n\t\t\t\t\t'tracks': tracks\n\t\n\t\t\t\t};\n\t\n\t\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn json;\n\t\n\t\t\t},\n\t\n\t\n\t\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\t\n\t\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\t\tvar tracks = [];\n\t\n\t\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\t\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\ttimes.push(\n\t\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\t\n\t\t\t\t\tvalues.push( 0, 1, 0 );\n\t\n\t\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\t\n\t\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\t\n\t\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\t\tvalues.push( values[ 0 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttracks.push(\n\t\t\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t\t}\n\t\n\t\t\t\treturn new AnimationClip( name, -1, tracks );\n\t\n\t\t\t},\n\t\n\t\t\tfindByName: function( objectOrClipArray, name ) {\n\t\n\t\t\t\tvar clipArray = objectOrClipArray;\n\t\n\t\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\t\n\t\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\t\n\t\t\t\t\tif ( clipArray[ i ].name === name ) {\n\t\n\t\t\t\t\t\treturn clipArray[ i ];\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\t\n\t\t\t\tvar animationToMorphTargets = {};\n\t\n\t\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\t\n\t\t\t\t// sort morph target names into animation groups based\n\t\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\t\n\t\t\t\t\tif ( parts && parts.length > 1 ) {\n\t\n\t\t\t\t\t\tvar name = parts[ 1 ];\n\t\n\t\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\t\tif ( ! animationMorphTargets ) {\n\t\n\t\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar clips = [];\n\t\n\t\t\t\tfor ( var name in animationToMorphTargets ) {\n\t\n\t\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn clips;\n\t\n\t\t\t},\n\t\n\t\t\t// parse the animation.hierarchy format\n\t\t\tparseAnimation: function( animation, bones ) {\n\t\n\t\t\t\tif ( ! animation ) {\n\t\n\t\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\t\n\t\t\t\t\t// only return track if there are actually keys.\n\t\t\t\t\tif ( animationKeys.length !== 0 ) {\n\t\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\tAnimationUtils.flattenJSON(\n\t\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\t\n\t\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\t\tif ( times.length !== 0 ) {\n\t\n\t\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar tracks = [];\n\t\n\t\t\t\tvar clipName = animation.name || 'default';\n\t\t\t\t// automatic length determination in AnimationClip.\n\t\t\t\tvar duration = animation.length || -1;\n\t\t\t\tvar fps = animation.fps || 30;\n\t\n\t\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\t\n\t\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\t\n\t\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\t\n\t\t\t\t\t// skip empty tracks\n\t\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\t\n\t\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\t\n\t\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\t\n\t\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\t\n\t\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\t\n\t\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\t\n\t\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// ...assume skeletal animation\n\t\n\t\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tracks.length === 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\t\n\t\t\t\treturn clip;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction MaterialLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\t\tthis.textures = {};\n\t\n\t\t}\n\t\n\t\tObject.assign( MaterialLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTextures: function ( value ) {\n\t\n\t\t\t\tthis.textures = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tvar textures = this.textures;\n\t\n\t\t\t\tfunction getTexture( name ) {\n\t\n\t\t\t\t\tif ( textures[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn textures[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar material = new Materials[ json.type ]();\n\t\n\t\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\t\n\t\t\t\t// for PointsMaterial\n\t\n\t\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\t\n\t\t\t\t// maps\n\t\n\t\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\n\t\t\t\tif ( json.alphaMap !== undefined ) {\n\t\n\t\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\t\tmaterial.transparent = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\t\n\t\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\t\tif ( json.normalScale !== undefined ) {\n\t\n\t\t\t\t\tvar normalScale = json.normalScale;\n\t\n\t\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\t\n\t\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\t\n\t\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\t\n\t\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\t\n\t\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\t\n\t\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\n\t\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\n\t\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\n\t\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\t\n\t\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\t\n\t\t\t\t// MultiMaterial\n\t\n\t\t\t\tif ( json.materials !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn material;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferGeometryLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( BufferGeometryLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\t\tvar index = json.data.index;\n\t\n\t\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t\t'Float64Array': Float64Array\n\t\t\t\t};\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = json.data.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\t\n\t\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\t\n\t\t\t\tif ( groups !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingSphere = json.data.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== undefined ) {\n\t\n\t\t\t\t\tvar center = new Vector3();\n\t\n\t\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\t\n\t\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Loader() {\n\t\n\t\t\tthis.onLoadStart = function () {};\n\t\t\tthis.onLoadProgress = function () {};\n\t\t\tthis.onLoadComplete = function () {};\n\t\n\t\t}\n\t\n\t\tLoader.prototype = {\n\t\n\t\t\tconstructor: Loader,\n\t\n\t\t\tcrossOrigin: undefined,\n\t\n\t\t\textractUrlBase: function ( url ) {\n\t\n\t\t\t\tvar parts = url.split( '/' );\n\t\n\t\t\t\tif ( parts.length === 1 ) return './';\n\t\n\t\t\t\tparts.pop();\n\t\n\t\t\t\treturn parts.join( '/' ) + '/';\n\t\n\t\t\t},\n\t\n\t\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\t\n\t\t\t\tvar array = [];\n\t\n\t\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\t\n\t\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tcreateMaterial: ( function () {\n\t\n\t\t\t\tvar color, textureLoader, materialLoader;\n\t\n\t\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\t\n\t\t\t\t\tif ( color === undefined ) color = new Color();\n\t\t\t\t\tif ( textureLoader === undefined ) textureLoader = new TextureLoader();\n\t\t\t\t\tif ( materialLoader === undefined ) materialLoader = new MaterialLoader();\n\t\n\t\t\t\t\t// convert from old material format\n\t\n\t\t\t\t\tvar textures = {};\n\t\n\t\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\t\n\t\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\t\n\t\t\t\t\t\tvar texture;\n\t\n\t\t\t\t\t\tif ( loader !== null ) {\n\t\n\t\t\t\t\t\t\ttexture = loader.load( fullPath );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( repeat !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\t\n\t\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( offset !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( wrap !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( anisotropy !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar uuid = _Math.generateUUID();\n\t\n\t\t\t\t\t\ttextures[ uuid ] = texture;\n\t\n\t\t\t\t\t\treturn uuid;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tvar json = {\n\t\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t\t};\n\t\n\t\t\t\t\tfor ( var name in m ) {\n\t\n\t\t\t\t\t\tvar value = m[ name ];\n\t\n\t\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\t\n\t\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\t\n\t\t\t\t\tmaterialLoader.setTextures( textures );\n\t\n\t\t\t\t\treturn materialLoader.parse( json );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t};\n\t\n\t\tLoader.Handlers = {\n\t\n\t\t\thandlers: [],\n\t\n\t\t\tadd: function ( regex, loader ) {\n\t\n\t\t\t\tthis.handlers.push( regex, loader );\n\t\n\t\t\t},\n\t\n\t\t\tget: function ( file ) {\n\t\n\t\t\t\tvar handlers = this.handlers;\n\t\n\t\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\t\tvar loader  = handlers[ i + 1 ];\n\t\n\t\t\t\t\tif ( regex.test( file ) ) {\n\t\n\t\t\t\t\t\treturn loader;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction JSONLoader( manager ) {\n\t\n\t\t\tif ( typeof manager === 'boolean' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\t\tmanager = undefined;\n\t\n\t\t\t}\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\tthis.withCredentials = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( JSONLoader.prototype, {\n\t\n\t\t\tload: function( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\t\tvar metadata = json.metadata;\n\t\n\t\t\t\t\tif ( metadata !== undefined ) {\n\t\n\t\t\t\t\t\tvar type = metadata.type;\n\t\n\t\t\t\t\t\tif ( type !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\t\tonLoad( object.geometry, object.materials );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\t\tthis.texturePath = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json, texturePath ) {\n\t\n\t\t\t\tvar geometry = new Geometry(),\n\t\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\t\n\t\t\t\tparseModel( scale );\n\t\n\t\t\t\tparseSkin();\n\t\t\t\tparseMorphing( scale );\n\t\t\t\tparseAnimations();\n\t\n\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\tfunction parseModel( scale ) {\n\t\n\t\t\t\t\tfunction isBitSet( value, position ) {\n\t\n\t\t\t\t\t\treturn value & ( 1 << position );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar i, j, fi,\n\t\n\t\t\t\t\toffset, zLength,\n\t\n\t\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\t\n\t\t\t\t\ttype,\n\t\t\t\t\tisQuad,\n\t\t\t\t\thasMaterial,\n\t\t\t\t\thasFaceVertexUv,\n\t\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\t\thasFaceColor, hasFaceVertexColor,\n\t\n\t\t\t\tvertex, face, faceA, faceB, hex, normal,\n\t\n\t\t\t\t\tuvLayer, uv, u, v,\n\t\n\t\t\t\t\tfaces = json.faces,\n\t\t\t\t\tvertices = json.vertices,\n\t\t\t\t\tnormals = json.normals,\n\t\t\t\t\tcolors = json.colors,\n\t\n\t\t\t\t\tnUvLayers = 0;\n\t\n\t\t\t\t\tif ( json.uvs !== undefined ) {\n\t\n\t\t\t\t\t\t// disregard empty arrays\n\t\n\t\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tzLength = vertices.length;\n\t\n\t\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\t\tvertex = new Vector3();\n\t\n\t\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\t\n\t\t\t\t\t\tgeometry.vertices.push( vertex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tzLength = faces.length;\n\t\n\t\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\t\ttype = faces[ offset ++ ];\n\t\n\t\n\t\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\t\n\t\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\t\n\t\t\t\t\t\tif ( isQuad ) {\n\t\n\t\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\t\toffset += 4;\n\t\n\t\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\t\n\t\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t\t);\n\t\n\t\n\t\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\t\tgeometry.faces.push( faceB );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\n\t\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.faces.push( face );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseSkin() {\n\t\n\t\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\t\n\t\t\t\t\tif ( json.skinWeights ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.skinIndices ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.bones = json.bones;\n\t\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseMorphing( scale ) {\n\t\n\t\t\t\t\tif ( json.morphTargets !== undefined ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\t\n\t\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\t\n\t\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\t\n\t\t\t\t\t\t\t\tdstVertices.push( vertex );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\t\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseAnimations() {\n\t\n\t\t\t\t\tvar outputAnimations = [];\n\t\n\t\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\t\tvar animations = [];\n\t\n\t\t\t\t\tif ( json.animation !== undefined ) {\n\t\n\t\t\t\t\t\tanimations.push( json.animation );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.animations !== undefined ) {\n\t\n\t\t\t\t\t\tif ( json.animations.length ) {\n\t\n\t\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tanimations.push( json.animations );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// parse implicit morph animations\n\t\t\t\t\tif ( geometry.morphTargets ) {\n\t\n\t\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\t\n\t\t\t\t\treturn { geometry: geometry };\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\t\n\t\t\t\t\treturn { geometry: geometry, materials: materials };\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ObjectLoader ( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\t\tthis.texturePath = '';\n\t\n\t\t}\n\t\n\t\tObject.assign( ObjectLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( this.texturePath === '' ) {\n\t\n\t\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\t\tthis.texturePath = value;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json, onLoad ) {\n\t\n\t\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\t\n\t\t\t\tvar images = this.parseImages( json.images, function () {\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t\t} );\n\t\n\t\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\t\n\t\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\t\n\t\t\t\tif ( json.animations ) {\n\t\n\t\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t},\n\t\n\t\t\tparseGeometries: function ( json ) {\n\t\n\t\t\t\tvar geometries = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar geometry;\n\t\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\t\tcase 'RingBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'BufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'Geometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\t\n\t\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgeometry.uuid = data.uuid;\n\t\n\t\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\n\t\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometries;\n\t\n\t\t\t},\n\t\n\t\t\tparseMaterials: function ( json, textures ) {\n\t\n\t\t\t\tvar materials = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\t\tloader.setTextures( textures );\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\t\tmaterials[ material.uuid ] = material;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn materials;\n\t\n\t\t\t},\n\t\n\t\t\tparseAnimations: function ( json ) {\n\t\n\t\t\t\tvar animations = [];\n\t\n\t\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\t\n\t\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\t\n\t\t\t\t\tanimations.push( clip );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn animations;\n\t\n\t\t\t},\n\t\n\t\t\tparseImages: function ( json, onLoad ) {\n\t\n\t\t\t\tvar scope = this;\n\t\t\t\tvar images = {};\n\t\n\t\t\t\tfunction loadImage( url ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\treturn loader.load( url, function () {\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, undefined, function () {\n\t\n\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json !== undefined && json.length > 0 ) {\n\t\n\t\t\t\t\tvar manager = new LoadingManager( onLoad );\n\t\n\t\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\t\n\t\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn images;\n\t\n\t\t\t},\n\t\n\t\t\tparseTextures: function ( json, images ) {\n\t\n\t\t\t\tfunction parseConstant( value, type ) {\n\t\n\t\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\t\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\t\n\t\t\t\t\treturn type[ value ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar textures = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\t\tif ( data.image === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\ttexture.uuid = data.uuid;\n\t\n\t\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\n\t\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );\n\t\n\t\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\t\tif ( data.wrap !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );\n\t\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );\n\t\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );\n\t\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\n\t\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\t\n\t\t\t\t\t\ttextures[ data.uuid ] = texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn textures;\n\t\n\t\t\t},\n\t\n\t\t\tparseObject: function () {\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\n\t\t\t\treturn function parseObject( data, geometries, materials ) {\n\t\n\t\t\t\t\tvar object;\n\t\n\t\t\t\t\tfunction getGeometry( name ) {\n\t\n\t\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn geometries[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfunction getMaterial( name ) {\n\t\n\t\t\t\t\t\tif ( name === undefined ) return undefined;\n\t\n\t\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn materials[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\t\tcase 'Scene':\n\t\n\t\t\t\t\t\t\tobject = new Scene();\n\t\n\t\t\t\t\t\t\tif ( data.background !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\t\n\t\t\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( data.fog !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\t\n\t\t\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\t\n\t\t\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\t\n\t\t\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PerspectiveCamera':\n\t\n\t\t\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\t\n\t\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'OrthographicCamera':\n\t\n\t\t\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'AmbientLight':\n\t\n\t\t\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'DirectionalLight':\n\t\n\t\t\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointLight':\n\t\n\t\t\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'SpotLight':\n\t\n\t\t\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'HemisphereLight':\n\t\n\t\t\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Mesh':\n\t\n\t\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\t\tvar material = getMaterial( data.material );\n\t\n\t\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\t\n\t\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'LOD':\n\t\n\t\t\t\t\t\t\tobject = new LOD();\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Line':\n\t\n\t\t\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'LineSegments':\n\t\n\t\t\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\t\tcase 'Points':\n\t\n\t\t\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Sprite':\n\t\n\t\t\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Group':\n\t\n\t\t\t\t\t\t\tobject = new Group();\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tobject = new Object3D();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.uuid = data.uuid;\n\t\n\t\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\t\tif ( data.matrix !== undefined ) {\n\t\n\t\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\t\n\t\t\t\t\tif ( data.shadow ) {\n\t\n\t\t\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\n\t\t\t\t\tif ( data.children !== undefined ) {\n\t\n\t\t\t\t\t\tfor ( var child in data.children ) {\n\t\n\t\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.type === 'LOD' ) {\n\t\n\t\t\t\t\t\tvar levels = data.levels;\n\t\n\t\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\t\n\t\t\t\t\t\t\tif ( child !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn object;\n\t\n\t\t\t\t};\n\t\n\t\t\t}()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Extensible curve object\n\t\t *\n\t\t * Some common of Curve methods\n\t\t * .getPoint(t), getTangent(t)\n\t\t * .getPointAt(u), getTangentAt(u)\n\t\t * .getPoints(), .getSpacedPoints()\n\t\t * .getLength()\n\t\t * .updateArcLengths()\n\t\t *\n\t\t * This following classes subclasses THREE.Curve:\n\t\t *\n\t\t * -- 2d classes --\n\t\t * THREE.LineCurve\n\t\t * THREE.QuadraticBezierCurve\n\t\t * THREE.CubicBezierCurve\n\t\t * THREE.SplineCurve\n\t\t * THREE.ArcCurve\n\t\t * THREE.EllipseCurve\n\t\t *\n\t\t * -- 3d classes --\n\t\t * THREE.LineCurve3\n\t\t * THREE.QuadraticBezierCurve3\n\t\t * THREE.CubicBezierCurve3\n\t\t * THREE.SplineCurve3\n\t\t *\n\t\t * A series of curves can be represented as a THREE.CurvePath\n\t\t *\n\t\t **/\n\t\n\t\t/**************************************************************\n\t\t *\tAbstract Curve base class\n\t\t **************************************************************/\n\t\n\t\tfunction Curve() {}\n\t\n\t\tCurve.prototype = {\n\t\n\t\t\tconstructor: Curve,\n\t\n\t\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t\t//\t- t [0 .. 1]\n\t\n\t\t\tgetPoint: function ( t ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\t// Get point at relative position in curve according to arc length\n\t\t\t// - u [0 .. 1]\n\t\n\t\t\tgetPointAt: function ( u ) {\n\t\n\t\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\t\treturn this.getPoint( t );\n\t\n\t\t\t},\n\t\n\t\t\t// Get sequence of points using getPoint( t )\n\t\n\t\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t// Get sequence of points using getPointAt( u )\n\t\n\t\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t// Get total curve arc length\n\t\n\t\t\tgetLength: function () {\n\t\n\t\t\t\tvar lengths = this.getLengths();\n\t\t\t\treturn lengths[ lengths.length - 1 ];\n\t\n\t\t\t},\n\t\n\t\t\t// Get list of cumulative segment lengths\n\t\n\t\t\tgetLengths: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\t\n\t\t\t\tif ( this.cacheArcLengths\n\t\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t\t&& ! this.needsUpdate ) {\n\t\n\t\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\t\treturn this.cacheArcLengths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.needsUpdate = false;\n\t\n\t\t\t\tvar cache = [];\n\t\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\t\tvar p, sum = 0;\n\t\n\t\t\t\tcache.push( 0 );\n\t\n\t\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\t\n\t\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\t\tcache.push( sum );\n\t\t\t\t\tlast = current;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cacheArcLengths = cache;\n\t\n\t\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\t\n\t\t\t},\n\t\n\t\t\tupdateArcLengths: function() {\n\t\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\tthis.getLengths();\n\t\n\t\t\t},\n\t\n\t\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\t\n\t\t\tgetUtoTmapping: function ( u, distance ) {\n\t\n\t\t\t\tvar arcLengths = this.getLengths();\n\t\n\t\t\t\tvar i = 0, il = arcLengths.length;\n\t\n\t\t\t\tvar targetArcLength; // The targeted u distance value to get\n\t\n\t\t\t\tif ( distance ) {\n\t\n\t\t\t\t\ttargetArcLength = distance;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//var time = Date.now();\n\t\n\t\t\t\t// binary search for the index with largest value smaller than target u distance\n\t\n\t\t\t\tvar low = 0, high = il - 1, comparison;\n\t\n\t\t\t\twhile ( low <= high ) {\n\t\n\t\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\t\n\t\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\t\n\t\t\t\t\tif ( comparison < 0 ) {\n\t\n\t\t\t\t\t\tlow = i + 1;\n\t\n\t\t\t\t\t} else if ( comparison > 0 ) {\n\t\n\t\t\t\t\t\thigh = i - 1;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\thigh = i;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t// DONE\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\ti = high;\n\t\n\t\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\t\n\t\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\t\n\t\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\t\treturn t;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\t\n\t\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\t\n\t\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\t\n\t\t\t\t// determine where we are between the 'before' and 'after' points\n\t\n\t\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\t\n\t\t\t\t// add that fractional amount to t\n\t\n\t\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\t\n\t\t\t\treturn t;\n\t\n\t\t\t},\n\t\n\t\t\t// Returns a unit vector tangent at t\n\t\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t\t// which seems to give a reasonable approximation\n\t\n\t\t\tgetTangent: function( t ) {\n\t\n\t\t\t\tvar delta = 0.0001;\n\t\t\t\tvar t1 = t - delta;\n\t\t\t\tvar t2 = t + delta;\n\t\n\t\t\t\t// Capping in case of danger\n\t\n\t\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\t\tif ( t2 > 1 ) t2 = 1;\n\t\n\t\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\t\tvar pt2 = this.getPoint( t2 );\n\t\n\t\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\t\treturn vec.normalize();\n\t\n\t\t\t},\n\t\n\t\t\tgetTangentAt: function ( u ) {\n\t\n\t\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\t\treturn this.getTangent( t );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\t\n\t\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\t\n\t\t\t\tvar normal = new Vector3();\n\t\n\t\t\t\tvar tangents = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar binormals = [];\n\t\n\t\t\t\tvar vec = new Vector3();\n\t\t\t\tvar mat = new Matrix4();\n\t\n\t\t\t\tvar i, u, theta;\n\t\n\t\t\t\t// compute the tangent vectors for each segment on the curve\n\t\n\t\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\t\t\tu = i / segments;\n\t\n\t\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\t\ttangents[ i ].normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t\t// and in the direction of the minimum tangent xyz component\n\t\n\t\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\t\tvar min = Number.MAX_VALUE;\n\t\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\t\n\t\t\t\tif ( tx <= min ) {\n\t\n\t\t\t\t\tmin = tx;\n\t\t\t\t\tnormal.set( 1, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ty <= min ) {\n\t\n\t\t\t\t\tmin = ty;\n\t\t\t\t\tnormal.set( 0, 1, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tz <= min ) {\n\t\n\t\t\t\t\tnormal.set( 0, 0, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\t\n\t\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t\n\t\n\t\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\t\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\t\n\t\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\t\n\t\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\t\n\t\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tvec.normalize();\n\t\n\t\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\t\n\t\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\t\n\t\t\t\tif ( closed === true ) {\n\t\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\t\ttheta /= segments;\n\t\n\t\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\t\n\t\t\t\t\t\ttheta = - theta;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\t\t\t// twist a little...\n\t\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\ttangents: tangents,\n\t\t\t\t\tnormals: normals,\n\t\t\t\t\tbinormals: binormals\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// TODO: Transformation for Curves?\n\t\n\t\t/**************************************************************\n\t\t *\t3D Curves\n\t\t **************************************************************/\n\t\n\t\t// A Factory method for creating new curve subclasses\n\t\n\t\tCurve.create = function ( constructor, getPointFunc ) {\n\t\n\t\t\tconstructor.prototype = Object.create( Curve.prototype );\n\t\t\tconstructor.prototype.constructor = constructor;\n\t\t\tconstructor.prototype.getPoint = getPointFunc;\n\t\n\t\t\treturn constructor;\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tLine\n\t\t **************************************************************/\n\t\n\t\tfunction LineCurve( v1, v2 ) {\n\t\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t}\n\t\n\t\tLineCurve.prototype = Object.create( Curve.prototype );\n\t\tLineCurve.prototype.constructor = LineCurve;\n\t\n\t\tLineCurve.prototype.isLineCurve = true;\n\t\n\t\tLineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tif ( t === 1 ) {\n\t\n\t\t\t\treturn this.v2.clone();\n\t\n\t\t\t}\n\t\n\t\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\t// Line curve is linear, so we can overwrite default getPointAt\n\t\n\t\tLineCurve.prototype.getPointAt = function ( u ) {\n\t\n\t\t\treturn this.getPoint( u );\n\t\n\t\t};\n\t\n\t\tLineCurve.prototype.getTangent = function( t ) {\n\t\n\t\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\t\n\t\t\treturn tangent.normalize();\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t **/\n\t\n\t\t/**************************************************************\n\t\t *\tCurved Path - a curve path is simply a array of connected\n\t\t *  curves, but retains the api of a curve\n\t\t **************************************************************/\n\t\n\t\tfunction CurvePath() {\n\t\n\t\t\tthis.curves = [];\n\t\n\t\t\tthis.autoClose = false; // Automatically closes the path\n\t\n\t\t}\n\t\n\t\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\t\n\t\t\tconstructor: CurvePath,\n\t\n\t\t\tadd: function ( curve ) {\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t},\n\t\n\t\t\tclosePath: function () {\n\t\n\t\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\t\n\t\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\t\n\t\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// To get accurate point with reference to\n\t\t\t// entire path distance at time t,\n\t\t\t// following has to be done:\n\t\n\t\t\t// 1. Length of each sub path have to be known\n\t\t\t// 2. Locate and identify type of curve\n\t\t\t// 3. Get t for the curve\n\t\t\t// 4. Return curve.getPointAt(t')\n\t\n\t\t\tgetPoint: function ( t ) {\n\t\n\t\t\t\tvar d = t * this.getLength();\n\t\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\t\tvar i = 0;\n\t\n\t\t\t\t// To think about boundaries points.\n\t\n\t\t\t\twhile ( i < curveLengths.length ) {\n\t\n\t\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\t\n\t\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\t\tvar curve = this.curves[ i ];\n\t\n\t\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\t\n\t\t\t\t\t\treturn curve.getPointAt( u );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ti ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\t\n\t\t\t},\n\t\n\t\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t\t// getPoint() depends on getLength\n\t\n\t\t\tgetLength: function () {\n\t\n\t\t\t\tvar lens = this.getCurveLengths();\n\t\t\t\treturn lens[ lens.length - 1 ];\n\t\n\t\t\t},\n\t\n\t\t\t// cacheLengths must be recalculated.\n\t\t\tupdateArcLengths: function () {\n\t\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\tthis.cacheLengths = null;\n\t\t\t\tthis.getLengths();\n\t\n\t\t\t},\n\t\n\t\t\t// Compute lengths and cache them\n\t\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\t\n\t\t\tgetCurveLengths: function () {\n\t\n\t\t\t\t// We use cache values if curves and cache array are same length\n\t\n\t\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\t\n\t\t\t\t\treturn this.cacheLengths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Get length of sub-curve\n\t\t\t\t// Push sums into cached array\n\t\n\t\t\t\tvar lengths = [], sums = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\t\tlengths.push( sums );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cacheLengths = lengths;\n\t\n\t\t\t\treturn lengths;\n\t\n\t\t\t},\n\t\n\t\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( ! divisions ) divisions = 40;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClose ) {\n\t\n\t\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\t\tdivisions = divisions || 12;\n\t\n\t\t\t\tvar points = [], last;\n\t\n\t\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\t\n\t\t\t\t\tvar curve = curves[ i ];\n\t\t\t\t\tvar resolution = (curve && curve.isEllipseCurve) ? divisions * 2\n\t\t\t\t\t\t: (curve && curve.isLineCurve) ? 1\n\t\t\t\t\t\t: (curve && curve.isSplineCurve) ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\t\n\t\t\t\t\tvar pts = curve.getPoints( resolution );\n\t\n\t\t\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\t\n\t\t\t\t\t\tvar point = pts[ j ];\n\t\n\t\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\t\n\t\t\t\t\t\tpoints.push( point );\n\t\t\t\t\t\tlast = point;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t/**************************************************************\n\t\t\t *\tCreate Geometries Helpers\n\t\t\t **************************************************************/\n\t\n\t\t\t/// Generate geometry from path points (for Line or Points objects)\n\t\n\t\t\tcreatePointsGeometry: function ( divisions ) {\n\t\n\t\t\t\tvar pts = this.getPoints( divisions );\n\t\t\t\treturn this.createGeometry( pts );\n\t\n\t\t\t},\n\t\n\t\t\t// Generate geometry from equidistant sampling along the path\n\t\n\t\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\t\n\t\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\t\treturn this.createGeometry( pts );\n\t\n\t\t\t},\n\t\n\t\t\tcreateGeometry: function ( points ) {\n\t\n\t\t\t\tvar geometry = new Geometry();\n\t\n\t\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar point = points[ i ];\n\t\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**************************************************************\n\t\t *\tEllipse curve\n\t\t **************************************************************/\n\t\n\t\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\tthis.aX = aX;\n\t\t\tthis.aY = aY;\n\t\n\t\t\tthis.xRadius = xRadius;\n\t\t\tthis.yRadius = yRadius;\n\t\n\t\t\tthis.aStartAngle = aStartAngle;\n\t\t\tthis.aEndAngle = aEndAngle;\n\t\n\t\t\tthis.aClockwise = aClockwise;\n\t\n\t\t\tthis.aRotation = aRotation || 0;\n\t\n\t\t}\n\t\n\t\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\t\tEllipseCurve.prototype.constructor = EllipseCurve;\n\t\n\t\tEllipseCurve.prototype.isEllipseCurve = true;\n\t\n\t\tEllipseCurve.prototype.getPoint = function( t ) {\n\t\n\t\t\tvar twoPi = Math.PI * 2;\n\t\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\t\n\t\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\t\n\t\t\tif ( deltaAngle < Number.EPSILON ) {\n\t\n\t\t\t\tif ( samePoints ) {\n\t\n\t\t\t\t\tdeltaAngle = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdeltaAngle = twoPi;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.aClockwise === true && ! samePoints ) {\n\t\n\t\t\t\tif ( deltaAngle === twoPi ) {\n\t\n\t\t\t\t\tdeltaAngle = - twoPi;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\t\n\t\t\tif ( this.aRotation !== 0 ) {\n\t\n\t\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\t\tvar sin = Math.sin( this.aRotation );\n\t\n\t\t\t\tvar tx = x - this.aX;\n\t\t\t\tvar ty = y - this.aY;\n\t\n\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\t\ty = tx * sin + ty * cos + this.aY;\n\t\n\t\t\t}\n\t\n\t\t\treturn new Vector2( x, y );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tvar CurveUtils = {\n\t\n\t\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\t\n\t\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\t\n\t\t\t},\n\t\n\t\t\t// Puay Bing, thanks for helping with this derivative!\n\t\n\t\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t\t3 * t * t * p3;\n\t\n\t\t\t},\n\t\n\t\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\t// To check if my formulas are correct\n\t\n\t\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\n\t\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\n\t\t\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\n\t\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\n\t\n\t\t\t\treturn h00 + h10 + h01 + h11;\n\t\n\t\t\t},\n\t\n\t\t\t// Catmull-Rom\n\t\n\t\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\t\n\t\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\t\tvar t2 = t * t;\n\t\t\t\tvar t3 = t * t2;\n\t\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tSpline curve\n\t\t **************************************************************/\n\t\n\t\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\t\n\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\t\n\t\t}\n\t\n\t\tSplineCurve.prototype = Object.create( Curve.prototype );\n\t\tSplineCurve.prototype.constructor = SplineCurve;\n\t\n\t\tSplineCurve.prototype.isSplineCurve = true;\n\t\n\t\tSplineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\t\n\t\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\t\tvar interpolate = CurveUtils.interpolate;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t\t);\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tCubic Bezier curve\n\t\t **************************************************************/\n\t\n\t\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\n\t\t}\n\t\n\t\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\t\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\t\n\t\tCubicBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tvar b3 = ShapeUtils.b3;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t\t);\n\t\n\t\t};\n\t\n\t\tCubicBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\t\tvar tangentCubicBezier = CurveUtils.tangentCubicBezier;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t\t).normalize();\n\t\n\t\t};\n\t\n\t\t/**************************************************************\n\t\t *\tQuadratic Bezier curve\n\t\t **************************************************************/\n\t\n\t\n\t\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t}\n\t\n\t\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\t\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\t\n\t\n\t\tQuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\t\tvar b2 = ShapeUtils.b2;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t\t);\n\t\n\t\t};\n\t\n\t\n\t\tQuadraticBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\t\tvar tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;\n\t\n\t\t\treturn new Vector2(\n\t\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t\t).normalize();\n\t\n\t\t};\n\t\n\t\tvar PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {\n\t\n\t\t\tfromPoints: function ( vectors ) {\n\t\n\t\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\t\n\t\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmoveTo: function ( x, y ) {\n\t\n\t\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\t\n\t\t\t},\n\t\n\t\t\tlineTo: function ( x, y ) {\n\t\n\t\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( x, y );\n\t\n\t\t\t},\n\t\n\t\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\n\t\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\t\tnew Vector2( aX, aY )\n\t\t\t\t);\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\n\t\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\t\tnew Vector2( aX, aY )\n\t\t\t\t);\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\t\n\t\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\t\n\t\t\t\tvar curve = new SplineCurve( npts );\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\t\n\t\t\t},\n\t\n\t\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\t\n\t\t\t},\n\t\n\t\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t\t},\n\t\n\t\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t\t},\n\t\n\t\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t\t\tif ( this.curves.length > 0 ) {\n\t\n\t\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\t\n\t\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\t\n\t\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\t\tthis.currentPoint.copy( lastPoint );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Defines a 2d shape plane using paths.\n\t\t **/\n\t\n\t\t// STEP 1 Create a path.\n\t\t// STEP 2 Turn path into shape.\n\t\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t\t// STEP 3a - Extract points from each shape, turn to vertices\n\t\t// STEP 3b - Triangulate each shape, add faces.\n\t\n\t\tfunction Shape() {\n\t\n\t\t\tPath.apply( this, arguments );\n\t\n\t\t\tthis.holes = [];\n\t\n\t\t}\n\t\n\t\tShape.prototype = Object.assign( Object.create( PathPrototype ), {\n\t\n\t\t\tconstructor: Shape,\n\t\n\t\t\tgetPointsHoles: function ( divisions ) {\n\t\n\t\t\t\tvar holesPts = [];\n\t\n\t\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn holesPts;\n\t\n\t\t\t},\n\t\n\t\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\t\n\t\t\textractAllPoints: function ( divisions ) {\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\t\tholes: this.getPointsHoles( divisions )\n\t\n\t\t\t\t};\n\t\n\t\t\t},\n\t\n\t\t\textractPoints: function ( divisions ) {\n\t\n\t\t\t\treturn this.extractAllPoints( divisions );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Creates free form 2d path using series of points, lines or curves.\n\t\t *\n\t\t **/\n\t\n\t\tfunction Path( points ) {\n\t\n\t\t\tCurvePath.call( this );\n\t\t\tthis.currentPoint = new Vector2();\n\t\n\t\t\tif ( points ) {\n\t\n\t\t\t\tthis.fromPoints( points );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tPath.prototype = PathPrototype;\n\t\tPathPrototype.constructor = Path;\n\t\n\t\n\t\t// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\t\tfunction ShapePath() {\n\t\t\tthis.subPaths = [];\n\t\t\tthis.currentPath = null;\n\t\t}\n\t\n\t\tShapePath.prototype = {\n\t\t\tmoveTo: function ( x, y ) {\n\t\t\t\tthis.currentPath = new Path();\n\t\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\t\tthis.currentPath.moveTo( x, y );\n\t\t\t},\n\t\t\tlineTo: function ( x, y ) {\n\t\t\t\tthis.currentPath.lineTo( x, y );\n\t\t\t},\n\t\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\t\t},\n\t\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\t\t},\n\t\t\tsplineThru: function ( pts ) {\n\t\t\t\tthis.currentPath.splineThru( pts );\n\t\t\t},\n\t\n\t\t\ttoShapes: function ( isCCW, noHoles ) {\n\t\n\t\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\t\n\t\t\t\t\tvar shapes = [];\n\t\n\t\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\t\n\t\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\n\t\t\t\t\t\tshapes.push( tmpShape );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn shapes;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\t\n\t\t\t\t\tvar polyLen = inPolygon.length;\n\t\n\t\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\t\tvar inside = false;\n\t\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\t\n\t\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\t\n\t\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\t\n\t\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\t\n\t\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\t\n\t\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\t\n\t\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t\t// continue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn\tinside;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\t\n\t\t\t\tvar subPaths = this.subPaths;\n\t\t\t\tif ( subPaths.length === 0 ) return [];\n\t\n\t\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\t\n\t\t\t\tif ( subPaths.length === 1 ) {\n\t\n\t\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\t\ttmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\t\tshapes.push( tmpShape );\n\t\t\t\t\treturn shapes;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\t\n\t\t\t\t// console.log(\"Holes first\", holesFirst);\n\t\n\t\t\t\tvar betterShapeHoles = [];\n\t\t\t\tvar newShapes = [];\n\t\t\t\tvar newShapeHoles = [];\n\t\t\t\tvar mainIdx = 0;\n\t\t\t\tvar tmpPoints;\n\t\n\t\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\t\tsolid = isCCW ? ! solid : solid;\n\t\n\t\t\t\t\tif ( solid ) {\n\t\n\t\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\t\n\t\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\t\n\t\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\t\t\t//console.log('cw', i);\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\t\n\t\t\t\t\t\t//console.log('ccw', i);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\t\tif ( newShapes.length > 1 ) {\n\t\n\t\t\t\t\tvar ambiguous = false;\n\t\t\t\t\tvar toChange = [];\n\t\n\t\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\t\n\t\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\t\tvar hole_unassigned = true;\n\t\n\t\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tambiguous = true;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\t\tif ( toChange.length > 0 ) {\n\t\n\t\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar tmpHoles;\n\t\n\t\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\t\n\t\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\t\tshapes.push( tmpShape );\n\t\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\t\n\t\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//console.log(\"shape\", shapes);\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Font( data ) {\n\t\n\t\t\tthis.data = data;\n\t\n\t\t}\n\t\n\t\tObject.assign( Font.prototype, {\n\t\n\t\t\tisFont: true,\n\t\n\t\t\tgenerateShapes: function ( text, size, divisions ) {\n\t\n\t\t\t\tfunction createPaths( text ) {\n\t\n\t\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\t\tvar offset = 0;\n\t\n\t\t\t\t\tvar paths = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\t\toffset += ret.offset;\n\t\n\t\t\t\t\t\tpaths.push( ret.path );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn paths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction createPath( c, scale, offset ) {\n\t\n\t\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\t\n\t\t\t\t\tif ( ! glyph ) return;\n\t\n\t\t\t\t\tvar path = new ShapePath();\n\t\n\t\t\t\t\tvar pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;\n\t\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\t\n\t\t\t\t\tif ( glyph.o ) {\n\t\n\t\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\t\n\t\t\t\t\t\t\tvar action = outline[ i ++ ];\n\t\n\t\t\t\t\t\t\tswitch ( action ) {\n\t\n\t\t\t\t\t\t\t\tcase 'm': // moveTo\n\t\n\t\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 'l': // lineTo\n\t\n\t\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\t\n\t\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\t\n\t\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( size === undefined ) size = 100;\n\t\t\t\tif ( divisions === undefined ) divisions = 4;\n\t\n\t\t\t\tvar data = this.data;\n\t\n\t\t\t\tvar paths = createPaths( text );\n\t\t\t\tvar shapes = [];\n\t\n\t\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\t\n\t\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction FontLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( FontLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tvar json;\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tjson = JSON.parse( text );\n\t\n\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar font = scope.parse( json );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( font );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\treturn new Font( json );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar context;\n\t\n\t\tfunction getAudioContext() {\n\t\n\t\t\tif ( context === undefined ) {\n\t\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\t\n\t\t\t}\n\t\n\t\t\treturn context;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t\t */\n\t\n\t\tfunction AudioLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( AudioLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar context = getAudioContext();\n\t\n\t\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\t\n\t\t\t\t\t\tonLoad( audioBuffer );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction StereoCamera() {\n\t\n\t\t\tthis.type = 'StereoCamera';\n\t\n\t\t\tthis.aspect = 1;\n\t\n\t\t\tthis.eyeSep = 0.064;\n\t\n\t\t\tthis.cameraL = new PerspectiveCamera();\n\t\t\tthis.cameraL.layers.enable( 1 );\n\t\t\tthis.cameraL.matrixAutoUpdate = false;\n\t\n\t\t\tthis.cameraR = new PerspectiveCamera();\n\t\t\tthis.cameraR.layers.enable( 2 );\n\t\t\tthis.cameraR.matrixAutoUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( StereoCamera.prototype, {\n\t\n\t\t\tupdate: ( function () {\n\t\n\t\t\t\tvar instance, focus, fov, aspect, near, far, zoom;\n\t\n\t\t\t\tvar eyeRight = new Matrix4();\n\t\t\t\tvar eyeLeft = new Matrix4();\n\t\n\t\t\t\treturn function update( camera ) {\n\t\n\t\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom;\n\t\n\t\t\t\t\tif ( needsUpdate ) {\n\t\n\t\t\t\t\t\tinstance = this;\n\t\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\t\tnear = camera.near;\n\t\t\t\t\t\tfar = camera.far;\n\t\t\t\t\t\tzoom = camera.zoom;\n\t\n\t\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\t\n\t\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\t\tvar eyeSep = this.eyeSep / 2;\n\t\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\t\tvar xmin, xmax;\n\t\n\t\t\t\t\t\t// translate xOffset\n\t\n\t\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\t\n\t\t\t\t\t\t// for left eye\n\t\n\t\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\t\n\t\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t\t// for right eye\n\t\n\t\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\t\n\t\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Camera for rendering cube maps\n\t\t *\t- renders scene into axis-aligned cube\n\t\t *\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction CubeCamera( near, far, cubeResolution ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'CubeCamera';\n\t\n\t\t\tvar fov = 90, aspect = 1;\n\t\n\t\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\t\tthis.add( cameraPX );\n\t\n\t\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\t\tthis.add( cameraNX );\n\t\n\t\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\t\tthis.add( cameraPY );\n\t\n\t\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\t\tthis.add( cameraNY );\n\t\n\t\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\t\tthis.add( cameraPZ );\n\t\n\t\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\t\tthis.add( cameraNZ );\n\t\n\t\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\t\n\t\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\t\n\t\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\t\n\t\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\t\n\t\t\t\tvar renderTarget = this.renderTarget;\n\t\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\t\n\t\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\n\t\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\t\n\t\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\t\n\t\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\t\n\t\t\t\trenderer.setRenderTarget( null );\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\t\tCubeCamera.prototype.constructor = CubeCamera;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AudioListener() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'AudioListener';\n\t\n\t\t\tthis.context = getAudioContext();\n\t\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect( this.context.destination );\n\t\n\t\t\tthis.filter = null;\n\t\n\t\t}\n\t\n\t\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: AudioListener,\n\t\n\t\t\tgetInput: function () {\n\t\n\t\t\t\treturn this.gain;\n\t\n\t\t\t},\n\t\n\t\t\tremoveFilter: function ( ) {\n\t\n\t\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\t\tthis.filter = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetFilter: function () {\n\t\n\t\t\t\treturn this.filter;\n\t\n\t\t\t},\n\t\n\t\t\tsetFilter: function ( value ) {\n\t\n\t\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.context.destination );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.filter = value;\n\t\t\t\tthis.gain.connect( this.filter );\n\t\t\t\tthis.filter.connect( this.context.destination );\n\t\n\t\t\t},\n\t\n\t\t\tgetMasterVolume: function () {\n\t\n\t\t\t\treturn this.gain.gain.value;\n\t\n\t\t\t},\n\t\n\t\t\tsetMasterVolume: function ( value ) {\n\t\n\t\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar quaternion = new Quaternion();\n\t\t\t\tvar scale = new Vector3();\n\t\n\t\t\t\tvar orientation = new Vector3();\n\t\n\t\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\t\tvar listener = this.context.listener;\n\t\t\t\t\tvar up = this.up;\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\t\n\t\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t\t */\n\t\n\t\tfunction Audio( listener ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Audio';\n\t\n\t\t\tthis.context = listener.context;\n\t\t\tthis.source = this.context.createBufferSource();\n\t\t\tthis.source.onended = this.onEnded.bind( this );\n\t\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect( listener.getInput() );\n\t\n\t\t\tthis.autoplay = false;\n\t\n\t\t\tthis.startTime = 0;\n\t\t\tthis.playbackRate = 1;\n\t\t\tthis.isPlaying = false;\n\t\t\tthis.hasPlaybackControl = true;\n\t\t\tthis.sourceType = 'empty';\n\t\n\t\t\tthis.filters = [];\n\t\n\t\t}\n\t\n\t\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Audio,\n\t\n\t\t\tgetOutput: function () {\n\t\n\t\t\t\treturn this.gain;\n\t\n\t\t\t},\n\t\n\t\t\tsetNodeSource: function ( audioNode ) {\n\t\n\t\t\t\tthis.hasPlaybackControl = false;\n\t\t\t\tthis.sourceType = 'audioNode';\n\t\t\t\tthis.source = audioNode;\n\t\t\t\tthis.connect();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetBuffer: function ( audioBuffer ) {\n\t\n\t\t\t\tthis.source.buffer = audioBuffer;\n\t\t\t\tthis.sourceType = 'buffer';\n\t\n\t\t\t\tif ( this.autoplay ) this.play();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tplay: function () {\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar source = this.context.createBufferSource();\n\t\n\t\t\t\tsource.buffer = this.source.buffer;\n\t\t\t\tsource.loop = this.source.loop;\n\t\t\t\tsource.onended = this.source.onended;\n\t\t\t\tsource.start( 0, this.startTime );\n\t\t\t\tsource.playbackRate.value = this.playbackRate;\n\t\n\t\t\t\tthis.isPlaying = true;\n\t\n\t\t\t\tthis.source = source;\n\t\n\t\t\t\treturn this.connect();\n\t\n\t\t\t},\n\t\n\t\t\tpause: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.startTime = this.context.currentTime;\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.startTime = 0;\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconnect: function () {\n\t\n\t\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\t\n\t\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.source.connect( this.getOutput() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdisconnect: function () {\n\t\n\t\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\t\n\t\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.source.disconnect( this.getOutput() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetFilters: function () {\n\t\n\t\t\t\treturn this.filters;\n\t\n\t\t\t},\n\t\n\t\t\tsetFilters: function ( value ) {\n\t\n\t\t\t\tif ( ! value ) value = [];\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.disconnect();\n\t\t\t\t\tthis.filters = value;\n\t\t\t\t\tthis.connect();\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.filters = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetFilter: function () {\n\t\n\t\t\t\treturn this.getFilters()[ 0 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetFilter: function ( filter ) {\n\t\n\t\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\t\n\t\t\t},\n\t\n\t\t\tsetPlaybackRate: function ( value ) {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.playbackRate = value;\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetPlaybackRate: function () {\n\t\n\t\t\t\treturn this.playbackRate;\n\t\n\t\t\t},\n\t\n\t\t\tonEnded: function () {\n\t\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t},\n\t\n\t\t\tgetLoop: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.source.loop;\n\t\n\t\t\t},\n\t\n\t\t\tsetLoop: function ( value ) {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.loop = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetVolume: function () {\n\t\n\t\t\t\treturn this.gain.gain.value;\n\t\n\t\t\t},\n\t\n\t\n\t\t\tsetVolume: function ( value ) {\n\t\n\t\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction PositionalAudio( listener ) {\n\t\n\t\t\tAudio.call( this, listener );\n\t\n\t\t\tthis.panner = this.context.createPanner();\n\t\t\tthis.panner.connect( this.gain );\n\t\n\t\t}\n\t\n\t\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\t\n\t\t\tconstructor: PositionalAudio,\n\t\n\t\t\tgetOutput: function () {\n\t\n\t\t\t\treturn this.panner;\n\t\n\t\t\t},\n\t\n\t\t\tgetRefDistance: function () {\n\t\n\t\t\t\treturn this.panner.refDistance;\n\t\n\t\t\t},\n\t\n\t\t\tsetRefDistance: function ( value ) {\n\t\n\t\t\t\tthis.panner.refDistance = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetRolloffFactor: function () {\n\t\n\t\t\t\treturn this.panner.rolloffFactor;\n\t\n\t\t\t},\n\t\n\t\t\tsetRolloffFactor: function ( value ) {\n\t\n\t\t\t\tthis.panner.rolloffFactor = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetDistanceModel: function () {\n\t\n\t\t\t\treturn this.panner.distanceModel;\n\t\n\t\t\t},\n\t\n\t\t\tsetDistanceModel: function ( value ) {\n\t\n\t\t\t\tthis.panner.distanceModel = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetMaxDistance: function () {\n\t\n\t\t\t\treturn this.panner.maxDistance;\n\t\n\t\t\t},\n\t\n\t\t\tsetMaxDistance: function ( value ) {\n\t\n\t\t\t\tthis.panner.maxDistance = value;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\n\t\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AudioAnalyser( audio, fftSize ) {\n\t\n\t\t\tthis.analyser = audio.context.createAnalyser();\n\t\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\t\n\t\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\t\n\t\t\taudio.getOutput().connect( this.analyser );\n\t\n\t\t}\n\t\n\t\tObject.assign( AudioAnalyser.prototype, {\n\t\n\t\t\tgetFrequencyData: function () {\n\t\n\t\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\t\n\t\t\t\treturn this.data;\n\t\n\t\t\t},\n\t\n\t\t\tgetAverageFrequency: function () {\n\t\n\t\t\t\tvar value = 0, data = this.getFrequencyData();\n\t\n\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\t\tvalue += data[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn value / data.length;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Buffered scene graph property that allows weighted accumulation.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\t\n\t\t\tthis.binding = binding;\n\t\t\tthis.valueSize = valueSize;\n\t\n\t\t\tvar bufferType = Float64Array,\n\t\t\t\tmixFunction;\n\t\n\t\t\tswitch ( typeName ) {\n\t\n\t\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\t\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'bool':\n\t\n\t\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\t\n\t\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\t\n\t\t\t}\n\t\n\t\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t\t//\n\t\t\t// interpolators can use .buffer as their .result\n\t\t\t// the data then goes to 'incoming'\n\t\t\t//\n\t\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t\t// the cumulative result and are compared to detect\n\t\t\t// changes\n\t\t\t//\n\t\t\t// 'orig' stores the original state of the property\n\t\n\t\t\tthis._mixBufferRegion = mixFunction;\n\t\n\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\tthis.useCount = 0;\n\t\t\tthis.referenceCount = 0;\n\t\n\t\t}\n\t\n\t\tPropertyMixer.prototype = {\n\t\n\t\t\tconstructor: PropertyMixer,\n\t\n\t\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\t\taccumulate: function( accuIndex, weight ) {\n\t\n\t\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t\t// the weight and shouldn't have made the call in the first place\n\t\n\t\t\t\tvar buffer = this.buffer,\n\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\t\n\t\t\t\tif ( currentWeight === 0 ) {\n\t\n\t\t\t\t\t// accuN := incoming * weight\n\t\n\t\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentWeight = weight;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// accuN := accuN + incoming * weight\n\t\n\t\t\t\t\tcurrentWeight += weight;\n\t\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cumulativeWeight = currentWeight;\n\t\n\t\t\t},\n\t\n\t\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\t\tapply: function( accuIndex ) {\n\t\n\t\t\t\tvar stride = this.valueSize,\n\t\t\t\t\tbuffer = this.buffer,\n\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\t\tweight = this.cumulativeWeight,\n\t\n\t\t\t\t\tbinding = this.binding;\n\t\n\t\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\t\tif ( weight < 1 ) {\n\t\n\t\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\t\n\t\t\t\t\tvar originalValueOffset = stride * 3;\n\t\n\t\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\t\n\t\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\t\n\t\t\t\t\t\t// value has changed -> update scene graph\n\t\n\t\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// remember the state of the bound property and copy it to both accus\n\t\t\tsaveOriginalState: function() {\n\t\n\t\t\t\tvar binding = this.binding;\n\t\n\t\t\t\tvar buffer = this.buffer,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toriginalValueOffset = stride * 3;\n\t\n\t\t\t\tbinding.getValue( buffer, originalValueOffset );\n\t\n\t\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\t},\n\t\n\t\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\t\trestoreOriginalState: function() {\n\t\n\t\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// mix functions\n\t\n\t\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tif ( t >= 0.5 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tQuaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\t\n\t\t\t},\n\t\n\t\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tvar s = 1 - t;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tvar j = dstOffset + i;\n\t\n\t\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * A reference to a real property in the scene graph.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\t\n\t\t\tthis.path = path;\n\t\t\tthis.parsedPath = parsedPath ||\n\t\t\t\t\tPropertyBinding.parseTrackName( path );\n\t\n\t\t\tthis.node = PropertyBinding.findNode(\n\t\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\t\n\t\t\tthis.rootNode = rootNode;\n\t\n\t\t}\n\t\n\t\tPropertyBinding.prototype = {\n\t\n\t\t\tconstructor: PropertyBinding,\n\t\n\t\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\t\n\t\t\t\tthis.bind();\n\t\t\t\tthis.getValue( targetArray, offset );\n\t\n\t\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t\t// prototype version of these methods with one that represents\n\t\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t\t// become no-ops.\n\t\n\t\t\t},\n\t\n\t\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\t\n\t\t\t\tthis.bind();\n\t\t\t\tthis.setValue( sourceArray, offset );\n\t\n\t\t\t},\n\t\n\t\t\t// create getter / setter pair for a property in the scene graph\n\t\t\tbind: function() {\n\t\n\t\t\t\tvar targetObject = this.node,\n\t\t\t\t\tparsedPath = this.parsedPath,\n\t\n\t\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\t\n\t\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\t\ttargetObject = PropertyBinding.findNode(\n\t\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\t\n\t\t\t\t\tthis.node = targetObject;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// set fail state so we can just 'return' on error\n\t\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\t\tthis.setValue = this._setValue_unavailable;\n\t\n\t\t \t\t// ensure there is a value node\n\t\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( objectName ) {\n\t\n\t\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\t\n\t\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\t\tswitch ( objectName ) {\n\t\n\t\t\t\t\t\tcase 'materials':\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.material ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'bones':\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t\t// and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\t\n\t\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\t\n\t\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\tif ( objectIndex !== undefined ) {\n\t\n\t\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// resolve property\n\t\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\t\n\t\t\t\tif ( nodeProperty === undefined ) {\n\t\n\t\t\t\t\tvar nodeName = parsedPath.nodeName;\n\t\n\t\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// determine versioning scheme\n\t\t\t\tvar versioning = this.Versioning.None;\n\t\n\t\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\t\n\t\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\t\n\t\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// determine how the property gets bound\n\t\t\t\tvar bindingType = this.BindingType.Direct;\n\t\n\t\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\t\n\t\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tif ( ! targetObject.geometry ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\t\n\t\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\t\tthis.propertyIndex = propertyIndex;\n\t\n\t\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\t\n\t\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\t\n\t\t\t\t\tbindingType = this.BindingType.EntireArray;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.propertyName = propertyName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// select getter / setter\n\t\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\t\n\t\t\t},\n\t\n\t\t\tunbind: function() {\n\t\n\t\t\t\tthis.node = null;\n\t\n\t\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\t\tthis.setValue = this._setValue_unbound;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\t\n\t\t\t// these are used to \"bind\" a nonexistent property\n\t\t\t_getValue_unavailable: function() {},\n\t\t\t_setValue_unavailable: function() {},\n\t\n\t\t\t// initial state of these methods that calls 'bind'\n\t\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\t\n\t\t\tBindingType: {\n\t\t\t\tDirect: 0,\n\t\t\t\tEntireArray: 1,\n\t\t\t\tArrayElement: 2,\n\t\t\t\tHasFromToArray: 3\n\t\t\t},\n\t\n\t\t\tVersioning: {\n\t\t\t\tNone: 0,\n\t\t\t\tNeedsUpdate: 1,\n\t\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t\t},\n\t\n\t\t\tGetterByBindingType: [\n\t\n\t\t\t\tfunction getValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_array( buffer, offset ) {\n\t\n\t\t\t\t\tvar source = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_toArray( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t],\n\t\n\t\t\tSetterByBindingTypeAndVersioning: [\n\t\n\t\t\t\t[\n\t\t\t\t\t// Direct\n\t\n\t\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// EntireArray\n\t\n\t\t\t\t\tfunction setValue_array( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// ArrayElement\n\t\n\t\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// HasToFromArray\n\t\n\t\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t]\n\t\n\t\t\t]\n\t\n\t\t} );\n\t\n\t\tPropertyBinding.Composite =\n\t\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\t\n\t\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\t\tPropertyBinding.parseTrackName( path );\n\t\n\t\t\tthis._targetGroup = targetGroup;\n\t\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\t\n\t\t};\n\t\n\t\tPropertyBinding.Composite.prototype = {\n\t\n\t\t\tconstructor: PropertyBinding.Composite,\n\t\n\t\t\tgetValue: function( array, offset ) {\n\t\n\t\t\t\tthis.bind(); // bind all binding\n\t\n\t\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\t\n\t\t\t\t// and only call .getValue on the first\n\t\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue: function( array, offset ) {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].setValue( array, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tbind: function() {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].bind();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tunbind: function() {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].unbind();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tPropertyBinding.create = function( root, path, parsedPath ) {\n\t\n\t\t\tif ( ! ( (root && root.isAnimationObjectGroup) ) ) {\n\t\n\t\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tPropertyBinding.parseTrackName = function( trackName ) {\n\t\n\t\t\t// matches strings in the form of:\n\t\t\t//    nodeName.property\n\t\t\t//    nodeName.property[accessor]\n\t\t\t//    nodeName.material.property[accessor]\n\t\t\t//    uuid.property[accessor]\n\t\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t\t//    parentName/nodeName.property\n\t\t\t//    parentName/parentName/nodeName.property[index]\n\t\t\t//    .bone[Armature.DEF_cog].position\n\t\t\t//    scene:helium_balloon_model:helium_balloon_model.position\n\t\t\t// created and tested via https://regex101.com/#javascript\n\t\n\t\t\tvar re = /^((?:\\w+[\\/:])*)(\\w+)?(?:\\.(\\w+)(?:\\[(.+)\\])?)?\\.(\\w+)(?:\\[(.+)\\])?$/;\n\t\t\tvar matches = re.exec( trackName );\n\t\n\t\t\tif ( ! matches ) {\n\t\n\t\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\t\n\t\t\t}\n\t\n\t\t\tvar results = {\n\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\tnodeName: matches[ 2 ], \t// allowed to be null, specified root node.\n\t\t\t\tobjectName: matches[ 3 ],\n\t\t\t\tobjectIndex: matches[ 4 ],\n\t\t\t\tpropertyName: matches[ 5 ],\n\t\t\t\tpropertyIndex: matches[ 6 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t\t};\n\t\n\t\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\t\n\t\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\t\n\t\t\t}\n\t\n\t\t\treturn results;\n\t\n\t\t};\n\t\n\t\tPropertyBinding.findNode = function( root, nodeName ) {\n\t\n\t\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\t\n\t\t\t\treturn root;\n\t\n\t\t\t}\n\t\n\t\t\t// search into skeleton bones.\n\t\t\tif ( root.skeleton ) {\n\t\n\t\t\t\tvar searchSkeleton = function( skeleton ) {\n\t\n\t\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\t\n\t\t\t\t\t\tif ( bone.name === nodeName ) {\n\t\n\t\t\t\t\t\t\treturn bone;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar bone = searchSkeleton( root.skeleton );\n\t\n\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\treturn bone;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// search into node subtree.\n\t\t\tif ( root.children ) {\n\t\n\t\t\t\tvar searchNodeSubtree = function( children ) {\n\t\n\t\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar childNode = children[ i ];\n\t\n\t\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\t\n\t\t\t\t\t\t\treturn childNode;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\t\n\t\t\t\t\t\tif ( result ) return result;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\t\n\t\t\t\tif ( subTreeNode ) {\n\t\n\t\t\t\t\treturn subTreeNode;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * A group of objects that receives a shared animation state.\n\t\t *\n\t\t * Usage:\n\t\t *\n\t\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t\t *\n\t\t * \t-\tInstead pass this object as 'root'.\n\t\t *\n\t\t * \t-\tYou can also add and remove objects later when the mixer\n\t\t * \t\tis running.\n\t\t *\n\t\t * Note:\n\t\t *\n\t\t *  \tObjects of this class appear as one object to the mixer,\n\t\t *  \tso cache control of the individual objects must be done\n\t\t *  \ton the group.\n\t\t *\n\t\t * Limitation:\n\t\t *\n\t\t * \t- \tThe animated properties must be compatible among the\n\t\t * \t\tall objects in the group.\n\t\t *\n\t\t *  -\tA single property can either be controlled through a\n\t\t *  \ttarget group or directly, but not both.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction AnimationObjectGroup( var_args ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\t// cached objects followed by the active ones\n\t\t\tthis._objects = Array.prototype.slice.call( arguments );\n\t\n\t\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t\t// note: read by PropertyBinding.Composite\n\t\n\t\t\tvar indices = {};\n\t\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tindices[ arguments[ i ].uuid ] = i;\n\t\n\t\t\t}\n\t\n\t\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.stats = {\n\t\n\t\t\t\tobjects: {\n\t\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t\t},\n\t\n\t\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tAnimationObjectGroup.prototype = {\n\t\n\t\t\tconstructor: AnimationObjectGroup,\n\t\n\t\t\tisAnimationObjectGroup: true,\n\t\n\t\t\tadd: function( var_args ) {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tpaths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index === undefined ) {\n\t\n\t\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\t\n\t\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\t\tobjects.push( object );\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\t\tnew PropertyBinding(\n\t\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\tvar knownObject = objects[ index ];\n\t\n\t\t\t\t\t\t// move existing object to the ACTIVE region\n\t\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\n\t\t\t\t\t\t\tif ( binding === undefined ) {\n\t\n\t\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t\t// or may not exist\n\t\n\t\t\t\t\t\t\t\tbinding = new PropertyBinding(\n\t\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\t\n\t\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\t\n\t\t\t\t\t} // else the object is already where we want it to be\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\tremove: function( var_args ) {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\t\n\t\t\t\t\t\t// move existing object into the CACHED region\n\t\n\t\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\t\n\t\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\t// remove & forget\n\t\t\tuncache: function( var_args ) {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\t\n\t\t\t\t\t\tif ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\t\n\t\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\t\n\t\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// object is active, just swap with the last and pop\n\t\n\t\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\t\n\t\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} // cached or active\n\t\n\t\t\t\t\t} // if object is known\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\t\n\t\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t\t// according to the contained objects in the group\n\t\n\t\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\t\tbindings = this._bindings;\n\t\n\t\t\t\tif ( index !== undefined ) return bindings[ index ];\n\t\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tobjects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tbindingsForPath = new Array( nObjects );\n\t\n\t\t\t\tindex = bindings.length;\n\t\n\t\t\t\tindicesByPath[ path ] = index;\n\t\n\t\t\t\tpaths.push( path );\n\t\t\t\tparsedPaths.push( parsedPath );\n\t\t\t\tbindings.push( bindingsForPath );\n\t\n\t\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = objects[ i ];\n\t\n\t\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\t\tnew PropertyBinding( object, path, parsedPath );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn bindingsForPath;\n\t\n\t\t\t},\n\t\n\t\t\tunsubscribe_: function( path ) {\n\t\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t\t// update the array previously obtained with 'subscribe_'\n\t\n\t\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\tindex = indicesByPath[ path ];\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tvar paths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\t\n\t\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\t\n\t\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\t\tbindings.pop();\n\t\n\t\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\t\tparsedPaths.pop();\n\t\n\t\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\t\tpaths.pop();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t\t * objects.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t *\n\t\t */\n\t\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\t\n\t\t\tthis._mixer = mixer;\n\t\t\tthis._clip = clip;\n\t\t\tthis._localRoot = localRoot || null;\n\t\n\t\t\tvar tracks = clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tinterpolants = new Array( nTracks );\n\t\n\t\t\tvar interpolantSettings = {\n\t\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\t\t};\n\t\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\t\tinterpolants[ i ] = interpolant;\n\t\t\t\tinterpolant.settings = interpolantSettings;\n\t\n\t\t\t}\n\t\n\t\t\tthis._interpolantSettings = interpolantSettings;\n\t\n\t\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\t\n\t\t\t// inside: PropertyMixer (managed by the mixer)\n\t\t\tthis._propertyBindings = new Array( nTracks );\n\t\n\t\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\t\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._weightInterpolant = null;\n\t\n\t\t\tthis.loop = LoopRepeat;\n\t\t\tthis._loopCount = -1;\n\t\n\t\t\t// global mixer time when the action is to be started\n\t\t\t// it's set back to 'null' upon start of the action\n\t\t\tthis._startTime = null;\n\t\n\t\t\t// scaled local time of the action\n\t\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\t\tthis.time = 0;\n\t\n\t\t\tthis.timeScale = 1;\n\t\t\tthis._effectiveTimeScale = 1;\n\t\n\t\t\tthis.weight = 1;\n\t\t\tthis._effectiveWeight = 1;\n\t\n\t\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\t\n\t\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\t\n\t\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\t\n\t\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\t\n\t\t}\n\t\n\t\tAnimationAction.prototype = {\n\t\n\t\t\tconstructor: AnimationAction,\n\t\n\t\t\t// State & Scheduling\n\t\n\t\t\tplay: function() {\n\t\n\t\t\t\tthis._mixer._activateAction( this );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function() {\n\t\n\t\t\t\tthis._mixer._deactivateAction( this );\n\t\n\t\t\t\treturn this.reset();\n\t\n\t\t\t},\n\t\n\t\t\treset: function() {\n\t\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.enabled = true;\n\t\n\t\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\t\tthis._startTime = null;\t// forget scheduling\n\t\n\t\t\t\treturn this.stopFading().stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\tisRunning: function() {\n\t\n\t\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\t\n\t\t\t},\n\t\n\t\t\t// return true when play has been called\n\t\t\tisScheduled: function() {\n\t\n\t\t\t\treturn this._mixer._isActiveAction( this );\n\t\n\t\t\t},\n\t\n\t\t\tstartAt: function( time ) {\n\t\n\t\t\t\tthis._startTime = time;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetLoop: function( mode, repetitions ) {\n\t\n\t\t\t\tthis.loop = mode;\n\t\t\t\tthis.repetitions = repetitions;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Weight\n\t\n\t\t\t// set the weight stopping any scheduled fading\n\t\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t\t// method does *not* change .enabled, because it would be confusing\n\t\t\tsetEffectiveWeight: function( weight ) {\n\t\n\t\t\t\tthis.weight = weight;\n\t\n\t\t\t\t// note: same logic as when updated at runtime\n\t\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\t\n\t\t\t\treturn this.stopFading();\n\t\n\t\t\t},\n\t\n\t\t\t// return the weight considering fading and .enabled\n\t\t\tgetEffectiveWeight: function() {\n\t\n\t\t\t\treturn this._effectiveWeight;\n\t\n\t\t\t},\n\t\n\t\t\tfadeIn: function( duration ) {\n\t\n\t\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\t\n\t\t\t},\n\t\n\t\t\tfadeOut: function( duration ) {\n\t\n\t\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\t\n\t\t\t},\n\t\n\t\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\t\n\t\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\t\tthis.fadeIn( duration );\n\t\n\t\t\t\tif( warp ) {\n\t\n\t\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\t\n\t\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\t\n\t\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\t\n\t\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\t\n\t\t\t},\n\t\n\t\t\tstopFading: function() {\n\t\n\t\t\t\tvar weightInterpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( weightInterpolant !== null ) {\n\t\n\t\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Time Scale Control\n\t\n\t\t\t// set the weight stopping any scheduled warping\n\t\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t\t// method does *not* change .paused, because it would be confusing\n\t\t\tsetEffectiveTimeScale: function( timeScale ) {\n\t\n\t\t\t\tthis.timeScale = timeScale;\n\t\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\t// return the time scale considering warping and .paused\n\t\t\tgetEffectiveTimeScale: function() {\n\t\n\t\t\t\treturn this._effectiveTimeScale;\n\t\n\t\t\t},\n\t\n\t\t\tsetDuration: function( duration ) {\n\t\n\t\t\t\tthis.timeScale = this._clip.duration / duration;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\tsyncWith: function( action ) {\n\t\n\t\t\t\tthis.time = action.time;\n\t\t\t\tthis.timeScale = action.timeScale;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\thalt: function( duration ) {\n\t\n\t\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\t\n\t\t\t},\n\t\n\t\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\t\n\t\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\t\n\t\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\t\ttimes[ 0 ] = now;\n\t\t\t\ttimes[ 1 ] = now + duration;\n\t\n\t\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstopWarping: function() {\n\t\n\t\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\tif ( timeScaleInterpolant !== null ) {\n\t\n\t\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Object Accessors\n\t\n\t\t\tgetMixer: function() {\n\t\n\t\t\t\treturn this._mixer;\n\t\n\t\t\t},\n\t\n\t\t\tgetClip: function() {\n\t\n\t\t\t\treturn this._clip;\n\t\n\t\t\t},\n\t\n\t\t\tgetRoot: function() {\n\t\n\t\t\t\treturn this._localRoot || this._mixer._root;\n\t\n\t\t\t},\n\t\n\t\t\t// Interna\n\t\n\t\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t\t// called by the mixer\n\t\n\t\t\t\tvar startTime = this._startTime;\n\t\n\t\t\t\tif ( startTime !== null ) {\n\t\n\t\t\t\t\t// check for scheduled start of action\n\t\n\t\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\t\n\t\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// start\n\t\n\t\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// apply time scale and advance time\n\t\n\t\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\t\tvar clipTime = this._updateTime( deltaTime );\n\t\n\t\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t\t// an effective weight of 0\n\t\n\t\t\t\tvar weight = this._updateWeight( time );\n\t\n\t\t\t\tif ( weight > 0 ) {\n\t\n\t\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\t\tvar propertyMixers = this._propertyBindings;\n\t\n\t\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_updateWeight: function( time ) {\n\t\n\t\t\t\tvar weight = 0;\n\t\n\t\t\t\tif ( this.enabled ) {\n\t\n\t\t\t\t\tweight = this.weight;\n\t\t\t\t\tvar interpolant = this._weightInterpolant;\n\t\n\t\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\t\tweight *= interpolantValue;\n\t\n\t\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\t\tthis.stopFading();\n\t\n\t\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\t\n\t\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\t\tthis.enabled = false;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._effectiveWeight = weight;\n\t\t\t\treturn weight;\n\t\n\t\t\t},\n\t\n\t\t\t_updateTimeScale: function( time ) {\n\t\n\t\t\t\tvar timeScale = 0;\n\t\n\t\t\t\tif ( ! this.paused ) {\n\t\n\t\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\t\ttimeScale *= interpolantValue;\n\t\n\t\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\t\tthis.stopWarping();\n\t\n\t\t\t\t\t\t\tif ( timeScale === 0 ) {\n\t\n\t\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\t\tthis.paused = true;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\t\treturn timeScale;\n\t\n\t\t\t},\n\t\n\t\t\t_updateTime: function( deltaTime ) {\n\t\n\t\t\t\tvar time = this.time + deltaTime;\n\t\n\t\t\t\tif ( deltaTime === 0 ) return time;\n\t\n\t\t\t\tvar duration = this._clip.duration,\n\t\n\t\t\t\t\tloop = this.loop,\n\t\t\t\t\tloopCount = this._loopCount;\n\t\n\t\t\t\tif ( loop === LoopOnce ) {\n\t\n\t\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t\t// just started\n\t\n\t\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\t\tthis._setEndings( true, true, false );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\thandle_stop: {\n\t\n\t\t\t\t\t\tif ( time >= duration ) {\n\t\n\t\t\t\t\t\t\ttime = duration;\n\t\n\t\t\t\t\t\t} else if ( time < 0 ) {\n\t\n\t\t\t\t\t\t\ttime = 0;\n\t\n\t\t\t\t\t\t} else break handle_stop;\n\t\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else { // repetitive Repeat or PingPong\n\t\n\t\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\t\n\t\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t\t// just started\n\t\n\t\t\t\t\t\tif ( deltaTime >= 0 ) {\n\t\n\t\t\t\t\t\t\tloopCount = 0;\n\t\n\t\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t\t// so leave loopCount at -1\n\t\n\t\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t\t// wrap around\n\t\n\t\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\t\ttime -= duration * loopDelta;\n\t\n\t\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\t\n\t\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\t\n\t\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\t\n\t\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\t\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// keep running\n\t\n\t\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t\t// entering the last round\n\t\n\t\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tthis._loopCount = loopCount;\n\t\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t\t// invert time for the \"pong round\"\n\t\n\t\t\t\t\t\tthis.time = time;\n\t\t\t\t\t\treturn duration - time;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.time = time;\n\t\t\t\treturn time;\n\t\n\t\t\t},\n\t\n\t\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\t\n\t\t\t\tvar settings = this._interpolantSettings;\n\t\n\t\t\t\tif ( pingPong ) {\n\t\n\t\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\t\n\t\t\t\t\tif ( atStart ) {\n\t\n\t\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( atEnd ) {\n\t\n\t\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\t\n\t\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\t\tinterpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\t\tthis._weightInterpolant = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * Player for AnimationClips.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction AnimationMixer( root ) {\n\t\n\t\t\tthis._root = root;\n\t\t\tthis._initMemoryManager();\n\t\t\tthis._accuIndex = 0;\n\t\n\t\t\tthis.time = 0;\n\t\n\t\t\tthis.timeScale = 1.0;\n\t\n\t\t}\n\t\n\t\tObject.assign( AnimationMixer.prototype, EventDispatcher.prototype, {\n\t\n\t\t\t// return an action for a clip optionally using a custom root target\n\t\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t\t// previously unknown clip/root combination is specified)\n\t\t\tclipAction: function( clip, optionalRoot ) {\n\t\n\t\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\t\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\t\tprototypeAction = null;\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\tvar existingAction =\n\t\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\t\n\t\t\t\t\tif ( existingAction !== undefined ) {\n\t\n\t\t\t\t\t\treturn existingAction;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t\t// the bindings again but can just copy\n\t\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\t\n\t\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\t\tif ( clipObject === null )\n\t\t\t\t\t\tclipObject = prototypeAction._clip;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// clip must be known when specified via string\n\t\t\t\tif ( clipObject === null ) return null;\n\t\n\t\t\t\t// allocate all resources required to run it\n\t\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\t\n\t\t\t\tthis._bindAction( newAction, prototypeAction );\n\t\n\t\t\t\t// and make the action known to the memory manager\n\t\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\t\n\t\t\t\treturn newAction;\n\t\n\t\t\t},\n\t\n\t\t\t// get an existing action\n\t\t\texistingAction: function( clip, optionalRoot ) {\n\t\n\t\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\t\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\t// deactivates all previously scheduled actions\n\t\t\tstopAllAction: function() {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\t\tthis._nActiveActions = 0;\n\t\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\t\tactions[ i ].reset();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].useCount = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// advance the time and update apply the animation\n\t\t\tupdate: function( deltaTime ) {\n\t\n\t\t\t\tdeltaTime *= this.timeScale;\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tnActions = this._nActiveActions,\n\t\n\t\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\t\n\t\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\t\n\t\t\t\t// run active actions\n\t\n\t\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\t\tvar action = actions[ i ];\n\t\n\t\t\t\t\tif ( action.enabled ) {\n\t\n\t\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update scene graph\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].apply( accuIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// return this mixer's root target object\n\t\t\tgetRoot: function() {\n\t\n\t\t\t\treturn this._root;\n\t\n\t\t\t},\n\t\n\t\t\t// free all resources specific to a particular clip\n\t\t\tuncacheClip: function( clip ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t\t// just throw away\n\t\n\t\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\t\n\t\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar action = actionsToRemove[ i ];\n\t\n\t\t\t\t\t\tthis._deactivateAction( action );\n\t\n\t\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\t\n\t\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\t\tactions.pop();\n\t\n\t\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// free all resources specific to a particular root target object\n\t\t\tuncacheRoot: function( root ) {\n\t\n\t\t\t\tvar rootUuid = root.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip;\n\t\n\t\t\t\tfor ( var clipUuid in actionsByClip ) {\n\t\n\t\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\t\n\t\t\t\t\tif ( action !== undefined ) {\n\t\n\t\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( bindingByName !== undefined ) {\n\t\n\t\t\t\t\tfor ( var trackName in bindingByName ) {\n\t\n\t\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// remove a targeted clip from the cache\n\t\t\tuncacheAction: function( clip, optionalRoot ) {\n\t\n\t\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\t\n\t\t\t\tif ( action !== null ) {\n\t\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t// Implementation details:\n\t\n\t\tObject.assign( AnimationMixer.prototype, {\n\t\n\t\t\t_bindAction: function( action, prototypeAction ) {\n\t\n\t\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( bindingsByName === undefined ) {\n\t\n\t\t\t\t\tbindingsByName = {};\n\t\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\t\n\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbinding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\t\t// existing binding, make sure the cache knows\n\t\n\t\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\t\n\t\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\t\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_activateAction: function( action ) {\n\t\n\t\t\t\tif ( ! this._isActiveAction( action ) ) {\n\t\n\t\t\t\t\tif ( action._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t\t// appears to be still using it -> rebind\n\t\n\t\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\t\n\t\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t\t// increment reference counts / sort out state\n\t\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\t\n\t\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\t\tbinding.saveOriginalState();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._lendAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_deactivateAction: function( action ) {\n\t\n\t\t\t\tif ( this._isActiveAction( action ) ) {\n\t\n\t\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\t\n\t\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\t\tthis._takeBackBinding( binding );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._takeBackAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// Memory manager\n\t\n\t\t\t_initMemoryManager: function() {\n\t\n\t\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\t\tthis._nActiveActions = 0;\n\t\n\t\t\t\tthis._actionsByClip = {};\n\t\t\t\t// inside:\n\t\t\t\t// {\n\t\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t\t// }\n\t\n\t\n\t\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\t\n\t\n\t\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\t\tthis._nActiveControlInterpolants = 0;\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tthis.stats = {\n\t\n\t\t\t\t\tactions: {\n\t\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t\t},\n\t\t\t\t\tbindings: {\n\t\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t\t},\n\t\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t},\n\t\n\t\t\t// Memory management for AnimationAction objects\n\t\n\t\t\t_isActiveAction: function( action ) {\n\t\n\t\t\t\tvar index = action._cacheIndex;\n\t\t\t\treturn index !== null && index < this._nActiveActions;\n\t\n\t\t\t},\n\t\n\t\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip === undefined ) {\n\t\n\t\t\t\t\tactionsForClip = {\n\t\n\t\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\t\tactionByRoot: {}\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t\taction._byClipCacheIndex = 0;\n\t\n\t\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\t\n\t\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\t\tknownActions.push( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t\taction._cacheIndex = actions.length;\n\t\t\t\tactions.push( action );\n\t\n\t\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveAction: function( action ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\t\tcacheIndex = action._cacheIndex;\n\t\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\t\n\t\t\t\taction._cacheIndex = null;\n\t\n\t\n\t\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\t\n\t\t\t\t\tlastKnownAction =\n\t\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\t\n\t\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\t\n\t\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\t\tknownActionsForClip.pop();\n\t\n\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\n\t\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\t\n\t\t\t\tdelete actionByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( knownActionsForClip.length === 0 ) {\n\t\n\t\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveBindingsForAction: function( action ) {\n\t\n\t\t\t\tvar bindings = action._propertyBindings;\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\t\n\t\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_lendAction: function( action ) {\n\t\n\t\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t\t// [  active actions >| inactive actions ]\n\t\t\t\t//                 s        a\n\t\t\t\t//                  <-swap->\n\t\t\t\t//                 a        s\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\t\n\t\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\t\n\t\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\t\tactions[ lastActiveIndex ] = action;\n\t\n\t\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackAction: function( action ) {\n\t\n\t\t\t\t// [  active actions  | inactive actions ]\n\t\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t\t//        a        s\n\t\t\t\t//         <-swap->\n\t\t\t\t//        s        a\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\t\n\t\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\t\n\t\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\t\tactions[ firstInactiveIndex ] = action;\n\t\n\t\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\t\tactions[ prevIndex ] = lastActiveAction;\n\t\n\t\t\t},\n\t\n\t\t\t// Memory management for PropertyMixer objects\n\t\n\t\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\t\n\t\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\t\tbindings = this._bindings;\n\t\n\t\t\t\tif ( bindingByName === undefined ) {\n\t\n\t\t\t\t\tbindingByName = {};\n\t\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tbindingByName[ trackName ] = binding;\n\t\n\t\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\t\tbindings.push( binding );\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveBinding: function( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tpropBinding = binding.binding,\n\t\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\t\ttrackName = propBinding.path,\n\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\t\tcacheIndex = binding._cacheIndex;\n\t\n\t\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\t\tbindings.pop();\n\t\n\t\t\t\tdelete bindingByName[ trackName ];\n\t\n\t\t\t\tremove_empty_map: {\n\t\n\t\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\t\n\t\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_lendBinding: function( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\t\n\t\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\t\n\t\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\t\tbindings[ lastActiveIndex ] = binding;\n\t\n\t\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackBinding: function( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\t\n\t\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\t\n\t\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\t\tbindings[ firstInactiveIndex ] = binding;\n\t\n\t\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// Memory management of Interpolants for weight and time scale\n\t\n\t\t\t_lendControlInterpolant: function() {\n\t\n\t\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\t\n\t\t\t\tif ( interpolant === undefined ) {\n\t\n\t\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\t\n\t\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn interpolant;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackControlInterpolant: function( interpolant ) {\n\t\n\t\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\t\n\t\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\t\n\t\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\t\n\t\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\t\n\t\t\t},\n\t\n\t\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Uniform( value ) {\n\t\n\t\t\tif ( typeof value === 'string' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\t\tvalue = arguments[ 1 ];\n\t\n\t\t\t}\n\t\n\t\t\tthis.value = value;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedBufferGeometry() {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'InstancedBufferGeometry';\n\t\t\tthis.maxInstancedCount = undefined;\n\t\n\t\t}\n\t\n\t\tInstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tInstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;\n\t\n\t\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\t\n\t\tInstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {\n\t\n\t\t\tthis.groups.push( {\n\t\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex\n\t\n\t\t\t} );\n\t\n\t\t};\n\t\n\t\tInstancedBufferGeometry.prototype.copy = function ( source ) {\n\t\n\t\t\tvar index = source.index;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = source.attributes;\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar groups = source.groups;\n\t\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.data = interleavedBuffer;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.offset = offset;\n\t\n\t\t\tthis.normalized = normalized === true;\n\t\n\t\t}\n\t\n\t\n\t\tInterleavedBufferAttribute.prototype = {\n\t\n\t\t\tconstructor: InterleavedBufferAttribute,\n\t\n\t\t\tisInterleavedBufferAttribute: true,\n\t\n\t\t\tget count() {\n\t\n\t\t\t\treturn this.data.count;\n\t\n\t\t\t},\n\t\n\t\t\tget array() {\n\t\n\t\t\t\treturn this.data.array;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( index, x ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( index, y ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( index, z ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( index, w ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetX: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\t\n\t\t\t},\n\t\n\t\t\tgetY: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\t\n\t\t\t},\n\t\n\t\t\tgetZ: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\t\n\t\t\t},\n\t\n\t\t\tgetW: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\t\tthis.data.array[ index + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\t\tthis.data.array[ index + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InterleavedBuffer( array, stride ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.array = array;\n\t\t\tthis.stride = stride;\n\t\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\t\n\t\t\tthis.dynamic = false;\n\t\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\t\tthis.version = 0;\n\t\n\t\t}\n\t\n\t\tInterleavedBuffer.prototype = {\n\t\n\t\t\tconstructor: InterleavedBuffer,\n\t\n\t\t\tisInterleavedBuffer: true,\n\t\n\t\t\tset needsUpdate( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t},\n\t\n\t\t\tsetArray: function ( array ) {\n\t\n\t\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\t\tthis.array = array;\n\t\n\t\t\t},\n\t\n\t\t\tsetDynamic: function ( value ) {\n\t\n\t\t\t\tthis.dynamic = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\t\tthis.count = source.count;\n\t\t\t\tthis.stride = source.stride;\n\t\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\t\tindex1 *= this.stride;\n\t\t\t\tindex2 *= attribute.stride;\n\t\n\t\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.array.set( value, offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\t\n\t\t\tInterleavedBuffer.call( this, array, stride );\n\t\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t\t}\n\t\n\t\tInstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );\n\t\tInstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;\n\t\n\t\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\t\n\t\tInstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\t\n\t\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\t\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\t\n\t\t\tBufferAttribute.call( this, array, itemSize );\n\t\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t\t}\n\t\n\t\tInstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tInstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;\n\t\n\t\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\t\n\t\tInstancedBufferAttribute.prototype.copy = function ( source ) {\n\t\n\t\t\tBufferAttribute.prototype.copy.call( this, source );\n\t\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author bhouston / http://clara.io/\n\t\t * @author stephomi / http://stephaneginier.com/\n\t\t */\n\t\n\t\tfunction Raycaster( origin, direction, near, far ) {\n\t\n\t\t\tthis.ray = new Ray( origin, direction );\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\tthis.near = near || 0;\n\t\t\tthis.far = far || Infinity;\n\t\n\t\t\tthis.params = {\n\t\t\t\tMesh: {},\n\t\t\t\tLine: {},\n\t\t\t\tLOD: {},\n\t\t\t\tPoints: { threshold: 1 },\n\t\t\t\tSprite: {}\n\t\t\t};\n\t\n\t\t\tObject.defineProperties( this.params, {\n\t\t\t\tPointCloud: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\t\treturn this.Points;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tfunction ascSort( a, b ) {\n\t\n\t\t\treturn a.distance - b.distance;\n\t\n\t\t}\n\t\n\t\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tobject.raycast( raycaster, intersects );\n\t\n\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tRaycaster.prototype = {\n\t\n\t\t\tconstructor: Raycaster,\n\t\n\t\t\tlinePrecision: 1,\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\t\tthis.ray.set( origin, direction );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCamera: function ( coords, camera ) {\n\t\n\t\t\t\tif ( (camera && camera.isPerspectiveCamera) ) {\n\t\n\t\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\n\t\t\t\t} else if ( (camera && camera.isOrthographicCamera) ) {\n\t\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tintersectObject: function ( object, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tintersectObject( object, this, intersects, recursive );\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t},\n\t\n\t\t\tintersectObjects: function ( objects, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tif ( Array.isArray( objects ) === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\t\treturn intersects;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Clock( autoStart ) {\n\t\n\t\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\t\n\t\t\tthis.startTime = 0;\n\t\t\tthis.oldTime = 0;\n\t\t\tthis.elapsedTime = 0;\n\t\n\t\t\tthis.running = false;\n\t\n\t\t}\n\t\n\t\tClock.prototype = {\n\t\n\t\t\tconstructor: Clock,\n\t\n\t\t\tstart: function () {\n\t\n\t\t\t\tthis.startTime = ( performance || Date ).now();\n\t\n\t\t\t\tthis.oldTime = this.startTime;\n\t\t\t\tthis.elapsedTime = 0;\n\t\t\t\tthis.running = true;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function () {\n\t\n\t\t\t\tthis.getElapsedTime();\n\t\t\t\tthis.running = false;\n\t\n\t\t\t},\n\t\n\t\t\tgetElapsedTime: function () {\n\t\n\t\t\t\tthis.getDelta();\n\t\t\t\treturn this.elapsedTime;\n\t\n\t\t\t},\n\t\n\t\t\tgetDelta: function () {\n\t\n\t\t\t\tvar diff = 0;\n\t\n\t\t\t\tif ( this.autoStart && ! this.running ) {\n\t\n\t\t\t\t\tthis.start();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.running ) {\n\t\n\t\t\t\t\tvar newTime = ( performance || Date ).now();\n\t\n\t\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\t\tthis.oldTime = newTime;\n\t\n\t\t\t\t\tthis.elapsedTime += diff;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn diff;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Spline from Tween.js, slightly optimized (and trashed)\n\t\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t\t *\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Spline( points ) {\n\t\n\t\t\tthis.points = points;\n\t\n\t\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\t\tpoint, intPoint, weight, w2, w3,\n\t\t\tpa, pb, pc, pd;\n\t\n\t\t\tthis.initFromArray = function ( a ) {\n\t\n\t\t\t\tthis.points = [];\n\t\n\t\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\t\n\t\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPoint = function ( k ) {\n\t\n\t\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\t\n\t\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\t\tc[ 1 ] = intPoint;\n\t\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\t\n\t\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\t\tpd = this.points[ c[ 3 ] ];\n\t\n\t\t\t\tw2 = weight * weight;\n\t\t\t\tw3 = weight * w2;\n\t\n\t\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\t\n\t\t\t\treturn v3;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getControlPointsArray = function () {\n\t\n\t\t\t\tvar i, p, l = this.points.length,\n\t\t\t\t\tcoords = [];\n\t\n\t\t\t\tfor ( i = 0; i < l; i ++ ) {\n\t\n\t\t\t\t\tp = this.points[ i ];\n\t\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn coords;\n\t\n\t\t\t};\n\t\n\t\t\t// approximate length by summing linear segments\n\t\n\t\t\tthis.getLength = function ( nSubDivisions ) {\n\t\n\t\t\t\tvar i, index, nSamples, position,\n\t\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\t\toldPosition = new Vector3(),\n\t\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\t\tchunkLengths = [],\n\t\t\t\t\ttotalLength = 0;\n\t\n\t\t\t\t// first point has 0 length\n\t\n\t\t\t\tchunkLengths[ 0 ] = 0;\n\t\n\t\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\t\n\t\t\t\tnSamples = this.points.length * nSubDivisions;\n\t\n\t\t\t\toldPosition.copy( this.points[ 0 ] );\n\t\n\t\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\t\n\t\t\t\t\tindex = i / nSamples;\n\t\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\ttmpVec.copy( position );\n\t\n\t\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\t\n\t\t\t\t\toldPosition.copy( position );\n\t\n\t\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\t\tintPoint = Math.floor( point );\n\t\n\t\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\t\n\t\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\t\toldIntPoint = intPoint;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// last point ends with total length\n\t\n\t\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\t\n\t\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\t\n\t\t\t};\n\t\n\t\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\t\n\t\t\t\tvar i, j,\n\t\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\t\trealDistance,\n\t\t\t\t\tsampling, position,\n\t\t\t\t\tnewpoints = [],\n\t\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\t\tsl = this.getLength();\n\t\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\t\n\t\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\t\n\t\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\t\n\t\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\t\n\t\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\t\n\t\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\t\n\t\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\t\n\t\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\t\n\t\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.points = newpoints;\n\t\n\t\t\t};\n\t\n\t\t\t// Catmull-Rom\n\t\n\t\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\t\n\t\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\t\n\t\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t\t *\n\t\t * The poles (phi) are at the positive and negative y axis.\n\t\t * The equator starts at positive z.\n\t\t */\n\t\n\t\tfunction Spherical( radius, phi, theta ) {\n\t\n\t\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t\tSpherical.prototype = {\n\t\n\t\t\tconstructor: Spherical,\n\t\n\t\t\tset: function ( radius, phi, theta ) {\n\t\n\t\t\t\tthis.radius = radius;\n\t\t\t\tthis.phi = phi;\n\t\t\t\tthis.theta = theta;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( other ) {\n\t\n\t\t\t\tthis.radius = other.radius;\n\t\t\t\tthis.phi = other.phi;\n\t\t\t\tthis.theta = other.theta;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\t\tmakeSafe: function() {\n\t\n\t\t\t\tvar EPS = 0.000001;\n\t\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromVector3: function( vec3 ) {\n\t\n\t\t\t\tthis.radius = vec3.length();\n\t\n\t\t\t\tif ( this.radius === 0 ) {\n\t\n\t\t\t\t\tthis.theta = 0;\n\t\t\t\t\tthis.phi = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t};\n\t\n\t\t/**\r\n\t\t * @author alteredq / http://alteredqualia.com/\r\n\t\t */\r\n\t\r\n\t\tfunction MorphBlendMesh( geometry, material ) {\n\t\r\n\t\t\tMesh.call( this, geometry, material );\r\n\t\r\n\t\t\tthis.animationsMap = {};\r\n\t\t\tthis.animationsList = [];\r\n\t\r\n\t\t\t// prepare default animation\r\n\t\t\t// (all frames played together in 1 second)\r\n\t\r\n\t\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\t\r\n\t\t\tvar name = \"__default\";\r\n\t\r\n\t\t\tvar startFrame = 0;\r\n\t\t\tvar endFrame = numFrames - 1;\r\n\t\r\n\t\t\tvar fps = numFrames / 1;\r\n\t\r\n\t\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\t\tthis.setAnimationWeight( name, 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tMorphBlendMesh.prototype = Object.create( Mesh.prototype );\r\n\t\tMorphBlendMesh.prototype.constructor = MorphBlendMesh;\r\n\t\r\n\t\tMorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\t\r\n\t\t\tvar animation = {\r\n\t\r\n\t\t\t\tstart: start,\r\n\t\t\t\tend: end,\r\n\t\r\n\t\t\t\tlength: end - start + 1,\r\n\t\r\n\t\t\t\tfps: fps,\r\n\t\t\t\tduration: ( end - start ) / fps,\r\n\t\r\n\t\t\t\tlastFrame: 0,\r\n\t\t\t\tcurrentFrame: 0,\r\n\t\r\n\t\t\t\tactive: false,\r\n\t\r\n\t\t\t\ttime: 0,\r\n\t\t\t\tdirection: 1,\r\n\t\t\t\tweight: 1,\r\n\t\r\n\t\t\t\tdirectionBackwards: false,\r\n\t\t\t\tmirroredLoop: false\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tthis.animationsMap[ name ] = animation;\r\n\t\t\tthis.animationsList.push( animation );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\t\r\n\t\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\t\r\n\t\t\tvar firstAnimation, frameRanges = {};\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\r\n\t\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\t\tvar chunks = morph.name.match( pattern );\r\n\t\r\n\t\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\t\r\n\t\t\t\t\tvar name = chunks[ 1 ];\r\n\t\r\n\t\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\t\tvar range = frameRanges[ name ];\r\n\t\r\n\t\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\t\tif ( i > range.end ) range.end = i;\r\n\t\r\n\t\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var name in frameRanges ) {\r\n\t\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\t\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.firstAnimation = firstAnimation;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.direction = 1;\r\n\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.direction = - 1;\r\n\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.fps = fps;\r\n\t\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.duration = duration;\r\n\t\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.weight = weight;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.time = time;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\t\r\n\t\t\tvar time = 0;\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\ttime = animation.time;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn time;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\t\r\n\t\t\tvar duration = - 1;\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tduration = animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn duration;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.time = 0;\r\n\t\t\t\tanimation.active = true;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\t\r\n\t\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\t\tif ( animation ) {\r\n\t\r\n\t\t\t\tanimation.active = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tMorphBlendMesh.prototype.update = function ( delta ) {\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar animation = this.animationsList[ i ];\r\n\t\r\n\t\t\t\tif ( ! animation.active ) continue;\r\n\t\r\n\t\t\t\tvar frameTime = animation.duration / animation.length;\r\n\t\r\n\t\t\t\tanimation.time += animation.direction * delta;\r\n\t\r\n\t\t\t\tif ( animation.mirroredLoop ) {\r\n\t\r\n\t\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\tanimation.direction *= - 1;\r\n\t\r\n\t\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\t\r\n\t\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\t\r\n\t\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\t\tvar weight = animation.weight;\r\n\t\r\n\t\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\t\tanimation.currentFrame = keyframe;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\t\r\n\t\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\t\r\n\t\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction ImmediateRenderObject( material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.material = material;\n\t\t\tthis.render = function ( renderCallback ) {};\n\t\n\t\t}\n\t\n\t\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\t\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\t\n\t\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\t\n\t\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t\t//\n\t\n\t\t\tvar nNormals = 0;\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\t\n\t\t\t\tnNormals = objGeometry.faces.length * 3;\n\t\n\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\t\n\t\t\t\tnNormals = objGeometry.attributes.normal.count;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t\t//\n\t\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\t\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\t\n\t\tVertexNormalsHelper.prototype.update = ( function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar normalMatrix = new Matrix3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\t\n\t\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\t\n\t\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\t\n\t\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\t\n\t\t\t\t\tvar objPos = objGeometry.attributes.position;\n\t\n\t\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\t\n\t\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\t\n\t\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\t\n\t\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction SpotLightHelper( light ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = [\n\t\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t\t0, 0, 0,   0, - 1,   1\n\t\t\t];\n\t\n\t\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\t\n\t\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\t\n\t\t\t\tpositions.push(\n\t\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { fog: false } );\n\t\n\t\t\tthis.cone = new LineSegments( geometry, material );\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\t\n\t\tSpotLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.cone.geometry.dispose();\n\t\t\tthis.cone.material.dispose();\n\t\n\t\t};\n\t\n\t\tSpotLightHelper.prototype.update = function () {\n\t\n\t\t\tvar vector = new Vector3();\n\t\t\tvar vector2 = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\t\n\t\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\t\n\t\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\n\t\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\t\n\t\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author Sean Griffin / http://twitter.com/sgrif\n\t\t * @author Michael Guerrero / http://realitymeltdown.com\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction SkeletonHelper( object ) {\n\t\n\t\t\tthis.bones = this.getBoneList( object );\n\t\n\t\t\tvar geometry = new Geometry();\n\t\n\t\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\t\n\t\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\t\tgeometry.colors.push( new Color( 0, 0, 1 ) );\n\t\t\t\t\tgeometry.colors.push( new Color( 0, 1, 0 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.dynamic = true;\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t\tthis.root = object;\n\t\n\t\t\tthis.matrix = object.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\n\t\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\t\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\t\n\t\tSkeletonHelper.prototype.getBoneList = function( object ) {\n\t\n\t\t\tvar boneList = [];\n\t\n\t\t\tif ( (object && object.isBone) ) {\n\t\n\t\t\t\tboneList.push( object );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\t\n\t\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn boneList;\n\t\n\t\t};\n\t\n\t\tSkeletonHelper.prototype.update = function () {\n\t\n\t\t\tvar geometry = this.geometry;\n\t\n\t\t\tvar matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );\n\t\n\t\t\tvar boneMatrix = new Matrix4();\n\t\n\t\t\tvar j = 0;\n\t\n\t\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\t\n\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\t\tj += 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction PointLightHelper( light, sphereSize ) {\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\tMesh.call( this, geometry, material );\n\t\n\t\t\tthis.matrix = this.light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\t/*\n\t\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\t\n\t\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\t\n\t\t\tvar d = light.distance;\n\t\n\t\t\tif ( d === 0.0 ) {\n\t\n\t\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t\t}\n\t\n\t\t\tthis.add( this.lightDistance );\n\t\t\t*/\n\t\n\t\t}\n\t\n\t\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\t\tPointLightHelper.prototype.constructor = PointLightHelper;\n\t\n\t\tPointLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\n\t\t};\n\t\n\t\tPointLightHelper.prototype.update = function () {\n\t\n\t\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t/*\n\t\t\tvar d = this.light.distance;\n\t\n\t\t\tif ( d === 0.0 ) {\n\t\n\t\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.lightDistance.visible = true;\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t\t}\n\t\t\t*/\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction HemisphereLightHelper( light, sphereSize ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.colors = [ new Color(), new Color() ];\n\t\n\t\t\tvar geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\t\tgeometry.rotateX( - Math.PI / 2 );\n\t\n\t\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\t\n\t\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\t\n\t\t\t}\n\t\n\t\t\tvar material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );\n\t\n\t\t\tthis.lightSphere = new Mesh( geometry, material );\n\t\t\tthis.add( this.lightSphere );\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\t\n\t\tHemisphereLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.lightSphere.geometry.dispose();\n\t\t\tthis.lightSphere.material.dispose();\n\t\n\t\t};\n\t\n\t\tHemisphereLightHelper.prototype.update = function () {\n\t\n\t\t\tvar vector = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction GridHelper( size, divisions, color1, color2 ) {\n\t\n\t\t\tdivisions = divisions || 1;\n\t\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\t\n\t\t\tvar center = divisions / 2;\n\t\t\tvar step = ( size * 2 ) / divisions;\n\t\t\tvar vertices = [], colors = [];\n\t\n\t\t\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\t\n\t\t\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\t\t\tvertices.push( k, 0, - size, k, 0, size );\n\t\n\t\t\t\tvar color = i === center ? color1 : color2;\n\t\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\n\t\t\t}\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t}\n\t\n\t\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\t\tGridHelper.prototype.constructor = GridHelper;\n\t\n\t\tGridHelper.prototype.setColors = function () {\n\t\n\t\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\t\n\t\t\t// FaceNormalsHelper only supports THREE.Geometry\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\t\n\t\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t\t//\n\t\n\t\t\tvar nNormals = 0;\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\t\n\t\t\t\tnNormals = objGeometry.faces.length;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t\t//\n\t\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\t\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\t\n\t\tFaceNormalsHelper.prototype.update = ( function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar normalMatrix = new Matrix3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\tvar idx = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t\t.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction DirectionalLightHelper( light, size ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tif ( size === undefined ) size = 1;\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( [\n\t\t\t\t- size,   size, 0,\n\t\t\t\t  size,   size, 0,\n\t\t\t\t  size, - size, 0,\n\t\t\t\t- size, - size, 0,\n\t\t\t\t- size,   size, 0\n\t\t\t], 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { fog: false } );\n\t\n\t\t\tthis.add( new Line( geometry, material ) );\n\t\n\t\t\tgeometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\t\n\t\t\tthis.add( new Line( geometry, material ));\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\t\n\t\tDirectionalLightHelper.prototype.dispose = function () {\n\t\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\t\tlightPlane.geometry.dispose();\n\t\t\tlightPlane.material.dispose();\n\t\t\ttargetLine.geometry.dispose();\n\t\t\ttargetLine.material.dispose();\n\t\n\t\t};\n\t\n\t\tDirectionalLightHelper.prototype.update = function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar v3 = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\t\tv3.subVectors( v2, v1 );\n\t\n\t\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\t\t\tlightPlane.lookAt( v3 );\n\t\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\t\ttargetLine.lookAt( v3 );\n\t\t\t\ttargetLine.scale.z = v3.length();\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t *\t- shows frustum, line of sight and up of the camera\n\t\t *\t- suitable for fast updates\n\t\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t\t */\n\t\n\t\tfunction CameraHelper( camera ) {\n\t\n\t\t\tvar geometry = new Geometry();\n\t\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\t\n\t\t\tvar pointMap = {};\n\t\n\t\t\t// colors\n\t\n\t\t\tvar hexFrustum = 0xffaa00;\n\t\t\tvar hexCone = 0xff0000;\n\t\t\tvar hexUp = 0x00aaff;\n\t\t\tvar hexTarget = 0xffffff;\n\t\t\tvar hexCross = 0x333333;\n\t\n\t\t\t// near\n\t\n\t\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\t\n\t\t\t// far\n\t\n\t\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\t\n\t\t\t// sides\n\t\n\t\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\t\n\t\t\t// cone\n\t\n\t\t\taddLine( \"p\", \"n1\", hexCone );\n\t\t\taddLine( \"p\", \"n2\", hexCone );\n\t\t\taddLine( \"p\", \"n3\", hexCone );\n\t\t\taddLine( \"p\", \"n4\", hexCone );\n\t\n\t\t\t// up\n\t\n\t\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\t\taddLine( \"u3\", \"u1\", hexUp );\n\t\n\t\t\t// target\n\t\n\t\t\taddLine( \"c\", \"t\", hexTarget );\n\t\t\taddLine( \"p\", \"c\", hexCross );\n\t\n\t\t\t// cross\n\t\n\t\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\t\n\t\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\t\n\t\t\tfunction addLine( a, b, hex ) {\n\t\n\t\t\t\taddPoint( a, hex );\n\t\t\t\taddPoint( b, hex );\n\t\n\t\t\t}\n\t\n\t\t\tfunction addPoint( id, hex ) {\n\t\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.colors.push( new Color( hex ) );\n\t\n\t\t\t\tif ( pointMap[ id ] === undefined ) {\n\t\n\t\t\t\t\tpointMap[ id ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\t\n\t\t\t}\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t\tthis.camera = camera;\n\t\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\t\n\t\t\tthis.matrix = camera.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.pointMap = pointMap;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\t\tCameraHelper.prototype.constructor = CameraHelper;\n\t\n\t\tCameraHelper.prototype.update = function () {\n\t\n\t\t\tvar geometry, pointMap;\n\t\n\t\t\tvar vector = new Vector3();\n\t\t\tvar camera = new Camera();\n\t\n\t\t\tfunction setPoint( point, x, y, z ) {\n\t\n\t\t\t\tvector.set( x, y, z ).unproject( camera );\n\t\n\t\t\t\tvar points = pointMap[ point ];\n\t\n\t\t\t\tif ( points !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tgeometry = this.geometry;\n\t\t\t\tpointMap = this.pointMap;\n\t\n\t\t\t\tvar w = 1, h = 1;\n\t\n\t\t\t\t// we need just camera projection matrix\n\t\t\t\t// world matrix must be identity\n\t\n\t\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\t\n\t\t\t\t// center / target\n\t\n\t\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\t\n\t\t\t\t// near\n\t\n\t\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\t\n\t\t\t\t// far\n\t\n\t\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\t\n\t\t\t\t// up\n\t\n\t\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\t\n\t\t\t\t// cross\n\t\n\t\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\t\n\t\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\t\n\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\t// a helper to show the world-axis-aligned bounding box for an object\n\t\n\t\tfunction BoundingBoxHelper( object, hex ) {\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.box = new Box3();\n\t\n\t\t\tMesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );\n\t\n\t\t}\n\t\n\t\tBoundingBoxHelper.prototype = Object.create( Mesh.prototype );\n\t\tBoundingBoxHelper.prototype.constructor = BoundingBoxHelper;\n\t\n\t\tBoundingBoxHelper.prototype.update = function () {\n\t\n\t\t\tthis.box.setFromObject( this.object );\n\t\n\t\t\tthis.box.getSize( this.scale );\n\t\n\t\t\tthis.box.getCenter( this.position );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BoxHelper( object, color ) {\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\n\t\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\t\tvar positions = new Float32Array( 8 * 3 );\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\t\n\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\tthis.update( object );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\t\tBoxHelper.prototype.constructor = BoxHelper;\n\t\n\t\tBoxHelper.prototype.update = ( function () {\n\t\n\t\t\tvar box = new Box3();\n\t\n\t\t\treturn function update( object ) {\n\t\n\t\t\t\tif ( (object && object.isBox3) ) {\n\t\n\t\t\t\t\tbox.copy( object );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tbox.setFromObject( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( box.isEmpty() ) return;\n\t\n\t\t\t\tvar min = box.min;\n\t\t\t\tvar max = box.max;\n\t\n\t\t\t\t/*\n\t\t\t\t  5____4\n\t\t\t\t1/___0/|\n\t\t\t\t| 6__|_7\n\t\t\t\t2/___3/\n\t\n\t\t\t\t0: max.x, max.y, max.z\n\t\t\t\t1: min.x, max.y, max.z\n\t\t\t\t2: min.x, min.y, max.z\n\t\t\t\t3: max.x, min.y, max.z\n\t\t\t\t4: max.x, max.y, min.z\n\t\t\t\t5: min.x, max.y, min.z\n\t\t\t\t6: min.x, min.y, min.z\n\t\t\t\t7: max.x, min.y, min.z\n\t\t\t\t*/\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\t\t\tvar array = position.array;\n\t\n\t\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\tthis.geometry.computeBoundingSphere();\n\t\n\t\t\t};\n\t\n\t\t} )();\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author zz85 / http://github.com/zz85\n\t\t * @author bhouston / http://clara.io\n\t\t *\n\t\t * Creates an arrow for visualizing directions\n\t\t *\n\t\t * Parameters:\n\t\t *  dir - Vector3\n\t\t *  origin - Vector3\n\t\t *  length - Number\n\t\t *  color - color in hex value\n\t\t *  headLength - Number\n\t\t *  headWidth - Number\n\t\t */\n\t\n\t\tvar lineGeometry = new BufferGeometry();\n\t\tlineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\t\n\t\tvar coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\n\t\n\t\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\t\n\t\t\t// dir is assumed to be normalized\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\t\tif ( length === undefined ) length = 1;\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tthis.position.copy( origin );\n\t\n\t\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\t\tthis.line.matrixAutoUpdate = false;\n\t\t\tthis.add( this.line );\n\t\n\t\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\t\tthis.cone.matrixAutoUpdate = false;\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.setDirection( dir );\n\t\t\tthis.setLength( length, headLength, headWidth );\n\t\n\t\t}\n\t\n\t\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\t\tArrowHelper.prototype.constructor = ArrowHelper;\n\t\n\t\tArrowHelper.prototype.setDirection = ( function () {\n\t\n\t\t\tvar axis = new Vector3();\n\t\t\tvar radians;\n\t\n\t\t\treturn function setDirection( dir ) {\n\t\n\t\t\t\t// dir is assumed to be normalized\n\t\n\t\t\t\tif ( dir.y > 0.99999 ) {\n\t\n\t\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\t\n\t\t\t\t} else if ( dir.y < - 0.99999 ) {\n\t\n\t\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\t\n\t\t\t\t\tradians = Math.acos( dir.y );\n\t\n\t\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\t\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\t\tthis.line.updateMatrix();\n\t\n\t\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\t\tthis.cone.position.y = length;\n\t\t\tthis.cone.updateMatrix();\n\t\n\t\t};\n\t\n\t\tArrowHelper.prototype.setColor = function ( color ) {\n\t\n\t\t\tthis.line.material.color.copy( color );\n\t\t\tthis.cone.material.color.copy( color );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author sroucheray / http://sroucheray.org/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AxisHelper( size ) {\n\t\n\t\t\tsize = size || 1;\n\t\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t\t0, 0, 0,  0, 0, size\n\t\t\t] );\n\t\n\t\t\tvar colors = new Float32Array( [\n\t\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t\t] );\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t}\n\t\n\t\tAxisHelper.prototype = Object.create( LineSegments.prototype );\n\t\tAxisHelper.prototype.constructor = AxisHelper;\n\t\n\t\t/**\n\t\t * @author zz85 https://github.com/zz85\n\t\t *\n\t\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t\t *\n\t\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t\t * curve.tension is used for catmullrom which defaults to 0.5\n\t\t */\n\t\n\t\tvar CatmullRomCurve3 = ( function() {\n\t\n\t\t\tvar\n\t\t\t\ttmp = new Vector3(),\n\t\t\t\tpx = new CubicPoly(),\n\t\t\t\tpy = new CubicPoly(),\n\t\t\t\tpz = new CubicPoly();\n\t\n\t\t\t/*\n\t\t\tBased on an optimized c++ solution in\n\t\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t\t - http://ideone.com/NoEbVM\n\t\n\t\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\t\twhich can be placed in CurveUtils.\n\t\t\t*/\n\t\n\t\t\tfunction CubicPoly() {}\n\t\n\t\t\t/*\n\t\t\t * Compute coefficients for a cubic polynomial\n\t\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t\t * such that\n\t\t\t *   p(0) = x0, p(1) = x1\n\t\t\t *  and\n\t\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t\t */\n\t\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\t\n\t\t\t\tthis.c0 = x0;\n\t\t\t\tthis.c1 = t0;\n\t\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\n\t\t\t};\n\t\n\t\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\t\n\t\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\t\n\t\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\t\tt1 *= dt1;\n\t\t\t\tt2 *= dt1;\n\t\n\t\t\t\t// initCubicPoly\n\t\t\t\tthis.init( x1, x2, t1, t2 );\n\t\n\t\t\t};\n\t\n\t\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\t\n\t\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\t\n\t\t\t};\n\t\n\t\t\tCubicPoly.prototype.calc = function( t ) {\n\t\n\t\t\t\tvar t2 = t * t;\n\t\t\t\tvar t3 = t2 * t;\n\t\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\t\n\t\t\t};\n\t\n\t\t\t// Subclass Three.js curve\n\t\t\treturn Curve.create(\n\t\n\t\t\t\tfunction ( p /* array of Vector3 */ ) {\n\t\n\t\t\t\t\tthis.points = p || [];\n\t\t\t\t\tthis.closed = false;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction ( t ) {\n\t\n\t\t\t\t\tvar points = this.points,\n\t\t\t\t\t\tpoint, intPoint, weight, l;\n\t\n\t\t\t\t\tl = points.length;\n\t\n\t\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\t\n\t\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\t\tweight = point - intPoint;\n\t\n\t\t\t\t\tif ( this.closed ) {\n\t\n\t\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\t\n\t\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\t\n\t\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\t\tweight = 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\t\n\t\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\t\n\t\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// extrapolate first point\n\t\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\t\tp0 = tmp;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\t\n\t\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\t\n\t\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// extrapolate last point\n\t\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\t\tp3 = tmp;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\t\n\t\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\t\n\t\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\t\n\t\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\t\n\t\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\t\n\t\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar v = new Vector3(\n\t\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\t\tpz.calc( weight )\n\t\t\t\t\t);\n\t\n\t\t\t\t\treturn v;\n\t\n\t\t\t\t}\n\t\n\t\t\t);\n\t\n\t\t} )();\n\t\n\t\t/**************************************************************\n\t\t *\tClosed Spline 3D curve\n\t\t **************************************************************/\n\t\n\t\n\t\tfunction ClosedSplineCurve3( points ) {\n\t\n\t\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\t\n\t\t\tCatmullRomCurve3.call( this, points );\n\t\t\tthis.type = 'catmullrom';\n\t\t\tthis.closed = true;\n\t\n\t\t}\n\t\n\t\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\t\n\t\t/**************************************************************\n\t\t *\tSpline 3D curve\n\t\t **************************************************************/\n\t\n\t\n\t\tvar SplineCurve3 = Curve.create(\n\t\n\t\t\tfunction ( points /* array of Vector3 */ ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar points = this.points;\n\t\t\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\t\t\tvar intPoint = Math.floor( point );\n\t\t\t\tvar weight = point - intPoint;\n\t\n\t\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\t\tvar point1 = points[ intPoint ];\n\t\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\t\t\tvar interpolate = CurveUtils.interpolate;\n\t\n\t\t\t\treturn new Vector3(\n\t\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tCubic Bezier 3D curve\n\t\t **************************************************************/\n\t\n\t\tvar CubicBezierCurve3 = Curve.create(\n\t\n\t\t\tfunction ( v0, v1, v2, v3 ) {\n\t\n\t\t\t\tthis.v0 = v0;\n\t\t\t\tthis.v1 = v1;\n\t\t\t\tthis.v2 = v2;\n\t\t\t\tthis.v3 = v3;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar b3 = ShapeUtils.b3;\n\t\n\t\t\t\treturn new Vector3(\n\t\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tQuadratic Bezier 3D curve\n\t\t **************************************************************/\n\t\n\t\tvar QuadraticBezierCurve3 = Curve.create(\n\t\n\t\t\tfunction ( v0, v1, v2 ) {\n\t\n\t\t\t\tthis.v0 = v0;\n\t\t\t\tthis.v1 = v1;\n\t\t\t\tthis.v2 = v2;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar b2 = ShapeUtils.b2;\n\t\n\t\t\t\treturn new Vector3(\n\t\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tLine3D\n\t\t **************************************************************/\n\t\n\t\tvar LineCurve3 = Curve.create(\n\t\n\t\t\tfunction ( v1, v2 ) {\n\t\n\t\t\t\tthis.v1 = v1;\n\t\t\t\tthis.v2 = v2;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tif ( t === 1 ) {\n\t\n\t\t\t\t\treturn this.v2.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\t\tvector.multiplyScalar( t );\n\t\t\t\tvector.add( this.v1 );\n\t\n\t\t\t\treturn vector;\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t\t/**************************************************************\n\t\t *\tArc curve\n\t\t **************************************************************/\n\t\n\t\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t}\n\t\n\t\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\t\tArcCurve.prototype.constructor = ArcCurve;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tvar SceneUtils = {\n\t\n\t\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\t\n\t\t\t\tvar group = new Group();\n\t\n\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn group;\n\t\n\t\t\t},\n\t\n\t\t\tdetach: function ( child, parent, scene ) {\n\t\n\t\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\t\tparent.remove( child );\n\t\t\t\tscene.add( child );\n\t\n\t\t\t},\n\t\n\t\t\tattach: function ( child, scene, parent ) {\n\t\n\t\t\t\tvar matrixWorldInverse = new Matrix4();\n\t\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\t\tchild.applyMatrix( matrixWorldInverse );\n\t\n\t\t\t\tscene.remove( child );\n\t\t\t\tparent.add( child );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Face4 ( a, b, c, d, normal, color, materialIndex ) {\n\t\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\t\t}\n\t\n\t\tvar LineStrip = 0;\n\t\n\t\tvar LinePieces = 1;\n\t\n\t\tfunction PointCloud ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\t\treturn new Points( geometry, material );\n\t\t}\n\t\n\t\tfunction ParticleSystem ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\t\treturn new Points( geometry, material );\n\t\t}\n\t\n\t\tfunction PointCloudMaterial ( parameters ) {\n\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\t}\n\t\n\t\tfunction ParticleBasicMaterial ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\t}\n\t\n\t\tfunction ParticleSystemMaterial ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\t}\n\t\n\t\tfunction Vertex ( x, y, z ) {\n\t\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\t\treturn new Vector3( x, y, z );\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction EdgesHelper( object, hex ) {\n\t\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t\t}\n\t\n\t\tfunction WireframeHelper( object, hex ) {\n\t\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t\t}\n\t\n\t\t//\n\t\n\t\tObject.assign( Box2.prototype, {\n\t\t\tcenter: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\t\t},\n\t\t\tempty: function () {\n\t\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\t\treturn this.isEmpty();\n\t\t\t},\n\t\t\tisIntersectionBox: function ( box ) {\n\t\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\t\t},\n\t\t\tsize: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\t\treturn this.getSize( optionalTarget );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Box3.prototype, {\n\t\t\tcenter: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\t\t},\n\t\t\tempty: function () {\n\t\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\t\treturn this.isEmpty();\n\t\t\t},\n\t\t\tisIntersectionBox: function ( box ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\t\t},\n\t\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\t\t},\n\t\t\tsize: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\t\treturn this.getSize( optionalTarget );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Line3.prototype, {\n\t\t\tcenter: function ( optionalTarget ) {\n\t\t\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Matrix3.prototype, {\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix3( this );\n\t\t\t},\n\t\t\tmultiplyVector3Array: function ( a ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\t\treturn this.applyToVector3Array( a );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Matrix4.prototype, {\n\t\t\textractPosition: function ( m ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\t\treturn this.copyPosition( m );\n\t\t\t},\n\t\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t\t},\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\t\treturn vector.applyProjection( this );\n\t\t\t},\n\t\t\tmultiplyVector4: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix4( this );\n\t\t\t},\n\t\t\tmultiplyVector3Array: function ( a ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\t\treturn this.applyToVector3Array( a );\n\t\t\t},\n\t\t\trotateAxis: function ( v ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\t\tv.transformDirection( this );\n\t\t\t},\n\t\t\tcrossVector: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix4( this );\n\t\t\t},\n\t\t\ttranslate: function ( v ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t\t},\n\t\t\trotateX: function ( angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t\t},\n\t\t\trotateY: function ( angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t\t},\n\t\t\trotateZ: function ( angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t\t},\n\t\t\trotateByAxis: function ( axis, angle ) {\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Plane.prototype, {\n\t\t\tisIntersectionLine: function ( line ) {\n\t\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\t\treturn this.intersectsLine( line );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Quaternion.prototype, {\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\t\treturn vector.applyQuaternion( this );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Ray.prototype, {\n\t\t\tisIntersectionBox: function ( box ) {\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\t\t},\n\t\t\tisIntersectionPlane: function ( plane ) {\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\t\treturn this.intersectsPlane( plane );\n\t\t\t},\n\t\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Shape.prototype, {\n\t\t\textrude: function ( options ) {\n\t\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\t\treturn new ExtrudeGeometry( this, options );\n\t\t\t},\n\t\t\tmakeGeometry: function ( options ) {\n\t\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\t\treturn new ShapeGeometry( this, options );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Vector3.prototype, {\n\t\t\tsetEulerFromRotationMatrix: function () {\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t\t},\n\t\t\tsetEulerFromQuaternion: function () {\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t\t},\n\t\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\t\treturn this.setFromMatrixPosition( m );\n\t\t\t},\n\t\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\t\treturn this.setFromMatrixScale( m );\n\t\t\t},\n\t\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( Object3D.prototype, {\n\t\t\tgetChildByName: function ( name ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\t\treturn this.getObjectByName( name );\n\t\t\t},\n\t\t\trenderDepth: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t\t},\n\t\t\ttranslate: function ( distance, axis ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( Object3D.prototype, {\n\t\t\teulerOrder: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\t\treturn this.rotation.order;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\t\tthis.rotation.order = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tuseQuaternion: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( LOD.prototype, {\n\t\t\tobjects: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\t\treturn this.levels;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\t\n\t\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\t\n\t\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\t\tthis.setFocalLength( focalLength );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Light.prototype, {\n\t\t\tonlyShadow: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraFov: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraLeft: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraRight: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraTop: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraBottom: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraNear: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraFar: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraVisible: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowBias: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\t\tthis.shadow.bias = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowDarkness: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapWidth: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapHeight: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( BufferAttribute.prototype, {\n\t\t\tlength: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\t\treturn this.array.length;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( BufferGeometry.prototype, {\n\t\t\taddIndex: function ( index ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\t\tthis.setIndex( index );\n\t\t\t},\n\t\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t\t}\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\t\tthis.addGroup( start, count );\n\t\t\t},\n\t\t\tclearDrawCalls: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\t\tthis.clearGroups();\n\t\t\t},\n\t\t\tcomputeTangents: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t\t},\n\t\t\tcomputeOffsets: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( BufferGeometry.prototype, {\n\t\t\tdrawcalls: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\t\treturn this.groups;\n\t\t\t\t}\n\t\t\t},\n\t\t\toffsets: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\t\treturn this.groups;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Material.prototype, {\n\t\t\twrapAround: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\twrapRGB: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\t\treturn new Color();\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\t\t\tmetal: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( ShaderMaterial.prototype, {\n\t\t\tderivatives: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\t\treturn this.extensions.derivatives;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tEventDispatcher.prototype = Object.assign( Object.create( {\n\t\n\t\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\t\n\t\t\tconstructor: EventDispatcher,\n\t\n\t\t\tapply: function ( target ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\t\n\t\t\t\tObject.assign( target, this );\n\t\n\t\t\t}\n\t\n\t\t} ), EventDispatcher.prototype );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Uniform.prototype, {\n\t\t\tdynamic: {\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\t}\n\t\t\t},\n\t\t\tonUpdate: {\n\t\t\t\tvalue: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( WebGLRenderer.prototype, {\n\t\t\tsupportsFloatTextures: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t\t},\n\t\t\tsupportsHalfFloatTextures: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t\t},\n\t\t\tsupportsStandardDerivatives: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t\t},\n\t\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t\t},\n\t\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t\t},\n\t\t\tsupportsBlendMinMax: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t\t},\n\t\t\tsupportsVertexTextures: function () {\n\t\t\t\treturn this.capabilities.vertexTextures;\n\t\t\t},\n\t\t\tsupportsInstancedArrays: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t\t},\n\t\t\tenableScissorTest: function ( boolean ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\t\tthis.setScissorTest( boolean );\n\t\t\t},\n\t\t\tinitMaterial: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t\t},\n\t\t\taddPrePlugin: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t\t},\n\t\t\taddPostPlugin: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t\t},\n\t\t\tupdateShadowMap: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( WebGLRenderer.prototype, {\n\t\t\tshadowMapEnabled: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapType: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.shadowMap.type;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\t\tthis.shadowMap.type = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapCullFace: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( WebGLShadowMap.prototype, {\n\t\t\tcullFace: {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\n\t\t\t\t},\n\t\t\t\tset: function ( cullFace ) {\n\t\t\t\t\tvar value = ( cullFace !== CullFaceBack );\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\t\tthis.renderReverseSided = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\t\t\twrapS: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\t\treturn this.texture.wrapS;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\t\tthis.texture.wrapS = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\twrapT: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\t\treturn this.texture.wrapT;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\t\tthis.texture.wrapT = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tmagFilter: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\t\treturn this.texture.magFilter;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\t\tthis.texture.magFilter = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tminFilter: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\t\treturn this.texture.minFilter;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\t\tthis.texture.minFilter = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanisotropy: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\t\treturn this.texture.anisotropy;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\toffset: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\t\treturn this.texture.offset;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\t\tthis.texture.offset = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\trepeat: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\t\treturn this.texture.repeat;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\t\tthis.texture.repeat = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tformat: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\t\treturn this.texture.format;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\t\tthis.texture.format = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\t\treturn this.texture.type;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\t\tthis.texture.type = value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgenerateMipmaps: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( Audio.prototype, {\n\t\t\tload: function ( file ) {\n\t\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\t\tvar scope = this;\n\t\t\t\tvar audioLoader = new AudioLoader();\n\t\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\t\tscope.setBuffer( buffer );\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( AudioAnalyser.prototype, {\n\t\t\tgetData: function ( file ) {\n\t\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\t\treturn this.getFrequencyData();\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tvar GeometryUtils = {\n\t\n\t\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\t\n\t\t\t\tvar matrix;\n\t\n\t\t\t\tif ( geometry2.isMesh ) {\n\t\n\t\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\t\n\t\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\t\tgeometry2 = geometry2.geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\t\n\t\t\t},\n\t\n\t\t\tcenter: function ( geometry ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\t\treturn geometry.center();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar ImageUtils = {\n\t\n\t\t\tcrossOrigin: undefined,\n\t\n\t\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\t\n\t\t\t\tvar loader = new TextureLoader();\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\t\n\t\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\t\n\t\t\t\tvar loader = new CubeTextureLoader();\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\t\n\t\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tloadCompressedTexture: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t\t},\n\t\n\t\t\tloadCompressedTextureCube: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction Projector () {\n\t\n\t\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\t\n\t\t\tthis.projectVector = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\t\tvector.project( camera );\n\t\n\t\t\t};\n\t\n\t\t\tthis.unprojectVector = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\t\tvector.unproject( camera );\n\t\n\t\t\t};\n\t\n\t\t\tthis.pickingRay = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction CanvasRenderer () {\n\t\n\t\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\t\n\t\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tthis.clear = function () {};\n\t\t\tthis.render = function () {};\n\t\t\tthis.setClearColor = function () {};\n\t\t\tthis.setSize = function () {};\n\t\n\t\t}\n\t\n\t\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\t\texports.WebGLRenderTarget = WebGLRenderTarget;\n\t\texports.WebGLRenderer = WebGLRenderer;\n\t\texports.ShaderLib = ShaderLib;\n\t\texports.UniformsLib = UniformsLib;\n\t\texports.UniformsUtils = UniformsUtils;\n\t\texports.ShaderChunk = ShaderChunk;\n\t\texports.FogExp2 = FogExp2;\n\t\texports.Fog = Fog;\n\t\texports.Scene = Scene;\n\t\texports.LensFlare = LensFlare;\n\t\texports.Sprite = Sprite;\n\t\texports.LOD = LOD;\n\t\texports.SkinnedMesh = SkinnedMesh;\n\t\texports.Skeleton = Skeleton;\n\t\texports.Bone = Bone;\n\t\texports.Mesh = Mesh;\n\t\texports.LineSegments = LineSegments;\n\t\texports.Line = Line;\n\t\texports.Points = Points;\n\t\texports.Group = Group;\n\t\texports.VideoTexture = VideoTexture;\n\t\texports.DataTexture = DataTexture;\n\t\texports.CompressedTexture = CompressedTexture;\n\t\texports.CubeTexture = CubeTexture;\n\t\texports.CanvasTexture = CanvasTexture;\n\t\texports.DepthTexture = DepthTexture;\n\t\texports.TextureIdCount = TextureIdCount;\n\t\texports.Texture = Texture;\n\t\texports.MaterialIdCount = MaterialIdCount;\n\t\texports.CompressedTextureLoader = CompressedTextureLoader;\n\t\texports.BinaryTextureLoader = BinaryTextureLoader;\n\t\texports.DataTextureLoader = DataTextureLoader;\n\t\texports.CubeTextureLoader = CubeTextureLoader;\n\t\texports.TextureLoader = TextureLoader;\n\t\texports.ObjectLoader = ObjectLoader;\n\t\texports.MaterialLoader = MaterialLoader;\n\t\texports.BufferGeometryLoader = BufferGeometryLoader;\n\t\texports.DefaultLoadingManager = DefaultLoadingManager;\n\t\texports.LoadingManager = LoadingManager;\n\t\texports.JSONLoader = JSONLoader;\n\t\texports.ImageLoader = ImageLoader;\n\t\texports.FontLoader = FontLoader;\n\t\texports.XHRLoader = XHRLoader;\n\t\texports.Loader = Loader;\n\t\texports.Cache = Cache;\n\t\texports.AudioLoader = AudioLoader;\n\t\texports.SpotLightShadow = SpotLightShadow;\n\t\texports.SpotLight = SpotLight;\n\t\texports.PointLight = PointLight;\n\t\texports.HemisphereLight = HemisphereLight;\n\t\texports.DirectionalLightShadow = DirectionalLightShadow;\n\t\texports.DirectionalLight = DirectionalLight;\n\t\texports.AmbientLight = AmbientLight;\n\t\texports.LightShadow = LightShadow;\n\t\texports.Light = Light;\n\t\texports.StereoCamera = StereoCamera;\n\t\texports.PerspectiveCamera = PerspectiveCamera;\n\t\texports.OrthographicCamera = OrthographicCamera;\n\t\texports.CubeCamera = CubeCamera;\n\t\texports.Camera = Camera;\n\t\texports.AudioListener = AudioListener;\n\t\texports.PositionalAudio = PositionalAudio;\n\t\texports.getAudioContext = getAudioContext;\n\t\texports.AudioAnalyser = AudioAnalyser;\n\t\texports.Audio = Audio;\n\t\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\t\texports.StringKeyframeTrack = StringKeyframeTrack;\n\t\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\t\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\t\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\t\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\t\texports.PropertyMixer = PropertyMixer;\n\t\texports.PropertyBinding = PropertyBinding;\n\t\texports.KeyframeTrack = KeyframeTrack;\n\t\texports.AnimationUtils = AnimationUtils;\n\t\texports.AnimationObjectGroup = AnimationObjectGroup;\n\t\texports.AnimationMixer = AnimationMixer;\n\t\texports.AnimationClip = AnimationClip;\n\t\texports.Uniform = Uniform;\n\t\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\t\texports.BufferGeometry = BufferGeometry;\n\t\texports.GeometryIdCount = GeometryIdCount;\n\t\texports.Geometry = Geometry;\n\t\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\t\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\t\texports.InterleavedBuffer = InterleavedBuffer;\n\t\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\t\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\t\texports.Float64Attribute = Float64Attribute;\n\t\texports.Float32Attribute = Float32Attribute;\n\t\texports.Uint32Attribute = Uint32Attribute;\n\t\texports.Int32Attribute = Int32Attribute;\n\t\texports.Uint16Attribute = Uint16Attribute;\n\t\texports.Int16Attribute = Int16Attribute;\n\t\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\t\texports.Uint8Attribute = Uint8Attribute;\n\t\texports.Int8Attribute = Int8Attribute;\n\t\texports.BufferAttribute = BufferAttribute;\n\t\texports.Face3 = Face3;\n\t\texports.Object3DIdCount = Object3DIdCount;\n\t\texports.Object3D = Object3D;\n\t\texports.Raycaster = Raycaster;\n\t\texports.Layers = Layers;\n\t\texports.EventDispatcher = EventDispatcher;\n\t\texports.Clock = Clock;\n\t\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\t\texports.LinearInterpolant = LinearInterpolant;\n\t\texports.DiscreteInterpolant = DiscreteInterpolant;\n\t\texports.CubicInterpolant = CubicInterpolant;\n\t\texports.Interpolant = Interpolant;\n\t\texports.Triangle = Triangle;\n\t\texports.Spline = Spline;\n\t\texports.Math = _Math;\n\t\texports.Spherical = Spherical;\n\t\texports.Plane = Plane;\n\t\texports.Frustum = Frustum;\n\t\texports.Sphere = Sphere;\n\t\texports.Ray = Ray;\n\t\texports.Matrix4 = Matrix4;\n\t\texports.Matrix3 = Matrix3;\n\t\texports.Box3 = Box3;\n\t\texports.Box2 = Box2;\n\t\texports.Line3 = Line3;\n\t\texports.Euler = Euler;\n\t\texports.Vector4 = Vector4;\n\t\texports.Vector3 = Vector3;\n\t\texports.Vector2 = Vector2;\n\t\texports.Quaternion = Quaternion;\n\t\texports.ColorKeywords = ColorKeywords;\n\t\texports.Color = Color;\n\t\texports.MorphBlendMesh = MorphBlendMesh;\n\t\texports.ImmediateRenderObject = ImmediateRenderObject;\n\t\texports.VertexNormalsHelper = VertexNormalsHelper;\n\t\texports.SpotLightHelper = SpotLightHelper;\n\t\texports.SkeletonHelper = SkeletonHelper;\n\t\texports.PointLightHelper = PointLightHelper;\n\t\texports.HemisphereLightHelper = HemisphereLightHelper;\n\t\texports.GridHelper = GridHelper;\n\t\texports.FaceNormalsHelper = FaceNormalsHelper;\n\t\texports.DirectionalLightHelper = DirectionalLightHelper;\n\t\texports.CameraHelper = CameraHelper;\n\t\texports.BoundingBoxHelper = BoundingBoxHelper;\n\t\texports.BoxHelper = BoxHelper;\n\t\texports.ArrowHelper = ArrowHelper;\n\t\texports.AxisHelper = AxisHelper;\n\t\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\t\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\t\texports.SplineCurve3 = SplineCurve3;\n\t\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\t\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\t\texports.LineCurve3 = LineCurve3;\n\t\texports.ArcCurve = ArcCurve;\n\t\texports.EllipseCurve = EllipseCurve;\n\t\texports.SplineCurve = SplineCurve;\n\t\texports.CubicBezierCurve = CubicBezierCurve;\n\t\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\t\texports.LineCurve = LineCurve;\n\t\texports.Shape = Shape;\n\t\texports.ShapePath = ShapePath;\n\t\texports.Path = Path;\n\t\texports.Font = Font;\n\t\texports.CurvePath = CurvePath;\n\t\texports.Curve = Curve;\n\t\texports.ShapeUtils = ShapeUtils;\n\t\texports.SceneUtils = SceneUtils;\n\t\texports.CurveUtils = CurveUtils;\n\t\texports.WireframeGeometry = WireframeGeometry;\n\t\texports.ParametricGeometry = ParametricGeometry;\n\t\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\t\texports.TetrahedronGeometry = TetrahedronGeometry;\n\t\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\t\texports.OctahedronGeometry = OctahedronGeometry;\n\t\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\t\texports.IcosahedronGeometry = IcosahedronGeometry;\n\t\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\t\texports.DodecahedronGeometry = DodecahedronGeometry;\n\t\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\t\texports.PolyhedronGeometry = PolyhedronGeometry;\n\t\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\t\texports.TubeGeometry = TubeGeometry;\n\t\texports.TubeBufferGeometry = TubeBufferGeometry;\n\t\texports.TorusKnotGeometry = TorusKnotGeometry;\n\t\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\t\texports.TorusGeometry = TorusGeometry;\n\t\texports.TorusBufferGeometry = TorusBufferGeometry;\n\t\texports.TextGeometry = TextGeometry;\n\t\texports.SphereBufferGeometry = SphereBufferGeometry;\n\t\texports.SphereGeometry = SphereGeometry;\n\t\texports.RingGeometry = RingGeometry;\n\t\texports.RingBufferGeometry = RingBufferGeometry;\n\t\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\t\texports.PlaneGeometry = PlaneGeometry;\n\t\texports.LatheGeometry = LatheGeometry;\n\t\texports.LatheBufferGeometry = LatheBufferGeometry;\n\t\texports.ShapeGeometry = ShapeGeometry;\n\t\texports.ExtrudeGeometry = ExtrudeGeometry;\n\t\texports.EdgesGeometry = EdgesGeometry;\n\t\texports.ConeGeometry = ConeGeometry;\n\t\texports.ConeBufferGeometry = ConeBufferGeometry;\n\t\texports.CylinderGeometry = CylinderGeometry;\n\t\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\t\texports.CircleBufferGeometry = CircleBufferGeometry;\n\t\texports.CircleGeometry = CircleGeometry;\n\t\texports.BoxBufferGeometry = BoxBufferGeometry;\n\t\texports.BoxGeometry = BoxGeometry;\n\t\texports.ShadowMaterial = ShadowMaterial;\n\t\texports.SpriteMaterial = SpriteMaterial;\n\t\texports.RawShaderMaterial = RawShaderMaterial;\n\t\texports.ShaderMaterial = ShaderMaterial;\n\t\texports.PointsMaterial = PointsMaterial;\n\t\texports.MultiMaterial = MultiMaterial;\n\t\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\t\texports.MeshStandardMaterial = MeshStandardMaterial;\n\t\texports.MeshPhongMaterial = MeshPhongMaterial;\n\t\texports.MeshNormalMaterial = MeshNormalMaterial;\n\t\texports.MeshLambertMaterial = MeshLambertMaterial;\n\t\texports.MeshDepthMaterial = MeshDepthMaterial;\n\t\texports.MeshBasicMaterial = MeshBasicMaterial;\n\t\texports.LineDashedMaterial = LineDashedMaterial;\n\t\texports.LineBasicMaterial = LineBasicMaterial;\n\t\texports.Material = Material;\n\t\texports.REVISION = REVISION;\n\t\texports.MOUSE = MOUSE;\n\t\texports.CullFaceNone = CullFaceNone;\n\t\texports.CullFaceBack = CullFaceBack;\n\t\texports.CullFaceFront = CullFaceFront;\n\t\texports.CullFaceFrontBack = CullFaceFrontBack;\n\t\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\t\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\t\texports.BasicShadowMap = BasicShadowMap;\n\t\texports.PCFShadowMap = PCFShadowMap;\n\t\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\t\texports.FrontSide = FrontSide;\n\t\texports.BackSide = BackSide;\n\t\texports.DoubleSide = DoubleSide;\n\t\texports.FlatShading = FlatShading;\n\t\texports.SmoothShading = SmoothShading;\n\t\texports.NoColors = NoColors;\n\t\texports.FaceColors = FaceColors;\n\t\texports.VertexColors = VertexColors;\n\t\texports.NoBlending = NoBlending;\n\t\texports.NormalBlending = NormalBlending;\n\t\texports.AdditiveBlending = AdditiveBlending;\n\t\texports.SubtractiveBlending = SubtractiveBlending;\n\t\texports.MultiplyBlending = MultiplyBlending;\n\t\texports.CustomBlending = CustomBlending;\n\t\texports.BlendingMode = BlendingMode;\n\t\texports.AddEquation = AddEquation;\n\t\texports.SubtractEquation = SubtractEquation;\n\t\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\t\texports.MinEquation = MinEquation;\n\t\texports.MaxEquation = MaxEquation;\n\t\texports.ZeroFactor = ZeroFactor;\n\t\texports.OneFactor = OneFactor;\n\t\texports.SrcColorFactor = SrcColorFactor;\n\t\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\t\texports.SrcAlphaFactor = SrcAlphaFactor;\n\t\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\t\texports.DstAlphaFactor = DstAlphaFactor;\n\t\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\t\texports.DstColorFactor = DstColorFactor;\n\t\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\t\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\t\texports.NeverDepth = NeverDepth;\n\t\texports.AlwaysDepth = AlwaysDepth;\n\t\texports.LessDepth = LessDepth;\n\t\texports.LessEqualDepth = LessEqualDepth;\n\t\texports.EqualDepth = EqualDepth;\n\t\texports.GreaterEqualDepth = GreaterEqualDepth;\n\t\texports.GreaterDepth = GreaterDepth;\n\t\texports.NotEqualDepth = NotEqualDepth;\n\t\texports.MultiplyOperation = MultiplyOperation;\n\t\texports.MixOperation = MixOperation;\n\t\texports.AddOperation = AddOperation;\n\t\texports.NoToneMapping = NoToneMapping;\n\t\texports.LinearToneMapping = LinearToneMapping;\n\t\texports.ReinhardToneMapping = ReinhardToneMapping;\n\t\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\t\texports.CineonToneMapping = CineonToneMapping;\n\t\texports.UVMapping = UVMapping;\n\t\texports.CubeReflectionMapping = CubeReflectionMapping;\n\t\texports.CubeRefractionMapping = CubeRefractionMapping;\n\t\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\t\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\t\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\t\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\t\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\t\texports.TextureMapping = TextureMapping;\n\t\texports.RepeatWrapping = RepeatWrapping;\n\t\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\t\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\t\texports.TextureWrapping = TextureWrapping;\n\t\texports.NearestFilter = NearestFilter;\n\t\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\t\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\t\texports.LinearFilter = LinearFilter;\n\t\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\t\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\t\texports.TextureFilter = TextureFilter;\n\t\texports.UnsignedByteType = UnsignedByteType;\n\t\texports.ByteType = ByteType;\n\t\texports.ShortType = ShortType;\n\t\texports.UnsignedShortType = UnsignedShortType;\n\t\texports.IntType = IntType;\n\t\texports.UnsignedIntType = UnsignedIntType;\n\t\texports.FloatType = FloatType;\n\t\texports.HalfFloatType = HalfFloatType;\n\t\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\t\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\t\texports.UnsignedShort565Type = UnsignedShort565Type;\n\t\texports.UnsignedInt248Type = UnsignedInt248Type;\n\t\texports.AlphaFormat = AlphaFormat;\n\t\texports.RGBFormat = RGBFormat;\n\t\texports.RGBAFormat = RGBAFormat;\n\t\texports.LuminanceFormat = LuminanceFormat;\n\t\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\t\texports.RGBEFormat = RGBEFormat;\n\t\texports.DepthFormat = DepthFormat;\n\t\texports.DepthStencilFormat = DepthStencilFormat;\n\t\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\t\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\t\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\t\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\t\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\t\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\t\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\t\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\t\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\t\texports.LoopOnce = LoopOnce;\n\t\texports.LoopRepeat = LoopRepeat;\n\t\texports.LoopPingPong = LoopPingPong;\n\t\texports.InterpolateDiscrete = InterpolateDiscrete;\n\t\texports.InterpolateLinear = InterpolateLinear;\n\t\texports.InterpolateSmooth = InterpolateSmooth;\n\t\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\t\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\t\texports.WrapAroundEnding = WrapAroundEnding;\n\t\texports.TrianglesDrawMode = TrianglesDrawMode;\n\t\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\t\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\t\texports.LinearEncoding = LinearEncoding;\n\t\texports.sRGBEncoding = sRGBEncoding;\n\t\texports.GammaEncoding = GammaEncoding;\n\t\texports.RGBEEncoding = RGBEEncoding;\n\t\texports.LogLuvEncoding = LogLuvEncoding;\n\t\texports.RGBM7Encoding = RGBM7Encoding;\n\t\texports.RGBM16Encoding = RGBM16Encoding;\n\t\texports.RGBDEncoding = RGBDEncoding;\n\t\texports.BasicDepthPacking = BasicDepthPacking;\n\t\texports.RGBADepthPacking = RGBADepthPacking;\n\t\texports.CubeGeometry = BoxGeometry;\n\t\texports.Face4 = Face4;\n\t\texports.LineStrip = LineStrip;\n\t\texports.LinePieces = LinePieces;\n\t\texports.MeshFaceMaterial = MultiMaterial;\n\t\texports.PointCloud = PointCloud;\n\t\texports.Particle = Sprite;\n\t\texports.ParticleSystem = ParticleSystem;\n\t\texports.PointCloudMaterial = PointCloudMaterial;\n\t\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\t\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\t\texports.Vertex = Vertex;\n\t\texports.EdgesHelper = EdgesHelper;\n\t\texports.WireframeHelper = WireframeHelper;\n\t\texports.GeometryUtils = GeometryUtils;\n\t\texports.ImageUtils = ImageUtils;\n\t\texports.Projector = Projector;\n\t\texports.CanvasRenderer = CanvasRenderer;\n\t\n\t\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t\tObject.defineProperty( exports, 'AudioContext', {\n\t\t\tget: function () {\n\t\t\t\treturn exports.getAudioContext();\n\t\t\t}\n\t\t});\n\t\n\t})));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tvar Stats = function () {\n\t\n\t\tvar mode = 0;\n\t\n\t\tvar container = document.createElement('div');\n\t\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\t\tcontainer.addEventListener('click', function (event) {\n\t\n\t\t\tevent.preventDefault();\n\t\t\tshowPanel(++mode % container.children.length);\n\t\t}, false);\n\t\n\t\t//\n\t\n\t\tfunction addPanel(panel) {\n\t\n\t\t\tcontainer.appendChild(panel.dom);\n\t\t\treturn panel;\n\t\t}\n\t\n\t\tfunction showPanel(id) {\n\t\n\t\t\tfor (var i = 0; i < container.children.length; i++) {\n\t\n\t\t\t\tcontainer.children[i].style.display = i === id ? 'block' : 'none';\n\t\t\t}\n\t\n\t\t\tmode = id;\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar beginTime = (performance || Date).now(),\n\t\t    prevTime = beginTime,\n\t\t    frames = 0;\n\t\n\t\tvar fpsPanel = addPanel(new Stats.Panel('FPS', '#0ff', '#002'));\n\t\tvar msPanel = addPanel(new Stats.Panel('MS', '#0f0', '#020'));\n\t\n\t\tif (self.performance && self.performance.memory) {\n\t\n\t\t\tvar memPanel = addPanel(new Stats.Panel('MB', '#f08', '#201'));\n\t\t}\n\t\n\t\tshowPanel(0);\n\t\n\t\treturn {\n\t\n\t\t\tREVISION: 16,\n\t\n\t\t\tdom: container,\n\t\n\t\t\taddPanel: addPanel,\n\t\t\tshowPanel: showPanel,\n\t\n\t\t\tbegin: function () {\n\t\n\t\t\t\tbeginTime = (performance || Date).now();\n\t\t\t},\n\t\n\t\t\tend: function () {\n\t\n\t\t\t\tframes++;\n\t\n\t\t\t\tvar time = (performance || Date).now();\n\t\n\t\t\t\tmsPanel.update(time - beginTime, 200);\n\t\n\t\t\t\tif (time > prevTime + 1000) {\n\t\n\t\t\t\t\tfpsPanel.update(frames * 1000 / (time - prevTime), 100);\n\t\n\t\t\t\t\tprevTime = time;\n\t\t\t\t\tframes = 0;\n\t\n\t\t\t\t\tif (memPanel) {\n\t\n\t\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\t\tmemPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn time;\n\t\t\t},\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tbeginTime = this.end();\n\t\t\t},\n\t\n\t\t\t// Backwards Compatibility\n\t\n\t\t\tdomElement: container,\n\t\t\tsetMode: showPanel\n\t\n\t\t};\n\t};\n\t\n\tStats.Panel = function (name, fg, bg) {\n\t\n\t\tvar min = Infinity,\n\t\t    max = 0,\n\t\t    round = Math.round;\n\t\tvar PR = round(window.devicePixelRatio || 1);\n\t\n\t\tvar WIDTH = 80 * PR,\n\t\t    HEIGHT = 48 * PR,\n\t\t    TEXT_X = 3 * PR,\n\t\t    TEXT_Y = 2 * PR,\n\t\t    GRAPH_X = 3 * PR,\n\t\t    GRAPH_Y = 15 * PR,\n\t\t    GRAPH_WIDTH = 74 * PR,\n\t\t    GRAPH_HEIGHT = 30 * PR;\n\t\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.width = WIDTH;\n\t\tcanvas.height = HEIGHT;\n\t\tcanvas.style.cssText = 'width:80px;height:48px';\n\t\n\t\tvar context = canvas.getContext('2d');\n\t\tcontext.font = 'bold ' + 9 * PR + 'px Helvetica,Arial,sans-serif';\n\t\tcontext.textBaseline = 'top';\n\t\n\t\tcontext.fillStyle = bg;\n\t\tcontext.fillRect(0, 0, WIDTH, HEIGHT);\n\t\n\t\tcontext.fillStyle = fg;\n\t\tcontext.fillText(name, TEXT_X, TEXT_Y);\n\t\tcontext.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n\t\n\t\tcontext.fillStyle = bg;\n\t\tcontext.globalAlpha = 0.9;\n\t\tcontext.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);\n\t\n\t\treturn {\n\t\n\t\t\tdom: canvas,\n\t\n\t\t\tupdate: function (value, maxValue) {\n\t\n\t\t\t\tmin = Math.min(min, value);\n\t\t\t\tmax = Math.max(max, value);\n\t\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalAlpha = 1;\n\t\t\t\tcontext.fillRect(0, 0, WIDTH, GRAPH_Y);\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.fillText(round(value) + ' ' + name + ' (' + round(min) + '-' + round(max) + ')', TEXT_X, TEXT_Y);\n\t\n\t\t\t\tcontext.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);\n\t\n\t\t\t\tcontext.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);\n\t\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalAlpha = 0.9;\n\t\t\t\tcontext.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));\n\t\t\t}\n\t\n\t\t};\n\t};\n\t\n\tif (true) {\n\t\n\t\tmodule.exports = Stats;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(6)\n\tmodule.exports.color = __webpack_require__(7)\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * dat-gui JavaScript Controller Library\n\t * http://code.google.com/p/dat-gui\n\t *\n\t * Copyright 2011 Data Arts Team, Google Creative Lab\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t */\n\t\n\t/** @namespace */\n\tvar dat = module.exports = dat || {};\n\t\n\t/** @namespace */\n\tdat.gui = dat.gui || {};\n\t\n\t/** @namespace */\n\tdat.utils = dat.utils || {};\n\t\n\t/** @namespace */\n\tdat.controllers = dat.controllers || {};\n\t\n\t/** @namespace */\n\tdat.dom = dat.dom || {};\n\t\n\t/** @namespace */\n\tdat.color = dat.color || {};\n\t\n\tdat.utils.css = (function () {\n\t  return {\n\t    load: function (url, doc) {\n\t      doc = doc || document;\n\t      var link = doc.createElement('link');\n\t      link.type = 'text/css';\n\t      link.rel = 'stylesheet';\n\t      link.href = url;\n\t      doc.getElementsByTagName('head')[0].appendChild(link);\n\t    },\n\t    inject: function(css, doc) {\n\t      doc = doc || document;\n\t      var injected = document.createElement('style');\n\t      injected.type = 'text/css';\n\t      injected.innerHTML = css;\n\t      doc.getElementsByTagName('head')[0].appendChild(injected);\n\t    }\n\t  }\n\t})();\n\t\n\t\n\tdat.utils.common = (function () {\n\t  \n\t  var ARR_EACH = Array.prototype.forEach;\n\t  var ARR_SLICE = Array.prototype.slice;\n\t\n\t  /**\n\t   * Band-aid methods for things that should be a lot easier in JavaScript.\n\t   * Implementation and structure inspired by underscore.js\n\t   * http://documentcloud.github.com/underscore/\n\t   */\n\t\n\t  return { \n\t    \n\t    BREAK: {},\n\t  \n\t    extend: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (!this.isUndefined(obj[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t      \n\t    },\n\t    \n\t    defaults: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (this.isUndefined(target[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t    \n\t    },\n\t    \n\t    compose: function() {\n\t      var toCall = ARR_SLICE.call(arguments);\n\t            return function() {\n\t              var args = ARR_SLICE.call(arguments);\n\t              for (var i = toCall.length -1; i >= 0; i--) {\n\t                args = [toCall[i].apply(this, args)];\n\t              }\n\t              return args[0];\n\t            }\n\t    },\n\t    \n\t    each: function(obj, itr, scope) {\n\t\n\t      \n\t      if (ARR_EACH && obj.forEach === ARR_EACH) { \n\t        \n\t        obj.forEach(itr, scope);\n\t        \n\t      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n\t        \n\t        for (var key = 0, l = obj.length; key < l; key++)\n\t          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n\t            return;\n\t            \n\t      } else {\n\t\n\t        for (var key in obj) \n\t          if (itr.call(scope, obj[key], key) === this.BREAK)\n\t            return;\n\t            \n\t      }\n\t            \n\t    },\n\t    \n\t    defer: function(fnc) {\n\t      setTimeout(fnc, 0);\n\t    },\n\t    \n\t    toArray: function(obj) {\n\t      if (obj.toArray) return obj.toArray();\n\t      return ARR_SLICE.call(obj);\n\t    },\n\t\n\t    isUndefined: function(obj) {\n\t      return obj === undefined;\n\t    },\n\t    \n\t    isNull: function(obj) {\n\t      return obj === null;\n\t    },\n\t    \n\t    isNaN: function(obj) {\n\t      return obj !== obj;\n\t    },\n\t    \n\t    isArray: Array.isArray || function(obj) {\n\t      return obj.constructor === Array;\n\t    },\n\t    \n\t    isObject: function(obj) {\n\t      return obj === Object(obj);\n\t    },\n\t    \n\t    isNumber: function(obj) {\n\t      return obj === obj+0;\n\t    },\n\t    \n\t    isString: function(obj) {\n\t      return obj === obj+'';\n\t    },\n\t    \n\t    isBoolean: function(obj) {\n\t      return obj === false || obj === true;\n\t    },\n\t    \n\t    isFunction: function(obj) {\n\t      return Object.prototype.toString.call(obj) === '[object Function]';\n\t    }\n\t  \n\t  };\n\t    \n\t})();\n\t\n\t\n\tdat.controllers.Controller = (function (common) {\n\t\n\t  /**\n\t   * @class An \"abstract\" class that represents a given property of an object.\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var Controller = function(object, property) {\n\t\n\t    this.initialValue = object[property];\n\t\n\t    /**\n\t     * Those who extend this class will put their DOM elements in here.\n\t     * @type {DOMElement}\n\t     */\n\t    this.domElement = document.createElement('div');\n\t\n\t    /**\n\t     * The object to manipulate\n\t     * @type {Object}\n\t     */\n\t    this.object = object;\n\t\n\t    /**\n\t     * The name of the property to manipulate\n\t     * @type {String}\n\t     */\n\t    this.property = property;\n\t\n\t    /**\n\t     * The function to be called on change.\n\t     * @type {Function}\n\t     * @ignore\n\t     */\n\t    this.__onChange = undefined;\n\t\n\t    /**\n\t     * The function to be called on finishing change.\n\t     * @type {Function}\n\t     * @ignore\n\t     */\n\t    this.__onFinishChange = undefined;\n\t\n\t  };\n\t\n\t  common.extend(\n\t\n\t      Controller.prototype,\n\t\n\t      /** @lends dat.controllers.Controller.prototype */\n\t      {\n\t\n\t        /**\n\t         * Specify that a function fire every time someone changes the value with\n\t         * this Controller.\n\t         *\n\t         * @param {Function} fnc This function will be called whenever the value\n\t         * is modified via this Controller.\n\t         * @returns {dat.controllers.Controller} this\n\t         */\n\t        onChange: function(fnc) {\n\t          this.__onChange = fnc;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Specify that a function fire every time someone \"finishes\" changing\n\t         * the value wih this Controller. Useful for values that change\n\t         * incrementally like numbers or strings.\n\t         *\n\t         * @param {Function} fnc This function will be called whenever\n\t         * someone \"finishes\" changing the value via this Controller.\n\t         * @returns {dat.controllers.Controller} this\n\t         */\n\t        onFinishChange: function(fnc) {\n\t          this.__onFinishChange = fnc;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Change the value of <code>object[property]</code>\n\t         *\n\t         * @param {Object} newValue The new value of <code>object[property]</code>\n\t         */\n\t        setValue: function(newValue) {\n\t          this.object[this.property] = newValue;\n\t          if (this.__onChange) {\n\t            this.__onChange.call(this, newValue);\n\t          }\n\t          this.updateDisplay();\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Gets the value of <code>object[property]</code>\n\t         *\n\t         * @returns {Object} The current value of <code>object[property]</code>\n\t         */\n\t        getValue: function() {\n\t          return this.object[this.property];\n\t        },\n\t\n\t        /**\n\t         * Refreshes the visual display of a Controller in order to keep sync\n\t         * with the object's current value.\n\t         * @returns {dat.controllers.Controller} this\n\t         */\n\t        updateDisplay: function() {\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * @returns {Boolean} true if the value has deviated from initialValue\n\t         */\n\t        isModified: function() {\n\t          return this.initialValue !== this.getValue()\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return Controller;\n\t\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.dom.dom = (function (common) {\n\t\n\t  var EVENT_MAP = {\n\t    'HTMLEvents': ['change'],\n\t    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],\n\t    'KeyboardEvents': ['keydown']\n\t  };\n\t\n\t  var EVENT_MAP_INV = {};\n\t  common.each(EVENT_MAP, function(v, k) {\n\t    common.each(v, function(e) {\n\t      EVENT_MAP_INV[e] = k;\n\t    });\n\t  });\n\t\n\t  var CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\n\t\n\t  function cssValueToPixels(val) {\n\t\n\t    if (val === '0' || common.isUndefined(val)) return 0;\n\t\n\t    var match = val.match(CSS_VALUE_PIXELS);\n\t\n\t    if (!common.isNull(match)) {\n\t      return parseFloat(match[1]);\n\t    }\n\t\n\t    // TODO ...ems? %?\n\t\n\t    return 0;\n\t\n\t  }\n\t\n\t  /**\n\t   * @namespace\n\t   * @member dat.dom\n\t   */\n\t  var dom = {\n\t\n\t    /**\n\t     * \n\t     * @param elem\n\t     * @param selectable\n\t     */\n\t    makeSelectable: function(elem, selectable) {\n\t\n\t      if (elem === undefined || elem.style === undefined) return;\n\t\n\t      elem.onselectstart = selectable ? function() {\n\t        return false;\n\t      } : function() {\n\t      };\n\t\n\t      elem.style.MozUserSelect = selectable ? 'auto' : 'none';\n\t      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\n\t      elem.unselectable = selectable ? 'on' : 'off';\n\t\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param horizontal\n\t     * @param vertical\n\t     */\n\t    makeFullscreen: function(elem, horizontal, vertical) {\n\t\n\t      if (common.isUndefined(horizontal)) horizontal = true;\n\t      if (common.isUndefined(vertical)) vertical = true;\n\t\n\t      elem.style.position = 'absolute';\n\t\n\t      if (horizontal) {\n\t        elem.style.left = 0;\n\t        elem.style.right = 0;\n\t      }\n\t      if (vertical) {\n\t        elem.style.top = 0;\n\t        elem.style.bottom = 0;\n\t      }\n\t\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param eventType\n\t     * @param params\n\t     */\n\t    fakeEvent: function(elem, eventType, params, aux) {\n\t      params = params || {};\n\t      var className = EVENT_MAP_INV[eventType];\n\t      if (!className) {\n\t        throw new Error('Event type ' + eventType + ' not supported.');\n\t      }\n\t      var evt = document.createEvent(className);\n\t      switch (className) {\n\t        case 'MouseEvents':\n\t          var clientX = params.x || params.clientX || 0;\n\t          var clientY = params.y || params.clientY || 0;\n\t          evt.initMouseEvent(eventType, params.bubbles || false,\n\t              params.cancelable || true, window, params.clickCount || 1,\n\t              0, //screen X\n\t              0, //screen Y\n\t              clientX, //client X\n\t              clientY, //client Y\n\t              false, false, false, false, 0, null);\n\t          break;\n\t        case 'KeyboardEvents':\n\t          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz\n\t          common.defaults(params, {\n\t            cancelable: true,\n\t            ctrlKey: false,\n\t            altKey: false,\n\t            shiftKey: false,\n\t            metaKey: false,\n\t            keyCode: undefined,\n\t            charCode: undefined\n\t          });\n\t          init(eventType, params.bubbles || false,\n\t              params.cancelable, window,\n\t              params.ctrlKey, params.altKey,\n\t              params.shiftKey, params.metaKey,\n\t              params.keyCode, params.charCode);\n\t          break;\n\t        default:\n\t          evt.initEvent(eventType, params.bubbles || false,\n\t              params.cancelable || true);\n\t          break;\n\t      }\n\t      common.defaults(evt, aux);\n\t      elem.dispatchEvent(evt);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param event\n\t     * @param func\n\t     * @param bool\n\t     */\n\t    bind: function(elem, event, func, bool) {\n\t      bool = bool || false;\n\t      if (elem.addEventListener)\n\t        elem.addEventListener(event, func, bool);\n\t      else if (elem.attachEvent)\n\t        elem.attachEvent('on' + event, func);\n\t      return dom;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param event\n\t     * @param func\n\t     * @param bool\n\t     */\n\t    unbind: function(elem, event, func, bool) {\n\t      bool = bool || false;\n\t      if (elem.removeEventListener)\n\t        elem.removeEventListener(event, func, bool);\n\t      else if (elem.detachEvent)\n\t        elem.detachEvent('on' + event, func);\n\t      return dom;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param className\n\t     */\n\t    addClass: function(elem, className) {\n\t      if (elem.className === undefined) {\n\t        elem.className = className;\n\t      } else if (elem.className !== className) {\n\t        var classes = elem.className.split(/ +/);\n\t        if (classes.indexOf(className) == -1) {\n\t          classes.push(className);\n\t          elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t        }\n\t      }\n\t      return dom;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     * @param className\n\t     */\n\t    removeClass: function(elem, className) {\n\t      if (className) {\n\t        if (elem.className === undefined) {\n\t          // elem.className = className;\n\t        } else if (elem.className === className) {\n\t          elem.removeAttribute('class');\n\t        } else {\n\t          var classes = elem.className.split(/ +/);\n\t          var index = classes.indexOf(className);\n\t          if (index != -1) {\n\t            classes.splice(index, 1);\n\t            elem.className = classes.join(' ');\n\t          }\n\t        }\n\t      } else {\n\t        elem.className = undefined;\n\t      }\n\t      return dom;\n\t    },\n\t\n\t    hasClass: function(elem, className) {\n\t      return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     */\n\t    getWidth: function(elem) {\n\t\n\t      var style = getComputedStyle(elem);\n\t\n\t      return cssValueToPixels(style['border-left-width']) +\n\t          cssValueToPixels(style['border-right-width']) +\n\t          cssValueToPixels(style['padding-left']) +\n\t          cssValueToPixels(style['padding-right']) +\n\t          cssValueToPixels(style['width']);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     */\n\t    getHeight: function(elem) {\n\t\n\t      var style = getComputedStyle(elem);\n\t\n\t      return cssValueToPixels(style['border-top-width']) +\n\t          cssValueToPixels(style['border-bottom-width']) +\n\t          cssValueToPixels(style['padding-top']) +\n\t          cssValueToPixels(style['padding-bottom']) +\n\t          cssValueToPixels(style['height']);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param elem\n\t     */\n\t    getOffset: function(elem) {\n\t      var offset = {left: 0, top:0};\n\t      if (elem.offsetParent) {\n\t        do {\n\t          offset.left += elem.offsetLeft;\n\t          offset.top += elem.offsetTop;\n\t        } while (elem = elem.offsetParent);\n\t      }\n\t      return offset;\n\t    },\n\t\n\t    // http://stackoverflow.com/posts/2684561/revisions\n\t    /**\n\t     * \n\t     * @param elem\n\t     */\n\t    isActive: function(elem) {\n\t      return elem === document.activeElement && ( elem.type || elem.href );\n\t    }\n\t\n\t  };\n\t\n\t  return dom;\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.controllers.OptionController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a select input to alter the property of an object, using a\n\t   * list of accepted values.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Object|string[]} options A map of labels to acceptable values, or\n\t   * a list of acceptable string values.\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var OptionController = function(object, property, options) {\n\t\n\t    OptionController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t\n\t    /**\n\t     * The drop down menu\n\t     * @ignore\n\t     */\n\t    this.__select = document.createElement('select');\n\t\n\t    if (common.isArray(options)) {\n\t      var map = {};\n\t      common.each(options, function(element) {\n\t        map[element] = element;\n\t      });\n\t      options = map;\n\t    }\n\t\n\t    common.each(options, function(value, key) {\n\t\n\t      var opt = document.createElement('option');\n\t      opt.innerHTML = key;\n\t      opt.setAttribute('value', value);\n\t      _this.__select.appendChild(opt);\n\t\n\t    });\n\t\n\t    // Acknowledge original value\n\t    this.updateDisplay();\n\t\n\t    dom.bind(this.__select, 'change', function() {\n\t      var desiredValue = this.options[this.selectedIndex].value;\n\t      _this.setValue(desiredValue);\n\t    });\n\t\n\t    this.domElement.appendChild(this.__select);\n\t\n\t  };\n\t\n\t  OptionController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      OptionController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        setValue: function(v) {\n\t          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);\n\t          if (this.__onFinishChange) {\n\t            this.__onFinishChange.call(this, this.getValue());\n\t          }\n\t          return toReturn;\n\t        },\n\t\n\t        updateDisplay: function() {\n\t          this.__select.value = this.getValue();\n\t          return OptionController.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return OptionController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.NumberController = (function (Controller, common) {\n\t\n\t  /**\n\t   * @class Represents a given property of an object that is a number.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Object} [params] Optional parameters\n\t   * @param {Number} [params.min] Minimum allowed value\n\t   * @param {Number} [params.max] Maximum allowed value\n\t   * @param {Number} [params.step] Increment by which to change value\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var NumberController = function(object, property, params) {\n\t\n\t    NumberController.superclass.call(this, object, property);\n\t\n\t    params = params || {};\n\t\n\t    this.__min = params.min;\n\t    this.__max = params.max;\n\t    this.__step = params.step;\n\t\n\t    if (common.isUndefined(this.__step)) {\n\t\n\t      if (this.initialValue == 0) {\n\t        this.__impliedStep = 1; // What are we, psychics?\n\t      } else {\n\t        // Hey Doug, check this out.\n\t        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;\n\t      }\n\t\n\t    } else {\n\t\n\t      this.__impliedStep = this.__step;\n\t\n\t    }\n\t\n\t    this.__precision = numDecimals(this.__impliedStep);\n\t\n\t\n\t  };\n\t\n\t  NumberController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      NumberController.prototype,\n\t      Controller.prototype,\n\t\n\t      /** @lends dat.controllers.NumberController.prototype */\n\t      {\n\t\n\t        setValue: function(v) {\n\t\n\t          if (this.__min !== undefined && v < this.__min) {\n\t            v = this.__min;\n\t          } else if (this.__max !== undefined && v > this.__max) {\n\t            v = this.__max;\n\t          }\n\t\n\t          if (this.__step !== undefined && v % this.__step != 0) {\n\t            v = Math.round(v / this.__step) * this.__step;\n\t          }\n\t\n\t          return NumberController.superclass.prototype.setValue.call(this, v);\n\t\n\t        },\n\t\n\t        /**\n\t         * Specify a minimum value for <code>object[property]</code>.\n\t         *\n\t         * @param {Number} minValue The minimum value for\n\t         * <code>object[property]</code>\n\t         * @returns {dat.controllers.NumberController} this\n\t         */\n\t        min: function(v) {\n\t          this.__min = v;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Specify a maximum value for <code>object[property]</code>.\n\t         *\n\t         * @param {Number} maxValue The maximum value for\n\t         * <code>object[property]</code>\n\t         * @returns {dat.controllers.NumberController} this\n\t         */\n\t        max: function(v) {\n\t          this.__max = v;\n\t          return this;\n\t        },\n\t\n\t        /**\n\t         * Specify a step value that dat.controllers.NumberController\n\t         * increments by.\n\t         *\n\t         * @param {Number} stepValue The step value for\n\t         * dat.controllers.NumberController\n\t         * @default if minimum and maximum specified increment is 1% of the\n\t         * difference otherwise stepValue is 1\n\t         * @returns {dat.controllers.NumberController} this\n\t         */\n\t        step: function(v) {\n\t          this.__step = v;\n\t          return this;\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  function numDecimals(x) {\n\t    x = x.toString();\n\t    if (x.indexOf('.') > -1) {\n\t      return x.length - x.indexOf('.') - 1;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }\n\t\n\t  return NumberController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.NumberControllerBox = (function (NumberController, dom, common) {\n\t\n\t  /**\n\t   * @class Represents a given property of an object that is a number and\n\t   * provides an input element with which to manipulate it.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   * @extends dat.controllers.NumberController\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Object} [params] Optional parameters\n\t   * @param {Number} [params.min] Minimum allowed value\n\t   * @param {Number} [params.max] Maximum allowed value\n\t   * @param {Number} [params.step] Increment by which to change value\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var NumberControllerBox = function(object, property, params) {\n\t\n\t    this.__truncationSuspended = false;\n\t\n\t    NumberControllerBox.superclass.call(this, object, property, params);\n\t\n\t    var _this = this;\n\t\n\t    /**\n\t     * {Number} Previous mouse y position\n\t     * @ignore\n\t     */\n\t    var prev_y;\n\t\n\t    this.__input = document.createElement('input');\n\t    this.__input.setAttribute('type', 'text');\n\t\n\t    // Makes it so manually specified values are not truncated.\n\t\n\t    dom.bind(this.__input, 'change', onChange);\n\t    dom.bind(this.__input, 'blur', onBlur);\n\t    dom.bind(this.__input, 'mousedown', onMouseDown);\n\t    dom.bind(this.__input, 'keydown', function(e) {\n\t\n\t      // When pressing entire, you can be as precise as you want.\n\t      if (e.keyCode === 13) {\n\t        _this.__truncationSuspended = true;\n\t        this.blur();\n\t        _this.__truncationSuspended = false;\n\t      }\n\t\n\t    });\n\t\n\t    function onChange() {\n\t      var attempted = parseFloat(_this.__input.value);\n\t      if (!common.isNaN(attempted)) _this.setValue(attempted);\n\t    }\n\t\n\t    function onBlur() {\n\t      onChange();\n\t      if (_this.__onFinishChange) {\n\t        _this.__onFinishChange.call(_this, _this.getValue());\n\t      }\n\t    }\n\t\n\t    function onMouseDown(e) {\n\t      dom.bind(window, 'mousemove', onMouseDrag);\n\t      dom.bind(window, 'mouseup', onMouseUp);\n\t      prev_y = e.clientY;\n\t    }\n\t\n\t    function onMouseDrag(e) {\n\t\n\t      var diff = prev_y - e.clientY;\n\t      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\n\t\n\t      prev_y = e.clientY;\n\t\n\t    }\n\t\n\t    function onMouseUp() {\n\t      dom.unbind(window, 'mousemove', onMouseDrag);\n\t      dom.unbind(window, 'mouseup', onMouseUp);\n\t    }\n\t\n\t    this.updateDisplay();\n\t\n\t    this.domElement.appendChild(this.__input);\n\t\n\t  };\n\t\n\t  NumberControllerBox.superclass = NumberController;\n\t\n\t  common.extend(\n\t\n\t      NumberControllerBox.prototype,\n\t      NumberController.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t\n\t          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\n\t          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  function roundToDecimal(value, decimals) {\n\t    var tenTo = Math.pow(10, decimals);\n\t    return Math.round(value * tenTo) / tenTo;\n\t  }\n\t\n\t  return NumberControllerBox;\n\t\n\t})(dat.controllers.NumberController,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {\n\t\n\t  /**\n\t   * @class Represents a given property of an object that is a number, contains\n\t   * a minimum and maximum, and provides a slider element with which to\n\t   * manipulate it. It should be noted that the slider element is made up of\n\t   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5\n\t   * <code>&lt;slider&gt;</code> element.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   * @extends dat.controllers.NumberController\n\t   * \n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   * @param {Number} minValue Minimum allowed value\n\t   * @param {Number} maxValue Maximum allowed value\n\t   * @param {Number} stepValue Increment by which to change value\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var NumberControllerSlider = function(object, property, min, max, step) {\n\t\n\t    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });\n\t\n\t    var _this = this;\n\t\n\t    this.__background = document.createElement('div');\n\t    this.__foreground = document.createElement('div');\n\t    \n\t\n\t\n\t    dom.bind(this.__background, 'mousedown', onMouseDown);\n\t    \n\t    dom.addClass(this.__background, 'slider');\n\t    dom.addClass(this.__foreground, 'slider-fg');\n\t\n\t    function onMouseDown(e) {\n\t\n\t      dom.bind(window, 'mousemove', onMouseDrag);\n\t      dom.bind(window, 'mouseup', onMouseUp);\n\t\n\t      onMouseDrag(e);\n\t    }\n\t\n\t    function onMouseDrag(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      var offset = dom.getOffset(_this.__background);\n\t      var width = dom.getWidth(_this.__background);\n\t      \n\t      _this.setValue(\n\t        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)\n\t      );\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function onMouseUp() {\n\t      dom.unbind(window, 'mousemove', onMouseDrag);\n\t      dom.unbind(window, 'mouseup', onMouseUp);\n\t      if (_this.__onFinishChange) {\n\t        _this.__onFinishChange.call(_this, _this.getValue());\n\t      }\n\t    }\n\t\n\t    this.updateDisplay();\n\t\n\t    this.__background.appendChild(this.__foreground);\n\t    this.domElement.appendChild(this.__background);\n\t\n\t  };\n\t\n\t  NumberControllerSlider.superclass = NumberController;\n\t\n\t  /**\n\t   * Injects default stylesheet for slider elements.\n\t   */\n\t  NumberControllerSlider.useDefaultStyles = function() {\n\t    css.inject(styleSheet);\n\t  };\n\t\n\t  common.extend(\n\t\n\t      NumberControllerSlider.prototype,\n\t      NumberController.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);\n\t          this.__foreground.style.width = pct*100+'%';\n\t          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t\n\t\n\t  );\n\t\n\t  function map(v, i1, i2, o1, o2) {\n\t    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\n\t  }\n\t\n\t  return NumberControllerSlider;\n\t  \n\t})(dat.controllers.NumberController,\n\tdat.dom.dom,\n\tdat.utils.css,\n\tdat.utils.common,\n\t\".slider {\\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\\n  height: 1em;\\n  border-radius: 1em;\\n  background-color: #eee;\\n  padding: 0 0.5em;\\n  overflow: hidden;\\n}\\n\\n.slider-fg {\\n  padding: 1px 0 2px 0;\\n  background-color: #aaa;\\n  height: 1em;\\n  margin-left: -0.5em;\\n  padding-right: 0.5em;\\n  border-radius: 1em 0 0 1em;\\n}\\n\\n.slider-fg:after {\\n  display: inline-block;\\n  border-radius: 1em;\\n  background-color: #fff;\\n  border:  1px solid #aaa;\\n  content: '';\\n  float: right;\\n  margin-right: -1em;\\n  margin-top: -1px;\\n  height: 0.9em;\\n  width: 0.9em;\\n}\");\n\t\n\t\n\tdat.controllers.FunctionController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a GUI interface to fire a specified method, a property of an object.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var FunctionController = function(object, property, text) {\n\t\n\t    FunctionController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t\n\t    this.__button = document.createElement('div');\n\t    this.__button.innerHTML = text === undefined ? 'Fire' : text;\n\t    dom.bind(this.__button, 'click', function(e) {\n\t      e.preventDefault();\n\t      _this.fire();\n\t      return false;\n\t    });\n\t\n\t    dom.addClass(this.__button, 'button');\n\t\n\t    this.domElement.appendChild(this.__button);\n\t\n\t\n\t  };\n\t\n\t  FunctionController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      FunctionController.prototype,\n\t      Controller.prototype,\n\t      {\n\t        \n\t        fire: function() {\n\t          if (this.__onChange) {\n\t            this.__onChange.call(this);\n\t          }\n\t          if (this.__onFinishChange) {\n\t            this.__onFinishChange.call(this, this.getValue());\n\t          }\n\t          this.getValue().call(this.object);\n\t        }\n\t      }\n\t\n\t  );\n\t\n\t  return FunctionController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.controllers.BooleanController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a checkbox input to alter the boolean property of an object.\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var BooleanController = function(object, property) {\n\t\n\t    BooleanController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t    this.__prev = this.getValue();\n\t\n\t    this.__checkbox = document.createElement('input');\n\t    this.__checkbox.setAttribute('type', 'checkbox');\n\t\n\t\n\t    dom.bind(this.__checkbox, 'change', onChange, false);\n\t\n\t    this.domElement.appendChild(this.__checkbox);\n\t\n\t    // Match original value\n\t    this.updateDisplay();\n\t\n\t    function onChange() {\n\t      _this.setValue(!_this.__prev);\n\t    }\n\t\n\t  };\n\t\n\t  BooleanController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      BooleanController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        setValue: function(v) {\n\t          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);\n\t          if (this.__onFinishChange) {\n\t            this.__onFinishChange.call(this, this.getValue());\n\t          }\n\t          this.__prev = this.getValue();\n\t          return toReturn;\n\t        },\n\t\n\t        updateDisplay: function() {\n\t          \n\t          if (this.getValue() === true) {\n\t            this.__checkbox.setAttribute('checked', 'checked');\n\t            this.__checkbox.checked = true;    \n\t          } else {\n\t              this.__checkbox.checked = false;\n\t          }\n\t\n\t          return BooleanController.superclass.prototype.updateDisplay.call(this);\n\t\n\t        }\n\t\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return BooleanController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common);\n\t\n\t\n\tdat.color.toString = (function (common) {\n\t\n\t  return function(color) {\n\t\n\t    if (color.a == 1 || common.isUndefined(color.a)) {\n\t\n\t      var s = color.hex.toString(16);\n\t      while (s.length < 6) {\n\t        s = '0' + s;\n\t      }\n\t\n\t      return '#' + s;\n\t\n\t    } else {\n\t\n\t      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\t\n\t    }\n\t\n\t  }\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.color.interpret = (function (toString, common) {\n\t\n\t  var result, toReturn;\n\t\n\t  var interpret = function() {\n\t\n\t    toReturn = false;\n\t\n\t    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\t\n\t    common.each(INTERPRETATIONS, function(family) {\n\t\n\t      if (family.litmus(original)) {\n\t\n\t        common.each(family.conversions, function(conversion, conversionName) {\n\t\n\t          result = conversion.read(original);\n\t\n\t          if (toReturn === false && result !== false) {\n\t            toReturn = result;\n\t            result.conversionName = conversionName;\n\t            result.conversion = conversion;\n\t            return common.BREAK;\n\t\n\t          }\n\t\n\t        });\n\t\n\t        return common.BREAK;\n\t\n\t      }\n\t\n\t    });\n\t\n\t    return toReturn;\n\t\n\t  };\n\t\n\t  var INTERPRETATIONS = [\n\t\n\t    // Strings\n\t    {\n\t\n\t      litmus: common.isString,\n\t\n\t      conversions: {\n\t\n\t        THREE_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt(\n\t                  '0x' +\n\t                      test[1].toString() + test[1].toString() +\n\t                      test[2].toString() + test[2].toString() +\n\t                      test[3].toString() + test[3].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        SIX_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9]{6})$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt('0x' + test[1].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGB: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGBA: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3]),\n\t              a: parseFloat(test[4])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Numbers\n\t    {\n\t\n\t      litmus: common.isNumber,\n\t\n\t      conversions: {\n\t\n\t        HEX: {\n\t          read: function(original) {\n\t            return {\n\t              space: 'HEX',\n\t              hex: original,\n\t              conversionName: 'HEX'\n\t            }\n\t          },\n\t\n\t          write: function(color) {\n\t            return color.hex;\n\t          }\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Arrays\n\t    {\n\t\n\t      litmus: common.isArray,\n\t\n\t      conversions: {\n\t\n\t        RGB_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 3) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b];\n\t          }\n\t\n\t        },\n\t\n\t        RGBA_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 4) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2],\n\t              a: original[3]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b, color.a];\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Objects\n\t    {\n\t\n\t      litmus: common.isObject,\n\t\n\t      conversions: {\n\t\n\t        RGBA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        RGB_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b\n\t            }\n\t          }\n\t        },\n\t\n\t        HSVA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        HSV_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v\n\t            }\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t\n\t\n\t  ];\n\t\n\t  return interpret;\n\t\n\t\n\t})(dat.color.toString,\n\tdat.utils.common);\n\t\n\t\n\tdat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {\n\t\n\t  css.inject(styleSheet);\n\t\n\t  /** Outer-most className for GUI's */\n\t  var CSS_NAMESPACE = 'dg';\n\t\n\t  var HIDE_KEY_CODE = 72;\n\t\n\t  /** The only value shared between the JS and SCSS. Use caution. */\n\t  var CLOSE_BUTTON_HEIGHT = 20;\n\t\n\t  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';\n\t\n\t  var SUPPORTS_LOCAL_STORAGE = (function() {\n\t    try {\n\t      return 'localStorage' in window && window['localStorage'] !== null;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  })();\n\t\n\t  var SAVE_DIALOGUE;\n\t\n\t  /** Have we yet to create an autoPlace GUI? */\n\t  var auto_place_virgin = true;\n\t\n\t  /** Fixed position div that auto place GUI's go inside */\n\t  var auto_place_container;\n\t\n\t  /** Are we hiding the GUI's ? */\n\t  var hide = false;\n\t\n\t  /** GUI's which should be hidden */\n\t  var hideable_guis = [];\n\t\n\t  /**\n\t   * A lightweight controller library for JavaScript. It allows you to easily\n\t   * manipulate variables and fire functions on the fly.\n\t   * @class\n\t   *\n\t   * @member dat.gui\n\t   *\n\t   * @param {Object} [params]\n\t   * @param {String} [params.name] The name of this GUI.\n\t   * @param {Object} [params.load] JSON object representing the saved state of\n\t   * this GUI.\n\t   * @param {Boolean} [params.auto=true]\n\t   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.\n\t   * @param {Boolean} [params.closed] If true, starts closed\n\t   */\n\t  var GUI = function(params) {\n\t\n\t    var _this = this;\n\t\n\t    /**\n\t     * Outermost DOM Element\n\t     * @type DOMElement\n\t     */\n\t    this.domElement = document.createElement('div');\n\t    this.__ul = document.createElement('ul');\n\t    this.domElement.appendChild(this.__ul);\n\t\n\t    dom.addClass(this.domElement, CSS_NAMESPACE);\n\t\n\t    /**\n\t     * Nested GUI's by name\n\t     * @ignore\n\t     */\n\t    this.__folders = {};\n\t\n\t    this.__controllers = [];\n\t\n\t    /**\n\t     * List of objects I'm remembering for save, only used in top level GUI\n\t     * @ignore\n\t     */\n\t    this.__rememberedObjects = [];\n\t\n\t    /**\n\t     * Maps the index of remembered objects to a map of controllers, only used\n\t     * in top level GUI.\n\t     *\n\t     * @private\n\t     * @ignore\n\t     *\n\t     * @example\n\t     * [\n\t     *  {\n\t     *    propertyName: Controller,\n\t     *    anotherPropertyName: Controller\n\t     *  },\n\t     *  {\n\t     *    propertyName: Controller\n\t     *  }\n\t     * ]\n\t     */\n\t    this.__rememberedObjectIndecesToControllers = [];\n\t\n\t    this.__listening = [];\n\t\n\t    params = params || {};\n\t\n\t    // Default parameters\n\t    params = common.defaults(params, {\n\t      autoPlace: true,\n\t      width: GUI.DEFAULT_WIDTH\n\t    });\n\t\n\t    params = common.defaults(params, {\n\t      resizable: params.autoPlace,\n\t      hideable: params.autoPlace\n\t    });\n\t\n\t\n\t    if (!common.isUndefined(params.load)) {\n\t\n\t      // Explicit preset\n\t      if (params.preset) params.load.preset = params.preset;\n\t\n\t    } else {\n\t\n\t      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\n\t\n\t    }\n\t\n\t    if (common.isUndefined(params.parent) && params.hideable) {\n\t      hideable_guis.push(this);\n\t    }\n\t\n\t    // Only root level GUI's are resizable.\n\t    params.resizable = common.isUndefined(params.parent) && params.resizable;\n\t\n\t\n\t    if (params.autoPlace && common.isUndefined(params.scrollable)) {\n\t      params.scrollable = true;\n\t    }\n\t//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;\n\t\n\t    // Not part of params because I don't want people passing this in via\n\t    // constructor. Should be a 'remembered' value.\n\t    var use_local_storage =\n\t        SUPPORTS_LOCAL_STORAGE &&\n\t            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\n\t\n\t    Object.defineProperties(this,\n\t\n\t        /** @lends dat.gui.GUI.prototype */\n\t        {\n\t\n\t          /**\n\t           * The parent <code>GUI</code>\n\t           * @type dat.gui.GUI\n\t           */\n\t          parent: {\n\t            get: function() {\n\t              return params.parent;\n\t            }\n\t          },\n\t\n\t          scrollable: {\n\t            get: function() {\n\t              return params.scrollable;\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Handles <code>GUI</code>'s element placement for you\n\t           * @type Boolean\n\t           */\n\t          autoPlace: {\n\t            get: function() {\n\t              return params.autoPlace;\n\t            }\n\t          },\n\t\n\t          /**\n\t           * The identifier for a set of saved values\n\t           * @type String\n\t           */\n\t          preset: {\n\t\n\t            get: function() {\n\t              if (_this.parent) {\n\t                return _this.getRoot().preset;\n\t              } else {\n\t                return params.load.preset;\n\t              }\n\t            },\n\t\n\t            set: function(v) {\n\t              if (_this.parent) {\n\t                _this.getRoot().preset = v;\n\t              } else {\n\t                params.load.preset = v;\n\t              }\n\t              setPresetSelectIndex(this);\n\t              _this.revert();\n\t            }\n\t\n\t          },\n\t\n\t          /**\n\t           * The width of <code>GUI</code> element\n\t           * @type Number\n\t           */\n\t          width: {\n\t            get: function() {\n\t              return params.width;\n\t            },\n\t            set: function(v) {\n\t              params.width = v;\n\t              setWidth(_this, v);\n\t            }\n\t          },\n\t\n\t          /**\n\t           * The name of <code>GUI</code>. Used for folders. i.e\n\t           * a folder's name\n\t           * @type String\n\t           */\n\t          name: {\n\t            get: function() {\n\t              return params.name;\n\t            },\n\t            set: function(v) {\n\t              // TODO Check for collisions among sibling folders\n\t              params.name = v;\n\t              if (title_row_name) {\n\t                title_row_name.innerHTML = params.name;\n\t              }\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Whether the <code>GUI</code> is collapsed or not\n\t           * @type Boolean\n\t           */\n\t          closed: {\n\t            get: function() {\n\t              return params.closed;\n\t            },\n\t            set: function(v) {\n\t              params.closed = v;\n\t              if (params.closed) {\n\t                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\n\t              } else {\n\t                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\n\t              }\n\t              // For browsers that aren't going to respect the CSS transition,\n\t              // Lets just check our height against the window height right off\n\t              // the bat.\n\t              this.onResize();\n\t\n\t              if (_this.__closeButton) {\n\t                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\n\t              }\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Contains all presets\n\t           * @type Object\n\t           */\n\t          load: {\n\t            get: function() {\n\t              return params.load;\n\t            }\n\t          },\n\t\n\t          /**\n\t           * Determines whether or not to use <a href=\"https://developer.mozilla.org/en/DOM/Storage#localStorage\">localStorage</a> as the means for\n\t           * <code>remember</code>ing\n\t           * @type Boolean\n\t           */\n\t          useLocalStorage: {\n\t\n\t            get: function() {\n\t              return use_local_storage;\n\t            },\n\t            set: function(bool) {\n\t              if (SUPPORTS_LOCAL_STORAGE) {\n\t                use_local_storage = bool;\n\t                if (bool) {\n\t                  dom.bind(window, 'unload', saveToLocalStorage);\n\t                } else {\n\t                  dom.unbind(window, 'unload', saveToLocalStorage);\n\t                }\n\t                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\n\t              }\n\t            }\n\t\n\t          }\n\t\n\t        });\n\t\n\t    // Are we a root level GUI?\n\t    if (common.isUndefined(params.parent)) {\n\t\n\t      params.closed = false;\n\t\n\t      dom.addClass(this.domElement, GUI.CLASS_MAIN);\n\t      dom.makeSelectable(this.domElement, false);\n\t\n\t      // Are we supposed to be loading locally?\n\t      if (SUPPORTS_LOCAL_STORAGE) {\n\t\n\t        if (use_local_storage) {\n\t\n\t          _this.useLocalStorage = true;\n\t\n\t          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\n\t\n\t          if (saved_gui) {\n\t            params.load = JSON.parse(saved_gui);\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t      this.__closeButton = document.createElement('div');\n\t      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\n\t      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\n\t      this.domElement.appendChild(this.__closeButton);\n\t\n\t      dom.bind(this.__closeButton, 'click', function() {\n\t\n\t        _this.closed = !_this.closed;\n\t\n\t\n\t      });\n\t\n\t\n\t      // Oh, you're a nested GUI!\n\t    } else {\n\t\n\t      if (params.closed === undefined) {\n\t        params.closed = true;\n\t      }\n\t\n\t      var title_row_name = document.createTextNode(params.name);\n\t      dom.addClass(title_row_name, 'controller-name');\n\t\n\t      var title_row = addRow(_this, title_row_name);\n\t\n\t      var on_click_title = function(e) {\n\t        e.preventDefault();\n\t        _this.closed = !_this.closed;\n\t        return false;\n\t      };\n\t\n\t      dom.addClass(this.__ul, GUI.CLASS_CLOSED);\n\t\n\t      dom.addClass(title_row, 'title');\n\t      dom.bind(title_row, 'click', on_click_title);\n\t\n\t      if (!params.closed) {\n\t        this.closed = false;\n\t      }\n\t\n\t    }\n\t\n\t    if (params.autoPlace) {\n\t\n\t      if (common.isUndefined(params.parent)) {\n\t\n\t        if (auto_place_virgin) {\n\t          auto_place_container = document.createElement('div');\n\t          dom.addClass(auto_place_container, CSS_NAMESPACE);\n\t          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);\n\t          document.body.appendChild(auto_place_container);\n\t          auto_place_virgin = false;\n\t        }\n\t\n\t        // Put it in the dom for you.\n\t        auto_place_container.appendChild(this.domElement);\n\t\n\t        // Apply the auto styles\n\t        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\n\t\n\t      }\n\t\n\t\n\t      // Make it not elastic.\n\t      if (!this.parent) setWidth(_this, params.width);\n\t\n\t    }\n\t\n\t    dom.bind(window, 'resize', function() { _this.onResize() });\n\t    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });\n\t    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });\n\t    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });\n\t    this.onResize();\n\t\n\t\n\t    if (params.resizable) {\n\t      addResizeHandle(this);\n\t    }\n\t\n\t    function saveToLocalStorage() {\n\t      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\n\t    }\n\t\n\t    var root = _this.getRoot();\n\t    function resetWidth() {\n\t        var root = _this.getRoot();\n\t        root.width += 1;\n\t        common.defer(function() {\n\t          root.width -= 1;\n\t        });\n\t      }\n\t\n\t      if (!params.parent) {\n\t        resetWidth();\n\t      }\n\t\n\t  };\n\t\n\t  GUI.toggleHide = function() {\n\t\n\t    hide = !hide;\n\t    common.each(hideable_guis, function(gui) {\n\t      gui.domElement.style.zIndex = hide ? -999 : 999;\n\t      gui.domElement.style.opacity = hide ? 0 : 1;\n\t    });\n\t  };\n\t\n\t  GUI.CLASS_AUTO_PLACE = 'a';\n\t  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\n\t  GUI.CLASS_MAIN = 'main';\n\t  GUI.CLASS_CONTROLLER_ROW = 'cr';\n\t  GUI.CLASS_TOO_TALL = 'taller-than-window';\n\t  GUI.CLASS_CLOSED = 'closed';\n\t  GUI.CLASS_CLOSE_BUTTON = 'close-button';\n\t  GUI.CLASS_DRAG = 'drag';\n\t\n\t  GUI.DEFAULT_WIDTH = 245;\n\t  GUI.TEXT_CLOSED = 'Close Controls';\n\t  GUI.TEXT_OPEN = 'Open Controls';\n\t\n\t  dom.bind(window, 'keydown', function(e) {\n\t\n\t    if (document.activeElement.type !== 'text' &&\n\t        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {\n\t      GUI.toggleHide();\n\t    }\n\t\n\t  }, false);\n\t\n\t  common.extend(\n\t\n\t      GUI.prototype,\n\t\n\t      /** @lends dat.gui.GUI */\n\t      {\n\t\n\t        /**\n\t         * @param object\n\t         * @param property\n\t         * @returns {dat.controllers.Controller} The new controller that was added.\n\t         * @instance\n\t         */\n\t        add: function(object, property) {\n\t\n\t          return add(\n\t              this,\n\t              object,\n\t              property,\n\t              {\n\t                factoryArgs: Array.prototype.slice.call(arguments, 2)\n\t              }\n\t          );\n\t\n\t        },\n\t\n\t        /**\n\t         * @param object\n\t         * @param property\n\t         * @returns {dat.controllers.ColorController} The new controller that was added.\n\t         * @instance\n\t         */\n\t        addColor: function(object, property) {\n\t\n\t          return add(\n\t              this,\n\t              object,\n\t              property,\n\t              {\n\t                color: true\n\t              }\n\t          );\n\t\n\t        },\n\t\n\t        /**\n\t         * @param controller\n\t         * @instance\n\t         */\n\t        remove: function(controller) {\n\t\n\t          // TODO listening?\n\t          this.__ul.removeChild(controller.__li);\n\t          this.__controllers.slice(this.__controllers.indexOf(controller), 1);\n\t          var _this = this;\n\t          common.defer(function() {\n\t            _this.onResize();\n\t          });\n\t\n\t        },\n\t\n\t        destroy: function() {\n\t\n\t          if (this.autoPlace) {\n\t            auto_place_container.removeChild(this.domElement);\n\t          }\n\t\n\t        },\n\t\n\t        /**\n\t         * @param name\n\t         * @returns {dat.gui.GUI} The new folder.\n\t         * @throws {Error} if this GUI already has a folder by the specified\n\t         * name\n\t         * @instance\n\t         */\n\t        addFolder: function(name) {\n\t\n\t          // We have to prevent collisions on names in order to have a key\n\t          // by which to remember saved values\n\t          if (this.__folders[name] !== undefined) {\n\t            throw new Error('You already have a folder in this GUI by the' +\n\t                ' name \"' + name + '\"');\n\t          }\n\t\n\t          var new_gui_params = { name: name, parent: this };\n\t\n\t          // We need to pass down the autoPlace trait so that we can\n\t          // attach event listeners to open/close folder actions to\n\t          // ensure that a scrollbar appears if the window is too short.\n\t          new_gui_params.autoPlace = this.autoPlace;\n\t\n\t          // Do we have saved appearance data for this folder?\n\t\n\t          if (this.load && // Anything loaded?\n\t              this.load.folders && // Was my parent a dead-end?\n\t              this.load.folders[name]) { // Did daddy remember me?\n\t\n\t            // Start me closed if I was closed\n\t            new_gui_params.closed = this.load.folders[name].closed;\n\t\n\t            // Pass down the loaded data\n\t            new_gui_params.load = this.load.folders[name];\n\t\n\t          }\n\t\n\t          var gui = new GUI(new_gui_params);\n\t          this.__folders[name] = gui;\n\t\n\t          var li = addRow(this, gui.domElement);\n\t          dom.addClass(li, 'folder');\n\t          return gui;\n\t\n\t        },\n\t\n\t        open: function() {\n\t          this.closed = false;\n\t        },\n\t\n\t        close: function() {\n\t          this.closed = true;\n\t        },\n\t\n\t        onResize: function() {\n\t\n\t          var root = this.getRoot();\n\t\n\t          if (root.scrollable) {\n\t\n\t            var top = dom.getOffset(root.__ul).top;\n\t            var h = 0;\n\t\n\t            common.each(root.__ul.childNodes, function(node) {\n\t              if (! (root.autoPlace && node === root.__save_row))\n\t                h += dom.getHeight(node);\n\t            });\n\t\n\t            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\n\t              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\n\t              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\n\t            } else {\n\t              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\n\t              root.__ul.style.height = 'auto';\n\t            }\n\t\n\t          }\n\t\n\t          if (root.__resize_handle) {\n\t            common.defer(function() {\n\t              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\n\t            });\n\t          }\n\t\n\t          if (root.__closeButton) {\n\t            root.__closeButton.style.width = root.width + 'px';\n\t          }\n\t\n\t        },\n\t\n\t        /**\n\t         * Mark objects for saving. The order of these objects cannot change as\n\t         * the GUI grows. When remembering new objects, append them to the end\n\t         * of the list.\n\t         *\n\t         * @param {Object...} objects\n\t         * @throws {Error} if not called on a top level GUI.\n\t         * @instance\n\t         */\n\t        remember: function() {\n\t\n\t          if (common.isUndefined(SAVE_DIALOGUE)) {\n\t            SAVE_DIALOGUE = new CenteredDiv();\n\t            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;\n\t          }\n\t\n\t          if (this.parent) {\n\t            throw new Error(\"You can only call remember on a top level GUI.\");\n\t          }\n\t\n\t          var _this = this;\n\t\n\t          common.each(Array.prototype.slice.call(arguments), function(object) {\n\t            if (_this.__rememberedObjects.length == 0) {\n\t              addSaveMenu(_this);\n\t            }\n\t            if (_this.__rememberedObjects.indexOf(object) == -1) {\n\t              _this.__rememberedObjects.push(object);\n\t            }\n\t          });\n\t\n\t          if (this.autoPlace) {\n\t            // Set save row width\n\t            setWidth(this, this.width);\n\t          }\n\t\n\t        },\n\t\n\t        /**\n\t         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.\n\t         * @instance\n\t         */\n\t        getRoot: function() {\n\t          var gui = this;\n\t          while (gui.parent) {\n\t            gui = gui.parent;\n\t          }\n\t          return gui;\n\t        },\n\t\n\t        /**\n\t         * @returns {Object} a JSON object representing the current state of\n\t         * this GUI as well as its remembered properties.\n\t         * @instance\n\t         */\n\t        getSaveObject: function() {\n\t\n\t          var toReturn = this.load;\n\t\n\t          toReturn.closed = this.closed;\n\t\n\t          // Am I remembering any values?\n\t          if (this.__rememberedObjects.length > 0) {\n\t\n\t            toReturn.preset = this.preset;\n\t\n\t            if (!toReturn.remembered) {\n\t              toReturn.remembered = {};\n\t            }\n\t\n\t            toReturn.remembered[this.preset] = getCurrentPreset(this);\n\t\n\t          }\n\t\n\t          toReturn.folders = {};\n\t          common.each(this.__folders, function(element, key) {\n\t            toReturn.folders[key] = element.getSaveObject();\n\t          });\n\t\n\t          return toReturn;\n\t\n\t        },\n\t\n\t        save: function() {\n\t\n\t          if (!this.load.remembered) {\n\t            this.load.remembered = {};\n\t          }\n\t\n\t          this.load.remembered[this.preset] = getCurrentPreset(this);\n\t          markPresetModified(this, false);\n\t\n\t        },\n\t\n\t        saveAs: function(presetName) {\n\t\n\t          if (!this.load.remembered) {\n\t\n\t            // Retain default values upon first save\n\t            this.load.remembered = {};\n\t            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\n\t\n\t          }\n\t\n\t          this.load.remembered[presetName] = getCurrentPreset(this);\n\t          this.preset = presetName;\n\t          addPresetOption(this, presetName, true);\n\t\n\t        },\n\t\n\t        revert: function(gui) {\n\t\n\t          common.each(this.__controllers, function(controller) {\n\t            // Make revert work on Default.\n\t            if (!this.getRoot().load.remembered) {\n\t              controller.setValue(controller.initialValue);\n\t            } else {\n\t              recallSavedValue(gui || this.getRoot(), controller);\n\t            }\n\t          }, this);\n\t\n\t          common.each(this.__folders, function(folder) {\n\t            folder.revert(folder);\n\t          });\n\t\n\t          if (!gui) {\n\t            markPresetModified(this.getRoot(), false);\n\t          }\n\t\n\t\n\t        },\n\t\n\t        listen: function(controller) {\n\t\n\t          var init = this.__listening.length == 0;\n\t          this.__listening.push(controller);\n\t          if (init) updateDisplays(this.__listening);\n\t\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  function add(gui, object, property, params) {\n\t\n\t    if (object[property] === undefined) {\n\t      throw new Error(\"Object \" + object + \" has no property \\\"\" + property + \"\\\"\");\n\t    }\n\t\n\t    var controller;\n\t\n\t    if (params.color) {\n\t\n\t      controller = new ColorController(object, property);\n\t\n\t    } else {\n\t\n\t      var factoryArgs = [object,property].concat(params.factoryArgs);\n\t      controller = controllerFactory.apply(gui, factoryArgs);\n\t\n\t    }\n\t\n\t    if (params.before instanceof Controller) {\n\t      params.before = params.before.__li;\n\t    }\n\t\n\t    recallSavedValue(gui, controller);\n\t\n\t    dom.addClass(controller.domElement, 'c');\n\t\n\t    var name = document.createElement('span');\n\t    dom.addClass(name, 'property-name');\n\t    name.innerHTML = controller.property;\n\t\n\t    var container = document.createElement('div');\n\t    container.appendChild(name);\n\t    container.appendChild(controller.domElement);\n\t\n\t    var li = addRow(gui, container, params.before);\n\t\n\t    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\n\t    dom.addClass(li, typeof controller.getValue());\n\t\n\t    augmentController(gui, li, controller);\n\t\n\t    gui.__controllers.push(controller);\n\t\n\t    return controller;\n\t\n\t  }\n\t\n\t  /**\n\t   * Add a row to the end of the GUI or before another row.\n\t   *\n\t   * @param gui\n\t   * @param [dom] If specified, inserts the dom content in the new row\n\t   * @param [liBefore] If specified, places the new row before another row\n\t   */\n\t  function addRow(gui, dom, liBefore) {\n\t    var li = document.createElement('li');\n\t    if (dom) li.appendChild(dom);\n\t    if (liBefore) {\n\t      gui.__ul.insertBefore(li, params.before);\n\t    } else {\n\t      gui.__ul.appendChild(li);\n\t    }\n\t    gui.onResize();\n\t    return li;\n\t  }\n\t\n\t  function augmentController(gui, li, controller) {\n\t\n\t    controller.__li = li;\n\t    controller.__gui = gui;\n\t\n\t    common.extend(controller, {\n\t\n\t      options: function(options) {\n\t\n\t        if (arguments.length > 1) {\n\t          controller.remove();\n\t\n\t          return add(\n\t              gui,\n\t              controller.object,\n\t              controller.property,\n\t              {\n\t                before: controller.__li.nextElementSibling,\n\t                factoryArgs: [common.toArray(arguments)]\n\t              }\n\t          );\n\t\n\t        }\n\t\n\t        if (common.isArray(options) || common.isObject(options)) {\n\t          controller.remove();\n\t\n\t          return add(\n\t              gui,\n\t              controller.object,\n\t              controller.property,\n\t              {\n\t                before: controller.__li.nextElementSibling,\n\t                factoryArgs: [options]\n\t              }\n\t          );\n\t\n\t        }\n\t\n\t      },\n\t\n\t      name: function(v) {\n\t        controller.__li.firstElementChild.firstElementChild.innerHTML = v;\n\t        return controller;\n\t      },\n\t\n\t      listen: function() {\n\t        controller.__gui.listen(controller);\n\t        return controller;\n\t      },\n\t\n\t      remove: function() {\n\t        controller.__gui.remove(controller);\n\t        return controller;\n\t      }\n\t\n\t    });\n\t\n\t    // All sliders should be accompanied by a box.\n\t    if (controller instanceof NumberControllerSlider) {\n\t\n\t      var box = new NumberControllerBox(controller.object, controller.property,\n\t          { min: controller.__min, max: controller.__max, step: controller.__step });\n\t\n\t      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {\n\t        var pc = controller[method];\n\t        var pb = box[method];\n\t        controller[method] = box[method] = function() {\n\t          var args = Array.prototype.slice.call(arguments);\n\t          pc.apply(controller, args);\n\t          return pb.apply(box, args);\n\t        }\n\t      });\n\t\n\t      dom.addClass(li, 'has-slider');\n\t      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\n\t\n\t    }\n\t    else if (controller instanceof NumberControllerBox) {\n\t\n\t      var r = function(returned) {\n\t\n\t        // Have we defined both boundaries?\n\t        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {\n\t\n\t          // Well, then lets just replace this with a slider.\n\t          controller.remove();\n\t          return add(\n\t              gui,\n\t              controller.object,\n\t              controller.property,\n\t              {\n\t                before: controller.__li.nextElementSibling,\n\t                factoryArgs: [controller.__min, controller.__max, controller.__step]\n\t              });\n\t\n\t        }\n\t\n\t        return returned;\n\t\n\t      };\n\t\n\t      controller.min = common.compose(r, controller.min);\n\t      controller.max = common.compose(r, controller.max);\n\t\n\t    }\n\t    else if (controller instanceof BooleanController) {\n\t\n\t      dom.bind(li, 'click', function() {\n\t        dom.fakeEvent(controller.__checkbox, 'click');\n\t      });\n\t\n\t      dom.bind(controller.__checkbox, 'click', function(e) {\n\t        e.stopPropagation(); // Prevents double-toggle\n\t      })\n\t\n\t    }\n\t    else if (controller instanceof FunctionController) {\n\t\n\t      dom.bind(li, 'click', function() {\n\t        dom.fakeEvent(controller.__button, 'click');\n\t      });\n\t\n\t      dom.bind(li, 'mouseover', function() {\n\t        dom.addClass(controller.__button, 'hover');\n\t      });\n\t\n\t      dom.bind(li, 'mouseout', function() {\n\t        dom.removeClass(controller.__button, 'hover');\n\t      });\n\t\n\t    }\n\t    else if (controller instanceof ColorController) {\n\t\n\t      dom.addClass(li, 'color');\n\t      controller.updateDisplay = common.compose(function(r) {\n\t        li.style.borderLeftColor = controller.__color.toString();\n\t        return r;\n\t      }, controller.updateDisplay);\n\t\n\t      controller.updateDisplay();\n\t\n\t    }\n\t\n\t    controller.setValue = common.compose(function(r) {\n\t      if (gui.getRoot().__preset_select && controller.isModified()) {\n\t        markPresetModified(gui.getRoot(), true);\n\t      }\n\t      return r;\n\t    }, controller.setValue);\n\t\n\t  }\n\t\n\t  function recallSavedValue(gui, controller) {\n\t\n\t    // Find the topmost GUI, that's where remembered objects live.\n\t    var root = gui.getRoot();\n\t\n\t    // Does the object we're controlling match anything we've been told to\n\t    // remember?\n\t    var matched_index = root.__rememberedObjects.indexOf(controller.object);\n\t\n\t    // Why yes, it does!\n\t    if (matched_index != -1) {\n\t\n\t      // Let me fetch a map of controllers for thcommon.isObject.\n\t      var controller_map =\n\t          root.__rememberedObjectIndecesToControllers[matched_index];\n\t\n\t      // Ohp, I believe this is the first controller we've created for this\n\t      // object. Lets make the map fresh.\n\t      if (controller_map === undefined) {\n\t        controller_map = {};\n\t        root.__rememberedObjectIndecesToControllers[matched_index] =\n\t            controller_map;\n\t      }\n\t\n\t      // Keep track of this controller\n\t      controller_map[controller.property] = controller;\n\t\n\t      // Okay, now have we saved any values for this controller?\n\t      if (root.load && root.load.remembered) {\n\t\n\t        var preset_map = root.load.remembered;\n\t\n\t        // Which preset are we trying to load?\n\t        var preset;\n\t\n\t        if (preset_map[gui.preset]) {\n\t\n\t          preset = preset_map[gui.preset];\n\t\n\t        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {\n\t\n\t          // Uhh, you can have the default instead?\n\t          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];\n\t\n\t        } else {\n\t\n\t          // Nada.\n\t\n\t          return;\n\t\n\t        }\n\t\n\t\n\t        // Did the loaded object remember thcommon.isObject?\n\t        if (preset[matched_index] &&\n\t\n\t          // Did we remember this particular property?\n\t            preset[matched_index][controller.property] !== undefined) {\n\t\n\t          // We did remember something for this guy ...\n\t          var value = preset[matched_index][controller.property];\n\t\n\t          // And that's what it is.\n\t          controller.initialValue = value;\n\t          controller.setValue(value);\n\t\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function getLocalStorageHash(gui, key) {\n\t    // TODO how does this deal with multiple GUI's?\n\t    return document.location.href + '.' + key;\n\t\n\t  }\n\t\n\t  function addSaveMenu(gui) {\n\t\n\t    var div = gui.__save_row = document.createElement('li');\n\t\n\t    dom.addClass(gui.domElement, 'has-save');\n\t\n\t    gui.__ul.insertBefore(div, gui.__ul.firstChild);\n\t\n\t    dom.addClass(div, 'save-row');\n\t\n\t    var gears = document.createElement('span');\n\t    gears.innerHTML = '&nbsp;';\n\t    dom.addClass(gears, 'button gears');\n\t\n\t    // TODO replace with FunctionController\n\t    var button = document.createElement('span');\n\t    button.innerHTML = 'Save';\n\t    dom.addClass(button, 'button');\n\t    dom.addClass(button, 'save');\n\t\n\t    var button2 = document.createElement('span');\n\t    button2.innerHTML = 'New';\n\t    dom.addClass(button2, 'button');\n\t    dom.addClass(button2, 'save-as');\n\t\n\t    var button3 = document.createElement('span');\n\t    button3.innerHTML = 'Revert';\n\t    dom.addClass(button3, 'button');\n\t    dom.addClass(button3, 'revert');\n\t\n\t    var select = gui.__preset_select = document.createElement('select');\n\t\n\t    if (gui.load && gui.load.remembered) {\n\t\n\t      common.each(gui.load.remembered, function(value, key) {\n\t        addPresetOption(gui, key, key == gui.preset);\n\t      });\n\t\n\t    } else {\n\t      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\n\t    }\n\t\n\t    dom.bind(select, 'change', function() {\n\t\n\t\n\t      for (var index = 0; index < gui.__preset_select.length; index++) {\n\t        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\n\t      }\n\t\n\t      gui.preset = this.value;\n\t\n\t    });\n\t\n\t    div.appendChild(select);\n\t    div.appendChild(gears);\n\t    div.appendChild(button);\n\t    div.appendChild(button2);\n\t    div.appendChild(button3);\n\t\n\t    if (SUPPORTS_LOCAL_STORAGE) {\n\t\n\t      var saveLocally = document.getElementById('dg-save-locally');\n\t      var explain = document.getElementById('dg-local-explain');\n\t\n\t      saveLocally.style.display = 'block';\n\t\n\t      var localStorageCheckBox = document.getElementById('dg-local-storage');\n\t\n\t      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\n\t        localStorageCheckBox.setAttribute('checked', 'checked');\n\t      }\n\t\n\t      function showHideExplain() {\n\t        explain.style.display = gui.useLocalStorage ? 'block' : 'none';\n\t      }\n\t\n\t      showHideExplain();\n\t\n\t      // TODO: Use a boolean controller, fool!\n\t      dom.bind(localStorageCheckBox, 'change', function() {\n\t        gui.useLocalStorage = !gui.useLocalStorage;\n\t        showHideExplain();\n\t      });\n\t\n\t    }\n\t\n\t    var newConstructorTextArea = document.getElementById('dg-new-constructor');\n\t\n\t    dom.bind(newConstructorTextArea, 'keydown', function(e) {\n\t      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {\n\t        SAVE_DIALOGUE.hide();\n\t      }\n\t    });\n\t\n\t    dom.bind(gears, 'click', function() {\n\t      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\n\t      SAVE_DIALOGUE.show();\n\t      newConstructorTextArea.focus();\n\t      newConstructorTextArea.select();\n\t    });\n\t\n\t    dom.bind(button, 'click', function() {\n\t      gui.save();\n\t    });\n\t\n\t    dom.bind(button2, 'click', function() {\n\t      var presetName = prompt('Enter a new preset name.');\n\t      if (presetName) gui.saveAs(presetName);\n\t    });\n\t\n\t    dom.bind(button3, 'click', function() {\n\t      gui.revert();\n\t    });\n\t\n\t//    div.appendChild(button2);\n\t\n\t  }\n\t\n\t  function addResizeHandle(gui) {\n\t\n\t    gui.__resize_handle = document.createElement('div');\n\t\n\t    common.extend(gui.__resize_handle.style, {\n\t\n\t      width: '6px',\n\t      marginLeft: '-3px',\n\t      height: '200px',\n\t      cursor: 'ew-resize',\n\t      position: 'absolute'\n\t//      border: '1px solid blue'\n\t\n\t    });\n\t\n\t    var pmouseX;\n\t\n\t    dom.bind(gui.__resize_handle, 'mousedown', dragStart);\n\t    dom.bind(gui.__closeButton, 'mousedown', dragStart);\n\t\n\t    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\n\t\n\t    function dragStart(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      pmouseX = e.clientX;\n\t\n\t      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\n\t      dom.bind(window, 'mousemove', drag);\n\t      dom.bind(window, 'mouseup', dragStop);\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function drag(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      gui.width += pmouseX - e.clientX;\n\t      gui.onResize();\n\t      pmouseX = e.clientX;\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function dragStop() {\n\t\n\t      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\n\t      dom.unbind(window, 'mousemove', drag);\n\t      dom.unbind(window, 'mouseup', dragStop);\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function setWidth(gui, w) {\n\t    gui.domElement.style.width = w + 'px';\n\t    // Auto placed save-rows are position fixed, so we have to\n\t    // set the width manually if we want it to bleed to the edge\n\t    if (gui.__save_row && gui.autoPlace) {\n\t      gui.__save_row.style.width = w + 'px';\n\t    }if (gui.__closeButton) {\n\t      gui.__closeButton.style.width = w + 'px';\n\t    }\n\t  }\n\t\n\t  function getCurrentPreset(gui, useInitialValues) {\n\t\n\t    var toReturn = {};\n\t\n\t    // For each object I'm remembering\n\t    common.each(gui.__rememberedObjects, function(val, index) {\n\t\n\t      var saved_values = {};\n\t\n\t      // The controllers I've made for thcommon.isObject by property\n\t      var controller_map =\n\t          gui.__rememberedObjectIndecesToControllers[index];\n\t\n\t      // Remember each value for each property\n\t      common.each(controller_map, function(controller, property) {\n\t        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();\n\t      });\n\t\n\t      // Save the values for thcommon.isObject\n\t      toReturn[index] = saved_values;\n\t\n\t    });\n\t\n\t    return toReturn;\n\t\n\t  }\n\t\n\t  function addPresetOption(gui, name, setSelected) {\n\t    var opt = document.createElement('option');\n\t    opt.innerHTML = name;\n\t    opt.value = name;\n\t    gui.__preset_select.appendChild(opt);\n\t    if (setSelected) {\n\t      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\n\t    }\n\t  }\n\t\n\t  function setPresetSelectIndex(gui) {\n\t    for (var index = 0; index < gui.__preset_select.length; index++) {\n\t      if (gui.__preset_select[index].value == gui.preset) {\n\t        gui.__preset_select.selectedIndex = index;\n\t      }\n\t    }\n\t  }\n\t\n\t  function markPresetModified(gui, modified) {\n\t    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\n\t//    console.log('mark', modified, opt);\n\t    if (modified) {\n\t      opt.innerHTML = opt.value + \"*\";\n\t    } else {\n\t      opt.innerHTML = opt.value;\n\t    }\n\t  }\n\t\n\t  function updateDisplays(controllerArray) {\n\t\n\t\n\t    if (controllerArray.length != 0) {\n\t\n\t      requestAnimationFrame(function() {\n\t        updateDisplays(controllerArray);\n\t      });\n\t\n\t    }\n\t\n\t    common.each(controllerArray, function(c) {\n\t      c.updateDisplay();\n\t    });\n\t\n\t  }\n\t\n\t  return GUI;\n\t\n\t})(dat.utils.css,\n\t\"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n      \\n    </div>\\n    \\n  </div>\\n\\n</div>\",\n\t\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\",\n\tdat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {\n\t\n\t      return function(object, property) {\n\t\n\t        var initialValue = object[property];\n\t\n\t        // Providing options?\n\t        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {\n\t          return new OptionController(object, property, arguments[2]);\n\t        }\n\t\n\t        // Providing a map?\n\t\n\t        if (common.isNumber(initialValue)) {\n\t\n\t          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {\n\t\n\t            // Has min and max.\n\t            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\n\t\n\t          } else {\n\t\n\t            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\n\t\n\t          }\n\t\n\t        }\n\t\n\t        if (common.isString(initialValue)) {\n\t          return new StringController(object, property);\n\t        }\n\t\n\t        if (common.isFunction(initialValue)) {\n\t          return new FunctionController(object, property, '');\n\t        }\n\t\n\t        if (common.isBoolean(initialValue)) {\n\t          return new BooleanController(object, property);\n\t        }\n\t\n\t      }\n\t\n\t    })(dat.controllers.OptionController,\n\tdat.controllers.NumberControllerBox,\n\tdat.controllers.NumberControllerSlider,\n\tdat.controllers.StringController = (function (Controller, dom, common) {\n\t\n\t  /**\n\t   * @class Provides a text input to alter the string property of an object.\n\t   *\n\t   * @extends dat.controllers.Controller\n\t   *\n\t   * @param {Object} object The object to be manipulated\n\t   * @param {string} property The name of the property to be manipulated\n\t   *\n\t   * @member dat.controllers\n\t   */\n\t  var StringController = function(object, property) {\n\t\n\t    StringController.superclass.call(this, object, property);\n\t\n\t    var _this = this;\n\t\n\t    this.__input = document.createElement('input');\n\t    this.__input.setAttribute('type', 'text');\n\t\n\t    dom.bind(this.__input, 'keyup', onChange);\n\t    dom.bind(this.__input, 'change', onChange);\n\t    dom.bind(this.__input, 'blur', onBlur);\n\t    dom.bind(this.__input, 'keydown', function(e) {\n\t      if (e.keyCode === 13) {\n\t        this.blur();\n\t      }\n\t    });\n\t    \n\t\n\t    function onChange() {\n\t      _this.setValue(_this.__input.value);\n\t    }\n\t\n\t    function onBlur() {\n\t      if (_this.__onFinishChange) {\n\t        _this.__onFinishChange.call(_this, _this.getValue());\n\t      }\n\t    }\n\t\n\t    this.updateDisplay();\n\t\n\t    this.domElement.appendChild(this.__input);\n\t\n\t  };\n\t\n\t  StringController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      StringController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t          // Stops the caret from moving on account of:\n\t          // keyup -> setValue -> updateDisplay\n\t          if (!dom.isActive(this.__input)) {\n\t            this.__input.value = this.getValue();\n\t          }\n\t          return StringController.superclass.prototype.updateDisplay.call(this);\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t\n\t  return StringController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.utils.common),\n\tdat.controllers.FunctionController,\n\tdat.controllers.BooleanController,\n\tdat.utils.common),\n\tdat.controllers.Controller,\n\tdat.controllers.BooleanController,\n\tdat.controllers.FunctionController,\n\tdat.controllers.NumberControllerBox,\n\tdat.controllers.NumberControllerSlider,\n\tdat.controllers.OptionController,\n\tdat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {\n\t\n\t  var ColorController = function(object, property) {\n\t\n\t    ColorController.superclass.call(this, object, property);\n\t\n\t    this.__color = new Color(this.getValue());\n\t    this.__temp = new Color(0);\n\t\n\t    var _this = this;\n\t\n\t    this.domElement = document.createElement('div');\n\t\n\t    dom.makeSelectable(this.domElement, false);\n\t\n\t    this.__selector = document.createElement('div');\n\t    this.__selector.className = 'selector';\n\t\n\t    this.__saturation_field = document.createElement('div');\n\t    this.__saturation_field.className = 'saturation-field';\n\t\n\t    this.__field_knob = document.createElement('div');\n\t    this.__field_knob.className = 'field-knob';\n\t    this.__field_knob_border = '2px solid ';\n\t\n\t    this.__hue_knob = document.createElement('div');\n\t    this.__hue_knob.className = 'hue-knob';\n\t\n\t    this.__hue_field = document.createElement('div');\n\t    this.__hue_field.className = 'hue-field';\n\t\n\t    this.__input = document.createElement('input');\n\t    this.__input.type = 'text';\n\t    this.__input_textShadow = '0 1px 1px ';\n\t\n\t    dom.bind(this.__input, 'keydown', function(e) {\n\t      if (e.keyCode === 13) { // on enter\n\t        onBlur.call(this);\n\t      }\n\t    });\n\t\n\t    dom.bind(this.__input, 'blur', onBlur);\n\t\n\t    dom.bind(this.__selector, 'mousedown', function(e) {\n\t\n\t      dom\n\t        .addClass(this, 'drag')\n\t        .bind(window, 'mouseup', function(e) {\n\t          dom.removeClass(_this.__selector, 'drag');\n\t        });\n\t\n\t    });\n\t\n\t    var value_field = document.createElement('div');\n\t\n\t    common.extend(this.__selector.style, {\n\t      width: '122px',\n\t      height: '102px',\n\t      padding: '3px',\n\t      backgroundColor: '#222',\n\t      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\n\t    });\n\t\n\t    common.extend(this.__field_knob.style, {\n\t      position: 'absolute',\n\t      width: '12px',\n\t      height: '12px',\n\t      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),\n\t      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\n\t      borderRadius: '12px',\n\t      zIndex: 1\n\t    });\n\t    \n\t    common.extend(this.__hue_knob.style, {\n\t      position: 'absolute',\n\t      width: '15px',\n\t      height: '2px',\n\t      borderRight: '4px solid #fff',\n\t      zIndex: 1\n\t    });\n\t\n\t    common.extend(this.__saturation_field.style, {\n\t      width: '100px',\n\t      height: '100px',\n\t      border: '1px solid #555',\n\t      marginRight: '3px',\n\t      display: 'inline-block',\n\t      cursor: 'pointer'\n\t    });\n\t\n\t    common.extend(value_field.style, {\n\t      width: '100%',\n\t      height: '100%',\n\t      background: 'none'\n\t    });\n\t    \n\t    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');\n\t\n\t    common.extend(this.__hue_field.style, {\n\t      width: '15px',\n\t      height: '100px',\n\t      display: 'inline-block',\n\t      border: '1px solid #555',\n\t      cursor: 'ns-resize'\n\t    });\n\t\n\t    hueGradient(this.__hue_field);\n\t\n\t    common.extend(this.__input.style, {\n\t      outline: 'none',\n\t//      width: '120px',\n\t      textAlign: 'center',\n\t//      padding: '4px',\n\t//      marginBottom: '6px',\n\t      color: '#fff',\n\t      border: 0,\n\t      fontWeight: 'bold',\n\t      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'\n\t    });\n\t\n\t    dom.bind(this.__saturation_field, 'mousedown', fieldDown);\n\t    dom.bind(this.__field_knob, 'mousedown', fieldDown);\n\t\n\t    dom.bind(this.__hue_field, 'mousedown', function(e) {\n\t      setH(e);\n\t      dom.bind(window, 'mousemove', setH);\n\t      dom.bind(window, 'mouseup', unbindH);\n\t    });\n\t\n\t    function fieldDown(e) {\n\t      setSV(e);\n\t      // document.body.style.cursor = 'none';\n\t      dom.bind(window, 'mousemove', setSV);\n\t      dom.bind(window, 'mouseup', unbindSV);\n\t    }\n\t\n\t    function unbindSV() {\n\t      dom.unbind(window, 'mousemove', setSV);\n\t      dom.unbind(window, 'mouseup', unbindSV);\n\t      // document.body.style.cursor = 'default';\n\t    }\n\t\n\t    function onBlur() {\n\t      var i = interpret(this.value);\n\t      if (i !== false) {\n\t        _this.__color.__state = i;\n\t        _this.setValue(_this.__color.toOriginal());\n\t      } else {\n\t        this.value = _this.__color.toString();\n\t      }\n\t    }\n\t\n\t    function unbindH() {\n\t      dom.unbind(window, 'mousemove', setH);\n\t      dom.unbind(window, 'mouseup', unbindH);\n\t    }\n\t\n\t    this.__saturation_field.appendChild(value_field);\n\t    this.__selector.appendChild(this.__field_knob);\n\t    this.__selector.appendChild(this.__saturation_field);\n\t    this.__selector.appendChild(this.__hue_field);\n\t    this.__hue_field.appendChild(this.__hue_knob);\n\t\n\t    this.domElement.appendChild(this.__input);\n\t    this.domElement.appendChild(this.__selector);\n\t\n\t    this.updateDisplay();\n\t\n\t    function setSV(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      var w = dom.getWidth(_this.__saturation_field);\n\t      var o = dom.getOffset(_this.__saturation_field);\n\t      var s = (e.clientX - o.left + document.body.scrollLeft) / w;\n\t      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;\n\t\n\t      if (v > 1) v = 1;\n\t      else if (v < 0) v = 0;\n\t\n\t      if (s > 1) s = 1;\n\t      else if (s < 0) s = 0;\n\t\n\t      _this.__color.v = v;\n\t      _this.__color.s = s;\n\t\n\t      _this.setValue(_this.__color.toOriginal());\n\t\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t    function setH(e) {\n\t\n\t      e.preventDefault();\n\t\n\t      var s = dom.getHeight(_this.__hue_field);\n\t      var o = dom.getOffset(_this.__hue_field);\n\t      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;\n\t\n\t      if (h > 1) h = 1;\n\t      else if (h < 0) h = 0;\n\t\n\t      _this.__color.h = h * 360;\n\t\n\t      _this.setValue(_this.__color.toOriginal());\n\t\n\t      return false;\n\t\n\t    }\n\t\n\t  };\n\t\n\t  ColorController.superclass = Controller;\n\t\n\t  common.extend(\n\t\n\t      ColorController.prototype,\n\t      Controller.prototype,\n\t\n\t      {\n\t\n\t        updateDisplay: function() {\n\t\n\t          var i = interpret(this.getValue());\n\t\n\t          if (i !== false) {\n\t\n\t            var mismatch = false;\n\t\n\t            // Check for mismatch on the interpreted value.\n\t\n\t            common.each(Color.COMPONENTS, function(component) {\n\t              if (!common.isUndefined(i[component]) &&\n\t                  !common.isUndefined(this.__color.__state[component]) &&\n\t                  i[component] !== this.__color.__state[component]) {\n\t                mismatch = true;\n\t                return {}; // break\n\t              }\n\t            }, this);\n\t\n\t            // If nothing diverges, we keep our previous values\n\t            // for statefulness, otherwise we recalculate fresh\n\t            if (mismatch) {\n\t              common.extend(this.__color.__state, i);\n\t            }\n\t\n\t          }\n\t\n\t          common.extend(this.__temp.__state, this.__color.__state);\n\t\n\t          this.__temp.a = 1;\n\t\n\t          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;\n\t          var _flip = 255 - flip;\n\t\n\t          common.extend(this.__field_knob.style, {\n\t            marginLeft: 100 * this.__color.s - 7 + 'px',\n\t            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\n\t            backgroundColor: this.__temp.toString(),\n\t            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'\n\t          });\n\t\n\t          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'\n\t\n\t          this.__temp.s = 1;\n\t          this.__temp.v = 1;\n\t\n\t          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());\n\t\n\t          common.extend(this.__input.style, {\n\t            backgroundColor: this.__input.value = this.__color.toString(),\n\t            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',\n\t            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'\n\t          });\n\t\n\t        }\n\t\n\t      }\n\t\n\t  );\n\t  \n\t  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];\n\t  \n\t  function linearGradient(elem, x, a, b) {\n\t    elem.style.background = '';\n\t    common.each(vendors, function(vendor) {\n\t      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';\n\t    });\n\t  }\n\t  \n\t  function hueGradient(elem) {\n\t    elem.style.background = '';\n\t    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'\n\t    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n\t  }\n\t\n\t\n\t  return ColorController;\n\t\n\t})(dat.controllers.Controller,\n\tdat.dom.dom,\n\tdat.color.Color = (function (interpret, math, toString, common) {\n\t\n\t  var Color = function() {\n\t\n\t    this.__state = interpret.apply(this, arguments);\n\t\n\t    if (this.__state === false) {\n\t      throw 'Failed to interpret color arguments';\n\t    }\n\t\n\t    this.__state.a = this.__state.a || 1;\n\t\n\t\n\t  };\n\t\n\t  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\t\n\t  common.extend(Color.prototype, {\n\t\n\t    toString: function() {\n\t      return toString(this);\n\t    },\n\t\n\t    toOriginal: function() {\n\t      return this.__state.conversion.write(this);\n\t    }\n\t\n\t  });\n\t\n\t  defineRGBComponent(Color.prototype, 'r', 2);\n\t  defineRGBComponent(Color.prototype, 'g', 1);\n\t  defineRGBComponent(Color.prototype, 'b', 0);\n\t\n\t  defineHSVComponent(Color.prototype, 'h');\n\t  defineHSVComponent(Color.prototype, 's');\n\t  defineHSVComponent(Color.prototype, 'v');\n\t\n\t  Object.defineProperty(Color.prototype, 'a', {\n\t\n\t    get: function() {\n\t      return this.__state.a;\n\t    },\n\t\n\t    set: function(v) {\n\t      this.__state.a = v;\n\t    }\n\t\n\t  });\n\t\n\t  Object.defineProperty(Color.prototype, 'hex', {\n\t\n\t    get: function() {\n\t\n\t      if (!this.__state.space !== 'HEX') {\n\t        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n\t      }\n\t\n\t      return this.__state.hex;\n\t\n\t    },\n\t\n\t    set: function(v) {\n\t\n\t      this.__state.space = 'HEX';\n\t      this.__state.hex = v;\n\t\n\t    }\n\t\n\t  });\n\t\n\t  function defineRGBComponent(target, component, componentHexIndex) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'RGB') {\n\t          return this.__state[component];\n\t        }\n\t\n\t        recalculateRGB(this, component, componentHexIndex);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'RGB') {\n\t          recalculateRGB(this, component, componentHexIndex);\n\t          this.__state.space = 'RGB';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function defineHSVComponent(target, component) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'HSV')\n\t          return this.__state[component];\n\t\n\t        recalculateHSV(this);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'HSV') {\n\t          recalculateHSV(this);\n\t          this.__state.space = 'HSV';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function recalculateRGB(color, component, componentHexIndex) {\n\t\n\t    if (color.__state.space === 'HEX') {\n\t\n\t      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\t\n\t    } else if (color.__state.space === 'HSV') {\n\t\n\t      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\t\n\t    } else {\n\t\n\t      throw 'Corrupted color state';\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function recalculateHSV(color) {\n\t\n\t    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\t\n\t    common.extend(color.__state,\n\t        {\n\t          s: result.s,\n\t          v: result.v\n\t        }\n\t    );\n\t\n\t    if (!common.isNaN(result.h)) {\n\t      color.__state.h = result.h;\n\t    } else if (common.isUndefined(color.__state.h)) {\n\t      color.__state.h = 0;\n\t    }\n\t\n\t  }\n\t\n\t  return Color;\n\t\n\t})(dat.color.interpret,\n\tdat.color.math = (function () {\n\t\n\t  var tmpComponent;\n\t\n\t  return {\n\t\n\t    hsv_to_rgb: function(h, s, v) {\n\t\n\t      var hi = Math.floor(h / 60) % 6;\n\t\n\t      var f = h / 60 - Math.floor(h / 60);\n\t      var p = v * (1.0 - s);\n\t      var q = v * (1.0 - (f * s));\n\t      var t = v * (1.0 - ((1.0 - f) * s));\n\t      var c = [\n\t        [v, t, p],\n\t        [q, v, p],\n\t        [p, v, t],\n\t        [p, q, v],\n\t        [t, p, v],\n\t        [v, p, q]\n\t      ][hi];\n\t\n\t      return {\n\t        r: c[0] * 255,\n\t        g: c[1] * 255,\n\t        b: c[2] * 255\n\t      };\n\t\n\t    },\n\t\n\t    rgb_to_hsv: function(r, g, b) {\n\t\n\t      var min = Math.min(r, g, b),\n\t          max = Math.max(r, g, b),\n\t          delta = max - min,\n\t          h, s;\n\t\n\t      if (max != 0) {\n\t        s = delta / max;\n\t      } else {\n\t        return {\n\t          h: NaN,\n\t          s: 0,\n\t          v: 0\n\t        };\n\t      }\n\t\n\t      if (r == max) {\n\t        h = (g - b) / delta;\n\t      } else if (g == max) {\n\t        h = 2 + (b - r) / delta;\n\t      } else {\n\t        h = 4 + (r - g) / delta;\n\t      }\n\t      h /= 6;\n\t      if (h < 0) {\n\t        h += 1;\n\t      }\n\t\n\t      return {\n\t        h: h * 360,\n\t        s: s,\n\t        v: max / 255\n\t      };\n\t    },\n\t\n\t    rgb_to_hex: function(r, g, b) {\n\t      var hex = this.hex_with_component(0, 2, r);\n\t      hex = this.hex_with_component(hex, 1, g);\n\t      hex = this.hex_with_component(hex, 0, b);\n\t      return hex;\n\t    },\n\t\n\t    component_from_hex: function(hex, componentIndex) {\n\t      return (hex >> (componentIndex * 8)) & 0xFF;\n\t    },\n\t\n\t    hex_with_component: function(hex, componentIndex, value) {\n\t      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n\t    }\n\t\n\t  }\n\t\n\t})(),\n\tdat.color.toString,\n\tdat.utils.common),\n\tdat.color.interpret,\n\tdat.utils.common),\n\tdat.utils.requestAnimationFrame = (function () {\n\t\n\t  /**\n\t   * requirejs version of Paul Irish's RequestAnimationFrame\n\t   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t   */\n\t\n\t  return window.webkitRequestAnimationFrame ||\n\t      window.mozRequestAnimationFrame ||\n\t      window.oRequestAnimationFrame ||\n\t      window.msRequestAnimationFrame ||\n\t      function(callback, element) {\n\t\n\t        window.setTimeout(callback, 1000 / 60);\n\t\n\t      };\n\t})(),\n\tdat.dom.CenteredDiv = (function (dom, common) {\n\t\n\t\n\t  var CenteredDiv = function() {\n\t\n\t    this.backgroundElement = document.createElement('div');\n\t    common.extend(this.backgroundElement.style, {\n\t      backgroundColor: 'rgba(0,0,0,0.8)',\n\t      top: 0,\n\t      left: 0,\n\t      display: 'none',\n\t      zIndex: '1000',\n\t      opacity: 0,\n\t      WebkitTransition: 'opacity 0.2s linear'\n\t    });\n\t\n\t    dom.makeFullscreen(this.backgroundElement);\n\t    this.backgroundElement.style.position = 'fixed';\n\t\n\t    this.domElement = document.createElement('div');\n\t    common.extend(this.domElement.style, {\n\t      position: 'fixed',\n\t      display: 'none',\n\t      zIndex: '1001',\n\t      opacity: 0,\n\t      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'\n\t    });\n\t\n\t\n\t    document.body.appendChild(this.backgroundElement);\n\t    document.body.appendChild(this.domElement);\n\t\n\t    var _this = this;\n\t    dom.bind(this.backgroundElement, 'click', function() {\n\t      _this.hide();\n\t    });\n\t\n\t\n\t  };\n\t\n\t  CenteredDiv.prototype.show = function() {\n\t\n\t    var _this = this;\n\t    \n\t\n\t\n\t    this.backgroundElement.style.display = 'block';\n\t\n\t    this.domElement.style.display = 'block';\n\t    this.domElement.style.opacity = 0;\n\t//    this.domElement.style.top = '52%';\n\t    this.domElement.style.webkitTransform = 'scale(1.1)';\n\t\n\t    this.layout();\n\t\n\t    common.defer(function() {\n\t      _this.backgroundElement.style.opacity = 1;\n\t      _this.domElement.style.opacity = 1;\n\t      _this.domElement.style.webkitTransform = 'scale(1)';\n\t    });\n\t\n\t  };\n\t\n\t  CenteredDiv.prototype.hide = function() {\n\t\n\t    var _this = this;\n\t\n\t    var hide = function() {\n\t\n\t      _this.domElement.style.display = 'none';\n\t      _this.backgroundElement.style.display = 'none';\n\t\n\t      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\n\t      dom.unbind(_this.domElement, 'transitionend', hide);\n\t      dom.unbind(_this.domElement, 'oTransitionEnd', hide);\n\t\n\t    };\n\t\n\t    dom.bind(this.domElement, 'webkitTransitionEnd', hide);\n\t    dom.bind(this.domElement, 'transitionend', hide);\n\t    dom.bind(this.domElement, 'oTransitionEnd', hide);\n\t\n\t    this.backgroundElement.style.opacity = 0;\n\t//    this.domElement.style.top = '48%';\n\t    this.domElement.style.opacity = 0;\n\t    this.domElement.style.webkitTransform = 'scale(1.1)';\n\t\n\t  };\n\t\n\t  CenteredDiv.prototype.layout = function() {\n\t    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';\n\t    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';\n\t  };\n\t  \n\t  function lockScroll(e) {\n\t    console.log(e);\n\t  }\n\t\n\t  return CenteredDiv;\n\t\n\t})(dat.dom.dom,\n\tdat.utils.common),\n\tdat.dom.dom,\n\tdat.utils.common);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * dat-gui JavaScript Controller Library\n\t * http://code.google.com/p/dat-gui\n\t *\n\t * Copyright 2011 Data Arts Team, Google Creative Lab\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t */\n\t\n\t/** @namespace */\n\tvar dat = module.exports = dat || {};\n\t\n\t/** @namespace */\n\tdat.color = dat.color || {};\n\t\n\t/** @namespace */\n\tdat.utils = dat.utils || {};\n\t\n\tdat.utils.common = (function () {\n\t  \n\t  var ARR_EACH = Array.prototype.forEach;\n\t  var ARR_SLICE = Array.prototype.slice;\n\t\n\t  /**\n\t   * Band-aid methods for things that should be a lot easier in JavaScript.\n\t   * Implementation and structure inspired by underscore.js\n\t   * http://documentcloud.github.com/underscore/\n\t   */\n\t\n\t  return { \n\t    \n\t    BREAK: {},\n\t  \n\t    extend: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (!this.isUndefined(obj[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t      \n\t    },\n\t    \n\t    defaults: function(target) {\n\t      \n\t      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n\t        \n\t        for (var key in obj)\n\t          if (this.isUndefined(target[key])) \n\t            target[key] = obj[key];\n\t        \n\t      }, this);\n\t      \n\t      return target;\n\t    \n\t    },\n\t    \n\t    compose: function() {\n\t      var toCall = ARR_SLICE.call(arguments);\n\t            return function() {\n\t              var args = ARR_SLICE.call(arguments);\n\t              for (var i = toCall.length -1; i >= 0; i--) {\n\t                args = [toCall[i].apply(this, args)];\n\t              }\n\t              return args[0];\n\t            }\n\t    },\n\t    \n\t    each: function(obj, itr, scope) {\n\t\n\t      \n\t      if (ARR_EACH && obj.forEach === ARR_EACH) { \n\t        \n\t        obj.forEach(itr, scope);\n\t        \n\t      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n\t        \n\t        for (var key = 0, l = obj.length; key < l; key++)\n\t          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n\t            return;\n\t            \n\t      } else {\n\t\n\t        for (var key in obj) \n\t          if (itr.call(scope, obj[key], key) === this.BREAK)\n\t            return;\n\t            \n\t      }\n\t            \n\t    },\n\t    \n\t    defer: function(fnc) {\n\t      setTimeout(fnc, 0);\n\t    },\n\t    \n\t    toArray: function(obj) {\n\t      if (obj.toArray) return obj.toArray();\n\t      return ARR_SLICE.call(obj);\n\t    },\n\t\n\t    isUndefined: function(obj) {\n\t      return obj === undefined;\n\t    },\n\t    \n\t    isNull: function(obj) {\n\t      return obj === null;\n\t    },\n\t    \n\t    isNaN: function(obj) {\n\t      return obj !== obj;\n\t    },\n\t    \n\t    isArray: Array.isArray || function(obj) {\n\t      return obj.constructor === Array;\n\t    },\n\t    \n\t    isObject: function(obj) {\n\t      return obj === Object(obj);\n\t    },\n\t    \n\t    isNumber: function(obj) {\n\t      return obj === obj+0;\n\t    },\n\t    \n\t    isString: function(obj) {\n\t      return obj === obj+'';\n\t    },\n\t    \n\t    isBoolean: function(obj) {\n\t      return obj === false || obj === true;\n\t    },\n\t    \n\t    isFunction: function(obj) {\n\t      return Object.prototype.toString.call(obj) === '[object Function]';\n\t    }\n\t  \n\t  };\n\t    \n\t})();\n\t\n\t\n\tdat.color.toString = (function (common) {\n\t\n\t  return function(color) {\n\t\n\t    if (color.a == 1 || common.isUndefined(color.a)) {\n\t\n\t      var s = color.hex.toString(16);\n\t      while (s.length < 6) {\n\t        s = '0' + s;\n\t      }\n\t\n\t      return '#' + s;\n\t\n\t    } else {\n\t\n\t      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\t\n\t    }\n\t\n\t  }\n\t\n\t})(dat.utils.common);\n\t\n\t\n\tdat.Color = dat.color.Color = (function (interpret, math, toString, common) {\n\t\n\t  var Color = function() {\n\t\n\t    this.__state = interpret.apply(this, arguments);\n\t\n\t    if (this.__state === false) {\n\t      throw 'Failed to interpret color arguments';\n\t    }\n\t\n\t    this.__state.a = this.__state.a || 1;\n\t\n\t\n\t  };\n\t\n\t  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\t\n\t  common.extend(Color.prototype, {\n\t\n\t    toString: function() {\n\t      return toString(this);\n\t    },\n\t\n\t    toOriginal: function() {\n\t      return this.__state.conversion.write(this);\n\t    }\n\t\n\t  });\n\t\n\t  defineRGBComponent(Color.prototype, 'r', 2);\n\t  defineRGBComponent(Color.prototype, 'g', 1);\n\t  defineRGBComponent(Color.prototype, 'b', 0);\n\t\n\t  defineHSVComponent(Color.prototype, 'h');\n\t  defineHSVComponent(Color.prototype, 's');\n\t  defineHSVComponent(Color.prototype, 'v');\n\t\n\t  Object.defineProperty(Color.prototype, 'a', {\n\t\n\t    get: function() {\n\t      return this.__state.a;\n\t    },\n\t\n\t    set: function(v) {\n\t      this.__state.a = v;\n\t    }\n\t\n\t  });\n\t\n\t  Object.defineProperty(Color.prototype, 'hex', {\n\t\n\t    get: function() {\n\t\n\t      if (!this.__state.space !== 'HEX') {\n\t        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n\t      }\n\t\n\t      return this.__state.hex;\n\t\n\t    },\n\t\n\t    set: function(v) {\n\t\n\t      this.__state.space = 'HEX';\n\t      this.__state.hex = v;\n\t\n\t    }\n\t\n\t  });\n\t\n\t  function defineRGBComponent(target, component, componentHexIndex) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'RGB') {\n\t          return this.__state[component];\n\t        }\n\t\n\t        recalculateRGB(this, component, componentHexIndex);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'RGB') {\n\t          recalculateRGB(this, component, componentHexIndex);\n\t          this.__state.space = 'RGB';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function defineHSVComponent(target, component) {\n\t\n\t    Object.defineProperty(target, component, {\n\t\n\t      get: function() {\n\t\n\t        if (this.__state.space === 'HSV')\n\t          return this.__state[component];\n\t\n\t        recalculateHSV(this);\n\t\n\t        return this.__state[component];\n\t\n\t      },\n\t\n\t      set: function(v) {\n\t\n\t        if (this.__state.space !== 'HSV') {\n\t          recalculateHSV(this);\n\t          this.__state.space = 'HSV';\n\t        }\n\t\n\t        this.__state[component] = v;\n\t\n\t      }\n\t\n\t    });\n\t\n\t  }\n\t\n\t  function recalculateRGB(color, component, componentHexIndex) {\n\t\n\t    if (color.__state.space === 'HEX') {\n\t\n\t      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\t\n\t    } else if (color.__state.space === 'HSV') {\n\t\n\t      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\t\n\t    } else {\n\t\n\t      throw 'Corrupted color state';\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function recalculateHSV(color) {\n\t\n\t    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\t\n\t    common.extend(color.__state,\n\t        {\n\t          s: result.s,\n\t          v: result.v\n\t        }\n\t    );\n\t\n\t    if (!common.isNaN(result.h)) {\n\t      color.__state.h = result.h;\n\t    } else if (common.isUndefined(color.__state.h)) {\n\t      color.__state.h = 0;\n\t    }\n\t\n\t  }\n\t\n\t  return Color;\n\t\n\t})(dat.color.interpret = (function (toString, common) {\n\t\n\t  var result, toReturn;\n\t\n\t  var interpret = function() {\n\t\n\t    toReturn = false;\n\t\n\t    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\t\n\t    common.each(INTERPRETATIONS, function(family) {\n\t\n\t      if (family.litmus(original)) {\n\t\n\t        common.each(family.conversions, function(conversion, conversionName) {\n\t\n\t          result = conversion.read(original);\n\t\n\t          if (toReturn === false && result !== false) {\n\t            toReturn = result;\n\t            result.conversionName = conversionName;\n\t            result.conversion = conversion;\n\t            return common.BREAK;\n\t\n\t          }\n\t\n\t        });\n\t\n\t        return common.BREAK;\n\t\n\t      }\n\t\n\t    });\n\t\n\t    return toReturn;\n\t\n\t  };\n\t\n\t  var INTERPRETATIONS = [\n\t\n\t    // Strings\n\t    {\n\t\n\t      litmus: common.isString,\n\t\n\t      conversions: {\n\t\n\t        THREE_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt(\n\t                  '0x' +\n\t                      test[1].toString() + test[1].toString() +\n\t                      test[2].toString() + test[2].toString() +\n\t                      test[3].toString() + test[3].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        SIX_CHAR_HEX: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^#([A-F0-9]{6})$/i);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'HEX',\n\t              hex: parseInt('0x' + test[1].toString())\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGB: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        },\n\t\n\t        CSS_RGBA: {\n\t\n\t          read: function(original) {\n\t\n\t            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n\t            if (test === null) return false;\n\t\n\t            return {\n\t              space: 'RGB',\n\t              r: parseFloat(test[1]),\n\t              g: parseFloat(test[2]),\n\t              b: parseFloat(test[3]),\n\t              a: parseFloat(test[4])\n\t            };\n\t\n\t          },\n\t\n\t          write: toString\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Numbers\n\t    {\n\t\n\t      litmus: common.isNumber,\n\t\n\t      conversions: {\n\t\n\t        HEX: {\n\t          read: function(original) {\n\t            return {\n\t              space: 'HEX',\n\t              hex: original,\n\t              conversionName: 'HEX'\n\t            }\n\t          },\n\t\n\t          write: function(color) {\n\t            return color.hex;\n\t          }\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Arrays\n\t    {\n\t\n\t      litmus: common.isArray,\n\t\n\t      conversions: {\n\t\n\t        RGB_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 3) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b];\n\t          }\n\t\n\t        },\n\t\n\t        RGBA_ARRAY: {\n\t          read: function(original) {\n\t            if (original.length != 4) return false;\n\t            return {\n\t              space: 'RGB',\n\t              r: original[0],\n\t              g: original[1],\n\t              b: original[2],\n\t              a: original[3]\n\t            };\n\t          },\n\t\n\t          write: function(color) {\n\t            return [color.r, color.g, color.b, color.a];\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t\n\t    // Objects\n\t    {\n\t\n\t      litmus: common.isObject,\n\t\n\t      conversions: {\n\t\n\t        RGBA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        RGB_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.r) &&\n\t                common.isNumber(original.g) &&\n\t                common.isNumber(original.b)) {\n\t              return {\n\t                space: 'RGB',\n\t                r: original.r,\n\t                g: original.g,\n\t                b: original.b\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              r: color.r,\n\t              g: color.g,\n\t              b: color.b\n\t            }\n\t          }\n\t        },\n\t\n\t        HSVA_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v) &&\n\t                common.isNumber(original.a)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v,\n\t                a: original.a\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v,\n\t              a: color.a\n\t            }\n\t          }\n\t        },\n\t\n\t        HSV_OBJ: {\n\t          read: function(original) {\n\t            if (common.isNumber(original.h) &&\n\t                common.isNumber(original.s) &&\n\t                common.isNumber(original.v)) {\n\t              return {\n\t                space: 'HSV',\n\t                h: original.h,\n\t                s: original.s,\n\t                v: original.v\n\t              }\n\t            }\n\t            return false;\n\t          },\n\t\n\t          write: function(color) {\n\t            return {\n\t              h: color.h,\n\t              s: color.s,\n\t              v: color.v\n\t            }\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t    }\n\t\n\t\n\t  ];\n\t\n\t  return interpret;\n\t\n\t\n\t})(dat.color.toString,\n\tdat.utils.common),\n\tdat.color.math = (function () {\n\t\n\t  var tmpComponent;\n\t\n\t  return {\n\t\n\t    hsv_to_rgb: function(h, s, v) {\n\t\n\t      var hi = Math.floor(h / 60) % 6;\n\t\n\t      var f = h / 60 - Math.floor(h / 60);\n\t      var p = v * (1.0 - s);\n\t      var q = v * (1.0 - (f * s));\n\t      var t = v * (1.0 - ((1.0 - f) * s));\n\t      var c = [\n\t        [v, t, p],\n\t        [q, v, p],\n\t        [p, v, t],\n\t        [p, q, v],\n\t        [t, p, v],\n\t        [v, p, q]\n\t      ][hi];\n\t\n\t      return {\n\t        r: c[0] * 255,\n\t        g: c[1] * 255,\n\t        b: c[2] * 255\n\t      };\n\t\n\t    },\n\t\n\t    rgb_to_hsv: function(r, g, b) {\n\t\n\t      var min = Math.min(r, g, b),\n\t          max = Math.max(r, g, b),\n\t          delta = max - min,\n\t          h, s;\n\t\n\t      if (max != 0) {\n\t        s = delta / max;\n\t      } else {\n\t        return {\n\t          h: NaN,\n\t          s: 0,\n\t          v: 0\n\t        };\n\t      }\n\t\n\t      if (r == max) {\n\t        h = (g - b) / delta;\n\t      } else if (g == max) {\n\t        h = 2 + (b - r) / delta;\n\t      } else {\n\t        h = 4 + (r - g) / delta;\n\t      }\n\t      h /= 6;\n\t      if (h < 0) {\n\t        h += 1;\n\t      }\n\t\n\t      return {\n\t        h: h * 360,\n\t        s: s,\n\t        v: max / 255\n\t      };\n\t    },\n\t\n\t    rgb_to_hex: function(r, g, b) {\n\t      var hex = this.hex_with_component(0, 2, r);\n\t      hex = this.hex_with_component(hex, 1, g);\n\t      hex = this.hex_with_component(hex, 0, b);\n\t      return hex;\n\t    },\n\t\n\t    component_from_hex: function(hex, componentIndex) {\n\t      return (hex >> (componentIndex * 8)) & 0xFF;\n\t    },\n\t\n\t    hex_with_component: function(hex, componentIndex, value) {\n\t      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n\t    }\n\t\n\t  }\n\t\n\t})(),\n\tdat.color.toString,\n\tdat.utils.common);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.THREE = __webpack_require__(3);\n\t\n\t(function () {\n\t  /**\n\t   * Cube\n\t   */\n\t  var Cube = window.Cube || {};\n\t\n\t  window.Cube = function () {\n\t    //Cube\n\t    p.init();\n\t  };\n\t\n\t  var p, s;\n\t\n\t  s = window.Cube;\n\t  p = s.prototype;\n\t\n\t  /**\n\t   * Cube\n\t   **/\n\t  p.init = function () {\n\t    var self = this;\n\t\n\t    //cubeGeometry\n\t    self.cubeGeometry = new THREE.BoxGeometry(4, 4, 4);\n\t\n\t    //cubeMaterial\n\t    self.cubeMaterial = new THREE.MeshLambertMaterial({\n\t      color: 0xff0000, wireframe: false\n\t    });\n\t\n\t    //cube\n\t    self.CubeObject = new THREE.Mesh(self.cubeGeometry, self.cubeMaterial);\n\t    self.CubeObject.castShadow = true;\n\t    //CubeObject\n\t    self.CubeObject.position.x = -4;\n\t    self.CubeObject.position.y = 3;\n\t    self.CubeObject.position.z = 0;\n\t\n\t    //CubeObject\n\t    return self.CubeObject;\n\t  };\n\t})();\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.THREE = __webpack_require__(3);\n\t\n\t(function () {\n\t  /**\n\t   * Plane\n\t   */\n\t  var Plane = window.Plane || {};\n\t\n\t  window.Plane = function () {\n\t    //Plane\n\t    p.init();\n\t  };\n\t\n\t  var p, s;\n\t\n\t  s = window.Plane;\n\t  p = s.prototype;\n\t\n\t  /**\n\t   * Plane\n\t   **/\n\t  p.init = function () {\n\t    var self = this;\n\t\n\t    //planeGeometry\n\t    self.planeGeometry = new THREE.PlaneGeometry(60, 20);\n\t\n\t    //planeMaterial\n\t    self.planeMaterial = new THREE.MeshLambertMaterial({\n\t      color: 0xffffff\n\t    });\n\t\n\t    //plane\n\t    self.PlaneObject = new THREE.Mesh(self.planeGeometry, self.planeMaterial);\n\t    self.PlaneObject.receiveShadow = true;\n\t    //plane\n\t    self.PlaneObject.rotation.x = -0.5 * Math.PI;\n\t    self.PlaneObject.position.x = 15;\n\t    self.PlaneObject.position.y = 0;\n\t    self.PlaneObject.position.z = 0;\n\t\n\t    //PlaneObject\n\t    return self.PlaneObject;\n\t  };\n\t})();\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ac0fe0884a29cb671be0","var cats = require('./main.js');\n\n// console.log(cats);\n\n\n// WEBPACK FOOTER //\n// ./src/js/app.js","window.THREE = require('three');\nvar Stats = require('./libs/stats.js');\nvar dat= require('dat-gui');\n\nrequire('./object/Cube.js');\nrequire('./object/Plane.js');\n\n(function() {\n\n  var sample = window.sample || {};\n  window.sample = sample;\n\n  //\n  $(function() {\n    new sample.MainDisplay();\n  });\n\n})();\n\n//Cube\nvar CubeObject = new Cube();\n\n//Plane\nvar PlaneObject = new Plane();\n\n\n(function(){\n  var sample = window.sample || {};\n  window.sample = sample;\n\n  /**\n   * \n   */\n  sample.MainDisplay = function () {\n    //\n    p.init();\n  };\n\n  var p, s;\n\n  s = sample.MainDisplay;\n  p = s.prototype;\n\n  var renderScene;\n\n  /**\n   * \n   */\n  p.init = function () {\n    var self = this;\n\n    this.$window = $(window);\n    this.$MainDisplay = $('#WebGL-output');\n\n    //WebGL renderer\n    this.renderer = new THREE.WebGLRenderer();\n    if (!this.renderer) {\n      alert('Three.js');\n    }\n    this.renderer.setClearColor(new THREE.Color(0xEEEEEE));\n    this.renderer.setSize( window.innerWidth, window.innerHeight );\n    this.renderer.shadowMap.enabled = true;\n\n    // \n    var pixelRatio = Math.min(window.devicePixelRatio || 1, 2);\n    this.renderer.setPixelRatio(pixelRatio);\n\n    //scene\n    this.scene = new THREE.Scene();\n\n    //camera\n    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n    this.camera.position.x = -30;\n    this.camera.position.y = 40;\n    this.camera.position.z = 30;\n    this.camera.lookAt(this.scene.position);\n\n    // window resize\n    this.$window.on('resize', function(e) {\n      self.onResize();\n    });\n\n    // resize\n    this.$window.trigger('resize');\n\n    //axes\n    // var axes = new THREE.AxisHelper(20);\n    // this.scene.add(axes);\n\n    //Plane\n    this.scene.add(PlaneObject.init());\n\n    //Cube\n    this.scene.add(CubeObject.init());\n\n    //sphereGeometry\n    // var sphereGeometry = new THREE.SphereGeometry(4, 20,20);\n    //\n    // //sphereMaterial\n    // var sphereMaterial = new THREE.MeshLambertMaterial({\n    //   color: 0x7777ff, wireframe: false\n    // });\n    //\n    // //sphere\n    // var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);\n    // sphere.castShadow = true;\n    // //sphere\n    // sphere.position.x = 20;\n    // sphere.position.y = 4;\n    // sphere.position.z = 2;\n    // this.scene.add(sphere);\n\n\n    var spotLight = new THREE.SpotLight(0xffffff);\n    spotLight.position.set(-20, 30, -5);\n    spotLight.castShadow = true;\n    this.scene.add(spotLight);\n\n    document.getElementById(\"WebGL-output\").appendChild(this.renderer.domElement);\n\n\n    var stats = initStats();\n    renderScene = function () {\n      stats.update();\n      // rotate the cube around its axes\n      // CubeObject.init().rotation.x += 0.02;\n      // CubeObject.init().rotation.y += 0.02;\n      // CubeObject.init().rotation.z += 0.02;\n\n      // bounce the sphere up and down\n      // step += 0.04;\n      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\n      // render using requestAnimationFrame\n      this.updateAnimation();\n    }.bind(this);\n\n    // call the render function\n    var step = 0;\n    renderScene();\n\n\n    /**\n     * dat.gui\n     * dat.gui\n     */\n    var controls = new function () {\n      this.rotationSpeed = 0.001;\n      this.bouncingSpeed = 0.001;\n    };\n\n    var gui = new dat.GUI();\n    gui.add(controls, 'rotationSpeed', 0, 0.1);\n    gui.add(controls, 'bouncingSpeed', 0, 0.1);\n\n    var render =  function() {\n      stats.update();\n      // rotate the cube around its axes\n      // cube.rotation.x += controls.rotationSpeed;\n      // cube.rotation.y += controls.rotationSpeed;\n      // cube.rotation.z += controls.rotationSpeed;\n\n      // bounce the sphere up and down\n      // step += controls.bouncingSpeed;\n      // sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n      // sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\n      requestAnimationFrame(render);\n      this.renderer.render(this.scene, this.camera);\n    }.bind(this);\n    render();\n\n  };\n\n  //Stats\n  function initStats() {\n\n    var stats = new Stats();\n\n    stats.setMode(0); // 0: fps, 1: ms\n\n    // Align top-left\n    stats.domElement.style.position = 'absolute';\n    stats.domElement.style.left = '0px';\n    stats.domElement.style.top = '0px';\n\n    document.getElementById(\"Stats-output\").appendChild(stats.domElement);\n\n    return stats;\n  }\n\n  /**\n   * \n   */\n  // p.start = function () {\n  //   var self = this;\n  //\n  //   var enterFrameHandler = function() {\n  //     requestAnimationFrame(enterFrameHandler);\n  //     self.update();\n  //   };\n  //\n  //   enterFrameHandler();\n  // };\n\n  /**\n   * \n   */\n  p.updateAnimation = function() {\n    requestAnimationFrame(renderScene);\n    this.renderer.render(this.scene, this.camera);\n  };\n\n\n  /**\n   * \n   * @param {jQuery.Event} e - jQuery\n   */\n  p.onResize = function () {\n\n    this.width = this.$window.width();\n    this.height = this.$window.height();\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n\n    this.renderer.setSize(this.width, this.height);\n  };\n\n\n\n  // p.createDatGUIBox = function () {\n\n  // };\n\n})();\n\n\n// WEBPACK FOOTER //\n// ./src/js/main.js","/*!\n * jQuery JavaScript Library v3.1.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-09-22T22:30Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.1.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\tresolve.call( undefined, value );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.call( undefined, value );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\tscale = scale || \".5\";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\nfunction manipulationTarget( elem, content ) {\n\tif ( jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn elem.getElementsByTagName( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\"position:relative;display:block;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"top:1%;width:50%\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.marginRight = \"50%\";\n\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\"padding:0;margin-top:1px;position:absolute\";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE <=9 only\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === \"width\" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar val,\n\t\tvalueIsBorderBox = true,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Support: IE <=11 only\n\t// Running getBoundingClientRect on a disconnected node\n\t// in IE throws an error.\n\tif ( elem.getClientRects().length ) {\n\t\tval = elem.getBoundingClientRect()[ name ];\n\t}\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction raf() {\n\tif ( timerId ) {\n\t\twindow.requestAnimationFrame( raf );\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off or if document is hidden\n\tif ( jQuery.fx.off || document.hidden ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = window.requestAnimationFrame ?\n\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tif ( window.cancelAnimationFrame ) {\n\t\twindow.cancelAnimationFrame( timerId );\n\t} else {\n\t\twindow.clearInterval( timerId );\n\t}\n\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === \"string\" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar docElem, win, rect, doc,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\t// Make sure element is not hidden (display: none)\n\t\tif ( rect.width || rect.height ) {\n\t\t\tdoc = elem.ownerDocument;\n\t\t\twin = getWindow( doc );\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\treturn {\n\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\treturn rect;\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\njQuery.parseJSON = JSON.parse;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t} );\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\n\nreturn jQuery;\n} );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jquery/dist/jquery.js\n// module id = 2\n// module chunks = 0","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.THREE = global.THREE || {})));\n}(this, (function (exports) { 'use strict';\n\n\t// Polyfills\n\n\tif ( Number.EPSILON === undefined ) {\n\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n\t}\n\n\t//\n\n\tif ( Math.sign === undefined ) {\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\t\tMath.sign = function ( x ) {\n\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t\t};\n\n\t}\n\n\tif ( Function.prototype.name === undefined ) {\n\n\t\t// Missing in IE9-11.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\t\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tif ( Object.assign === undefined ) {\n\n\t\t// Missing in IE.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t\t( function () {\n\n\t\t\tObject.assign = function ( target ) {\n\n\t\t\t\t'use strict';\n\n\t\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t\t}\n\n\t\t\t\tvar output = Object( target );\n\n\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\n\t\t\t};\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\n\tfunction EventDispatcher() {}\n\n\tObject.assign( EventDispatcher.prototype, {\n\n\t\taddEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\t\tlisteners[ type ] = [];\n\n\t\t\t}\n\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\t\tlisteners[ type ].push( listener );\n\n\t\t\t}\n\n\t\t},\n\n\t\thasEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return false;\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdispatchEvent: function ( event ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tevent.target = this;\n\n\t\t\t\tvar array = [], i = 0;\n\t\t\t\tvar length = listenerArray.length;\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tvar REVISION = '82';\n\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\tvar CullFaceNone = 0;\n\tvar CullFaceBack = 1;\n\tvar CullFaceFront = 2;\n\tvar CullFaceFrontBack = 3;\n\tvar FrontFaceDirectionCW = 0;\n\tvar FrontFaceDirectionCCW = 1;\n\tvar BasicShadowMap = 0;\n\tvar PCFShadowMap = 1;\n\tvar PCFSoftShadowMap = 2;\n\tvar FrontSide = 0;\n\tvar BackSide = 1;\n\tvar DoubleSide = 2;\n\tvar FlatShading = 1;\n\tvar SmoothShading = 2;\n\tvar NoColors = 0;\n\tvar FaceColors = 1;\n\tvar VertexColors = 2;\n\tvar NoBlending = 0;\n\tvar NormalBlending = 1;\n\tvar AdditiveBlending = 2;\n\tvar SubtractiveBlending = 3;\n\tvar MultiplyBlending = 4;\n\tvar CustomBlending = 5;\n\tvar BlendingMode = {\n\t\tNoBlending: NoBlending,\n\t\tNormalBlending: NormalBlending,\n\t\tAdditiveBlending: AdditiveBlending,\n\t\tSubtractiveBlending: SubtractiveBlending,\n\t\tMultiplyBlending: MultiplyBlending,\n\t\tCustomBlending: CustomBlending\n\t};\n\tvar AddEquation = 100;\n\tvar SubtractEquation = 101;\n\tvar ReverseSubtractEquation = 102;\n\tvar MinEquation = 103;\n\tvar MaxEquation = 104;\n\tvar ZeroFactor = 200;\n\tvar OneFactor = 201;\n\tvar SrcColorFactor = 202;\n\tvar OneMinusSrcColorFactor = 203;\n\tvar SrcAlphaFactor = 204;\n\tvar OneMinusSrcAlphaFactor = 205;\n\tvar DstAlphaFactor = 206;\n\tvar OneMinusDstAlphaFactor = 207;\n\tvar DstColorFactor = 208;\n\tvar OneMinusDstColorFactor = 209;\n\tvar SrcAlphaSaturateFactor = 210;\n\tvar NeverDepth = 0;\n\tvar AlwaysDepth = 1;\n\tvar LessDepth = 2;\n\tvar LessEqualDepth = 3;\n\tvar EqualDepth = 4;\n\tvar GreaterEqualDepth = 5;\n\tvar GreaterDepth = 6;\n\tvar NotEqualDepth = 7;\n\tvar MultiplyOperation = 0;\n\tvar MixOperation = 1;\n\tvar AddOperation = 2;\n\tvar NoToneMapping = 0;\n\tvar LinearToneMapping = 1;\n\tvar ReinhardToneMapping = 2;\n\tvar Uncharted2ToneMapping = 3;\n\tvar CineonToneMapping = 4;\n\tvar UVMapping = 300;\n\tvar CubeReflectionMapping = 301;\n\tvar CubeRefractionMapping = 302;\n\tvar EquirectangularReflectionMapping = 303;\n\tvar EquirectangularRefractionMapping = 304;\n\tvar SphericalReflectionMapping = 305;\n\tvar CubeUVReflectionMapping = 306;\n\tvar CubeUVRefractionMapping = 307;\n\tvar TextureMapping = {\n\t\tUVMapping: UVMapping,\n\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t};\n\tvar RepeatWrapping = 1000;\n\tvar ClampToEdgeWrapping = 1001;\n\tvar MirroredRepeatWrapping = 1002;\n\tvar TextureWrapping = {\n\t\tRepeatWrapping: RepeatWrapping,\n\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t};\n\tvar NearestFilter = 1003;\n\tvar NearestMipMapNearestFilter = 1004;\n\tvar NearestMipMapLinearFilter = 1005;\n\tvar LinearFilter = 1006;\n\tvar LinearMipMapNearestFilter = 1007;\n\tvar LinearMipMapLinearFilter = 1008;\n\tvar TextureFilter = {\n\t\tNearestFilter: NearestFilter,\n\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\tLinearFilter: LinearFilter,\n\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t};\n\tvar UnsignedByteType = 1009;\n\tvar ByteType = 1010;\n\tvar ShortType = 1011;\n\tvar UnsignedShortType = 1012;\n\tvar IntType = 1013;\n\tvar UnsignedIntType = 1014;\n\tvar FloatType = 1015;\n\tvar HalfFloatType = 1016;\n\tvar UnsignedShort4444Type = 1017;\n\tvar UnsignedShort5551Type = 1018;\n\tvar UnsignedShort565Type = 1019;\n\tvar UnsignedInt248Type = 1020;\n\tvar AlphaFormat = 1021;\n\tvar RGBFormat = 1022;\n\tvar RGBAFormat = 1023;\n\tvar LuminanceFormat = 1024;\n\tvar LuminanceAlphaFormat = 1025;\n\tvar RGBEFormat = RGBAFormat;\n\tvar DepthFormat = 1026;\n\tvar DepthStencilFormat = 1027;\n\tvar RGB_S3TC_DXT1_Format = 2001;\n\tvar RGBA_S3TC_DXT1_Format = 2002;\n\tvar RGBA_S3TC_DXT3_Format = 2003;\n\tvar RGBA_S3TC_DXT5_Format = 2004;\n\tvar RGB_PVRTC_4BPPV1_Format = 2100;\n\tvar RGB_PVRTC_2BPPV1_Format = 2101;\n\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\n\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\n\tvar RGB_ETC1_Format = 2151;\n\tvar LoopOnce = 2200;\n\tvar LoopRepeat = 2201;\n\tvar LoopPingPong = 2202;\n\tvar InterpolateDiscrete = 2300;\n\tvar InterpolateLinear = 2301;\n\tvar InterpolateSmooth = 2302;\n\tvar ZeroCurvatureEnding = 2400;\n\tvar ZeroSlopeEnding = 2401;\n\tvar WrapAroundEnding = 2402;\n\tvar TrianglesDrawMode = 0;\n\tvar TriangleStripDrawMode = 1;\n\tvar TriangleFanDrawMode = 2;\n\tvar LinearEncoding = 3000;\n\tvar sRGBEncoding = 3001;\n\tvar GammaEncoding = 3007;\n\tvar RGBEEncoding = 3002;\n\tvar LogLuvEncoding = 3003;\n\tvar RGBM7Encoding = 3004;\n\tvar RGBM16Encoding = 3005;\n\tvar RGBDEncoding = 3006;\n\tvar BasicDepthPacking = 3200;\n\tvar RGBADepthPacking = 3201;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar _Math = {\n\n\t\tDEG2RAD: Math.PI / 180,\n\t\tRAD2DEG: 180 / Math.PI,\n\n\t\tgenerateUUID: function () {\n\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\tvar uuid = new Array( 36 );\n\t\t\tvar rnd = 0, r;\n\n\t\t\treturn function generateUUID() {\n\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn uuid.join( '' );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclamp: function ( value, min, max ) {\n\n\t\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t\t},\n\n\t\t// compute euclidian modulo of m % n\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\t\teuclideanModulo: function ( n, m ) {\n\n\t\t\treturn ( ( n % m ) + m ) % m;\n\n\t\t},\n\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t\t},\n\n\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\t\tlerp: function ( x, y, t ) {\n\n\t\t\treturn ( 1 - t ) * x + t * y;\n\n\t\t},\n\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\t\tsmoothstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * ( 3 - 2 * x );\n\n\t\t},\n\n\t\tsmootherstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t\t},\n\n\t\trandom16: function () {\n\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\treturn Math.random();\n\n\t\t},\n\n\t\t// Random integer from <low, high> interval\n\n\t\trandInt: function ( low, high ) {\n\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t\t},\n\n\t\t// Random float from <low, high> interval\n\n\t\trandFloat: function ( low, high ) {\n\n\t\t\treturn low + Math.random() * ( high - low );\n\n\t\t},\n\n\t\t// Random float from <-range/2, range/2> interval\n\n\t\trandFloatSpread: function ( range ) {\n\n\t\t\treturn range * ( 0.5 - Math.random() );\n\n\t\t},\n\n\t\tdegToRad: function ( degrees ) {\n\n\t\t\treturn degrees * _Math.DEG2RAD;\n\n\t\t},\n\n\t\tradToDeg: function ( radians ) {\n\n\t\t\treturn radians * _Math.RAD2DEG;\n\n\t\t},\n\n\t\tisPowerOfTwo: function ( value ) {\n\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t\t},\n\n\t\tnearestPowerOfTwo: function ( value ) {\n\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t\t},\n\n\t\tnextPowerOfTwo: function ( value ) {\n\n\t\t\tvalue --;\n\t\t\tvalue |= value >> 1;\n\t\t\tvalue |= value >> 2;\n\t\t\tvalue |= value >> 4;\n\t\t\tvalue |= value >> 8;\n\t\t\tvalue |= value >> 16;\n\t\t\tvalue ++;\n\n\t\t\treturn value;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author egraether / http://egraether.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tfunction Vector2( x, y ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\n\t}\n\n\tVector2.prototype = {\n\n\t\tconstructor: Vector2,\n\n\t\tisVector2: true,\n\n\t\tget width() {\n\n\t\t\treturn this.x;\n\n\t\t},\n\n\t\tset width( value ) {\n\n\t\t\tthis.x = value;\n\n\t\t},\n\n\t\tget height() {\n\n\t\t\treturn this.y;\n\n\t\t},\n\n\t\tset height( value ) {\n\n\t\t\tthis.y = value;\n\n\t\t},\n\n\t\t//\n\n\t\tset: function ( x, y ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v ) {\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector2();\n\t\t\t\t\tmax = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t\t},\n\n\t\tlengthManhattan: function() {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tangle: function () {\n\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\t\treturn angle;\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateAround: function ( center, angle ) {\n\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\t\tvar x = this.x - center.x;\n\t\t\tvar y = this.y - center.y;\n\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t */\n\n\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\tObject.defineProperty( this, 'id', { value: TextureIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.sourceFile = '';\n\n\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding !== undefined ? encoding :  LinearEncoding;\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t}\n\n\tTexture.DEFAULT_IMAGE = undefined;\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\n\tTexture.prototype = {\n\n\t\tconstructor: Texture,\n\n\t\tisTexture: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\t\tthis.mapping = source.mapping;\n\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\n\t\t\tthis.anisotropy = source.anisotropy;\n\n\t\t\tthis.format = source.format;\n\t\t\tthis.type = source.type;\n\n\t\t\tthis.offset.copy( source.offset );\n\t\t\tthis.repeat.copy( source.repeat );\n\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t\t}\n\n\t\t\tfunction getDataURL( image ) {\n\n\t\t\t\tvar canvas;\n\n\t\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\t\tcanvas = image;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\n\t\t\t\tmapping: this.mapping,\n\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\n\t\t\t\tflipY: this.flipY\n\t\t\t};\n\n\t\t\tif ( this.image !== undefined ) {\n\n\t\t\t\t// TODO: Move to THREE.Image\n\n\t\t\t\tvar image = this.image;\n\n\t\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\n\t\t\t\t}\n\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\toutput.image = image.uuid;\n\n\t\t\t}\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t},\n\n\t\ttransformUv: function ( uv ) {\n\n\t\t\tif ( this.mapping !== UVMapping )  return;\n\n\t\t\tuv.multiply( this.repeat );\n\t\t\tuv.add( this.offset );\n\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.flipY ) {\n\n\t\t\t\tuv.y = 1 - uv.y;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tObject.assign( Texture.prototype, EventDispatcher.prototype );\n\n\tvar count = 0;\n\tfunction TextureIdCount() { return count++; }\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector4( x, y, z, w ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\tthis.w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tVector4.prototype = {\n\n\t\tconstructor: Vector4,\n\n\t\tisVector4: true,\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( w ) {\n\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tcase 3: return this.w;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\t\t\tthis.w *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t\t// q is assumed to be normalized\n\n\t\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\t\tif ( s < 0.0001 ) {\n\n\t\t\t\t this.x = 1;\n\t\t\t\t this.y = 0;\n\t\t\t\t this.z = 0;\n\n\t\t\t} else {\n\n\t\t\t\t this.x = q.x / s;\n\t\t\t\t this.y = q.y / s;\n\t\t\t\t this.z = q.z / s;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\t\tte = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t\t}\n\n\t\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\t\tangle = Math.PI;\n\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.set( x, y, z, angle );\n\n\t\t\t\treturn this; // return 180 deg rotation\n\n\t\t\t}\n\n\t\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\tthis.w = Math.min( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\tthis.w = Math.max( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\tmax = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\t\tthis.w = Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\t\tthis.w = Math.ceil( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\t\tthis.w = Math.round( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\t\tthis.w = - this.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\t\tthis.w = array[ offset + 3 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\tarray[ offset + 3 ] = this.w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author szimek / https://github.com/szimek/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Marius Kintel / https://github.com/kintel\n\t */\n\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\tfunction WebGLRenderTarget( width, height, options ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\toptions = options || {};\n\n\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\n\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n\t}\n\n\tObject.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {\n\n\t\tisWebGLRenderTarget: true,\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\tthis.scissor.set( 0, 0, width, height );\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\n\t\t\tthis.viewport.copy( source.viewport );\n\n\t\t\tthis.texture = source.texture.clone();\n\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com\n\t */\n\n\tfunction WebGLRenderTargetCube( width, height, options ) {\n\n\t\tWebGLRenderTarget.call( this, width, height, options );\n\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\tthis.activeMipMapLevel = 0;\n\n\t}\n\n\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\n\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Quaternion( x, y, z, w ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tQuaternion.prototype = {\n\n\t\tconstructor: Quaternion,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget w () {\n\n\t\t\treturn this._w;\n\n\t\t},\n\n\t\tset w ( value ) {\n\n\t\t\tthis._w = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t\t},\n\n\t\tcopy: function ( quaternion ) {\n\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromEuler: function ( euler, update ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\t\tvar order = euler.order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t}\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos( halfAngle );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\ts;\n\n\t\t\tif ( trace > 0 ) {\n\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t\t} else if ( m22 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t\t} else {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromUnitVectors: function () {\n\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\t\tvar v1, r;\n\n\t\t\tvar EPS = 0.000001;\n\n\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\t\tif ( r < EPS ) {\n\n\t\t\t\t\tr = 0;\n\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t\t}\n\n\t\t\t\tthis._x = v1.x;\n\t\t\t\tthis._y = v1.y;\n\t\t\t\tthis._z = v1.z;\n\t\t\t\tthis._w = r;\n\n\t\t\t\treturn this.normalize();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tinverse: function () {\n\n\t\t\treturn this.conjugate().normalize();\n\n\t\t},\n\n\t\tconjugate: function () {\n\n\t\t\tthis._x *= - 1;\n\t\t\tthis._y *= - 1;\n\t\t\tthis._z *= - 1;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tvar l = this.length();\n\n\t\t\tif ( l === 0 ) {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\n\t\t\t} else {\n\n\t\t\t\tl = 1 / l;\n\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( q, p ) {\n\n\t\t\tif ( p !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyQuaternions( this, q );\n\n\t\t},\n\n\t\tpremultiply: function ( q ) {\n\n\t\t\treturn this.multiplyQuaternions( q, this );\n\n\t\t},\n\n\t\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tslerp: function ( qb, t ) {\n\n\t\t\tif ( t === 0 ) return this;\n\t\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\t\tthis._w = - qb._w;\n\t\t\t\tthis._x = - qb._x;\n\t\t\t\tthis._y = - qb._y;\n\t\t\t\tthis._z = - qb._z;\n\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t\t} else {\n\n\t\t\t\tthis.copy( qb );\n\n\t\t\t}\n\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( quaternion ) {\n\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis._x = array[ offset ];\n\t\t\tthis._y = array[ offset + 1 ];\n\t\t\tthis._z = array[ offset + 2 ];\n\t\t\tthis._w = array[ offset + 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\tObject.assign( Quaternion, {\n\n\t\tslerp: function( qa, qb, qm, t ) {\n\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t\t},\n\n\t\tslerpFlat: function(\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\t\tvar s = 1 - t,\n\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t\t}\n\n\t\t\t\tvar tDir = t * dir;\n\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdst[ dstOffset ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author *kile / http://kile.stravaganza.org/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector3( x, y, z ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\n\t}\n\n\tVector3.prototype = {\n\n\t\tconstructor: Vector3,\n\n\t\tisVector3: true,\n\n\t\tset: function ( x, y, z ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyEuler: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyEuler( euler ) {\n\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyAxisAngle: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix3: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyProjection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 projection matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyQuaternion: function ( q ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t\t// calculate quat * vector\n\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t\t// calculate result * inverse quat\n\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function project( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tunproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function unproject( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttransformDirection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\t\treturn this.normalize();\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector3();\n\t\t\t\t\tmax = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tcross: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\treturn this.crossVectors( v, w );\n\n\t\t\t}\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\tthis.z = x * v.y - y * v.x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossVectors: function ( a, b ) {\n\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tprojectOnVector: function ( vector ) {\n\n\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\n\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\n\t\t},\n\n\t\tprojectOnPlane: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\t\treturn this.sub( v1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\treflect: function () {\n\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\n\t\t\tvar v1;\n\n\t\t\treturn function reflect( normal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tangleTo: function ( v ) {\n\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t\t// clamp, to handle numerical problems\n\n\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t\t},\n\n\t\tsetFromSpherical: function( s ) {\n\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixPosition: function ( m ) {\n\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t\t},\n\n\t\tsetFromMatrixScale: function ( m ) {\n\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\t\tif ( typeof m === 'number' ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\tvar temp = m;\n\t\t\t\tm = index;\n\t\t\t\tindex = temp;\n\n\t\t\t}\n\n\t\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author jordi_ros / http://plattsoft.com\n\t * @author D1plo1d / http://github.com/D1plo1d\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author timknip / http://www.floorplanner.com/\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Matrix4() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix4.prototype = {\n\n\t\tconstructor: Matrix4,\n\n\t\tisMatrix4: true,\n\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new Matrix4().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tthis.elements.set( m.elements );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyPosition: function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\tte[ 14 ] = me[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\tthis.set(\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t0,       0,       0,       1\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractRotation: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function extractRotation( m ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeRotationFromEuler: function ( euler ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\tte[ 8 ] = d;\n\n\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\tte[ 9 ] = - b * c;\n\n\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\tte[ 8 ] = a * d;\n\n\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b;\n\n\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\tte[ 6 ] = b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\t\tte[ 2 ] = - d;\n\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\t\tte[ 1 ] = f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b * e;\n\n\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - f;\n\t\t\t\tte[ 8 ] = d * e;\n\n\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t\t}\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\tte[ 4 ] = xy - wz;\n\t\t\tte[ 8 ] = xz + wy;\n\n\t\t\tte[ 1 ] = xy + wz;\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\tte[ 9 ] = yz - wx;\n\n\t\t\tte[ 2 ] = xz - wy;\n\t\t\tte[ 6 ] = yz + wx;\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlookAt: function () {\n\n\t\t\tvar x, y, z;\n\n\t\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\t\tif ( x === undefined ) {\n\n\t\t\t\t\tx = new Vector3();\n\t\t\t\t\ty = new Vector3();\n\t\t\t\t\tz = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z = 1;\n\n\t\t\t\t}\n\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\ty.crossVectors( z, x );\n\n\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiply: function ( m, n ) {\n\n\t\t\tif ( n !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyMatrices( this, m );\n\n\t\t},\n\n\t\tpremultiply: function ( m ) {\n\n\t\t\treturn this.multiplyMatrices( m, this );\n\n\t\t},\n\n\t\tmultiplyMatrices: function ( a, b ) {\n\n\t\t\tvar ae = a.elements;\n\t\t\tvar be = b.elements;\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyToArray: function ( a, b, r ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tthis.multiplyMatrices( a, b );\n\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t\t//TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\treturn (\n\t\t\t\tn41 * (\n\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t) +\n\t\t\t\tn42 * (\n\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t) +\n\t\t\t\tn43 * (\n\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t) +\n\t\t\t\tn44 * (\n\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t)\n\n\t\t\t);\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar tmp;\n\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetPosition: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function getPosition() {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetPosition: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 12 ] = v.x;\n\t\t\tte[ 13 ] = v.y;\n\t\t\tte[ 14 ] = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tvar te = this.elements,\n\t\t\t\tme = m.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tscale: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetMaxScaleOnAxis: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t\t},\n\n\t\tmakeTranslation: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationX: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0,  0, 0,\n\t\t\t\t0, c, - s, 0,\n\t\t\t\t0, s,  c, 0,\n\t\t\t\t0, 0,  0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationY: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t- s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationZ: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\tc, - s, 0, 0,\n\t\t\t\ts,  c, 0, 0,\n\t\t\t\t0,  0, 1, 0,\n\t\t\t\t0,  0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\t\tvar c = Math.cos( angle );\n\t\t\tvar s = Math.sin( angle );\n\t\t\tvar t = 1 - c;\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\tvar tx = t * x, ty = t * y;\n\n\t\t\tthis.set(\n\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\t return this;\n\n\t\t},\n\n\t\tmakeScale: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\tx, 0, 0, 0,\n\t\t\t\t0, y, 0, 0,\n\t\t\t\t0, 0, z, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompose: function ( position, quaternion, scale ) {\n\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\tthis.scale( scale );\n\t\t\tthis.setPosition( position );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdecompose: function () {\n\n\t\t\tvar vector, matrix;\n\n\t\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tvector = new Vector3();\n\t\t\t\t\tmatrix = new Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\tvar det = this.determinant();\n\t\t\t\tif ( det < 0 ) {\n\n\t\t\t\t\tsx = - sx;\n\n\t\t\t\t}\n\n\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\tposition.z = te[ 14 ];\n\n\t\t\t\t// scale the rotation part\n\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\tvar invSZ = 1 / sz;\n\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\t\tscale.x = sx;\n\t\t\t\tscale.y = sy;\n\t\t\t\tscale.z = sz;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = 2 * near / ( right - left );\n\t\t\tvar y = 2 * near / ( top - bottom );\n\n\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\t\tvar ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );\n\t\t\tvar ymin = - ymax;\n\t\t\tvar xmin = ymin * aspect;\n\t\t\tvar xmax = ymax * aspect;\n\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t\t},\n\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar w = 1.0 / ( right - left );\n\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\tvar p = 1.0 / ( far - near );\n\n\t\t\tvar x = ( right + left ) * w;\n\t\t\tvar y = ( top + bottom ) * h;\n\t\t\tvar z = ( far + near ) * p;\n\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( matrix ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = matrix.elements;\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tCubeTexture.prototype = Object.create( Texture.prototype );\n\tCubeTexture.prototype.constructor = CubeTexture;\n\n\tCubeTexture.prototype.isCubeTexture = true;\n\n\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\n\t\tget: function () {\n\n\t\t\treturn this.image;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.image = value;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t *\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [renderer] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (renderer factorizations):\n\t *\n\t * .upload( gl, seq, values, renderer )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (renderer factorizations):\n\t *\n\t * .setValue( gl, name, value )\n\t *\n\t * \t\tsets uniform with  name 'name' to 'value'\n\t *\n\t * .set( gl, obj, prop )\n\t *\n\t * \t\tsets uniform from object and property with same name than uniform\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\n\tvar emptyTexture = new Texture();\n\tvar emptyCubeTexture = new CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tfunction UniformContainer() {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\tvar arrayCacheF32 = [];\n\tvar arrayCacheI32 = [];\n\n\t// Flattening for arrays of vectors and matrices\n\n\tfunction flatten( array, nBlocks, blockSize ) {\n\n\t\tvar firstElem = array[ 0 ];\n\n\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t// unoptimized: ! isNaN( firstElem )\n\t\t// see http://jacksondunstan.com/articles/983\n\n\t\tvar n = nBlocks * blockSize,\n\t\t\tr = arrayCacheF32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Float32Array( n );\n\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t}\n\n\t\tif ( nBlocks !== 0 ) {\n\n\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\toffset += blockSize;\n\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n\t// Texture unit allocation\n\n\tfunction allocTexUnits( renderer, n ) {\n\n\t\tvar r = arrayCacheI32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Int32Array( n );\n\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\treturn r;\n\n\t}\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t// Single scalar\n\n\tfunction setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }\n\tfunction setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }\n\n\t// Single float vector (from flat array or THREE.VectorN)\n\n\tfunction setValue2fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t}\n\n\tfunction setValue3fv( gl, v ) {\n\n\t\tif ( v.x !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\telse if ( v.r !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\telse\n\t\t\tgl.uniform3fv( this.addr, v );\n\n\t}\n\n\tfunction setValue4fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t}\n\n\t// Single matrix (from flat array or MatrixN)\n\n\tfunction setValue2fm( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue3fm( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue4fm( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t}\n\n\t// Single texture (2D / Cube)\n\n\tfunction setValueT1( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t}\n\n\tfunction setValueT6( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t}\n\n\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\tfunction setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }\n\tfunction setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }\n\tfunction setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }\n\n\t// Helper to pick the right setter for the singular case\n\n\tfunction getSingularSetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// Array of scalars\n\n\tfunction setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }\n\tfunction setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }\n\n\t// Array of vectors (flat or from THREE classes)\n\n\tfunction setValueV2a( gl, v ) {\n\n\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t}\n\n\tfunction setValueV3a( gl, v ) {\n\n\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t}\n\n\tfunction setValueV4a( gl, v ) {\n\n\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t}\n\n\t// Array of matrices (flat or from THREE clases)\n\n\tfunction setValueM2a( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t}\n\n\tfunction setValueM3a( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t}\n\n\tfunction setValueM4a( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t}\n\n\t// Array of textures (2D / Cube)\n\n\tfunction setValueT1a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\tfunction setValueT6a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\tfunction getPureArraySetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// --- Uniform Classes ---\n\n\tfunction SingleUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction StructuredUniform( id ) {\n\n\t\tthis.id = id;\n\n\t\tUniformContainer.call( this ); // mix-in\n\n\t}\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n\t// extracts\n\t// \t- the identifier (member name or array index)\n\t//  - followed by an optional right bracket (found when array index)\n\t//  - followed by an optional left bracket or dot (type of subscript)\n\t//\n\t// Note: These portions can be read in a non-overlapping fashion and\n\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t// in the uniform names.\n\n\tfunction addUniform( container, uniformObject ) {\n\n\t\tcontainer.seq.push( uniformObject );\n\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t}\n\n\tfunction parseUniform( activeInfo, addr, container ) {\n\n\t\tvar path = activeInfo.name,\n\t\t\tpathLength = path.length;\n\n\t\t// reset RegExp object, because of the early exit of a previous run\n\t\tRePathPart.lastIndex = 0;\n\n\t\tfor (; ;) {\n\n\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\tid = match[ 1 ],\n\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\tif ( subscript === undefined ||\n\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\tvar map = container.map,\n\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t}\n\n\t\t\t\tcontainer = next;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Root Container\n\n\tfunction WebGLUniforms( gl, program, renderer ) {\n\n\t\tUniformContainer.call( this );\n\n\t\tthis.renderer = renderer;\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\tpath = info.name,\n\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\t/**\n\t * Uniform Utilities\n\t */\n\n\tvar UniformsUtils = {\n\n\t\tmerge: function ( uniforms ) {\n\n\t\t\tvar merged = {};\n\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn merged;\n\n\t\t},\n\n\t\tclone: function ( uniforms_src ) {\n\n\t\t\tvar uniforms_dst = {};\n\n\t\t\tfor ( var u in uniforms_src ) {\n\n\t\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uniforms_dst;\n\n\t\t}\n\n\t};\n\n\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\n\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\n\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n\tvar bsdfs = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\n\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\n\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\n\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\n\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n\tvar defaultnormal_vertex = \"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\n\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\n\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\t#else\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\t#endif\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\n\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\\t\\t\\tdirectLight.color = pointLight.color;\\n\\t\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\t#include <normal_flip>\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\t#include <normal_flip>\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\n\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\n\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t \\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\t\\t\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n\tvar logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\n\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\n\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\n\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar normal_flip = \"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\n\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n\tvar project_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\n\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n\tvar tonemapping_pars_fragment = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\n\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\n\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\n\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\n\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar distanceRGBA_frag = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n\tvar distanceRGBA_vert = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\n\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\n\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight;\\n\\treflectedLight.directDiffuse = vec3( 0.0 );\\n\\treflectedLight.directSpecular = vec3( 0.0 );\\n\\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n}\\n\";\n\n\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar normal_frag = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n\tvar normal_vert = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvNormal = normalize( normalMatrix * normal );\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar shadow_frag = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n\tvar shadow_vert = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar ShaderChunk = {\n\t\talphamap_fragment: alphamap_fragment,\n\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\talphatest_fragment: alphatest_fragment,\n\t\taomap_fragment: aomap_fragment,\n\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\tbegin_vertex: begin_vertex,\n\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\tbsdfs: bsdfs,\n\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\tcolor_fragment: color_fragment,\n\t\tcolor_pars_fragment: color_pars_fragment,\n\t\tcolor_pars_vertex: color_pars_vertex,\n\t\tcolor_vertex: color_vertex,\n\t\tcommon: common,\n\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\temissivemap_fragment: emissivemap_fragment,\n\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\tencodings_fragment: encodings_fragment,\n\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\tenvmap_fragment: envmap_fragment,\n\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\tenvmap_vertex: envmap_vertex,\n\t\tfog_fragment: fog_fragment,\n\t\tfog_pars_fragment: fog_pars_fragment,\n\t\tlightmap_fragment: lightmap_fragment,\n\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\tlights_pars: lights_pars,\n\t\tlights_phong_fragment: lights_phong_fragment,\n\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\tlights_physical_fragment: lights_physical_fragment,\n\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\tlights_template: lights_template,\n\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\tmap_fragment: map_fragment,\n\t\tmap_pars_fragment: map_pars_fragment,\n\t\tmap_particle_fragment: map_particle_fragment,\n\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\tnormal_flip: normal_flip,\n\t\tnormal_fragment: normal_fragment,\n\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\tpacking: packing,\n\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\tproject_vertex: project_vertex,\n\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\tshadowmap_vertex: shadowmap_vertex,\n\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\tskinbase_vertex: skinbase_vertex,\n\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\tskinning_vertex: skinning_vertex,\n\t\tskinnormal_vertex: skinnormal_vertex,\n\t\tspecularmap_fragment: specularmap_fragment,\n\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\ttonemapping_fragment: tonemapping_fragment,\n\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\tuv_pars_fragment: uv_pars_fragment,\n\t\tuv_pars_vertex: uv_pars_vertex,\n\t\tuv_vertex: uv_vertex,\n\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\tuv2_vertex: uv2_vertex,\n\t\tworldpos_vertex: worldpos_vertex,\n\n\t\tcube_frag: cube_frag,\n\t\tcube_vert: cube_vert,\n\t\tdepth_frag: depth_frag,\n\t\tdepth_vert: depth_vert,\n\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\tequirect_frag: equirect_frag,\n\t\tequirect_vert: equirect_vert,\n\t\tlinedashed_frag: linedashed_frag,\n\t\tlinedashed_vert: linedashed_vert,\n\t\tmeshbasic_frag: meshbasic_frag,\n\t\tmeshbasic_vert: meshbasic_vert,\n\t\tmeshlambert_frag: meshlambert_frag,\n\t\tmeshlambert_vert: meshlambert_vert,\n\t\tmeshphong_frag: meshphong_frag,\n\t\tmeshphong_vert: meshphong_vert,\n\t\tmeshphysical_frag: meshphysical_frag,\n\t\tmeshphysical_vert: meshphysical_vert,\n\t\tnormal_frag: normal_frag,\n\t\tnormal_vert: normal_vert,\n\t\tpoints_frag: points_frag,\n\t\tpoints_vert: points_vert,\n\t\tshadow_frag: shadow_frag,\n\t\tshadow_vert: shadow_vert\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Color( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\n\t\t}\n\n\t\treturn this.setRGB( r, g, b );\n\n\t}\n\n\tColor.prototype = {\n\n\t\tconstructor: Color,\n\n\t\tisColor: true,\n\n\t\tr: 1, g: 1, b: 1,\n\n\t\tset: function ( value ) {\n\n\t\t\tif ( (value && value.isColor) ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHex: function ( hex ) {\n\n\t\t\thex = Math.floor( hex );\n\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetRGB: function ( r, g, b ) {\n\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHSL: function () {\n\n\t\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\n\t\t\t\tif ( s === 0 ) {\n\n\t\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetStyle: function ( style ) {\n\n\t\t\tfunction handleAlpha( string ) {\n\n\t\t\t\tif ( string === undefined ) return;\n\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar m;\n\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t\t// rgb / hsl\n\n\t\t\t\tvar color;\n\t\t\t\tvar name = m[ 1 ];\n\t\t\t\tvar components = m[ 2 ];\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t\t// hex color\n\n\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\tvar size = hex.length;\n\n\t\t\t\tif ( size === 3 ) {\n\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( style && style.length > 0 ) {\n\n\t\t\t\t// color keywords\n\t\t\t\tvar hex = ColorKeywords[ style ];\n\n\t\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t\t// red\n\t\t\t\t\tthis.setHex( hex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// unknown color\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t\t},\n\n\t\tcopy: function ( color ) {\n\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertGammaToLinear: function () {\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tthis.r = r * r;\n\t\t\tthis.g = g * g;\n\t\t\tthis.b = b * b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertLinearToGamma: function () {\n\n\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\tthis.b = Math.sqrt( this.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetHex: function () {\n\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t\t},\n\n\t\tgetHexString: function () {\n\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t\t},\n\n\t\tgetHSL: function ( optionalTarget ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tvar max = Math.max( r, g, b );\n\t\t\tvar min = Math.min( r, g, b );\n\n\t\t\tvar hue, saturation;\n\t\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\t\tif ( min === max ) {\n\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\n\t\t\t} else {\n\n\t\t\t\tvar delta = max - min;\n\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\t\tswitch ( max ) {\n\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\n\t\t\t}\n\n\t\t\thsl.h = hue;\n\t\t\thsl.s = saturation;\n\t\t\thsl.l = lightness;\n\n\t\t\treturn hsl;\n\n\t\t},\n\n\t\tgetStyle: function () {\n\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t\t},\n\n\t\toffsetHSL: function ( h, s, l ) {\n\n\t\t\tvar hsl = this.getHSL();\n\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( color ) {\n\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddColors: function ( color1, color2 ) {\n\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function( color ) {\n\n\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( color ) {\n\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerp: function ( color, alpha ) {\n\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( c ) {\n\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.r = array[ offset ];\n\t\t\tthis.g = array[ offset + 1 ];\n\t\t\tthis.b = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.r;\n\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\tarray[ offset + 2 ] = this.b;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\treturn this.getHex();\n\n\t\t}\n\n\t};\n\n\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\n\tvar UniformsLib = {\n\n\t\tcommon: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },\n\n\t\t\tspecularMap: { value: null },\n\t\t\talphaMap: { value: null },\n\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\treflectivity: { value: 1.0 },\n\t\t\trefractionRatio: { value: 0.98 }\n\n\t\t},\n\n\t\taomap: {\n\n\t\t\taoMap: { value: null },\n\t\t\taoMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\tlightmap: {\n\n\t\t\tlightMap: { value: null },\n\t\t\tlightMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\temissivemap: {\n\n\t\t\temissiveMap: { value: null }\n\n\t\t},\n\n\t\tbumpmap: {\n\n\t\t\tbumpMap: { value: null },\n\t\t\tbumpScale: { value: 1 }\n\n\t\t},\n\n\t\tnormalmap: {\n\n\t\t\tnormalMap: { value: null },\n\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t\t},\n\n\t\tdisplacementmap: {\n\n\t\t\tdisplacementMap: { value: null },\n\t\t\tdisplacementScale: { value: 1 },\n\t\t\tdisplacementBias: { value: 0 }\n\n\t\t},\n\n\t\troughnessmap: {\n\n\t\t\troughnessMap: { value: null }\n\n\t\t},\n\n\t\tmetalnessmap: {\n\n\t\t\tmetalnessMap: { value: null }\n\n\t\t},\n\n\t\tfog: {\n\n\t\t\tfogDensity: { value: 0.00025 },\n\t\t\tfogNear: { value: 1 },\n\t\t\tfogFar: { value: 2000 },\n\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t\t},\n\n\t\tlights: {\n\n\t\t\tambientLightColor: { value: [] },\n\n\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tcolor: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\t\tspotLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdirection: {},\n\t\t\t\tdistance: {},\n\t\t\t\tconeCos: {},\n\t\t\t\tpenumbraCos: {},\n\t\t\t\tdecay: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tspotShadowMap: { value: [] },\n\t\t\tspotShadowMatrix: { value: [] },\n\n\t\t\tpointLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdecay: {},\n\t\t\t\tdistance: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tpointShadowMap: { value: [] },\n\t\t\tpointShadowMatrix: { value: [] },\n\n\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tskyColor: {},\n\t\t\t\tgroundColor: {}\n\t\t\t} }\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\t\t\tsize: { value: 1.0 },\n\t\t\tscale: { value: 1.0 },\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t */\n\n\tvar ShaderLib = {\n\n\t\tbasic: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t\t},\n\n\t\tlambert: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t\t},\n\n\t\tphong: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\tspecular : { value: new Color( 0x111111 ) },\n\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t\t},\n\n\t\tstandard: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\tmetalness: { value: 0 },\n\t\t\t\t\tenvMapIntensity : { value: 1 }, // temporary\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.points,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\tfragmentShader: ShaderChunk.points_frag\n\n\t\t},\n\n\t\tdashed: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.fog,\n\n\t\t\t\t{\n\t\t\t\t\tscale    : { value: 1 },\n\t\t\t\t\tdashSize : { value: 1 },\n\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t\t},\n\n\t\tdepth: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.displacementmap\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t\t},\n\n\t\tnormal: {\n\n\t\t\tuniforms: {\n\n\t\t\t\topacity : { value: 1.0 }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tcube: {\n\n\t\t\tuniforms: {\n\t\t\t\ttCube: { value: null },\n\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tequirect: {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t\ttFlip: { value: - 1 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t\t},\n\n\t\tdistanceRGBA: {\n\n\t\t\tuniforms: {\n\n\t\t\t\tlightPos: { value: new Vector3() }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t\t}\n\n\t};\n\n\tShaderLib.physical = {\n\n\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\tShaderLib.standard.uniforms,\n\n\t\t\t{\n\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Box2( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\n\t}\n\n\tBox2.prototype = {\n\n\t\tconstructor: Box2,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlarePlugin( renderer, flares ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar shader, program, attributes, uniforms;\n\n\t\tvar tempTexture, occlusionTexture;\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t- 1,  1,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\t// buffers\n\n\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\telementBuffer    = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\t// textures\n\n\t\t\ttempTexture      = gl.createTexture();\n\t\t\tocclusionTexture = gl.createTexture();\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tshader = {\n\n\t\t\t\tvertexShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" ),\n\n\t\t\t\tfragmentShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t// pink square\n\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t\t// restore\n\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t\t// flare\n\n\t\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" )\n\n\t\t\t};\n\n\t\t\tprogram = createProgram( shader );\n\n\t\t\tattributes = {\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t};\n\n\t\t}\n\n\t\t/*\n\t\t * Render lens flares\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t *         reads these back and calculates occlusion.\n\t\t */\n\n\t\tthis.render = function ( scene, camera, viewport ) {\n\n\t\t\tif ( flares.length === 0 ) return;\n\n\t\t\tvar tempPosition = new Vector3();\n\n\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\t\tvar size = 16 / viewport.w,\n\t\t\t\tscale = new Vector2( size * invAspect, size );\n\n\t\t\tvar screenPosition = new Vector3( 1, 1, 0 ),\n\t\t\t\tscreenPositionPixels = new Vector2( 1, 1 );\n\n\t\t\tvar validArea = new Box2();\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t// setup gl and common used attribs/uniforms\n\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.setDepthWrite( false );\n\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t\t// calc object screen position\n\n\t\t\t\tvar flare = flares[ i ];\n\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t\t// setup arrays for gl programs\n\n\t\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t\t// screen cull\n\n\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// render pink quad\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// restore graphics\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// update object positions\n\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// render flares\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\tstate.setDepthWrite( true );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram( shader ) {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\t\tgl.compileShader( fragmentShader );\n\t\t\tgl.compileShader( vertexShader );\n\n\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\tgl.attachShader( program, vertexShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpritePlugin( renderer, sprites ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar program, attributes, uniforms;\n\n\t\tvar texture;\n\n\t\t// decompose matrixWorld\n\n\t\tvar spritePosition = new Vector3();\n\t\tvar spriteRotation = new Quaternion();\n\t\tvar spriteScale = new Vector3();\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\telementBuffer = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\tprogram = createProgram();\n\n\t\t\tattributes = {\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t};\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = 8;\n\t\t\tcanvas.height = 8;\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.fillStyle = 'white';\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\t\ttexture = new Texture( canvas );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( sprites.length === 0 ) return;\n\n\t\t\t// setup gl\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.BLEND );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\t\tvar oldFogType = 0;\n\t\t\tvar sceneFogType = 0;\n\t\t\tvar fog = scene.fog;\n\n\t\t\tif ( fog ) {\n\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\t\tif ( (fog && fog.isFog) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\toldFogType = 1;\n\t\t\t\t\tsceneFogType = 1;\n\n\t\t\t\t} else if ( (fog && fog.isFogExp2) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\toldFogType = 2;\n\t\t\t\t\tsceneFogType = 2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\toldFogType = 0;\n\t\t\t\tsceneFogType = 0;\n\n\t\t\t}\n\n\n\t\t\t// update positions and sort\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t\t}\n\n\t\t\tsprites.sort( painterSortStable );\n\n\t\t\t// render all sprites\n\n\t\t\tvar scale = [];\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\tvar material = sprite.material;\n\n\t\t\t\tif ( material.visible === false ) continue;\n\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\t\tvar fogType = 0;\n\n\t\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\t\tfogType = sceneFogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\toldFogType = fogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram() {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform float rotation;',\n\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t\t'attribute vec2 position;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform vec3 color;',\n\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t'uniform float opacity;',\n\n\t\t\t\t'uniform int fogType;',\n\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t'uniform float fogNear;',\n\t\t\t\t'uniform float fogFar;',\n\t\t\t\t'uniform float alphaTest;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t\t'}',\n\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.compileShader( vertexShader );\n\t\t\tgl.compileShader( fragmentShader );\n\n\t\t\tgl.attachShader( program, vertexShader );\n\t\t\tgl.attachShader( program, fragmentShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn b.id - a.id;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Material() {\n\n\t\tObject.defineProperty( this, 'id', { value: MaterialIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.alphaTest = 0;\n\t\tthis.premultipliedAlpha = false;\n\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\t\tthis.visible = true;\n\n\t\tthis._needsUpdate = true;\n\n\t}\n\n\tMaterial.prototype = {\n\n\t\tconstructor: Material,\n\n\t\tisMaterial: true,\n\n\t\tget needsUpdate() {\n\n\t\t\treturn this._needsUpdate;\n\n\t\t},\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.update();\n\t\t\tthis._needsUpdate = value;\n\n\t\t},\n\n\t\tsetValues: function ( values ) {\n\n\t\t\tif ( values === undefined ) return;\n\n\t\t\tfor ( var key in values ) {\n\n\t\t\t\tvar newValue = values[ key ];\n\n\t\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar currentValue = this[ key ];\n\n\t\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( (currentValue && currentValue.isColor) ) {\n\n\t\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t\t} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar isRoot = meta === undefined;\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Material serialization\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( (this.color && this.color.isColor) ) data.color = this.color.getHex();\n\n\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\t\tif ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();\n\t\t\tif ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\t\tif ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\tif ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.bumpMap && this.bumpMap.isTexture) ) {\n\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t\t}\n\t\t\tif ( (this.normalMap && this.normalMap.isTexture) ) {\n\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t\t}\n\t\t\tif ( (this.displacementMap && this.displacementMap.isTexture) ) {\n\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t\t}\n\t\t\tif ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.envMap && this.envMap.isTexture) ) {\n\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t\t}\n\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\tif ( this.shading !== SmoothShading ) data.shading = this.shading;\n\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\tdata.depthTest = this.depthTest;\n\t\t\tdata.depthWrite = this.depthWrite;\n\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\t\tdata.skinning = this.skinning;\n\t\t\tdata.morphTargets = this.morphTargets;\n\n\t\t\t// TODO: Copied from Object3D.toJSON\n\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.lights = source.lights;\n\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.shading = source.shading;\n\t\t\tthis.vertexColors = source.vertexColors;\n\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\n\t\t\tthis.colorWrite = source.colorWrite;\n\n\t\t\tthis.precision = source.precision;\n\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\t\tthis.alphaTest = source.alphaTest;\n\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\t\tthis.overdraw = source.overdraw;\n\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\tthis.clipIntersection = source.clipIntersection;\n\n\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\tdstPlanes = null;\n\n\t\t\tif ( srcPlanes !== null ) {\n\n\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array( n );\n\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t\tthis.clippingPlanes = dstPlanes;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t};\n\n\tObject.assign( Material.prototype, EventDispatcher.prototype );\n\n\tvar count$1 = 0;\n\tfunction MaterialIdCount() { return count$1++; }\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  defines: { \"label\" : \"value\" },\n\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *  fragmentShader: <string>,\n\t *  vertexShader: <string>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  lights: <bool>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction ShaderMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\tthis.morphTargets = false; // set to use morph targets\n\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv2': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tShaderMaterial.prototype = Object.create( Material.prototype );\n\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\n\tShaderMaterial.prototype.isShaderMaterial = true;\n\n\tShaderMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\n\t\tthis.defines = source.defines;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.skinning = source.skinning;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.extensions = source.extensions;\n\n\t\treturn this;\n\n\t};\n\n\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\n\t\tdata.uniforms = this.uniforms;\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / https://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshDepthMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\n\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Box3( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\n\t}\n\n\tBox3.prototype = {\n\n\t\tconstructor: Box3,\n\n\t\tisBox3: true,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromArray: function ( array ) {\n\n\t\t\tvar minX = + Infinity;\n\t\t\tvar minY = + Infinity;\n\t\t\tvar minZ = + Infinity;\n\n\t\t\tvar maxX = - Infinity;\n\t\t\tvar maxY = - Infinity;\n\t\t\tvar maxZ = - Infinity;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar x = array[ i ];\n\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\tvar z = array[ i + 2 ];\n\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t\t}\n\n\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromObject: function () {\n\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromObject( object ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\t\tthis.makeEmpty();\n\n\t\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\t\t\tvar array, offset, stride;\n\n\t\t\t\t\t\t\t\tif ( (attribute && attribute.isInterleavedBufferAttribute) ) {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\t\tstride = 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\n\t\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsSphere: ( function () {\n\n\t\t\tvar closestPoint;\n\n\t\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new Vector3();\n\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\t\tvar min, max;\n\n\t\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t\t} else {\n\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t\t}\n\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetBoundingSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Sphere();\n\n\t\t\t\tthis.getCenter( result.center );\n\n\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar points = [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t];\n\n\t\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\t\tthis.setFromPoints( points );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Sphere( center, radius ) {\n\n\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n\t}\n\n\tSphere.prototype = {\n\n\t\tconstructor: Sphere,\n\n\t\tset: function ( center, radius ) {\n\n\t\t\tthis.center.copy( center );\n\t\t\tthis.radius = radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function () {\n\n\t\t\tvar box = new Box3();\n\n\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\t\tvar center = this.center;\n\n\t\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\n\t\t\t\t}\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( sphere ) {\n\n\t\t\tthis.center.copy( sphere.center );\n\t\t\tthis.radius = sphere.radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tempty: function () {\n\n\t\t\treturn ( this.radius <= 0 );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsSphere( this );\n\n\t\t},\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t// the center of the sphere to the plane.\n\t\t\t//\n\t\t\t// distance = q * n - d\n\t\t\t//\n\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t// then there is no intersection.\n\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.copy( point );\n\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\t\tvar box = optionalTarget || new Box3();\n\n\t\t\tbox.set( this.center, this.center );\n\t\t\tbox.expandByScalar( this.radius );\n\n\t\t\treturn box;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.center.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( sphere ) {\n\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t * @author tschw\n\t */\n\n\tfunction Matrix3() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix3.prototype = {\n\n\t\tconstructor: Matrix3,\n\n\t\tisMatrix3: true,\n\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix4: function( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t\t},\n\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\t\tif ( (matrix && matrix.isMatrix4) ) {\n\n\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t\t}\n\n\t\t\tvar me = matrix.elements,\n\t\t\t\tte = this.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar tmp, m = this.elements;\n\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t\t},\n\n\t\ttransposeIntoArray: function ( r ) {\n\n\t\t\tvar m = this.elements;\n\n\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\tr[ 8 ] = m[ 8 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 9; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Plane( normal, constant ) {\n\n\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n\t}\n\n\tPlane.prototype = {\n\n\t\tconstructor: Plane,\n\n\t\tset: function ( normal, constant ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponents: function ( x, y, z, w ) {\n\n\t\t\tthis.normal.set( x, y, z );\n\t\t\tthis.constant = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCoplanarPoints: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( plane ) {\n\n\t\t\tthis.normal.copy( plane.normal );\n\t\t\tthis.constant = plane.constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\tthis.constant *= inverseNormalLength;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.constant *= - 1;\n\t\t\tthis.normal.negate();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) + this.constant;\n\n\t\t},\n\n\t\tdistanceToSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t\t},\n\n\t\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t\t},\n\n\t\torthoPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t\t},\n\n\t\tintersectLine: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tvar direction = line.delta( v1 );\n\n\t\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsLine: function ( line ) {\n\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsPlane( this );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn sphere.intersectsPlane( this );\n\n\t\t},\n\n\t\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar m1 = new Matrix3();\n\n\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t\t// transform normal based on theory here:\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( plane ) {\n\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tthis.planes = [\n\n\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\n\t\t];\n\n\t}\n\n\tFrustum.prototype = {\n\n\t\tconstructor: Frustum,\n\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\tplanes[ 5 ].copy( p5 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( frustum ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix: function ( m ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar me = m.elements;\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tintersectsObject: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsObject( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSprite: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar center = sphere.center;\n\t\t\tvar negRadius = - sphere.radius;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsBox: function () {\n\n\t\t\tvar p1 = new Vector3(),\n\t\t\t\tp2 = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\tvar planes = this.planes;\n\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t}(),\n\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {\n\n\t\tvar _gl = _renderer.context,\n\t\t_state = _renderer.state,\n\t\t_frustum = new Frustum(),\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_lightShadows = _lights.shadows,\n\n\t\t_shadowMapSize = new Vector2(),\n\t\t_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\n\t\t_lookTarget = new Vector3(),\n\t\t_lightPositionWorld = new Vector3(),\n\n\t\t_renderList = [],\n\n\t\t_MorphingFlag = 1,\n\t\t_SkinningFlag = 2,\n\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t\t_materialCache = {};\n\n\t\tvar cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tvar cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t\tvar cube2DViewPorts = [\n\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t];\n\n\t\t// init\n\n\t\tvar depthMaterialTemplate = new MeshDepthMaterial();\n\t\tdepthMaterialTemplate.depthPacking = RGBADepthPacking;\n\t\tdepthMaterialTemplate.clipping = true;\n\n\t\tvar distanceShader = ShaderLib[ \"distanceRGBA\" ];\n\t\tvar distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );\n\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\t\tvar distanceMaterial = new ShaderMaterial( {\n\t\t\t\tdefines: {\n\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t},\n\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning,\n\t\t\t\tclipping: true\n\t\t\t} );\n\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tthis.enabled = false;\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis.type = PCFShadowMap;\n\n\t\tthis.renderReverseSided = true;\n\t\tthis.renderSingleSided = true;\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t\t// Set GL state for depth map.\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t_state.disable( _gl.BLEND );\n\t\t\t_state.setDepthTest( true );\n\t\t\t_state.setScissorTest( false );\n\n\t\t\t// render depth map\n\n\t\t\tvar faceCount, isPointLight;\n\n\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\n\t\t\t\tif ( (light && light.isPointLight) ) {\n\n\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\tisPointLight = true;\n\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t// following orientation:\n\t\t\t\t\t//\n\t\t\t\t\t//  xzXZ\n\t\t\t\t\t//   y Y\n\t\t\t\t\t//\n\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t// z - Negative z direction\n\n\t\t\t\t\t// positive X\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative X\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Z\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative Z\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Y\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t// negative Y\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\tisPointLight = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tif ( (shadow && shadow.isSpotLightShadow) ) {\n\n\t\t\t\t\tshadow.update( light );\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t_renderer.clear();\n\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t// run a single pass if not\n\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t\t// compute shadow matrix\n\n\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t);\n\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t\t_renderList.length = 0;\n\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t\t// render shadow map\n\t\t\t\t\t// render regular objects\n\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( (material && material.isMultiMaterial) ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Restore GL state.\n\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\t\tscope.needsUpdate = false;\n\n\t\t};\n\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tvar result = null;\n\n\t\t\tvar materialVariants = _depthMaterials;\n\t\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t\t}\n\n\t\t\tif ( ! customMaterial ) {\n\n\t\t\t\tvar useMorphing = false;\n\n\t\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\n\t\t\t\tvar variantIndex = 0;\n\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t\t} else {\n\n\t\t\t\tresult = customMaterial;\n\n\t\t\t}\n\n\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\n\t\t\tvar side = material.side;\n\n\t\t\tif ( scope.renderSingleSided && side == DoubleSide ) {\n\n\t\t\t\tside = FrontSide;\n\n\t\t\t}\n\n\t\t\tif ( scope.renderReverseSided ) {\n\n\t\t\t\tif ( side === FrontSide ) side = BackSide;\n\t\t\t\telse if ( side === BackSide ) side = FrontSide;\n\n\t\t\t}\n\n\t\t\tresult.side = side;\n\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\n\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Ray( origin, direction ) {\n\n\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\n\t}\n\n\tRay.prototype = {\n\n\t\tconstructor: Ray,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\tthis.origin.copy( origin );\n\t\t\tthis.direction.copy( direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( ray ) {\n\n\t\t\tthis.origin.copy( ray.origin );\n\t\t\tthis.direction.copy( ray.direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t\t},\n\n\t\tlookAt: function ( v ) {\n\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trecast: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function recast( t ) {\n\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\tresult.subVectors( point, this.origin );\n\t\t\tvar directionDistance = result.dot( this.direction );\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn result.copy( this.origin );\n\n\t\t\t}\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t\t},\n\n\t\tdistanceSqToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t\t// point behind the ray\n\n\t\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t\t}\n\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\t\treturn v1.distanceToSquared( point );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceSqToSegment: function () {\n\n\t\t\tvar segCenter = new Vector3();\n\t\t\tvar segDir = new Vector3();\n\t\t\tvar diff = new Vector3();\n\n\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t// defined by v0 and v1\n\t\t\t\t// It can also set two optional targets :\n\t\t\t\t// - The closest point on the ray\n\t\t\t\t// - The closest point on the segment\n\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\t\tif ( det > 0 ) {\n\n\t\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\textDet = segExtent * det;\n\n\t\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t\t}\n\n\t\t\t\treturn sqrDist;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\tvar t0 = tca - thc;\n\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\tvar t1 = tca + thc;\n\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t\t},\n\n\t\tdistanceToPlane: function ( plane ) {\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\t\treturn 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t\t// Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t :  null;\n\n\t\t},\n\n\t\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\t\tvar t = this.distanceToPlane( plane );\n\n\t\t\tif ( t === null ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn this.at( t, optionalTarget );\n\n\t\t},\n\n\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// check if the ray lies on the plane first\n\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\t\tif ( distToPoint === 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tintersectBox: function ( box, optionalTarget ) {\n\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\t\tvar origin = this.origin;\n\n\t\t\tif ( invdirx >= 0 ) {\n\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t\t} else {\n\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t\t}\n\n\t\t\tif ( invdiry >= 0 ) {\n\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t\t} else {\n\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\t\tif ( invdirz >= 0 ) {\n\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t\t} else {\n\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t\t//return point closest to the ray (positive side)\n\n\t\t\tif ( tmax < 0 ) return null;\n\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t\t},\n\n\t\tintersectsBox: ( function () {\n\n\t\t\tvar v = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectTriangle: function () {\n\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\tvar diff = new Vector3();\n\t\t\tvar edge1 = new Vector3();\n\t\t\tvar edge2 = new Vector3();\n\t\t\tvar normal = new Vector3();\n\n\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\tvar sign;\n\n\t\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\tsign = 1;\n\n\t\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\t\tsign = - 1;\n\t\t\t\t\tDdN = - DdN;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t\t// b1 < 0, no intersection\n\t\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t\t// b2 < 0, no intersection\n\t\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t\t// t < 0, no intersection\n\t\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Ray intersects triangle.\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix4: function ( matrix4 ) {\n\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\tthis.direction.sub( this.origin );\n\t\t\tthis.direction.normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( ray ) {\n\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Euler( x, y, z, order ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._order = order || Euler.DefaultOrder;\n\n\t}\n\n\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\n\tEuler.DefaultOrder = 'XYZ';\n\n\tEuler.prototype = {\n\n\t\tconstructor: Euler,\n\n\t\tisEuler: true,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget order () {\n\n\t\t\treturn this._order;\n\n\t\t},\n\n\t\tset order ( value ) {\n\n\t\t\tthis._order = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, order ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t\t},\n\n\t\tcopy: function ( euler ) {\n\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\t\tvar clamp = _Math.clamp;\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements;\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\torder = order || this._order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t\t}\n\n\t\t\tthis._order = order;\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromQuaternion: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromVector3: function ( v, order ) {\n\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t\t},\n\n\t\treorder: function () {\n\n\t\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t\tvar q = new Quaternion();\n\n\t\t\treturn function reorder( newOrder ) {\n\n\t\t\t\tq.setFromEuler( this );\n\n\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( euler ) {\n\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t\t},\n\n\t\tfromArray: function ( array ) {\n\n\t\t\tthis._x = array[ 0 ];\n\t\t\tthis._y = array[ 1 ];\n\t\t\tthis._z = array[ 2 ];\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._order;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoVector3: function ( optionalResult ) {\n\n\t\t\tif ( optionalResult ) {\n\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t\t} else {\n\n\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t\t}\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Layers() {\n\n\t\tthis.mask = 1;\n\n\t}\n\n\tLayers.prototype = {\n\n\t\tconstructor: Layers,\n\n\t\tset: function ( channel ) {\n\n\t\t\tthis.mask = 1 << channel;\n\n\t\t},\n\n\t\tenable: function ( channel ) {\n\n\t\t\tthis.mask |= 1 << channel;\n\n\t\t},\n\n\t\ttoggle: function ( channel ) {\n\n\t\t\tthis.mask ^= 1 << channel;\n\n\t\t},\n\n\t\tdisable: function ( channel ) {\n\n\t\t\tthis.mask &= ~ ( 1 << channel );\n\n\t\t},\n\n\t\ttest: function ( layers ) {\n\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author elephantatwork / www.elephantatwork.ch\n\t */\n\n\tfunction Object3D() {\n\n\t\tObject.defineProperty( this, 'id', { value: Object3DIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DefaultUp.clone();\n\n\t\tvar position = new Vector3();\n\t\tvar rotation = new Euler();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation.onChange( onRotationChange );\n\t\tquaternion.onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.userData = {};\n\n\t\tthis.onBeforeRender = function(){}; \n\t\tthis.onAfterRender = function(){};\n\n\t}\n\n\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\tObject3D.DefaultMatrixAutoUpdate = true;\n\n\tObject.assign( Object3D.prototype, EventDispatcher.prototype, {\n\n\t\tisObject3D: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t\t},\n\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t\t},\n\n\t\tsetRotationFromEuler: function ( euler ) {\n\n\t\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t\t},\n\n\t\tsetRotationFromMatrix: function ( m ) {\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t\t},\n\n\t\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t\t// assumes q is normalized\n\n\t\t\tthis.quaternion.copy( q );\n\n\t\t},\n\n\t\trotateOnAxis: function () {\n\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar q1 = new Quaternion();\n\n\t\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateOnAxis: function () {\n\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function translateX( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function translateY( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function translateZ( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlocalToWorld: function ( vector ) {\n\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t\t},\n\n\t\tworldToLocal: function () {\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function worldToLocal( vector ) {\n\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tadd: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( object === this ) {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( (object && object.isObject3D) ) {\n\n\t\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\t\tobject.parent.remove( object );\n\n\t\t\t\t}\n\n\t\t\t\tobject.parent = this;\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\t\tthis.children.push( object );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tremove: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar index = this.children.indexOf( object );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tobject.parent = null;\n\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetObjectById: function ( id ) {\n\n\t\t\treturn this.getObjectByProperty( 'id', id );\n\n\t\t},\n\n\t\tgetObjectByName: function ( name ) {\n\n\t\t\treturn this.getObjectByProperty( 'name', name );\n\n\t\t},\n\n\t\tgetObjectByProperty: function ( name, value ) {\n\n\t\t\tif ( this[ name ] === value ) return this;\n\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\t\tif ( object !== undefined ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t},\n\n\t\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t\t},\n\n\t\tgetWorldQuaternion: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar scale = new Vector3();\n\n\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Quaternion();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldRotation: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Euler();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldScale: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldDirection: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\traycast: function () {},\n\n\t\ttraverse: function ( callback ) {\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverse( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseVisible: function ( callback ) {\n\n\t\t\tif ( this.visible === false ) return;\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseAncestors: function ( callback ) {\n\n\t\t\tvar parent = this.parent;\n\n\t\t\tif ( parent !== null ) {\n\n\t\t\t\tcallback( parent );\n\n\t\t\t\tparent.traverseAncestors( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrix: function () {\n\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t\t},\n\n\t\tupdateMatrixWorld: function ( force ) {\n\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t\tforce = true;\n\n\t\t\t}\n\n\t\t\t// update children\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\t// meta is '' when called from JSON.stringify\n\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\t\tvar output = {};\n\n\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// standard Object3D serialization\n\n\t\t\tvar object = {};\n\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\n\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\tif ( this.visible === false ) object.visible = false;\n\n\t\t\tobject.matrix = this.matrix.toArray();\n\n\t\t\t//\n\n\t\t\tif ( this.geometry !== undefined ) {\n\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t\t}\n\n\t\t\tif ( this.material !== undefined ) {\n\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = this.material.uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( this.children.length > 0 ) {\n\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t\t}\n\n\t\t\toutput.object = object;\n\n\t\t\treturn output;\n\n\t\t\t// extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function ( recursive ) {\n\n\t\t\treturn new this.constructor().copy( this, recursive );\n\n\t\t},\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tif ( recursive === undefined ) recursive = true;\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.up.copy( source.up );\n\n\t\t\tthis.position.copy( source.position );\n\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\tthis.scale.copy( source.scale );\n\n\t\t\tthis.matrix.copy( source.matrix );\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\t\tthis.visible = source.visible;\n\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\tthis.add( child.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\tvar count$2 = 0;\n\tfunction Object3DIdCount() { return count$2++; }\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Line3( start, end ) {\n\n\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\n\t}\n\n\tLine3.prototype = {\n\n\t\tconstructor: Line3,\n\n\t\tset: function ( start, end ) {\n\n\t\t\tthis.start.copy( start );\n\t\t\tthis.end.copy( end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( line ) {\n\n\t\t\tthis.start.copy( line.start );\n\t\t\tthis.end.copy( line.end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tdelta: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.subVectors( this.end, this.start );\n\n\t\t},\n\n\t\tdistanceSq: function () {\n\n\t\t\treturn this.start.distanceToSquared( this.end );\n\n\t\t},\n\n\t\tdistance: function () {\n\n\t\t\treturn this.start.distanceTo( this.end );\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tclosestPointToPointParameter: function () {\n\n\t\t\tvar startP = new Vector3();\n\t\t\tvar startEnd = new Vector3();\n\n\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\t\tif ( clampToLine ) {\n\n\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t\treturn t;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\tthis.end.applyMatrix4( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( line ) {\n\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Triangle( a, b, c ) {\n\n\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n\t}\n\n\tTriangle.normal = function () {\n\n\t\tvar v0 = new Vector3();\n\n\t\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.subVectors( c, b );\n\t\t\tv0.subVectors( a, b );\n\t\t\tresult.cross( v0 );\n\n\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t\t}\n\n\t\t\treturn result.set( 0, 0, 0 );\n\n\t\t};\n\n\t}();\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tTriangle.barycoordFromPoint = function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\t\tv0.subVectors( c, a );\n\t\t\tv1.subVectors( b, a );\n\t\t\tv2.subVectors( point, a );\n\n\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\tvar dot12 = v1.dot( v2 );\n\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t// collinear or singular triangle\n\t\t\tif ( denom === 0 ) {\n\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t\t}\n\n\t\t\tvar invDenom = 1 / denom;\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t\t// barycentric coordinates must always sum to 1\n\t\t\treturn result.set( 1 - u - v, v, u );\n\n\t\t};\n\n\t}();\n\n\tTriangle.containsPoint = function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function containsPoint( point, a, b, c ) {\n\n\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t\t};\n\n\t}();\n\n\tTriangle.prototype = {\n\n\t\tconstructor: Triangle,\n\n\t\tset: function ( a, b, c ) {\n\n\t\t\tthis.a.copy( a );\n\t\t\tthis.b.copy( b );\n\t\t\tthis.c.copy( c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\tthis.c.copy( points[ i2 ] );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( triangle ) {\n\n\t\t\tthis.a.copy( triangle.a );\n\t\t\tthis.b.copy( triangle.b );\n\t\t\tthis.c.copy( triangle.c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tarea: function () {\n\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function area() {\n\n\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmidpoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t\t},\n\n\t\tnormal: function ( optionalTarget ) {\n\n\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tplane: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Plane();\n\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t\t},\n\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t\t},\n\n\t\tclosestPointToPoint: function () {\n\n\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\t\tif ( plane === undefined ) {\n\n\t\t\t\t\tplane = new Plane();\n\t\t\t\t\tedgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\t\t\tprojectedPoint = new Vector3();\n\t\t\t\t\tclosestPoint = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tvar minDistance = Infinity;\n\n\t\t\t\t// project the point onto the plane of the triangle\n\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t\t// check if the projection lies within the triangle\n\n\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t\t// if so, this is the closest point\n\n\t\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( triangle ) {\n\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.normal = (normal && normal.isVector3) ? normal : new Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\t\tthis.color = (color && color.isColor) ? color : new Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\t}\n\n\tFace3.prototype = {\n\n\t\tconstructor: Face3,\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.a = source.a;\n\t\t\tthis.b = source.b;\n\t\t\tthis.c = source.c;\n\n\t\t\tthis.normal.copy( source.normal );\n\t\t\tthis.color.copy( source.color );\n\n\t\t\tthis.materialIndex = source.materialIndex;\n\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  shading: THREE.SmoothShading,\n\t *  depthTest: <bool>,\n\t *  depthWrite: <bool>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>\n\t * }\n\t */\n\n\tfunction MeshBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\n\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferAttribute( array, itemSize, normalized ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized === true;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tBufferAttribute.prototype = {\n\n\t\tconstructor: BufferAttribute,\n\n\t\tisBufferAttribute: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.itemSize = source.itemSize;\n\t\t\tthis.count = source.count;\n\t\t\tthis.normalized = source.normalized;\n\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyArray: function ( array ) {\n\n\t\t\tthis.array.set( array );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyColorsArray: function ( colors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\tvar color = colors[ i ];\n\n\t\t\t\tif ( color === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\tcolor = new Color();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyIndicesArray: function ( indices ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tvar index = indices[ i ];\n\n\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector2sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector3sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector4sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize ];\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\t\tthis.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Int8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n\t}\n\n\tfunction Int16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int16Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint16Array( array ), itemSize );\n\n\t}\n\n\tfunction Int32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int32Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float64Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float64Array( array ), itemSize );\n\n\t}\n\n\t// Deprecated\n\n\tfunction DynamicBufferAttribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Geometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Geometry';\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\tthis.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = false;\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.lineDistancesNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( Geometry.prototype, EventDispatcher.prototype, {\n\n\t\tisGeometry: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\tthis.verticesNeedUpdate = true;\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfromBufferGeometry: function ( geometry ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tvar positions = attributes.position.array;\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\t\tvar tempNormals = [];\n\t\t\tvar tempUVs = [];\n\t\t\tvar tempUVs2 = [];\n\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\t\tscope.faces.push( face );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t\tvar center = this.boundingSphere.center;\n\t\t\tvar radius = this.boundingSphere.radius;\n\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\t\tvar matrix = new Matrix4();\n\t\t\tmatrix.set(\n\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\tthis.applyMatrix( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tvar face = this.faces[ f ];\n\n\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tface.normal.copy( cb );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\t\tvar v, vl, f, fl, face, vertices;\n\n\t\t\tvertices = new Array( this.vertices.length );\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ] = new Vector3();\n\n\t\t\t}\n\n\t\t\tif ( areaWeighted ) {\n\n\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\t\tvar vA, vB, vC;\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.computeFaceNormals();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ].normalize();\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeFlatVertexNormals: function () {\n\n\t\t\tvar f, fl, face;\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeMorphNormals: function () {\n\n\t\t\tvar i, il, f, fl, face;\n\n\t\t\t// save original normals\n\t\t\t// - create temp variables on first access\n\t\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\t\tvar tmpGeo = new Geometry();\n\t\t\ttmpGeo.faces = this.faces;\n\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\t// create on first access\n\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t\t// set vertices to morph target\n\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t\t// compute morph normals\n\n\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t\t// store morph normals\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore original normals\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeTangents: function () {\n\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t\t},\n\n\t\tcomputeLineDistances: function () {\n\n\t\t\tvar d = 0;\n\t\t\tvar vertices = this.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tif ( i > 0 ) {\n\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\t\tif ( (geometry && geometry.isGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\t\tif ( matrix !== undefined ) {\n\n\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\t\tvertices1.push( vertexCopy );\n\n\t\t\t}\n\n\t\t\t// colors\n\n\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\t\tfaces1.push( faceCopy );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\t\tif ( uv === undefined ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tuvs1.push( uvCopy );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmergeMesh: function ( mesh ) {\n\n\t\t\tif ( (mesh && mesh.isMesh) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t\t},\n\n\t\t/*\n\t\t * Checks for duplicate vertices with hashmap.\n\t\t * Duplicated vertices are removed\n\t\t * and faces' vertices are updated.\n\t\t */\n\n\t\tmergeVertices: function () {\n\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\tvar unique = [], changes = [];\n\n\t\t\tvar v, key;\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\tvar i, il, face;\n\t\t\tvar indices, j, jl;\n\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tv = this.vertices[ i ];\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t// have to remove them from the geometry.\n\t\t\tvar faceIndicesToRemove = [];\n\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tface = this.faces[ i ];\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\n\t\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t\tvar dupIndex = - 1;\n\n\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Use unique set of vertices\n\n\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\tthis.vertices = unique;\n\t\t\treturn diff;\n\n\t\t},\n\n\t\tsortFacesByMaterialIndex: function () {\n\n\t\t\tvar faces = this.faces;\n\t\t\tvar length = faces.length;\n\n\t\t\t// tag faces\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tfaces[ i ]._id = i;\n\n\t\t\t}\n\n\t\t\t// sort faces\n\n\t\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t}\n\n\t\t\tfaces.sort( materialIndexSort );\n\n\t\t\t// sort uvs\n\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\t\tvar newUvs1, newUvs2;\n\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tvar id = faces[ i ]._id;\n\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t\t}\n\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Geometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t\tvar faces = [];\n\t\t\tvar normals = [];\n\t\t\tvar normalsHash = {};\n\t\t\tvar colors = [];\n\t\t\tvar colorsHash = {};\n\t\t\tvar uvs = [];\n\t\t\tvar uvsHash = {};\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tvar hasMaterial = true;\n\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\t\tvar faceType = 0;\n\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\t\tfaces.push( faceType );\n\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\tfaces.push( face.materialIndex );\n\n\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t\t}\n\n\t\t\tfunction getNormalIndex( normal ) {\n\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getColorIndex( color ) {\n\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\tcolors.push( color.getHex() );\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getUvIndex( uv ) {\n\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tdata.data = {};\n\n\t\t\tdata.data.vertices = vertices;\n\t\t\tdata.data.normals = normals;\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\tdata.data.faces = faces;\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new Geometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.vertices = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\t\tthis.colors = [];\n\n\t\t\tvar vertices = source.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar colors = source.colors;\n\n\t\t\tfor ( var i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar faces = source.faces;\n\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tvar count$3 = 0;\n\tfunction GeometryIdCount() { return count$3++; }\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'DirectGeometry';\n\n\t\tthis.indices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( DirectGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tcomputeBoundingBox: Geometry.prototype.computeBoundingBox,\n\t\tcomputeBoundingSphere: Geometry.prototype.computeBoundingSphere,\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeGroups: function ( geometry ) {\n\n\t\t\tvar group;\n\t\t\tvar groups = [];\n\t\t\tvar materialIndex;\n\n\t\t\tvar faces = geometry.faces;\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// materials\n\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup = {\n\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( group !== undefined ) {\n\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\tgroups.push( group );\n\n\t\t\t}\n\n\t\t\tthis.groups = groups;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t\t// morphs\n\n\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\t\tvar morphTargetsPosition;\n\n\t\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\t\tmorphTargetsPosition = [];\n\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t\t}\n\n\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\t\tvar morphTargetsNormal;\n\n\t\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\t\tmorphTargetsNormal = [];\n\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\tvar skinWeights = geometry.skinWeights;\n\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t\t//\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar normal = face.normal;\n\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t\t}\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = face.color;\n\n\t\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// morphs\n\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t\t}\n\n\t\t\t\t// skins\n\n\t\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeGroups( geometry );\n\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t}\n\n\tObject.assign( BufferGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tisBufferGeometry: true,\n\n\t\tgetIndex: function () {\n\n\t\t\treturn this.index;\n\n\t\t},\n\n\t\tsetIndex: function ( index ) {\n\n\t\t\tthis.index = index;\n\n\t\t},\n\n\t\taddAttribute: function ( name, attribute ) {\n\n\t\t\tif ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( name === 'index' ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\tthis.setIndex( attribute );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.attributes[ name ] = attribute;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetAttribute: function ( name ) {\n\n\t\t\treturn this.attributes[ name ];\n\n\t\t},\n\n\t\tremoveAttribute: function ( name ) {\n\n\t\t\tdelete this.attributes[ name ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddGroup: function ( start, count, materialIndex ) {\n\n\t\t\tthis.groups.push( {\n\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t\t} );\n\n\t\t},\n\n\t\tclearGroups: function () {\n\n\t\t\tthis.groups = [];\n\n\t\t},\n\n\t\tsetDrawRange: function ( start, count ) {\n\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\n\t\t},\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar position = this.attributes.position;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tvar normal = this.attributes.normal;\n\n\t\t\tif ( normal !== undefined ) {\n\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\tnormal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isPoints) || (object && object.isLine) ) {\n\n\t\t\t\tvar positions = new Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\tvar colors = new Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\t\tvar lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( (object && object.isMesh) ) {\n\n\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateFromObject: function ( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isMesh) ) {\n\n\t\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\t\tdirect = undefined;\n\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( direct === undefined ) {\n\n\t\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t\tgeometry = direct;\n\n\t\t\t}\n\n\t\t\tvar attribute;\n\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.normal;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.color;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.uv;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\tthis.groups = geometry.groups;\n\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t\t},\n\n\t\tfromDirectGeometry: function ( geometry ) {\n\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t\t}\n\n\t\t\t// groups\n\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\t// morphs\n\n\t\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\t\tvar array = [];\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\t\tvar attribute = new Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t\t}\n\n\t\t\t// skinning\n\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\t\tvar skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\t\tvar skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position.array;\n\n\t\t\tif ( positions !== undefined ) {\n\n\t\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t\t} else {\n\n\t\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t\t}\n\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tvar box = new Box3();\n\t\t\tvar vector = new Vector3();\n\n\t\t\treturn function computeBoundingSphere() {\n\n\t\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t\t}\n\n\t\t\t\tvar positions = this.attributes.position;\n\n\t\t\t\tif ( positions ) {\n\n\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\tbox.getCenter( center );\n\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\t// backwards compatibility\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tvar index = this.index;\n\t\t\tvar attributes = this.attributes;\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( attributes.position ) {\n\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset existing normals to zero\n\n\t\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\tvar vA, vB, vC,\n\n\t\t\t\tpA = new Vector3(),\n\t\t\t\tpB = new Vector3(),\n\t\t\t\tpC = new Vector3(),\n\n\t\t\t\tcb = new Vector3(),\n\t\t\t\tab = new Vector3();\n\n\t\t\t\t// indexed elements\n\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.normalizeNormals();\n\n\t\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmerge: function ( geometry, offset ) {\n\n\t\t\tif ( (geometry && geometry.isBufferGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalizeNormals: function () {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\n\t\t\tvar x, y, z, n;\n\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\t\tx = normals[ i ];\n\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\tz = normals[ i + 2 ];\n\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\t\tnormals[ i ] *= n;\n\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoNonIndexed: function () {\n\n\t\t\tif ( this.index === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar geometry2 = new BufferGeometry();\n\n\t\t\tvar indices = this.index.array;\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\n\t\t\t}\n\n\t\t\treturn geometry2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard BufferGeometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tdata.data = { attributes: {} };\n\n\t\t\tvar index = this.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: array\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = this.boundingSphere;\n\n\t\t\tif ( boundingSphere !== null ) {\n\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new BufferGeometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tvar index = source.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.setIndex( index.clone() );\n\n\t\t\t}\n\n\t\t\tvar attributes = source.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t\t}\n\n\t\t\tvar groups = source.groups;\n\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tBufferGeometry.MaxIndex = 65535;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author jonobr1 / http://jonobr1.com/\n\t */\n\n\tfunction Mesh( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t\tthis.drawMode = TrianglesDrawMode;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Mesh,\n\n\t\tisMesh: true,\n\n\t\tsetDrawMode: function ( value ) {\n\n\t\t\tthis.drawMode = value;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.drawMode = source.drawMode;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateMorphTargets: function () {\n\n\t\t\tvar morphTargets = this.geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ morphTargets[ m ].name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\tvar vA = new Vector3();\n\t\t\tvar vB = new Vector3();\n\t\t\tvar vC = new Vector3();\n\n\t\t\tvar tempA = new Vector3();\n\t\t\tvar tempB = new Vector3();\n\t\t\tvar tempC = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tvar barycoord = new Vector3();\n\n\t\t\tvar intersectionPoint = new Vector3();\n\t\t\tvar intersectionPointWorld = new Vector3();\n\n\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\t\treturn uv1.clone();\n\n\t\t\t}\n\n\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\t\tvar intersect;\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersect === null ) return null;\n\n\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\t\treturn {\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\tobject: object\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t\t}\n\n\t\t\t\treturn intersection;\n\n\t\t\t}\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar material = this.material;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\tif ( material === undefined ) return;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\t// Check boundingBox before continuing\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t\t}\n\n\t\t\t\tvar uvs, intersection;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar a, b, c;\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\tvar isFaceMaterial = (material && material.isMultiMaterial);\n\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'BoxBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tvar scope = this;\n\n\t\t// segments\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\t\tvar numberOfVertices = 0;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// build each side of the box geometry\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount( w, h, d ) {\n\n\t\t\tvar vertices = 0;\n\n\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\t\treturn vertices;\n\n\t\t}\n\n\t\tfunction calculateIndexCount( w, h, d ) {\n\n\t\t\tvar index = 0;\n\n\t\t\t// calculate the amount of squares for each side\n\t\t\tindex += w * h * 2; // xy\n\t\t\tindex += w * d * 2; // xz\n\t\t\tindex += d * h * 2; // zy\n\n\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t\t}\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\tvar segmentHeight = height / gridY;\n\n\t\t\tvar widthHalf = width / 2;\n\t\t\tvar heightHalf = height / 2;\n\t\t\tvar depthHalf = depth / 2;\n\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\n\t\t\tvar vertexCounter = 0;\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// uvs\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PlaneBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tvar width_half = width / 2;\n\t\tvar height_half = height / 2;\n\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar segment_width = width / gridX;\n\t\tvar segment_height = height / gridY;\n\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\t\tvar offset = 0;\n\t\tvar offset2 = 0;\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segment_height - height_half;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\t\tvertices[ offset ] = x;\n\t\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\toffset += 3;\n\t\t\t\toffset2 += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\toffset = 0;\n\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices[ offset ] = a;\n\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\t\toffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction Camera() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\t\tthis.projectionMatrix = new Matrix4();\n\n\t}\n\n\tCamera.prototype = Object.create( Object3D.prototype );\n\tCamera.prototype.constructor = Camera;\n\n\tCamera.prototype.isCamera = true;\n\n\tCamera.prototype.getWorldDirection = function () {\n\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.lookAt = function () {\n\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.clone = function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t};\n\n\tCamera.prototype.copy = function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author greggman / http://games.greggman.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author tschw\n\t */\n\n\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near !== undefined ? near : 0.1;\n\t\tthis.far = far !== undefined ? far : 2000;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: PerspectiveCamera,\n\n\t\tisPerspectiveCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\t\tsetFocalLength: function ( focalLength ) {\n\n\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\t\tgetFocalLength: function () {\n\n\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t\t},\n\n\t\tgetEffectiveFOV: function () {\n\n\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t\t},\n\n\t\tgetFilmWidth: function () {\n\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t\t},\n\n\t\tgetFilmHeight: function () {\n\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t\t},\n\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *   +---+---+---+\n\t\t *   | A | B | C |\n\t\t *   +---+---+---+\n\t\t *   | D | E | F |\n\t\t *   +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *   var w = 1920;\n\t\t *   var h = 1080;\n\t\t *   var fullWidth = w * 3;\n\t\t *   var fullHeight = h * 2;\n\t\t *\n\t\t *   --A--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *   --B--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *   --C--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *   --D--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *   --E--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *   --F--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar near = this.near,\n\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\theight = 2 * top,\n\t\t\t\twidth = this.aspect * height,\n\t\t\t\tleft = - 0.5 * width,\n\t\t\t\tview = this.view;\n\n\t\t\tif ( view !== null ) {\n\n\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\n\t\t\t}\n\n\t\t\tvar skew = this.filmOffset;\n\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\n\t\t\tdata.object.aspect = this.aspect;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author arose / http://github.com/arose\n\t */\n\n\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: OrthographicCamera,\n\n\t\tisOrthographicCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\t\tvar left = cx - dx;\n\t\t\tvar right = cx + dx;\n\t\t\tvar top = cy + dy;\n\t\t\tvar bottom = cy - dy;\n\n\t\t\tif ( this.view !== null ) {\n\n\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t\t}\n\n\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tvar type, size;\n\n\t\tfunction setIndex( index ) {\n\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t\tsize = 4;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\tsize = 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawElements( mode, count, type, start * size );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry, start, count ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tsetMode: setMode,\n\t\t\tsetIndex: setIndex,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar position = geometry.attributes.position;\n\n\t\t\tvar count = 0;\n\n\t\t\tif ( (position && position.isInterleavedBufferAttribute) ) {\n\n\t\t\t\tcount = position.data.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t} else {\n\n\t\t\t\tcount = position.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t}\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\t\t\tsetMode: setMode,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLLights() {\n\n\t\tvar lights = {};\n\n\t\treturn {\n\n\t\t\tget: function ( light ) {\n\n\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\t\treturn lights[ light.id ];\n\n\t\t\t\t}\n\n\t\t\t\tvar uniforms;\n\n\t\t\t\tswitch ( light.type ) {\n\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\t\treturn uniforms;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\tfunction WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material.isRawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\t\t\t'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( ! material.isShaderMaterial ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLPrograms( renderer, capabilities ) {\n\n\t\tvar programs = [];\n\n\t\tvar shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points'\n\t\t};\n\n\t\tvar parameterNames = [\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\"\n\t\t];\n\n\n\t\tfunction allocateBones( object ) {\n\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\t\treturn 1024;\n\n\t\t\t} else {\n\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//    (up to 54 should be safe)\n\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\t\tif ( object !== undefined && (object && object.isSkinnedMesh) ) {\n\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn maxBones;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\t\tvar encoding;\n\n\t\t\tif ( ! map ) {\n\n\t\t\t\tencoding = LinearEncoding;\n\n\t\t\t} else if ( (map && map.isTexture) ) {\n\n\t\t\t\tencoding = map.encoding;\n\n\t\t\t} else if ( (map && map.isWebGLRenderTarget) ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\tencoding = map.texture.encoding;\n\n\t\t\t}\n\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\t\tencoding = GammaEncoding;\n\n\t\t\t}\n\n\t\t\treturn encoding;\n\n\t\t}\n\n\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {\n\n\t\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\n\t\t\tvar maxBones = allocateBones( object );\n\t\t\tvar precision = renderer.getPrecision();\n\n\t\t\tif ( material.precision !== null ) {\n\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\t\tvar parameters = {\n\n\t\t\t\tshaderID: shaderID,\n\n\t\t\t\tprecision: precision,\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\tmap: !! material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\t\tcombine: material.combine,\n\n\t\t\t\tvertexColors: material.vertexColors,\n\n\t\t\t\tfog: !! fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp: (fog && fog.isFogExp2),\n\n\t\t\t\tflatShading: material.shading === FlatShading,\n\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\t\tskinning: material.skinning,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\tnumClipIntersection: nClipIntersection,\n\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\tflipSided: material.side === BackSide,\n\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t\t};\n\n\t\t\treturn parameters;\n\n\t\t};\n\n\t\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\t\tvar array = [];\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tarray.push( parameters.shaderID );\n\n\t\t\t} else {\n\n\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\tarray.push( material.vertexShader );\n\n\t\t\t}\n\n\t\t\tif ( material.defines !== undefined ) {\n\n\t\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\t\tarray.push( name );\n\t\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t\t}\n\n\t\t\treturn array.join();\n\n\t\t};\n\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\t\tvar program;\n\n\t\t\t// Check if code has been already compiled\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\t\tvar programInfo = programs[ p ];\n\n\t\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t++ program.usedTimes;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tprogram = new WebGLProgram( renderer, code, material, parameters );\n\t\t\t\tprograms.push( program );\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t};\n\n\t\tthis.releaseProgram = function( program ) {\n\n\t\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t\t// Remove from unordered set\n\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\tprograms.pop();\n\n\t\t\t\t// Free WebGL resources\n\t\t\t\tprogram.destroy();\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tthis.programs = programs;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLGeometries( gl, properties, info ) {\n\n\t\tvar geometries = {};\n\n\t\tfunction onGeometryDispose( event ) {\n\n\t\t\tvar geometry = event.target;\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t\t}\n\n\t\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\t\tdelete geometries[ geometry.id ];\n\n\t\t\t// TODO\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe ) {\n\n\t\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( geometry );\n\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( buffergeometry );\n\n\t\t\t//\n\n\t\t\tinfo.memory.geometries --;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction deleteAttribute( attribute ) {\n\n\t\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\t\tif ( buffer !== undefined ) {\n\n\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction deleteAttributes( attributes ) {\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tproperties.delete( attribute.data );\n\n\t\t\t} else {\n\n\t\t\t\tproperties.delete( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\t\t\treturn geometries[ geometry.id ];\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\t\t\tvar buffergeometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tbuffergeometry = geometry;\n\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t\t\t}\n\n\t\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\t\t\tinfo.memory.geometries ++;\n\n\t\t\t\treturn buffergeometry;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLObjects( gl, properties, info ) {\n\n\t\tvar geometries = new WebGLGeometries( gl, properties, info );\n\n\t\t//\n\n\t\tfunction update( object ) {\n\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\t\tvar geometry = geometries.get( object );\n\n\t\t\tif ( object.geometry.isGeometry ) {\n\n\t\t\t\tgeometry.updateFromObject( object );\n\n\t\t\t}\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var name in morphAttributes ) {\n\n\t\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\t\tvar data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\t\tvar attributeProperties = properties.get( data );\n\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tif ( data.dynamic === false ) {\n\n\t\t\t\tgl.bufferData( bufferType, data.array, gl.STATIC_DRAW );\n\n\t\t\t} else if ( data.updateRange.count === - 1 ) {\n\n\t\t\t\t// Not using update ranges\n\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t\t}\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction getWireframeAttribute( geometry ) {\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\t\treturn property.wireframe;\n\n\t\t\t}\n\n\t\t\tvar indices = [];\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\t\tvar position = attributes.position;\n\n\t\t\t// console.time( 'wireframe' );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar edges = {};\n\t\t\t\tvar array = index.array;\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar array = attributes.position.array;\n\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\tvar c = i + 2;\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// console.timeEnd( 'wireframe' );\n\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar attribute = new BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\tproperty.wireframe = attribute;\n\n\t\t\treturn attribute;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tgetAttributeBuffer: getAttributeBuffer,\n\t\t\tgetWireframeAttribute: getWireframeAttribute,\n\n\t\t\tupdate: update\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\t\tvar _infoMemory = info.memory;\n\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t\t//\n\n\t\tfunction clampToMaxSize( image, maxSize ) {\n\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t// premultiplied alpha.\n\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\n\t\t}\n\n\t\tfunction makePowerOfTwo( image ) {\n\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = _Math.nearestPowerOfTwo( image.width );\n\t\t\t\tcanvas.height = _Math.nearestPowerOfTwo( image.height );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Fallback filters for non-power-of-2 textures\n\n\t\tfunction filterFallback( f ) {\n\n\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\n\t\t\t\treturn _gl.NEAREST;\n\n\t\t\t}\n\n\t\t\treturn _gl.LINEAR;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction onTextureDispose( event ) {\n\n\t\t\tvar texture = event.target;\n\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\t\tdeallocateTexture( texture );\n\n\t\t\t_infoMemory.textures --;\n\n\n\t\t}\n\n\t\tfunction onRenderTargetDispose( event ) {\n\n\t\t\tvar renderTarget = event.target;\n\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t\t_infoMemory.textures --;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction deallocateTexture( texture ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t\t} else {\n\n\t\t\t\t// 2D texture\n\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\t// remove all webgl properties\n\t\t\tproperties.delete( texture );\n\n\t\t}\n\n\t\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\tif ( ! renderTarget ) return;\n\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t\t}\n\n\t\t\tproperties.delete( renderTarget.texture );\n\t\t\tproperties.delete( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\n\n\t\tfunction setTexture2D( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tvar image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureCube( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image.length === 6 ) {\n\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\t\tvar isCompressed = (texture && texture.isCompressedTexture);\n\t\t\t\t\tvar isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);\n\n\t\t\t\t\tvar cubeImage = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension ) {\n\n\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\t\timage = makePowerOfTwo( image );\n\n\t\t\t}\n\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\tif ( (texture && texture.isDepthTexture) ) {\n\n\t\t\t\t// populate depth texture with dummy data\n\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\t}\n\n\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\n\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\n\t\t\t\t}\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t} else if ( (texture && texture.isDataTexture) ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( (texture && texture.isCompressedTexture) ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\t// Render targets\n\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else {\n\n\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t}\n\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {\n\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t\t}\n\n\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\n\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error('Unknown depthTexture format')\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup GL resources for a non-texture depth buffer\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Set up GL resources for the render target\n\t\tfunction setupRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t\t// Setup framebuffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t\t// Setup color buffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t// Setup depth and stencil buffers\n\n\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\t\tvar texture = renderTarget.texture;\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\ttexture.minFilter !== NearestFilter &&\n\t\t\t\t\ttexture.minFilter !== LinearFilter ) {\n\n\t\t\t\tvar target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\tstate.bindTexture( target, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n\t}\n\n\t/**\n\t * @author fordacious / fordacious.github.io\n\t */\n\n\tfunction WebGLProperties() {\n\n\t\tvar properties = {};\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar uuid = object.uuid;\n\t\t\t\tvar map = properties[ uuid ];\n\n\t\t\t\tif ( map === undefined ) {\n\n\t\t\t\t\tmap = {};\n\t\t\t\t\tproperties[ uuid ] = map;\n\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\n\t\t\t},\n\n\t\t\tdelete: function ( object ) {\n\n\t\t\t\tdelete properties[ object.uuid ];\n\n\t\t\t},\n\n\t\t\tclear: function () {\n\n\t\t\t\tproperties = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLState( gl, extensions, paramThreeToGL ) {\n\n\t\tfunction ColorBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar color = new Vector4();\n\t\t\tvar currentColorMask = null;\n\t\t\tvar currentColorClear = new Vector4();\n\n\t\t\treturn {\n\n\t\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( r, g, b, a ) {\n\n\t\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\tcurrentColorClear.set( 0, 0, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction DepthBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentDepthMask = null;\n\t\t\tvar currentDepthFunc = null;\n\t\t\tvar currentDepthClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction StencilBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentStencilMask = null;\n\t\t\tvar currentStencilFunc = null;\n\t\t\tvar currentStencilRef = null;\n\t\t\tvar currentStencilFuncMask = null;\n\t\t\tvar currentStencilFail  = null;\n\t\t\tvar currentStencilZFail = null;\n\t\t\tvar currentStencilZPass = null;\n\t\t\tvar currentStencilClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tvar colorBuffer = new ColorBuffer();\n\t\tvar depthBuffer = new DepthBuffer();\n\t\tvar stencilBuffer = new StencilBuffer();\n\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\t\tvar capabilities = {};\n\n\t\tvar compressedTextureFormats = null;\n\n\t\tvar currentBlending = null;\n\t\tvar currentBlendEquation = null;\n\t\tvar currentBlendSrc = null;\n\t\tvar currentBlendDst = null;\n\t\tvar currentBlendEquationAlpha = null;\n\t\tvar currentBlendSrcAlpha = null;\n\t\tvar currentBlendDstAlpha = null;\n\t\tvar currentPremultipledAlpha = false;\n\n\t\tvar currentFlipSided = null;\n\t\tvar currentCullFace = null;\n\n\t\tvar currentLineWidth = null;\n\n\t\tvar currentPolygonOffsetFactor = null;\n\t\tvar currentPolygonOffsetUnits = null;\n\n\t\tvar currentScissorTest = null;\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\t\tvar currentTextureSlot = null;\n\t\tvar currentBoundTextures = {};\n\n\t\tvar currentScissor = new Vector4();\n\t\tvar currentViewport = new Vector4();\n\n\t\tfunction createTexture( type, target, count ) {\n\n\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\tvar texture = gl.createTexture();\n\n\t\t\tgl.bindTexture( type, texture );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tvar emptyTextures = {};\n\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t\t//\n\n\t\tfunction init() {\n\n\t\t\tclearColor( 0, 0, 0, 1 );\n\t\t\tclearDepth( 1 );\n\t\t\tclearStencil( 0 );\n\n\t\t\tenable( gl.DEPTH_TEST );\n\t\t\tsetDepthFunc( LessEqualDepth );\n\n\t\t\tsetFlipSided( false );\n\t\t\tsetCullFace( CullFaceBack );\n\t\t\tenable( gl.CULL_FACE );\n\n\t\t\tenable( gl.BLEND );\n\t\t\tsetBlending( NormalBlending );\n\n\t\t}\n\n\t\tfunction initAttributes() {\n\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tnewAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttribute( attribute ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disableUnusedAttributes() {\n\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\t\tgl.enable( id );\n\t\t\t\tcapabilities[ id ] = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\t\tgl.disable( id );\n\t\t\t\tcapabilities[ id ] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getCompressedTextureFormats() {\n\n\t\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\t\tcompressedTextureFormats = [];\n\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn compressedTextureFormats;\n\n\t\t}\n\n\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\t\tif ( blending !== NoBlending ) {\n\n\t\t\t\tenable( gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.BLEND );\n\n\t\t\t}\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( blending === AdditiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === SubtractiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === MultiplyBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blending === CustomBlending ) {\n\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t\t}\n\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction setColorWrite( colorWrite ) {\n\n\t\t\tcolorBuffer.setMask( colorWrite );\n\n\t\t}\n\n\t\tfunction setDepthTest( depthTest ) {\n\n\t\t\tdepthBuffer.setTest( depthTest );\n\n\t\t}\n\n\t\tfunction setDepthWrite( depthWrite ) {\n\n\t\t\tdepthBuffer.setMask( depthWrite );\n\n\t\t}\n\n\t\tfunction setDepthFunc( depthFunc ) {\n\n\t\t\tdepthBuffer.setFunc( depthFunc );\n\n\t\t}\n\n\t\tfunction setStencilTest( stencilTest ) {\n\n\t\t\tstencilBuffer.setTest( stencilTest );\n\n\t\t}\n\n\t\tfunction setStencilWrite( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( stencilWrite );\n\n\t\t}\n\n\t\tfunction setStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\tstencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t}\n\n\t\tfunction setStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\tstencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction setFlipSided( flipSided ) {\n\n\t\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\t\tif ( flipSided ) {\n\n\t\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFlipSided = flipSided;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setCullFace( cullFace ) {\n\n\t\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\t\tenable( gl.CULL_FACE );\n\n\t\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\tcurrentCullFace = cullFace;\n\n\t\t}\n\n\t\tfunction setLineWidth( width ) {\n\n\t\t\tif ( width !== currentLineWidth ) {\n\n\t\t\t\tgl.lineWidth( width );\n\n\t\t\t\tcurrentLineWidth = width;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\t\tif ( polygonOffset ) {\n\n\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getScissorTest() {\n\n\t\t\treturn currentScissorTest;\n\n\t\t}\n\n\t\tfunction setScissorTest( scissorTest ) {\n\n\t\t\tcurrentScissorTest = scissorTest;\n\n\t\t\tif ( scissorTest ) {\n\n\t\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// texture\n\n\t\tfunction activeTexture( webglSlot ) {\n\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\tactiveTexture();\n\n\t\t\t}\n\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\t\tif ( boundTexture === undefined ) {\n\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t\t}\n\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction compressedTexImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction texImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction clearColor( r, g, b, a ) {\n\n\t\t\tcolorBuffer.setClear( r, g, b, a );\n\n\t\t}\n\n\t\tfunction clearDepth( depth ) {\n\n\t\t\tdepthBuffer.setClear( depth );\n\n\t\t}\n\n\t\tfunction clearStencil( stencil ) {\n\n\t\t\tstencilBuffer.setClear( stencil );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction scissor( scissor ) {\n\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\tcurrentScissor.copy( scissor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction viewport( viewport ) {\n\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\tcurrentViewport.copy( viewport );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction reset() {\n\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcapabilities = {};\n\n\t\t\tcompressedTextureFormats = null;\n\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\n\t\t\tcurrentBlending = null;\n\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\n\t\t\tcolorBuffer.reset();\n\t\t\tdepthBuffer.reset();\n\t\t\tstencilBuffer.reset();\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tbuffers: {\n\t\t\t\tcolor: colorBuffer,\n\t\t\t\tdepth: depthBuffer,\n\t\t\t\tstencil: stencilBuffer\n\t\t\t},\n\n\t\t\tinit: init,\n\t\t\tinitAttributes: initAttributes,\n\t\t\tenableAttribute: enableAttribute,\n\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\tenable: enable,\n\t\t\tdisable: disable,\n\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\n\t\t\tsetBlending: setBlending,\n\n\t\t\tsetColorWrite: setColorWrite,\n\t\t\tsetDepthTest: setDepthTest,\n\t\t\tsetDepthWrite: setDepthWrite,\n\t\t\tsetDepthFunc: setDepthFunc,\n\t\t\tsetStencilTest: setStencilTest,\n\t\t\tsetStencilWrite: setStencilWrite,\n\t\t\tsetStencilFunc: setStencilFunc,\n\t\t\tsetStencilOp: setStencilOp,\n\n\t\t\tsetFlipSided: setFlipSided,\n\t\t\tsetCullFace: setCullFace,\n\n\t\t\tsetLineWidth: setLineWidth,\n\t\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\t\tgetScissorTest: getScissorTest,\n\t\t\tsetScissorTest: setScissorTest,\n\n\t\t\tactiveTexture: activeTexture,\n\t\t\tbindTexture: bindTexture,\n\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\ttexImage2D: texImage2D,\n\n\t\t\tclearColor: clearColor,\n\t\t\tclearDepth: clearDepth,\n\t\t\tclearStencil: clearStencil,\n\n\t\t\tscissor: scissor,\n\t\t\tviewport: viewport,\n\n\t\t\treset: reset\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\t\tvar maxAnisotropy;\n\n\t\tfunction getMaxAnisotropy() {\n\n\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t\t} else {\n\n\t\t\t\tmaxAnisotropy = 0;\n\n\t\t\t}\n\n\t\t\treturn maxAnisotropy;\n\n\t\t}\n\n\t\tfunction getMaxPrecision( precision ) {\n\n\t\t\tif ( precision === 'highp' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'highp';\n\n\t\t\t\t}\n\n\t\t\t\tprecision = 'mediump';\n\n\t\t\t}\n\n\t\t\tif ( precision === 'mediump' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'mediump';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn 'lowp';\n\n\t\t}\n\n\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tvar maxPrecision = getMaxPrecision( precision );\n\n\t\tif ( maxPrecision !== precision ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\tprecision = maxPrecision;\n\n\t\t}\n\n\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\t\treturn {\n\n\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\t\tprecision: precision,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tmaxTextures: maxTextures,\n\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\t\tmaxAttributes: maxAttributes,\n\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\tmaxVaryings: maxVaryings,\n\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\t\tvertexTextures: vertexTextures,\n\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\tfloatVertexTextures: floatVertexTextures\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLExtensions( gl ) {\n\n\t\tvar extensions = {};\n\n\t\treturn {\n\n\t\t\tget: function ( name ) {\n\n\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\t\t\treturn extensions[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tvar extension;\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\textension = gl.getExtension( name );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\textensions[ name ] = extension;\n\n\t\t\t\treturn extension;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction WebGLClipping() {\n\n\t\tvar scope = this,\n\n\t\t\tglobalState = null,\n\t\t\tnumGlobalPlanes = 0,\n\t\t\tlocalClippingEnabled = false,\n\t\t\trenderingShadows = false,\n\n\t\t\tplane = new Plane(),\n\t\t\tviewNormalMatrix = new Matrix3(),\n\n\t\t\tuniform = { value: null, needsUpdate: false };\n\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\tthis.numIntersection = 0;\n\n\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\t\tvar enabled =\n\t\t\t\tplanes.length !== 0 ||\n\t\t\t\tenableLocalClipping ||\n\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\tlocalClippingEnabled;\n\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\tnumGlobalPlanes = planes.length;\n\n\t\t\treturn enabled;\n\n\t\t};\n\n\t\tthis.beginShadows = function() {\n\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes( null );\n\n\t\t};\n\n\t\tthis.endShadows = function() {\n\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\n\t\t};\n\n\t\tthis.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t// there's no local clipping\n\n\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t// there's no global clipping\n\n\t\t\t\t\tprojectPlanes( null );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\tthis.numPlanes += nGlobal;\n\n\t\t\t}\n\n\n\t\t};\n\n\t\tfunction resetGlobalState() {\n\n\t\t\tif ( uniform.value !== globalState ) {\n\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\tscope.numIntersection = 0;\n\n\t\t}\n\n\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\tdstArray = null;\n\n\t\t\tif ( nPlanes !== 0 ) {\n\n\t\t\t\tdstArray = uniform.value;\n\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\t\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t * @author tschw\n\t */\n\n\tfunction WebGLRenderer( parameters ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\n\t\tparameters = parameters || {};\n\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\t\tvar lights = [];\n\n\t\tvar opaqueObjects = [];\n\t\tvar opaqueObjectsLastIndex = - 1;\n\t\tvar transparentObjects = [];\n\t\tvar transparentObjectsLastIndex = - 1;\n\n\t\tvar morphInfluences = new Float32Array( 8 );\n\n\t\tvar sprites = [];\n\t\tvar lensFlares = [];\n\n\t\t// public properties\n\n\t\tthis.domElement = _canvas;\n\t\tthis.context = null;\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\tthis.gammaInput = false;\n\t\tthis.gammaOutput = false;\n\n\t\t// physical lights\n\n\t\tthis.physicallyCorrectLights = false;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = LinearToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\t\tthis.toneMappingWhitePoint = 1.0;\n\n\t\t// morphs\n\n\t\tthis.maxMorphTargets = 8;\n\t\tthis.maxMorphNormals = 4;\n\n\t\t// internal properties\n\n\t\tvar _this = this,\n\n\t\t// internal state cache\n\n\t\t_currentProgram = null,\n\t\t_currentRenderTarget = null,\n\t\t_currentFramebuffer = null,\n\t\t_currentMaterialId = - 1,\n\t\t_currentGeometryProgram = '',\n\t\t_currentCamera = null,\n\n\t\t_currentScissor = new Vector4(),\n\t\t_currentScissorTest = null,\n\n\t\t_currentViewport = new Vector4(),\n\n\t\t//\n\n\t\t_usedTextureUnits = 0,\n\n\t\t//\n\n\t\t_clearColor = new Color( 0x000000 ),\n\t\t_clearAlpha = 0,\n\n\t\t_width = _canvas.width,\n\t\t_height = _canvas.height,\n\n\t\t_pixelRatio = 1,\n\n\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t_scissorTest = false,\n\n\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\n\t\t// frustum\n\n\t\t_frustum = new Frustum(),\n\n\t\t// clipping\n\n\t\t_clipping = new WebGLClipping(),\n\t\t_clippingEnabled = false,\n\t\t_localClippingEnabled = false,\n\n\t\t_sphere = new Sphere(),\n\n\t\t// camera matrices cache\n\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_vector3 = new Vector3(),\n\n\t\t// light arrays cache\n\n\t\t_lights = {\n\n\t\t\thash: '',\n\n\t\t\tambient: [ 0, 0, 0 ],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\tpoint: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: [],\n\n\t\t\tshadows: []\n\n\t\t},\n\n\t\t// info\n\n\t\t_infoRender = {\n\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\n\t\t};\n\n\t\tthis.info = {\n\n\t\t\trender: _infoRender,\n\t\t\tmemory: {\n\n\t\t\t\tgeometries: 0,\n\t\t\t\ttextures: 0\n\n\t\t\t},\n\t\t\tprograms: null\n\n\t\t};\n\n\n\t\t// initialize\n\n\t\tvar _gl;\n\n\t\ttry {\n\n\t\t\tvar attributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t};\n\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t\t}\n\n\t\tvar extensions = new WebGLExtensions( _gl );\n\n\t\textensions.get( 'WEBGL_depth_texture' );\n\t\textensions.get( 'OES_texture_float' );\n\t\textensions.get( 'OES_texture_float_linear' );\n\t\textensions.get( 'OES_texture_half_float' );\n\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\textensions.get( 'OES_standard_derivatives' );\n\t\textensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\tBufferGeometry.MaxIndex = 4294967296;\n\n\t\t}\n\n\t\tvar capabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\tvar state = new WebGLState( _gl, extensions, paramThreeToGL );\n\t\tvar properties = new WebGLProperties();\n\t\tvar textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\tvar objects = new WebGLObjects( _gl, properties, this.info );\n\t\tvar programCache = new WebGLPrograms( this, capabilities );\n\t\tvar lightCache = new WebGLLights();\n\n\t\tthis.info.programs = programCache.programs;\n\n\t\tvar bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\tvar indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t\t//\n\n\t\tvar backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\tvar backgroundCamera2 = new PerspectiveCamera();\n\t\tvar backgroundPlaneMesh = new Mesh(\n\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t);\n\t\tvar backgroundBoxShader = ShaderLib[ 'cube' ];\n\t\tvar backgroundBoxMesh = new Mesh(\n\t\t\tnew BoxBufferGeometry( 5, 5, 5 ),\n\t\t\tnew ShaderMaterial( {\n\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tfog: false\n\t\t\t} )\n\t\t);\n\n\t\t//\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\tfunction glClearColor( r, g, b, a ) {\n\n\t\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t}\n\n\t\t\tstate.clearColor( r, g, b, a );\n\n\t\t}\n\n\t\tfunction setDefaultGLState() {\n\n\t\t\tstate.init();\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t}\n\n\t\tfunction resetGLState() {\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\n\t\t\tstate.reset();\n\n\t\t}\n\n\t\tsetDefaultGLState();\n\n\t\tthis.context = _gl;\n\t\tthis.capabilities = capabilities;\n\t\tthis.extensions = extensions;\n\t\tthis.properties = properties;\n\t\tthis.state = state;\n\n\t\t// shadow map\n\n\t\tvar shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );\n\n\t\tthis.shadowMap = shadowMap;\n\n\n\t\t// Plugins\n\n\t\tvar spritePlugin = new SpritePlugin( this, sprites );\n\t\tvar lensFlarePlugin = new LensFlarePlugin( this, lensFlares );\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t\t};\n\n\t\tthis.getMaxAnisotropy = function () {\n\n\t\t\treturn capabilities.getMaxAnisotropy();\n\n\t\t};\n\n\t\tthis.getPrecision = function () {\n\n\t\t\treturn capabilities.precision;\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t\t};\n\n\t\tthis.getSize = function () {\n\n\t\t\treturn {\n\t\t\t\twidth: _width,\n\t\t\t\theight: _height\n\t\t\t};\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t_canvas.height = height * _pixelRatio;\n\n\t\t\tif ( updateStyle !== false ) {\n\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function () {\n\n\t\t\treturn _clearColor;\n\n\t\t};\n\n\t\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t\t_clearColor.set( color );\n\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn _clearAlpha;\n\n\t\t};\n\n\t\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t\t_clearAlpha = alpha;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.clear = function ( color, depth, stencil ) {\n\n\t\t\tvar bits = 0;\n\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\tthis.clear( color, depth, stencil );\n\n\t\t};\n\n\t\t// Reset\n\n\t\tthis.resetGLState = resetGLState;\n\n\t\tthis.dispose = function() {\n\n\t\t\ttransparentObjects = [];\n\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\topaqueObjects = [];\n\t\t\topaqueObjectsLastIndex = -1;\n\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tresetGLState();\n\t\t\tsetDefaultGLState();\n\n\t\t\tproperties.clear();\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tvar material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\tproperties.delete( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReference( material ) {\n\n\t\t\tvar programInfo = properties.get( material ).program;\n\n\t\t\tmaterial.program = undefined;\n\n\t\t\tif ( programInfo !== undefined ) {\n\n\t\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar buffers = properties.get( object );\n\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( object.hasPositions ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasNormals ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t     ! material.isMeshStandardMaterial &&\n\t\t\t\t       material.shading === FlatShading ) {\n\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\t\tobject.count = 0;\n\n\t\t};\n\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\t\tsetMaterial( material );\n\n\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\tvar updateBuffers = false;\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\t\tvar activeInfluences = [];\n\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t\t}\n\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t\t}\n\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {\n\n\t\t\t\t\tmorphInfluences[ i ] = 0.0;\n\n\t\t\t\t}\n\n\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar position = geometry.attributes.position;\n\t\t\tvar rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\tvar renderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( index );\n\n\t\t\t} else {\n\n\t\t\t\trenderer = bufferRenderer;\n\n\t\t\t}\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar dataCount = 0;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdataCount = index.count;\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\tdataCount = position.count;\n\n\t\t\t}\n\n\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t\tif ( drawCount === 0 ) return;\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t}\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t\tvar programAttributes = program.getAttributes();\n\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\t\tfor ( var name in programAttributes ) {\n\n\t\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\t\tconsole.warn( \"Unsupported data buffer format: Float64Array\" );\n\n\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t}\n\n\t\t// Sorting\n\n\t\tfunction absNumericalSort( a, b ) {\n\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\n\t\t\t\treturn a.material.program.id - b.material.program.id;\n\n\t\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\t\treturn a.material.id - b.material.id;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn a.z - b.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction reversePainterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// reset caching for this frame\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\tlights.length = 0;\n\n\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\ttransparentObjectsLastIndex = - 1;\n\n\t\t\tsprites.length = 0;\n\t\t\tlensFlares.length = 0;\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\t\tprojectObject( scene, camera );\n\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\t\tsetupShadows( lights );\n\n\t\t\tshadowMap.render( scene, camera );\n\n\t\t\tsetupLights( lights, camera );\n\n\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t\t//\n\n\t\t\t_infoRender.calls = 0;\n\t\t\t_infoRender.vertices = 0;\n\t\t\t_infoRender.faces = 0;\n\t\t\t_infoRender.points = 0;\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\trenderTarget = null;\n\n\t\t\t}\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t\t//\n\n\t\t\tvar background = scene.background;\n\n\t\t\tif ( background === null ) {\n\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t\t} else if ( background && background.isColor ) {\n\n\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\t\t\tforceClear = true;\n\n\t\t\t}\n\n\t\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t\t}\n\n\t\t\tif ( background && background.isCubeTexture ) {\n\n\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t\tobjects.update( backgroundBoxMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t\t} else if ( background && background.isTexture ) {\n\n\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t\tobjects.update( backgroundPlaneMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.overrideMaterial ) {\n\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\t\trenderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\trenderObjects( transparentObjects, scene, camera, overrideMaterial );\n\n\t\t\t} else {\n\n\t\t\t\t// opaque pass (front-to-back order)\n\n\t\t\t\tstate.setBlending( NoBlending );\n\t\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\t\t// transparent pass (back-to-front order)\n\n\t\t\t\trenderObjects( transparentObjects, scene, camera );\n\n\t\t\t}\n\n\t\t\t// custom render plugins (post pass)\n\n\t\t\tspritePlugin.render( scene, camera );\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t\t}\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.setDepthTest( true );\n\t\t\tstate.setDepthWrite( true );\n\t\t\tstate.setColorWrite( true );\n\n\t\t\t// _gl.finish();\n\n\t\t};\n\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\t\tvar array, index;\n\n\t\t\t// allocate the next position in the appropriate array\n\n\t\t\tif ( material.transparent ) {\n\n\t\t\t\tarray = transparentObjects;\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t\t} else {\n\n\t\t\t\tarray = opaqueObjects;\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t\t}\n\n\t\t\t// recycle existing render item or grow the array\n\n\t\t\tvar renderItem = array[ index ];\n\n\t\t\tif ( renderItem !== undefined ) {\n\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\trenderItem.group = group;\n\n\t\t\t} else {\n\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\n\t\t\t\t// assert( index === array.length );\n\t\t\t\tarray.push( renderItem );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Duplicated code (Frustum)\n\n\t\tfunction isObjectViewable( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSpriteViewable( sprite ) {\n\n\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSphereViewable( sphere ) {\n\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\t\tif ( numPlanes === 0 ) return true;\n\n\t\t\tvar planes = _this.clippingPlanes,\n\n\t\t\t\tcenter = sphere.center,\n\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\ti = 0;\n\n\t\t\tdo {\n\n\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t\t} while ( ++ i !== numPlanes );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isLight ) {\n\n\t\t\t\t\tlights.push( object );\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isLensFlare ) {\n\n\t\t\t\t\tlensFlares.push( object );\n\n\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\t\tif ( material.isMultiMaterial ) {\n\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\t\tvar object = renderItem.object;\n\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\tvar group = renderItem.group;\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tsetMaterial( material );\n\n\t\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\n\t\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\n\t\t\t\t}\n\n\t\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction initMaterial( material, fog, object ) {\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\t\tvar program = materialProperties.program;\n\t\t\tvar programChange = true;\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t} else if ( program.code !== code ) {\n\n\t\t\t\t// changed glsl or parameters\n\t\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t\t// same glsl and uniform list\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// only rebuild uniform list\n\t\t\t\tprogramChange = false;\n\n\t\t\t}\n\n\t\t\tif ( programChange ) {\n\n\t\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\t\tmaterialProperties.program = program;\n\t\t\t\tmaterial.program = program;\n\n\t\t\t}\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t     ! material.isRawShaderMaterial ||\n\t\t\t       material.clipping === true ) {\n\n\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t\t}\n\n\t\t\tmaterialProperties.fog = fog;\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t\t}\n\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\tuniformsList =\n\t\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\t}\n\n\t\tfunction setMaterial( material ) {\n\n\t\t\tmaterial.side === DoubleSide\n\t\t\t\t? state.disable( _gl.CULL_FACE )\n\t\t\t\t: state.enable( _gl.CULL_FACE );\n\n\t\t\tstate.setFlipSided( material.side === BackSide );\n\n\t\t\tmaterial.transparent === true\n\t\t\t\t? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t: state.setBlending( NoBlending );\n\n\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t}\n\n\t\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t\t_usedTextureUnits = 0;\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tif ( _clippingEnabled ) {\n\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate === false ) {\n\n\t\t\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes || \n\t \t\t\t\t  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate ) {\n\n\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\tmaterial.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\tvar refreshProgram = false;\n\t\t\tvar refreshMaterial = false;\n\t\t\tvar refreshLights = false;\n\n\t\t\tvar program = materialProperties.program,\n\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t_currentProgram = program.id;\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t\t// load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.envMap ) {\n\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isShaderMaterial ||\n\t\t\t\t     material.skinning ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\t}\n\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t\t}\n\n\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// not sure why, but otherwise weird things happen\n\n\t\t\tif ( material.skinning ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tvar skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tif ( material.lights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isMeshDepthMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh single material specific uniforms\n\n\t\t\t\tif ( material.isLineBasicMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isLineDashedMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t\t}\n\n\t\t\t\tWebGLUniforms.upload(\n\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t\t}\n\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// Uniforms (refresh uniforms objects)\n\n\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t\tif ( material.emissive ) {\n\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t\t}\n\n\t\t\tuniforms.map.value = material.map;\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\tif ( material.aoMap ) {\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\t// uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. normal map\n\t\t\t// 4. bump map\n\t\t\t// 5. alpha map\n\t\t\t// 6. emissive map\n\n\t\t\tvar uvScaleMap;\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\tuvScaleMap = material.map;\n\n\t\t\t} else if ( material.specularMap ) {\n\n\t\t\t\tuvScaleMap = material.specularMap;\n\n\t\t\t} else if ( material.displacementMap ) {\n\n\t\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t\t} else if ( material.normalMap ) {\n\n\t\t\t\tuvScaleMap = material.normalMap;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t\t} else if ( material.roughnessMap ) {\n\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t\t} else if ( material.metalnessMap ) {\n\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t\t} else if ( material.alphaMap ) {\n\n\t\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t\t} else if ( material.emissiveMap ) {\n\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t\t// backwards compatibility\n\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t\t}\n\n\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t\tuniforms.envMap.value = material.envMap;\n\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t}\n\n\t\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t}\n\n\t\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\n\t\t}\n\n\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\tuniforms.scale.value = _height * 0.5;\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tvar offset = material.map.offset;\n\t\t\t\tvar repeat = material.map.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\n\t\t\tuniforms.fogColor.value = fog.color;\n\n\t\t\tif ( fog.isFog ) {\n\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\t\tuniforms.specular.value = material.specular;\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\n\t\t\tif ( material.roughnessMap ) {\n\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.metalnessMap ) {\n\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t\tif ( material.envMap ) {\n\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\n\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\t// Lighting\n\n\t\tfunction setupShadows( lights ) {\n\n\t\t\tvar lightShadowsLength = 0;\n\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.shadows.length = lightShadowsLength;\n\n\t\t}\n\n\t\tfunction setupLights( lights, camera ) {\n\n\t\t\tvar l, ll, light,\n\t\t\tr = 0, g = 0, b = 0,\n\t\t\tcolor,\n\t\t\tintensity,\n\t\t\tdistance,\n\t\t\tshadowMap,\n\n\t\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\t\tdirectionalLength = 0,\n\t\t\tpointLength = 0,\n\t\t\tspotLength = 0,\n\t\t\themiLength = 0;\n\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\t\tlight = lights[ l ];\n\n\t\t\t\tcolor = light.color;\n\t\t\t\tintensity = light.intensity;\n\t\t\t\tdistance = light.distance;\n\n\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\n\t\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t_lights.ambient[ 2 ] = b;\n\n\t\t\t_lights.directional.length = directionalLength;\n\t\t\t_lights.spot.length = spotLength;\n\t\t\t_lights.point.length = pointLength;\n\t\t\t_lights.hemi.length = hemiLength;\n\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t\t}\n\n\t\t// GL state setting\n\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\t\tstate.setCullFace( cullFace );\n\t\t\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\n\n\t\t};\n\n\t\t// Textures\n\n\t\tfunction allocTextureUnit() {\n\n\t\t\tvar textureUnit = _usedTextureUnits;\n\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t\t}\n\n\t\t\t_usedTextureUnits += 1;\n\n\t\t\treturn textureUnit;\n\n\t\t}\n\n\t\tthis.allocTextureUnit = allocTextureUnit;\n\n\t\t// this.setTexture2D = setTexture2D;\n\t\tthis.setTexture2D = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTexture = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTexture( texture, slot ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTextureCube = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t// TODO: unify these code paths\n\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.getCurrentRenderTarget = function() {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t}\n\n\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\tvar framebuffer;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t\t}\n\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = null;\n\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t\t}\n\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tstate.viewport( _currentViewport );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\t\tif ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tvar restore = false;\n\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t\trestore = true;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\tvar textureType = texture.type;\n\n\t\t\t\t\tif ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Map three.js constants to WebGL constants\n\n\t\tfunction paramThreeToGL( p ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( p === RepeatWrapping ) return _gl.REPEAT;\n\t\t\tif ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\tif ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\t\tif ( p === NearestFilter ) return _gl.NEAREST;\n\t\t\tif ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\tif ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\t\tif ( p === LinearFilter ) return _gl.LINEAR;\n\t\t\tif ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\tif ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\t\tif ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\tif ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\t\tif ( p === ByteType ) return _gl.BYTE;\n\t\t\tif ( p === ShortType ) return _gl.SHORT;\n\t\t\tif ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\tif ( p === IntType ) return _gl.INT;\n\t\t\tif ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\tif ( p === FloatType ) return _gl.FLOAT;\n\n\t\t\tif ( p === HalfFloatType ) {\n\n\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\n\t\t\t}\n\n\t\t\tif ( p === AlphaFormat ) return _gl.ALPHA;\n\t\t\tif ( p === RGBFormat ) return _gl.RGB;\n\t\t\tif ( p === RGBAFormat ) return _gl.RGBA;\n\t\t\tif ( p === LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\tif ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\tif ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\t\tif ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;\n\n\t\t\tif ( p === AddEquation ) return _gl.FUNC_ADD;\n\t\t\tif ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\tif ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\t\tif ( p === ZeroFactor ) return _gl.ZERO;\n\t\t\tif ( p === OneFactor ) return _gl.ONE;\n\t\t\tif ( p === SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\tif ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\tif ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\tif ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\tif ( p === DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\tif ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\t\tif ( p === DstColorFactor ) return _gl.DST_COLOR;\n\t\t\tif ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\tif ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\t p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t\t}\n\n\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\n\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction FogExp2 ( color, density ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n\t}\n\n\tFogExp2.prototype.isFogExp2 = true;\n\n\tFogExp2.prototype.clone = function () {\n\n\t\treturn new FogExp2( this.color.getHex(), this.density );\n\n\t};\n\n\tFogExp2.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Fog ( color, near, far ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\n\t}\n\n\tFog.prototype.isFog = true;\n\n\tFog.prototype.clone = function () {\n\n\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\n\t};\n\n\tFog.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Scene () {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.fog = null;\n\t\tthis.overrideMaterial = null;\n\n\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t}\n\n\tScene.prototype = Object.create( Object3D.prototype );\n\n\tScene.prototype.constructor = Scene;\n\n\tScene.prototype.copy = function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t};\n\n\tScene.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlare( texture, size, distance, blending, color ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.lensFlares = [];\n\n\t\tthis.positionScreen = new Vector3();\n\t\tthis.customUpdateCallback = undefined;\n\n\t\tif ( texture !== undefined ) {\n\n\t\t\tthis.add( texture, size, distance, blending, color );\n\n\t\t}\n\n\t}\n\n\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LensFlare,\n\n\t\tisLensFlare: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\t\tif ( size === undefined ) size = - 1;\n\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\tif ( color === undefined ) color = new Color( 0xffffff );\n\t\t\tif ( blending === undefined ) blending = NormalBlending;\n\n\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\t\tthis.lensFlares.push( {\n\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\tcolor: color,\t\t// color\n\t\t\t\tblending: blending\t// blending\n\t\t\t} );\n\n\t\t},\n\n\t\t/*\n\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t */\n\n\t\tupdateLensFlares: function () {\n\n\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\tvar flare;\n\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *\tuvOffset: new THREE.Vector2(),\n\t *\tuvScale: new THREE.Vector2()\n\t * }\n\t */\n\n\tfunction SpriteMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\t\tthis.map = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\n\tSpriteMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.map = source.map;\n\n\t\tthis.rotation = source.rotation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Sprite( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Sprite';\n\n\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\t}\n\n\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Sprite,\n\n\t\tisSprite: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\tpoint: this.position,\n\t\t\t\t\tface: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LOD() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t}\n\t\t} );\n\n\t}\n\n\n\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LOD,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source, false );\n\n\t\t\tvar levels = source.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddLevel: function ( object, distance ) {\n\n\t\t\tif ( distance === undefined ) distance = 0;\n\n\t\t\tdistance = Math.abs( distance );\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\t\tthis.add( object );\n\n\t\t},\n\n\t\tgetObjectForDistance: function ( distance ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tupdate: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar levels = this.levels;\n\n\t\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.levels = [];\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.generateMipmaps  = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n\tDataTexture.prototype = Object.create( Texture.prototype );\n\tDataTexture.prototype.constructor = DataTexture;\n\n\tDataTexture.prototype.isDataTexture = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author michael guerrero / http://realitymeltdown.com\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Skeleton( bones, boneInverses, useVertexTexture ) {\n\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\t\tthis.identityMatrix = new Matrix4();\n\n\t\t// copy the bone array\n\n\t\tbones = bones || [];\n\n\t\tthis.bones = bones.slice( 0 );\n\n\t\t// create a bone texture or an array of floats\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\tsize = _Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\tsize = Math.max( size, 4 );\n\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t\t}\n\n\t\t// use the supplied bone inverses or calculate the inverses\n\n\t\tif ( boneInverses === undefined ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tObject.assign( Skeleton.prototype, {\n\n\t\tcalculateInverses: function () {\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tvar inverse = new Matrix4();\n\n\t\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boneInverses.push( inverse );\n\n\t\t\t}\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tvar bone;\n\n\t\t\t// recover the bind-time world matrices\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// compute the local matrices, positions, rotations and scales\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: ( function () {\n\n\t\t\tvar offsetMatrix = new Matrix4();\n\n\t\t\treturn function update() {\n\n\t\t\t\t// flatten bone matrices to array\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tclone: function () {\n\n\t\t\treturn new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Bone( skin ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Bone';\n\n\t\tthis.skin = skin;\n\n\t}\n\n\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Bone,\n\n\t\tisBone: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.skin = source.skin;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkinnedMesh( geometry, material, useVertexTexture ) {\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = \"attached\";\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\t// init bones\n\n\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t// convenience) for THREE.SkinnedMesh to do this.\n\n\t\tvar bones = [];\n\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\t\tvar bone, gbone;\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tbone = new Bone( this );\n\t\t\t\tbones.push( bone );\n\n\t\t\t\tbone.name = gbone.name;\n\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t\t}\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.normalizeSkinWeights();\n\n\t\tthis.updateMatrixWorld( true );\n\t\tthis.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n\t}\n\n\n\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\t\tconstructor: SkinnedMesh,\n\n\t\tisSkinnedMesh: true,\n\n\t\tbind: function( skeleton, bindMatrix ) {\n\n\t\t\tthis.skeleton = skeleton;\n\n\t\t\tif ( bindMatrix === undefined ) {\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t\t}\n\n\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tthis.skeleton.pose();\n\n\t\t},\n\n\t\tnormalizeSkinWeights: function () {\n\n\t\t\tif ( (this.geometry && this.geometry.isGeometry) ) {\n\n\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {\n\n\t\t\t\tvar vec = new Vector4();\n\n\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrixWorld: function( force ) {\n\n\t\t\tMesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function() {\n\n\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *  linecap: \"round\",\n\t *  linejoin: \"round\"\n\t * }\n\t */\n\n\tfunction LineBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\n\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n\tLineBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Line( geometry, material, mode ) {\n\n\t\tif ( mode === 1 ) {\n\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\treturn new LineSegments( geometry, material );\n\n\t\t}\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Line,\n\n\t\tisLine: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\tvar precisionSq = precision * precision;\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar vStart = new Vector3();\n\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\tvar interRay = new Vector3();\n\t\t\t\tvar step = (this && this.isLineSegments) ? 2 : 1;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LineSegments( geometry, material ) {\n\n\t\tLine.call( this, geometry, material );\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\t\tconstructor: LineSegments,\n\n\t\tisLineSegments: true\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  size: <float>,\n\t *  sizeAttenuation: <bool>\n\t * }\n\t */\n\n\tfunction PointsMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tPointsMaterial.prototype = Object.create( Material.prototype );\n\tPointsMaterial.prototype.constructor = PointsMaterial;\n\n\tPointsMaterial.prototype.isPointsMaterial = true;\n\n\tPointsMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Points( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Points,\n\n\t\tisPoints: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar object = this;\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\tvar position = new Vector3();\n\n\t\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Group() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Group';\n\n\t}\n\n\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Group\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.generateMipmaps = false;\n\n\t\tvar scope = this;\n\n\t\tfunction update() {\n\n\t\t\trequestAnimationFrame( update );\n\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\t\tscope.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdate();\n\n\t}\n\n\tVideoTexture.prototype = Object.create( Texture.prototype );\n\tVideoTexture.prototype.constructor = VideoTexture;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\tCompressedTexture.prototype.constructor = CompressedTexture;\n\n\tCompressedTexture.prototype.isCompressedTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\tCanvasTexture.prototype.constructor = CanvasTexture;\n\n\t/**\n\t * @author Matt DesLauriers / @mattdesl\n\t * @author atix / arthursilber.de\n\t */\n\n\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )\n\n\t\t}\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.type = type !== undefined ? type : UnsignedShortType;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps\t= false;\n\n\t}\n\n\tDepthTexture.prototype = Object.create( Texture.prototype );\n\tDepthTexture.prototype.constructor = DepthTexture;\n\tDepthTexture.prototype.isDepthTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WireframeGeometry( geometry ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar numEdges = 0;\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// Indexed BufferGeometry\n\n\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\tvar groups = geometry.groups;\n\t\t\t\tvar numEdges = 0;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\tvar numTris = numEdges / 3;\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'ParametricBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// generate vertices and uvs\n\n\t\tvar vertices = [];\n\t\tvar uvs = [];\n\n\t\tvar i, j, p;\n\t\tvar u, v;\n\n\t\tvar sliceCount = slices + 1;\n\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\t\tv = i / stacks;\n\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tu = j / slices;\n\n\t\t\t\tp = func( u, v );\n\t\t\t\tvertices.push( p.x, p.y, p.z );\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tvar indices = [];\n\t\tvar a, b, c, d;\n\n\t\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\t\ta = i * sliceCount + j;\n\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t}\n\n\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n\t/**\n\t * @author zz85 / https://github.com/zz85\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricGeometry( func, slices, stacks ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\n\t\t// default buffer data\n\n\t\tvar vertexBuffer = [];\n\t\tvar uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tappplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );\n\t\tthis.normalizeNormals();\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tvar cols = Math.pow( 2, detail );\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tvar v = [];\n\n\t\t\tvar i, j;\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( i = 0 ; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tvar rows = cols - i;\n\n\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( i = 0; i < cols ; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction appplyRadius( radius ) {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tvar stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\tvar centroid = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tvar azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth  ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] =  uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\n\t\tvar vertices = [\n\t\t\t1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction TetrahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction OctahedronBufferGeometry( radius,detail ) {\n\n\t\tvar vertices = [\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction OctahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tvar vertices = [\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction IcosahedronGeometry( radius, detail ) {\n\n\t \tGeometry.call( this );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tvar r = 1 / t;\n\n\t\tvar vertices = [\n\n\t\t\t// (1, 1, 1)\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t\t// (0, 1/, )\n\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t\t// (1/, , 0)\n\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t r, - t,  0,     r,  t,  0,\n\n\t\t\t// (, 0, 1/)\n\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t- t,  0,  r,     t,  0,  r\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n\t/**\n\t * @author Abe Pazos / https://hamoid.com\n\t */\n\n\tfunction DodecahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\n\t/**\n\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t *\n\t */\n\n\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TubeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\ttubularSegments = tubularSegments || 64;\n\t\tradius = radius || 1;\n\t\tradialSegments = radialSegments || 8;\n\t\tclosed = closed || false;\n\n\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar i, j;\n\n\t\t// buffer\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\t\tvar indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tvar P = path.getPointAt( i / tubularSegments );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tvar N = frames.normals[ i ];\n\t\t\tvar B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tvar sin =   Math.sin( v );\n\t\t\t\tvar cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t * @author WestLangley / https://github.com/WestLangley\n\t * @author zz85 / https://github.com/zz85\n\t * @author miningold / https://github.com/miningold\n\t * @author jonobr1 / https://github.com/jonobr1\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t */\n\n\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\n\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = bufferGeometry.tangents;\n\t\tthis.normals = bufferGeometry.normals;\n\t\tthis.binormals = bufferGeometry.binormals;\n\n\t\t// create geometry\n\n\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\tTubeGeometry.prototype.constructor = TubeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t */\n\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\tp = p || 2;\n\t\tq = q || 3;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar i, j, index = 0, indexOffset = 0;\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar P1 = new Vector3();\n\t\tvar P2 = new Vector3();\n\n\t\tvar B = new Vector3();\n\t\tvar T = new Vector3();\n\t\tvar N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tvar cu = Math.cos( u );\n\t\t\tvar su = Math.sin( u );\n\t\t\tvar quOverP = q / p * u;\n\t\t\tvar cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t */\n\n\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\tarc = arc || Math.PI * 2;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\n\t\t// helper variables\n\t\tvar center = new Vector3();\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t\t// uv\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t\t// update offsets\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offset\n\t\t\t\tindexBufferOffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t */\n\n\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n\t}\n\n\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusGeometry.prototype.constructor = TorusGeometry;\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar ShapeUtils = {\n\n\t\t// calculate area of the contour polygon\n\n\t\tarea: function ( contour ) {\n\n\t\t\tvar n = contour.length;\n\t\t\tvar a = 0.0;\n\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t\t}\n\n\t\t\treturn a * 0.5;\n\n\t\t},\n\n\t\ttriangulate: ( function () {\n\n\t\t\t/**\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t * See original code and more information here:\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t *\n\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t * www.actionsnippet.com\n\t\t\t *\n\t\t\t * ported to javascript by Joshua Koo\n\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t *\n\t\t\t */\n\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\t\tvar p;\n\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\tvar cx, cy, px, py;\n\n\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\t\tif ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;\n\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// takes in an contour array and returns\n\n\t\t\treturn function triangulate( contour, indices ) {\n\n\t\t\t\tvar n = contour.length;\n\n\t\t\t\tif ( n < 3 ) return null;\n\n\t\t\t\tvar result = [],\n\t\t\t\t\tverts = [],\n\t\t\t\t\tvertIndices = [];\n\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\t\tvar u, v, w;\n\n\t\t\t\tif ( ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t\t}\n\n\t\t\t\tvar nv = n;\n\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnv --;\n\n\t\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t} )(),\n\n\t\ttriangulateShape: function ( contour, holes ) {\n\n\t\t\tfunction removeDupEndPts(points) {\n\n\t\t\t\tvar l = points.length;\n\n\t\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\t\tpoints.pop();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tremoveDupEndPts( contour );\n\t\t\tholes.forEach( removeDupEndPts );\n\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\n\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t\t// return real intersection point\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t// both segments are points\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t\t// The order of legs is important\n\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t\t// angle != 180 deg.\n\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\tvar hole;\n\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar indepHoles = [];\n\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tindepHoles.push( h );\n\n\t\t\t\t}\n\n\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\t\tcounter --;\n\t\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t\t}\n\n\n\t\t\tvar i, il, f, face,\n\t\t\t\tkey, index,\n\t\t\t\tallPointsMap = {};\n\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\t\tvar allpoints = contour.concat();\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t\t}\n\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t\t// prepare all points map\n\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\n\t\t\t\t}\n\n\t\t\t\tallPointsMap[ key ] = i;\n\n\t\t\t}\n\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\t\tvar triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t\t// check all face vertices against all points map\n\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\t\tface = triangles[ i ];\n\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangles.concat();\n\n\t\t},\n\n\t\tisClockWise: function ( pts ) {\n\n\t\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t\t},\n\n\t\t// Bezier Curves formulas obtained from\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t\t// Quad Bezier Functions\n\n\t\tb2: ( function () {\n\n\t\t\tfunction b2p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p1( t, p ) {\n\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p2( t, p ) {\n\n\t\t\t\treturn t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\t// Cubic Bezier Functions\n\n\t\tb3: ( function () {\n\n\t\t\tfunction b3p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p1( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * k * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p2( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * t * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p3( t, p ) {\n\n\t\t\t\treturn t * t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *  curveSegments: <int>, // number of points on the curves\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *  amount: <int>, // Depth to extrude the shape\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t *  bevelSegments: <int>, // number of bevel layers\n\t *\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t *\n\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ExtrudeGeometry( shapes, options ) {\n\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\t\tshapes = [];\n\t\t\treturn;\n\n\t\t}\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t\t// can't really use automatic vertex normals\n\t\t// as then front and back sides get smoothed too\n\t\t// should do separate smoothing just for sides\n\n\t\t//this.computeVertexNormals();\n\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n\t}\n\n\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\n\tExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tvar sl = shapes.length;\n\n\t\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\t\tvar shape = shapes[ s ];\n\t\t\tthis.addShape( shape, options );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\t\tvar extrudePath = options.extrudePath;\n\t\tvar extrudePts, extrudeByPath = false;\n\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\n\t\tvar splineTube, binormal, normal, position2;\n\t\tif ( extrudePath ) {\n\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t// SETUP TNB variables\n\n\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\tbinormal = new Vector3();\n\t\t\tnormal = new Vector3();\n\t\t\tposition2 = new Vector3();\n\n\t\t}\n\n\t\t// Safeguards if bevels are not enabled\n\n\t\tif ( ! bevelEnabled ) {\n\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\n\t\t}\n\n\t\t// Variables initialization\n\n\t\tvar ahole, h, hl; // looping of holes\n\t\tvar scope = this;\n\n\t\tvar shapesOffset = this.vertices.length;\n\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t\t}\n\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t/* Vertices */\n\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tvertices = vertices.concat( ahole );\n\n\t\t}\n\n\n\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t}\n\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\n\n\t\t// Find directions for point movement\n\n\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t// not collinear\n\n\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\treturn\tnew Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tnew Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t}\n\n\n\t\tvar contourMovements = [];\n\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t}\n\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\toneHoleMovements = [];\n\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t}\n\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t}\n\n\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbs = bevelSize;\n\n\t\t// Back facing vertices\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\n\t\tvar s;\n\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Add bevel segments planes\n\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos ( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Faces */\n\n\t\t// Top and bottom faces\n\n\t\tbuildLidFaces();\n\n\t\t// Sides faces\n\n\t\tbuildSideFaces();\n\n\n\t\t/////  Internal functions\n\n\t\tfunction buildLidFaces() {\n\n\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Create faces for the z-sides of the shape\n\n\t\tfunction buildSideFaces() {\n\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\n\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction v( x, y, z ) {\n\n\t\t\tscope.vertices.push( new Vector3( x, y, z ) );\n\n\t\t}\n\n\t\tfunction f3( a, b, c ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, c, null, null, 0 ) );\n\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t\t}\n\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\t\t\td += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, d, null, null, 1 ) );\n\t\t\tscope.faces.push( new Face3( b, c, d, null, null, 1 ) );\n\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.WorldUVGenerator = {\n\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a.x, a.y ),\n\t\t\t\tnew Vector2( b.x, b.y ),\n\t\t\t\tnew Vector2( c.x, c.y )\n\t\t\t];\n\n\t\t},\n\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\t\t\tvar d = vertices[ indexD ];\n\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.x, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.x, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.x, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.x, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.y, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.y, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.y, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.y, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *  font: <THREE.Font>, // font\n\t *\n\t *  size: <float>, // size of the text\n\t *  height: <float>, // thickness to extrude text\n\t *  curveSegments: <int>, // number of points on the curves\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t *  bevelSize: <float> // how far from text outline is bevel\n\t * }\n\t */\n\n\tfunction TextGeometry( text, parameters ) {\n\n\t\tparameters = parameters || {};\n\n\t\tvar font = parameters.font;\n\n\t\tif ( (font && font.isFont) === false ) {\n\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new Geometry();\n\n\t\t}\n\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t\t// translate parameters to ExtrudeGeometry API\n\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t\t// defaults\n\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\tExtrudeGeometry.call( this, shapes, parameters );\n\n\t\tthis.type = 'TextGeometry';\n\n\t}\n\n\tTextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );\n\tTextGeometry.prototype.constructor = TextGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * based on THREE.SphereGeometry\n\t */\n\n\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'SphereBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\t\tvar thetaEnd = thetaStart + thetaLength;\n\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\t\tvar positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\tvar index = 0, vertices = [], normal = new Vector3();\n\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar verticesRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\t\tvar u = x / widthSegments;\n\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\tverticesRow.push( index );\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvertices.push( verticesRow );\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', positions );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n\t}\n\n\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\tSphereGeometry.prototype.constructor = SphereGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'RingBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tinnerRadius = innerRadius || 20;\n\t\touterRadius = outerRadius || 50;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// some helper variables\n\t\tvar index = 0, indexOffset = 0, segment;\n\t\tvar radius = innerRadius;\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\t// values are generate from the inside of the ring to the outside\n\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex++;\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = segment;\n\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\tvar d = segment + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t}\n\n\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n\t/**\n\t * @author Kaleb Murphy\n\t */\n\n\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n\t}\n\n\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\tRingGeometry.prototype.constructor = RingGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n\t}\n\n\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t // points - to create a closed torus, one must use a set of points\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t // segments - the number of circumference segments to create\n\t // phiStart - the starting radian\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t //    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'LatheBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments ) || 12;\n\t\tphiStart = phiStart || 0;\n\t\tphiLength = phiLength || Math.PI * 2;\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\tvar indexCount = segments * points.length * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar index = 0, indexOffset = 0, base;\n\t\tvar inverseSegments = 1.0 / segments;\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar i, j;\n\n\t\t// generate vertices and uvs\n\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tvar sin = Math.sin( phi );\n\t\t\tvar cos = Math.cos( phi );\n\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tbase = j + i * points.length;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = base;\n\t\t\t\tvar b = base + points.length;\n\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\tvar d = base + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\tif( phiLength === Math.PI * 2 ) {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\t\t\tvar n1 = new Vector3();\n\t\t\tvar n2 = new Vector3();\n\t\t\tvar n = new Vector3();\n\n\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\tbase = segments * points.length * 3;\n\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\t// average normals\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\t// assign the new values to both normals\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t\t} // next row\n\n\t\t}\n\n\t}\n\n\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n\t/**\n\t * @author astrodud / http://astrodud.isgreat.org/\n\t * @author zz85 / https://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t */\n\n\t// points - to create a closed torus, one must use a set of points\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t// segments - the number of circumference segments to create\n\t// phiStart - the starting radian\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t//    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\tLatheGeometry.prototype.constructor = LatheGeometry;\n\n\t/**\n\t * @author jonobr1 / http://jonobr1.com\n\t *\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t * ExtrudeGeometry.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t *\n\t *\tmaterial: <int> // material index for front and back faces\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ShapeGeometry( shapes, options ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t}\n\n\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\n\t/**\n\t * Add an array of shapes to THREE.ShapeGeometry.\n\t */\n\tShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tthis.addShape( shapes[ i ], options );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t */\n\tShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tif ( options === undefined ) options = {};\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar material = options.material;\n\t\tvar uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t\t//\n\n\t\tvar i, l, hole;\n\n\t\tvar shapesOffset = this.vertices.length;\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\t\thole = holes[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false;\n\n\t\t}\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t// Vertices\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\t\t\tvertices = vertices.concat( hole );\n\n\t\t}\n\n\t\t//\n\n\t\tvar vert, vlen = vertices.length;\n\t\tvar face, flen = faces.length;\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = vertices[ i ];\n\n\t\t\tthis.vertices.push( new Vector3( vert.x, vert.y, 0 ) );\n\n\t\t}\n\n\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\t\tthis.faces.push( new Face3( a, b, c, null, null, material ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tvar geometry2;\n\n\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tgeometry2 = new Geometry();\n\t\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tgeometry2 = geometry.clone();\n\n\t\t}\n\n\t\tgeometry2.mergeVertices();\n\t\tgeometry2.computeFaceNormals();\n\n\t\tvar vertices = geometry2.vertices;\n\t\tvar faces = geometry2.faces;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t\t} else {\n\n\t\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = [];\n\n\t\tfor ( var key in hash ) {\n\n\t\t\tvar h = hash[ key ];\n\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );\n\n\t}\n\n\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CylinderBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tvar scope = this;\n\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\theight = height !== undefined ? height : 100;\n\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t\t// used to calculate buffer length\n\n\t\tvar nbCap = 0;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t\t}\n\n\t\tvar vertexCount = calculateVertexCount();\n\t\tvar indexCount = calculateIndexCount();\n\n\t\t// buffers\n\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\n\t\tvar index = 0,\n\t\t    indexOffset = 0,\n\t\t    indexArray = [],\n\t\t    halfHeight = height / 2;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount() {\n\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction calculateIndexCount() {\n\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction generateTorso() {\n\n\t\t\tvar x, y;\n\t\t\tvar normal = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tvar indexRow = [];\n\n\t\t\t\tvar v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\tindexRow.push( index );\n\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\t\tvar uv = new Vector2();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// save the index of the first center vertex\n\t\t\tcenterIndexStart = index;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = 0.5;\n\t\t\t\tuv.y = 0.5;\n\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tcenterIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t}\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\tConeGeometry.prototype.constructor = ConeGeometry;\n\n\t/**\n\t * @author: abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CircleBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tvar vertices = segments + 2;\n\n\t\tvar positions = new Float32Array( vertices * 3 );\n\t\tvar normals = new Float32Array( vertices * 3 );\n\t\tvar uvs = new Float32Array( vertices * 2 );\n\n\t\t// center data is already zero, but need to set a few extras\n\t\tnormals[ 2 ] = 1.0;\n\t\tuvs[ 0 ] = 0.5;\n\t\tuvs[ 1 ] = 0.5;\n\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n\t/**\n\t * @author hughes\n\t */\n\n\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n\t}\n\n\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\tCircleGeometry.prototype.constructor = CircleGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t */\n\n\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\tBoxGeometry.prototype.constructor = BoxGeometry;\n\n\n\n\tvar Geometries = Object.freeze({\n\t\tWireframeGeometry: WireframeGeometry,\n\t\tParametricGeometry: ParametricGeometry,\n\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\tOctahedronGeometry: OctahedronGeometry,\n\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\tTubeGeometry: TubeGeometry,\n\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\tTorusGeometry: TorusGeometry,\n\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\tTextGeometry: TextGeometry,\n\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\tSphereGeometry: SphereGeometry,\n\t\tRingGeometry: RingGeometry,\n\t\tRingBufferGeometry: RingBufferGeometry,\n\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\tPlaneGeometry: PlaneGeometry,\n\t\tLatheGeometry: LatheGeometry,\n\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\tShapeGeometry: ShapeGeometry,\n\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\tEdgesGeometry: EdgesGeometry,\n\t\tConeGeometry: ConeGeometry,\n\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\tCylinderGeometry: CylinderGeometry,\n\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\tCircleGeometry: CircleGeometry,\n\t\tBoxBufferGeometry: BoxBufferGeometry,\n\t\tBoxGeometry: BoxGeometry\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ShadowMaterial() {\n\n\t\tShaderMaterial.call( this, {\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib[ \"lights\" ],\n\t\t\t\t{\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t}\n\t\t\t] ),\n\t\t\tvertexShader: ShaderChunk[ 'shadow_vert' ],\n\t\t\tfragmentShader: ShaderChunk[ 'shadow_frag' ]\n\t\t} );\n\n\t\tthis.lights = true;\n\t\tthis.transparent = true;\n\n\t\tObject.defineProperties( this, {\n\t\t\topacity: {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\n\tShadowMaterial.prototype.isShadowMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction RawShaderMaterial( parameters ) {\n\n\t\tShaderMaterial.call( this, parameters );\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\n\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MultiMaterial( materials ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.type = 'MultiMaterial';\n\n\t\tthis.materials = materials instanceof Array ? materials : [];\n\n\t\tthis.visible = true;\n\n\t}\n\n\tMultiMaterial.prototype = {\n\n\t\tconstructor: MultiMaterial,\n\n\t\tisMultiMaterial: true,\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.2,\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\ttype: this.type,\n\t\t\t\tmaterials: []\n\t\t\t};\n\n\t\t\tvar materials = this.materials;\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\tdelete material.metadata;\n\n\t\t\t\toutput.materials.push( material );\n\n\t\t\t}\n\n\t\t\toutput.visible = this.visible;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\tvar material = new this.constructor();\n\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tmaterial.visible = this.visible;\n\n\t\t\treturn material;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  roughness: <float>,\n\t *  metalness: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *  envMapIntensity: <float>\n\t *\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshStandardMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 0.5;\n\t\tthis.metalness = 0.5;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\n\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  reflectivity: <float>\n\t * }\n\t */\n\n\tfunction MeshPhysicalMaterial( parameters ) {\n\n\t\tMeshStandardMaterial.call( this );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\tthis.clearCoat = 0.0;\n\t\tthis.clearCoatRoughness = 0.0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\n\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.reflectivity = source.reflectivity;\n\n\t\tthis.clearCoat = source.clearCoat;\n\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  specular: <hex>,\n\t *  shininess: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshPhongMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\n\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * parameters = {\n\t *  opacity: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshNormalMaterial( parameters ) {\n\n\t\tMaterial.call( this, parameters );\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\n\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshLambertMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\n\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *\n\t *  scale: <float>,\n\t *  dashSize: <float>,\n\t *  gapSize: <float>\n\t * }\n\t */\n\n\tfunction LineDashedMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineDashedMaterial.prototype = Object.create( Material.prototype );\n\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\n\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n\tLineDashedMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t};\n\n\n\n\tvar Materials = Object.freeze({\n\t\tShadowMaterial: ShadowMaterial,\n\t\tSpriteMaterial: SpriteMaterial,\n\t\tRawShaderMaterial: RawShaderMaterial,\n\t\tShaderMaterial: ShaderMaterial,\n\t\tPointsMaterial: PointsMaterial,\n\t\tMultiMaterial: MultiMaterial,\n\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\tLineDashedMaterial: LineDashedMaterial,\n\t\tLineBasicMaterial: LineBasicMaterial,\n\t\tMaterial: Material\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar Cache = {\n\n\t\tenabled: false,\n\n\t\tfiles: {},\n\n\t\tadd: function ( key, file ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\t\tthis.files[ key ] = file;\n\n\t\t},\n\n\t\tget: function ( key ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\t\treturn this.files[ key ];\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete this.files[ key ];\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.files = {};\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tvar DefaultLoadingManager = new LoadingManager();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction XHRLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( XHRLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( url === undefined ) url = '';\n\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\t\tvar scope = this;\n\n\t\t\tvar cached = Cache.get( url );\n\n\t\t\tif ( cached !== undefined ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t\treturn cached;\n\n\t\t\t}\n\n\t\t\t// Check for data: URI\n\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\n\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\tif ( dataUriRegexResult ) {\n\n\t\t\t\tvar mimeType = dataUriRegexResult[1];\n\t\t\t\tvar isBase64 = !!dataUriRegexResult[2];\n\t\t\t\tvar data = dataUriRegexResult[3];\n\n\t\t\t\tdata = window.decodeURIComponent(data);\n\n\t\t\t\tif( isBase64 ) {\n\t\t\t\t\tdata = window.atob(data);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar response;\n\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\t \tresponse = new ArrayBuffer( data.length );\n\t\t\t\t\t\t\tvar view = new Uint8Array( response );\n\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\t\tresponse = new Blob( [ response ], { \"type\" : mimeType } );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\trequest.open( 'GET', url, true );\n\n\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\tvar response = event.target.response;\n\n\t\t\t\t\tCache.add( url, response );\n\n\t\t\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( onProgress !== undefined ) {\n\n\t\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\t\t\tonProgress( event );\n\n\t\t\t\t\t}, false );\n\n\t\t\t\t}\n\n\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );\n\n\t\t\t\trequest.send( null );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn request;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetResponseType: function ( value ) {\n\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t */\n\n\tfunction CompressedTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( CompressedTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar images = [];\n\n\t\t\tvar texture = new CompressedTexture();\n\t\t\ttexture.image = images;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\n\t\t\t\t\tloaded += 1;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\tvar loaded = 0;\n\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\t\tloadTexture( i );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Nikos M. / https://github.com/foo123/\n\t *\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t */\n\n\tvar DataTextureLoader = BinaryTextureLoader;\n\tfunction BinaryTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( BinaryTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texture = new DataTexture();\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\t\tif ( ! texData ) return;\n\n\t\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\t\ttexture.image = texData.image;\n\n\t\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\t\ttexture.format = texData.format;\n\n\t\t\t\t}\n\t\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\t\ttexture.type = texData.type;\n\n\t\t\t\t}\n\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t}, onProgress, onError );\n\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ImageLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( ImageLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\timage.onload = function () {\n\n\t\t\t\timage.onload = null;\n\n\t\t\t\tURL.revokeObjectURL( image.src );\n\n\t\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t};\n\t\t\timage.onerror = onError;\n\n\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\timage.src = url;\n\n\t\t\t} else {\n\n\t\t\t\tvar loader = new XHRLoader();\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn image;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( CubeTextureLoader.prototype, {\n\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new CubeTexture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\t\tloaded ++;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, undefined, onError );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction TextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( TextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new Texture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( image ) {\n\n\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\ttexture.image = image;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\t\tonLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Light( color, intensity ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\t\tthis.receiveShadow = undefined;\n\n\t}\n\n\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Light,\n\n\t\tisLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.intensity = source.intensity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\n\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\n\t\tLight.call( this, skyColor, intensity );\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.castShadow = undefined;\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: HemisphereLight,\n\n\t\tisHemisphereLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.groundColor.copy( source.groundColor );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LightShadow( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.radius = 1;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.matrix = new Matrix4();\n\n\t}\n\n\tObject.assign( LightShadow.prototype, {\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.camera = source.camera.clone();\n\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\n\t\t\tthis.mapSize.copy( source.mapSize );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar object = {};\n\n\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\tdelete object.camera.matrix;\n\n\t\t\treturn object;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SpotLightShadow() {\n\n\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t}\n\n\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: SpotLightShadow,\n\n\t\tisSpotLightShadow: true,\n\n\t\tupdate: function ( light ) {\n\n\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tvar far = light.distance || 500;\n\n\t\t\tvar camera = this.camera;\n\n\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: SpotLight,\n\n\t\tisSpotLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\n\tfunction PointLight( color, intensity, distance, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'PointLight';\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t}\n\n\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: PointLight,\n\n\t\tisPointLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectionalLightShadow( light ) {\n\n\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t}\n\n\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: DirectionalLightShadow\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DirectionalLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: DirectionalLight,\n\n\t\tisDirectionalLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AmbientLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'AmbientLight';\n\n\t\tthis.castShadow = undefined;\n\n\t}\n\n\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: AmbientLight,\n\n\t\tisAmbientLight: true,\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tvar AnimationUtils = {\n\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function( array, from, to ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t\t}\n\n\t\t\treturn array.slice( from, to );\n\n\t\t},\n\n\t\t// converts an array to a specific type\n\t\tconvertArray: function( array, type, forceClone ) {\n\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\t\treturn new type( array ); // create typed array\n\n\t\t\t}\n\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t\t},\n\n\t\tisTypedArray: function( object ) {\n\n\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t! ( object instanceof DataView );\n\n\t\t},\n\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function( times ) {\n\n\t\t\tfunction compareTime( i, j ) {\n\n\t\t\t\treturn times[ i ] - times[ j ];\n\n\t\t\t}\n\n\t\t\tvar n = times.length;\n\t\t\tvar result = new Array( n );\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\t\tresult.sort( compareTime );\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function( values, stride, order ) {\n\n\t\t\tvar nValues = values.length;\n\t\t\tvar result = new values.constructor( nValues );\n\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t}\n\n\t\t\tif ( key === undefined ) return; // no data\n\n\t\t\tvar value = key[ valuePropertyName ];\n\t\t\tif ( value === undefined ) return; // no data\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t// ...assume THREE.Math-ish\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t * @author tschw\n\t */\n\n\tfunction Interpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t}\n\n\tInterpolant.prototype = {\n\n\t\tconstructor: Interpolant,\n\n\t\tevaluate: function( t ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\ti1 = this._cachedIndex,\n\n\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\tvalidate_interval: {\n\n\t\t\t\tseek: {\n\n\t\t\t\t\tvar right;\n\n\t\t\t\t\tlinear_scan: {\n\t//- See http://jsperf.com/comparison-to-undefined/3\n\t//- slower code:\n\t//-\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t//- slower code:\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t\t} // linear scan\n\n\t\t\t\t\t// binary search\n\n\t\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t\t// check boundary cases, again\n\n\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // seek\n\n\t\t\t\tthis._cachedIndex = i1;\n\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t\t} // validate_interval\n\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t\t},\n\n\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t// Note: The indirection allows central control of many interpolants.\n\n\t\t// --- Protected interface\n\n\t\tDefaultSettings_: {},\n\n\t\tgetSettings_: function() {\n\n\t\t\treturn this.settings || this.DefaultSettings_;\n\n\t\t},\n\n\t\tcopySampleValue_: function( index ) {\n\n\t\t\t// copies a sample value to the result buffer\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = index * stride;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// Template methods for derived classes:\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t// implementations shall return this.resultBuffer\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\t// empty\n\n\t\t}\n\n\t};\n\n\tObject.assign( Interpolant.prototype, {\n\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_,\n\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_\n\n\t} );\n\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction CubicInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = -0;\n\t\tthis._offsetPrev = -0;\n\t\tthis._weightNext = -0;\n\t\tthis._offsetNext = -0;\n\n\t}\n\n\tCubicInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: CubicInterpolant,\n\n\t\tDefaultSettings_: {\n\n\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\tiPrev = i1 - 2,\n\t\t\t\tiNext = i1 + 1,\n\n\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\ttNext = pp[ iNext ];\n\n\t\t\tif ( tPrev === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tNext === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\tstride = this.valueSize;\n\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\n\t\t},\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tpp = p * p,\n\t\t\t\tppp = pp * p;\n\n\t\t\t// evaluate polynomials\n\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t\t// combine data linearly\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction LinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: LinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset1 = i1 * stride,\n\t\t\t\toffset0 = offset1 - stride,\n\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tweight0 = 1 - weight1;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction DiscreteInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tDiscreteInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: DiscreteInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t}\n\n\t} );\n\n\tvar KeyframeTrackPrototype;\n\n\tKeyframeTrackPrototype = {\n\n\t\tTimeBufferType: Float32Array,\n\t\tValueBufferType: Float32Array,\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\t\treturn new DiscreteInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new LinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\t\treturn new CubicInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tsetInterpolation: function( interpolation ) {\n\n\t\t\tvar factoryMethod;\n\n\t\t\tswitch ( interpolation ) {\n\n\t\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateLinear:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateSmooth:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( factoryMethod === undefined ) {\n\n\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( message );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.createInterpolant = factoryMethod;\n\n\t\t},\n\n\t\tgetInterpolation: function() {\n\n\t\t\tswitch ( this.createInterpolant ) {\n\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\t\treturn InterpolateLinear;\n\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\t\treturn InterpolateSmooth;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetValueSize: function() {\n\n\t\t\treturn this.values.length / this.times.length;\n\n\t\t},\n\n\t\t// move all keyframes either forwards or backwards in time\n\t\tshift: function( timeOffset ) {\n\n\t\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\tscale: function( timeScale ) {\n\n\t\t\tif( timeScale !== 1.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\ttrim: function( startTime, endTime ) {\n\n\t\t\tvar times = this.times,\n\t\t\t\tnKeys = times.length,\n\t\t\t\tfrom = 0,\n\t\t\t\tto = nKeys - 1;\n\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t\t++ to; // inclusive -> exclusive bound\n\n\t\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\tthis.values = AnimationUtils.\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\tvalidate: function() {\n\n\t\t\tvar valid = true;\n\n\t\t\tvar valueSize = this.getValueSize();\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\n\t\t\t\tnKeys = times.length;\n\n\t\t\tif( nKeys === 0 ) {\n\n\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar prevTime = null;\n\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\t\tvar currTime = times[ i ];\n\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tprevTime = currTime;\n\n\t\t\t}\n\n\t\t\tif ( values !== undefined ) {\n\n\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn valid;\n\n\t\t},\n\n\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\toptimize: function() {\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\t\t\tstride = this.getValueSize(),\n\n\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\t\twriteIndex = 1,\n\t\t\t\tlastIndex = times.length - 1;\n\n\t\t\tfor( var i = 1; i < lastIndex; ++ i ) {\n\n\t\t\t\tvar keep = false;\n\n\t\t\t\tvar time = times[ i ];\n\t\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else keep = true;\n\n\t\t\t\t}\n\n\t\t\t\t// in-place compaction\n\n\t\t\t\tif ( keep ) {\n\n\t\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j )\n\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t++ writeIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// flush last keyframe (compaction looks ahead)\n\n\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )\n\n\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t\tif ( writeIndex !== times.length ) {\n\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\tfunction KeyframeTrackConstructor( name, times, values, interpolation ) {\n\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\t\tif( times === undefined || times.length === 0 ) {\n\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t\t}\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t\tthis.validate();\n\t\tthis.optimize();\n\n\t}\n\n\t/**\n\t *\n\t * A Track of vectored keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tVectorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: VectorKeyframeTrack,\n\n\t\tValueTypeName: 'vector'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction QuaternionLinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tQuaternionLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: QuaternionLinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset = i1 * stride,\n\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\t\tQuaternion.slerpFlat( result, 0,\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of quaternion keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tQuaternionKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: QuaternionKeyframeTrack,\n\n\t\tValueTypeName: 'quaternion',\n\n\t\t// ValueBufferType is inherited\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new QuaternionLinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of numeric keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tNumberKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: NumberKeyframeTrack,\n\n\t\tValueTypeName: 'number',\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t *\n\t * A Track that interpolates Strings\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tStringKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: StringKeyframeTrack,\n\n\t\tValueTypeName: 'string',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of Boolean keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction BooleanKeyframeTrack( name, times, values ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values );\n\n\t}\n\n\tBooleanKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: BooleanKeyframeTrack,\n\n\t\tValueTypeName: 'bool',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t\t// Note: Actually this track could have a optimized / compressed\n\t\t// representation of a single value and a custom interpolant that\n\t\t// computes \"firstValue ^ isOdd( index )\".\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of keyframe values that represent color.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tColorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: ColorKeyframeTrack,\n\n\t\tValueTypeName: 'color'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\n\t\t// Note: Very basic implementation and nothing special yet.\n\t\t// However, this is the place for color space parameterization.\n\n\t} );\n\n\t/**\n\t *\n\t * A timed sequence of keyframes for a specific property.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.apply( this, arguments );\n\n\t}\n\n\tKeyframeTrack.prototype = KeyframeTrackPrototype;\n\tKeyframeTrackPrototype.constructor = KeyframeTrack;\n\n\t// Static methods:\n\n\tObject.assign( KeyframeTrack, {\n\n\t\t// Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\n\t\tparse: function( json ) {\n\n\t\t\tif( json.type === undefined ) {\n\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t\t}\n\n\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\t\tif ( json.times === undefined ) {\n\n\t\t\t\tvar times = [], values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\t\tjson.times = times;\n\t\t\t\tjson.values = values;\n\n\t\t\t}\n\n\t\t\t// derived classes can define a static parse method\n\t\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\t\treturn trackType.parse( json );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\treturn new trackType(\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function( track ) {\n\n\t\t\tvar trackType = track.constructor;\n\n\t\t\tvar json;\n\n\t\t\t// derived classes can define a static toJSON method\n\t\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\t\tjson = trackType.toJSON( track );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t\t};\n\n\t\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\t\treturn json;\n\n\t\t},\n\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\t\tcase \"scalar\":\n\t\t\t\tcase \"double\":\n\t\t\t\tcase \"float\":\n\t\t\t\tcase \"number\":\n\t\t\t\tcase \"integer\":\n\n\t\t\t\t\treturn NumberKeyframeTrack;\n\n\t\t\t\tcase \"vector\":\n\t\t\t\tcase \"vector2\":\n\t\t\t\tcase \"vector3\":\n\t\t\t\tcase \"vector4\":\n\n\t\t\t\t\treturn VectorKeyframeTrack;\n\n\t\t\t\tcase \"color\":\n\n\t\t\t\t\treturn ColorKeyframeTrack;\n\n\t\t\t\tcase \"quaternion\":\n\n\t\t\t\t\treturn QuaternionKeyframeTrack;\n\n\t\t\t\tcase \"bool\":\n\t\t\t\tcase \"boolean\":\n\n\t\t\t\t\treturn BooleanKeyframeTrack;\n\n\t\t\t\tcase \"string\":\n\n\t\t\t\t\treturn StringKeyframeTrack;\n\n\t\t\t}\n\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Reusable set of Tracks that represent an animation.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tfunction AnimationClip( name, duration, tracks ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t\tthis.optimize();\n\n\t}\n\n\tAnimationClip.prototype = {\n\n\t\tconstructor: AnimationClip,\n\n\t\tresetDuration: function() {\n\n\t\t\tvar tracks = this.tracks,\n\t\t\t\tduration = 0;\n\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\t\tvar track = this.tracks[ i ];\n\n\t\t\t\tduration = Math.max(\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.duration = duration;\n\n\t\t},\n\n\t\ttrim: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\toptimize: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].optimize();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t// Static methods:\n\n\tObject.assign( AnimationClip, {\n\n\t\tparse: function( json ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\n\t\t},\n\n\n\t\ttoJSON: function( clip ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tclipTracks = clip.tracks;\n\n\t\t\tvar json = {\n\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks\n\n\t\t\t};\n\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn json;\n\n\t\t},\n\n\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\ttimes.push(\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttracks.push(\n\t\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, -1, tracks );\n\n\t\t},\n\n\t\tfindByName: function( objectOrClipArray, name ) {\n\n\t\t\tvar clipArray = objectOrClipArray;\n\n\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\t\treturn clipArray[ i ];\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\t\tvar animationToMorphTargets = {};\n\n\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t\t// sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar clips = [];\n\n\t\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t\t}\n\n\t\t\treturn clips;\n\n\t\t},\n\n\t\t// parse the animation.hierarchy format\n\t\tparseAnimation: function( animation, bones ) {\n\n\t\t\tif ( ! animation ) {\n\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tAnimationUtils.flattenJSON(\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar clipName = animation.name || 'default';\n\t\t\t// automatic length determination in AnimationClip.\n\t\t\tvar duration = animation.length || -1;\n\t\t\tvar fps = animation.fps || 30;\n\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t\t// skip empty tracks\n\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\n\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tracks.length === 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MaterialLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.textures = {};\n\n\t}\n\n\tObject.assign( MaterialLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTextures: function ( value ) {\n\n\t\t\tthis.textures = value;\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar textures = this.textures;\n\n\t\t\tfunction getTexture( name ) {\n\n\t\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn textures[ name ];\n\n\t\t\t}\n\n\t\t\tvar material = new Materials[ json.type ]();\n\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\n\t\t\t// for PointsMaterial\n\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t\t// maps\n\n\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\n\t\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\t\tvar normalScale = json.normalScale;\n\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t\t}\n\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\n\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t\t// MultiMaterial\n\n\t\t\tif ( json.materials !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometryLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( BufferGeometryLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar geometry = new BufferGeometry();\n\n\t\t\tvar index = json.data.index;\n\n\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t'Float64Array': Float64Array\n\t\t\t};\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tvar attributes = json.data.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t\t}\n\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\t\tif ( groups !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\t\tvar center = new Vector3();\n\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Loader() {\n\n\t\tthis.onLoadStart = function () {};\n\t\tthis.onLoadProgress = function () {};\n\t\tthis.onLoadComplete = function () {};\n\n\t}\n\n\tLoader.prototype = {\n\n\t\tconstructor: Loader,\n\n\t\tcrossOrigin: undefined,\n\n\t\textractUrlBase: function ( url ) {\n\n\t\t\tvar parts = url.split( '/' );\n\n\t\t\tif ( parts.length === 1 ) return './';\n\n\t\t\tparts.pop();\n\n\t\t\treturn parts.join( '/' ) + '/';\n\n\t\t},\n\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tcreateMaterial: ( function () {\n\n\t\t\tvar color, textureLoader, materialLoader;\n\n\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\t\tif ( color === undefined ) color = new Color();\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new TextureLoader();\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new MaterialLoader();\n\n\t\t\t\t// convert from old material format\n\n\t\t\t\tvar textures = {};\n\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\n\t\t\t\t\tvar texture;\n\n\t\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar uuid = _Math.generateUUID();\n\n\t\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\t\treturn uuid;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar json = {\n\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t};\n\n\t\t\t\tfor ( var name in m ) {\n\n\t\t\t\t\tvar value = m[ name ];\n\n\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\t\treturn materialLoader.parse( json );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\tLoader.Handlers = {\n\n\t\thandlers: [],\n\n\t\tadd: function ( regex, loader ) {\n\n\t\t\tthis.handlers.push( regex, loader );\n\n\t\t},\n\n\t\tget: function ( file ) {\n\n\t\t\tvar handlers = this.handlers;\n\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction JSONLoader( manager ) {\n\n\t\tif ( typeof manager === 'boolean' ) {\n\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\n\t\t}\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.withCredentials = false;\n\n\t}\n\n\tObject.assign( JSONLoader.prototype, {\n\n\t\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\n\t\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\t\tvar type = metadata.type;\n\n\t\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tparse: function ( json, texturePath ) {\n\n\t\t\tvar geometry = new Geometry(),\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\t\tparseModel( scale );\n\n\t\t\tparseSkin();\n\t\t\tparseMorphing( scale );\n\t\t\tparseAnimations();\n\n\t\t\tgeometry.computeFaceNormals();\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tfunction parseModel( scale ) {\n\n\t\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t\t}\n\n\t\t\t\tvar i, j, fi,\n\n\t\t\t\toffset, zLength,\n\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\t\ttype,\n\t\t\t\tisQuad,\n\t\t\t\thasMaterial,\n\t\t\t\thasFaceVertexUv,\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\t\tuvLayer, uv, u, v,\n\n\t\t\t\tfaces = json.faces,\n\t\t\t\tvertices = json.vertices,\n\t\t\t\tnormals = json.normals,\n\t\t\t\tcolors = json.colors,\n\n\t\t\t\tnUvLayers = 0;\n\n\t\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t\t// disregard empty arrays\n\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\tvertex = new Vector3();\n\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseSkin() {\n\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.bones = json.bones;\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseMorphing( scale ) {\n\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAnimations() {\n\n\t\t\t\tvar outputAnimations = [];\n\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\n\t\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\t\tanimations.push( json.animation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t\t}\n\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t\t}\n\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\t\treturn { geometry: geometry };\n\n\t\t\t} else {\n\n\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ObjectLoader ( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.texturePath = '';\n\n\t}\n\n\tObject.assign( ObjectLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( this.texturePath === '' ) {\n\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\n\t\t},\n\n\t\tparse: function ( json, onLoad ) {\n\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t} );\n\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\t\tif ( json.animations ) {\n\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t\t}\n\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t},\n\n\t\tparseGeometries: function ( json ) {\n\n\t\t\tvar geometries = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar geometry;\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometries;\n\n\t\t},\n\n\t\tparseMaterials: function ( json, textures ) {\n\n\t\t\tvar materials = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\tloader.setTextures( textures );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t},\n\n\t\tparseAnimations: function ( json ) {\n\n\t\t\tvar animations = [];\n\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\n\t\t\t\tanimations.push( clip );\n\n\t\t\t}\n\n\t\t\treturn animations;\n\n\t\t},\n\n\t\tparseImages: function ( json, onLoad ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar images = {};\n\n\t\t\tfunction loadImage( url ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\treturn loader.load( url, function () {\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, undefined, function () {\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\t\tvar manager = new LoadingManager( onLoad );\n\n\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn images;\n\n\t\t},\n\n\t\tparseTextures: function ( json, images ) {\n\n\t\t\tfunction parseConstant( value, type ) {\n\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\t\treturn type[ value ];\n\n\t\t\t}\n\n\t\t\tvar textures = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );\n\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn textures;\n\n\t\t},\n\n\t\tparseObject: function () {\n\n\t\t\tvar matrix = new Matrix4();\n\n\t\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\t\tvar object;\n\n\t\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn geometries[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn materials[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'Scene':\n\n\t\t\t\t\t\tobject = new Scene();\n\n\t\t\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LOD':\n\n\t\t\t\t\t\tobject = new LOD();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Line':\n\n\t\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LineSegments':\n\n\t\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Group':\n\n\t\t\t\t\t\tobject = new Group();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tobject = new Object3D();\n\n\t\t\t\t}\n\n\t\t\t\tobject.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\t\tif ( data.shadow ) {\n\n\t\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\t\tvar levels = data.levels;\n\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t};\n\n\t\t}()\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Extensible curve object\n\t *\n\t * Some common of Curve methods\n\t * .getPoint(t), getTangent(t)\n\t * .getPointAt(u), getTangentAt(u)\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following classes subclasses THREE.Curve:\n\t *\n\t * -- 2d classes --\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.SplineCurve\n\t * THREE.ArcCurve\n\t * THREE.EllipseCurve\n\t *\n\t * -- 3d classes --\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.SplineCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tAbstract Curve base class\n\t **************************************************************/\n\n\tfunction Curve() {}\n\n\tCurve.prototype = {\n\n\t\tconstructor: Curve,\n\n\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\n\t\tgetPointAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getPoint( t );\n\n\t\t},\n\n\t\t// Get sequence of points using getPoint( t )\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get sequence of points using getPointAt( u )\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get total curve arc length\n\n\t\tgetLength: function () {\n\n\t\t\tvar lengths = this.getLengths();\n\t\t\treturn lengths[ lengths.length - 1 ];\n\n\t\t},\n\n\t\t// Get list of cumulative segment lengths\n\n\t\tgetLengths: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\t\tif ( this.cacheArcLengths\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\treturn this.cacheArcLengths;\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tvar cache = [];\n\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\tvar p, sum = 0;\n\n\t\t\tcache.push( 0 );\n\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\tcache.push( sum );\n\t\t\t\tlast = current;\n\n\t\t\t}\n\n\t\t\tthis.cacheArcLengths = cache;\n\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t\t},\n\n\t\tupdateArcLengths: function() {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\t\tgetUtoTmapping: function ( u, distance ) {\n\n\t\t\tvar arcLengths = this.getLengths();\n\n\t\t\tvar i = 0, il = arcLengths.length;\n\n\t\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\t\tif ( distance ) {\n\n\t\t\t\ttargetArcLength = distance;\n\n\t\t\t} else {\n\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t\t}\n\n\t\t\t//var time = Date.now();\n\n\t\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\t\tvar low = 0, high = il - 1, comparison;\n\n\t\t\twhile ( low <= high ) {\n\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\t\tlow = i + 1;\n\n\t\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\t\thigh = i - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// DONE\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ti = high;\n\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\treturn t;\n\n\t\t\t}\n\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t\t// determine where we are between the 'before' and 'after' points\n\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t\t// add that fractional amount to t\n\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\t\treturn t;\n\n\t\t},\n\n\t\t// Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\n\t\tgetTangent: function( t ) {\n\n\t\t\tvar delta = 0.0001;\n\t\t\tvar t1 = t - delta;\n\t\t\tvar t2 = t + delta;\n\n\t\t\t// Capping in case of danger\n\n\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\tvar pt2 = this.getPoint( t2 );\n\n\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\treturn vec.normalize();\n\n\t\t},\n\n\t\tgetTangentAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getTangent( t );\n\n\t\t},\n\n\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\t\tvar normal = new Vector3();\n\n\t\t\tvar tangents = [];\n\t\t\tvar normals = [];\n\t\t\tvar binormals = [];\n\n\t\t\tvar vec = new Vector3();\n\t\t\tvar mat = new Matrix4();\n\n\t\t\tvar i, u, theta;\n\n\t\t\t// compute the tangent vectors for each segment on the curve\n\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\t\tu = i / segments;\n\n\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\ttangents[ i ].normalize();\n\n\t\t\t}\n\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the minimum tangent xyz component\n\n\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\tvar min = Number.MAX_VALUE;\n\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\n\t\t\tif ( tx <= min ) {\n\n\t\t\t\tmin = tx;\n\t\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( ty <= min ) {\n\n\t\t\t\tmin = ty;\n\t\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t\t}\n\n\t\t\tif ( tz <= min ) {\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t\t}\n\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\t\tvec.normalize();\n\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t\t}\n\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\t\tif ( closed === true ) {\n\n\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\ttheta /= segments;\n\n\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\t\ttheta = - theta;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t\t// twist a little...\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttangents: tangents,\n\t\t\t\tnormals: normals,\n\t\t\t\tbinormals: binormals\n\t\t\t};\n\n\t\t}\n\n\t};\n\n\t// TODO: Transformation for Curves?\n\n\t/**************************************************************\n\t *\t3D Curves\n\t **************************************************************/\n\n\t// A Factory method for creating new curve subclasses\n\n\tCurve.create = function ( constructor, getPointFunc ) {\n\n\t\tconstructor.prototype = Object.create( Curve.prototype );\n\t\tconstructor.prototype.constructor = constructor;\n\t\tconstructor.prototype.getPoint = getPointFunc;\n\n\t\treturn constructor;\n\n\t};\n\n\t/**************************************************************\n\t *\tLine\n\t **************************************************************/\n\n\tfunction LineCurve( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tLineCurve.prototype = Object.create( Curve.prototype );\n\tLineCurve.prototype.constructor = LineCurve;\n\n\tLineCurve.prototype.isLineCurve = true;\n\n\tLineCurve.prototype.getPoint = function ( t ) {\n\n\t\tif ( t === 1 ) {\n\n\t\t\treturn this.v2.clone();\n\n\t\t}\n\n\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\treturn point;\n\n\t};\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\n\tLineCurve.prototype.getPointAt = function ( u ) {\n\n\t\treturn this.getPoint( u );\n\n\t};\n\n\tLineCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\t\treturn tangent.normalize();\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *  curves, but retains the api of a curve\n\t **************************************************************/\n\n\tfunction CurvePath() {\n\n\t\tthis.curves = [];\n\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\t\tconstructor: CurvePath,\n\n\t\tadd: function ( curve ) {\n\n\t\t\tthis.curves.push( curve );\n\n\t\t},\n\n\t\tclosePath: function () {\n\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tvar d = t * this.getLength();\n\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\tvar i = 0;\n\n\t\t\t// To think about boundaries points.\n\n\t\t\twhile ( i < curveLengths.length ) {\n\n\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t\t},\n\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\t\tgetLength: function () {\n\n\t\t\tvar lens = this.getCurveLengths();\n\t\t\treturn lens[ lens.length - 1 ];\n\n\t\t},\n\n\t\t// cacheLengths must be recalculated.\n\t\tupdateArcLengths: function () {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\t\tgetCurveLengths: function () {\n\n\t\t\t// We use cache values if curves and cache array are same length\n\n\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\t\treturn this.cacheLengths;\n\n\t\t\t}\n\n\t\t\t// Get length of sub-curve\n\t\t\t// Push sums into cached array\n\n\t\t\tvar lengths = [], sums = 0;\n\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\tlengths.push( sums );\n\n\t\t\t}\n\n\t\t\tthis.cacheLengths = lengths;\n\n\t\t\treturn lengths;\n\n\t\t},\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 40;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tdivisions = divisions || 12;\n\n\t\t\tvar points = [], last;\n\n\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\t\tvar curve = curves[ i ];\n\t\t\t\tvar resolution = (curve && curve.isEllipseCurve) ? divisions * 2\n\t\t\t\t\t: (curve && curve.isLineCurve) ? 1\n\t\t\t\t\t: (curve && curve.isSplineCurve) ? divisions * curve.points.length\n\t\t\t\t\t: divisions;\n\n\t\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\n\t\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\tpoints.push( point );\n\t\t\t\t\tlast = point;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t/**************************************************************\n\t\t *\tCreate Geometries Helpers\n\t\t **************************************************************/\n\n\t\t/// Generate geometry from path points (for Line or Points objects)\n\n\t\tcreatePointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\t// Generate geometry from equidistant sampling along the path\n\n\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\tcreateGeometry: function ( points ) {\n\n\t\t\tvar geometry = new Geometry();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**************************************************************\n\t *\tEllipse curve\n\t **************************************************************/\n\n\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation || 0;\n\n\t}\n\n\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\tEllipseCurve.prototype.constructor = EllipseCurve;\n\n\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\tEllipseCurve.prototype.getPoint = function( t ) {\n\n\t\tvar twoPi = Math.PI * 2;\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\tvar sin = Math.sin( this.aRotation );\n\n\t\t\tvar tx = x - this.aX;\n\t\t\tvar ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn new Vector2( x, y );\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar CurveUtils = {\n\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t\t},\n\n\t\t// Puay Bing, thanks for helping with this derivative!\n\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t3 * t * t * p3;\n\n\t\t},\n\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\t// To check if my formulas are correct\n\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\n\n\t\t\treturn h00 + h10 + h01 + h11;\n\n\t\t},\n\n\t\t// Catmull-Rom\n\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t};\n\n\t/**************************************************************\n\t *\tSpline curve\n\t **************************************************************/\n\n\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\n\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t}\n\n\tSplineCurve.prototype = Object.create( Curve.prototype );\n\tSplineCurve.prototype.constructor = SplineCurve;\n\n\tSplineCurve.prototype.isSplineCurve = true;\n\n\tSplineCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\treturn new Vector2(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t);\n\n\t};\n\n\t/**************************************************************\n\t *\tCubic Bezier curve\n\t **************************************************************/\n\n\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\n\tCubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b3 = ShapeUtils.b3;\n\n\t\treturn new Vector2(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t);\n\n\t};\n\n\tCubicBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentCubicBezier = CurveUtils.tangentCubicBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t).normalize();\n\n\t};\n\n\t/**************************************************************\n\t *\tQuadratic Bezier curve\n\t **************************************************************/\n\n\n\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\n\n\tQuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b2 = ShapeUtils.b2;\n\n\t\treturn new Vector2(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t);\n\n\t};\n\n\n\tQuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t).normalize();\n\n\t};\n\n\tvar PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n\t\tfromPoints: function ( vectors ) {\n\n\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmoveTo: function ( x, y ) {\n\n\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\t},\n\n\t\tlineTo: function ( x, y ) {\n\n\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( x, y );\n\n\t\t},\n\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\t\tvar curve = new SplineCurve( npts );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\t},\n\n\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t},\n\n\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\tthis.currentPoint.copy( lastPoint );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Defines a 2d shape plane using paths.\n\t **/\n\n\t// STEP 1 Create a path.\n\t// STEP 2 Turn path into shape.\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t// STEP 3a - Extract points from each shape, turn to vertices\n\t// STEP 3b - Triangulate each shape, add faces.\n\n\tfunction Shape() {\n\n\t\tPath.apply( this, arguments );\n\n\t\tthis.holes = [];\n\n\t}\n\n\tShape.prototype = Object.assign( Object.create( PathPrototype ), {\n\n\t\tconstructor: Shape,\n\n\t\tgetPointsHoles: function ( divisions ) {\n\n\t\t\tvar holesPts = [];\n\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t\t}\n\n\t\t\treturn holesPts;\n\n\t\t},\n\n\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\t\textractAllPoints: function ( divisions ) {\n\n\t\t\treturn {\n\n\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t\t};\n\n\t\t},\n\n\t\textractPoints: function ( divisions ) {\n\n\t\t\treturn this.extractAllPoints( divisions );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Creates free form 2d path using series of points, lines or curves.\n\t *\n\t **/\n\n\tfunction Path( points ) {\n\n\t\tCurvePath.call( this );\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.fromPoints( points );\n\n\t\t}\n\n\t}\n\n\tPath.prototype = PathPrototype;\n\tPathPrototype.constructor = Path;\n\n\n\t// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\tfunction ShapePath() {\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\t}\n\n\tShapePath.prototype = {\n\t\tmoveTo: function ( x, y ) {\n\t\t\tthis.currentPath = new Path();\n\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\tthis.currentPath.moveTo( x, y );\n\t\t},\n\t\tlineTo: function ( x, y ) {\n\t\t\tthis.currentPath.lineTo( x, y );\n\t\t},\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\t},\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\t},\n\t\tsplineThru: function ( pts ) {\n\t\t\tthis.currentPath.splineThru( pts );\n\t\t},\n\n\t\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\t\tvar shapes = [];\n\n\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t\t}\n\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\tvar inside = false;\n\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn\tinside;\n\n\t\t\t}\n\n\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\n\t\t\tvar subPaths = this.subPaths;\n\t\t\tif ( subPaths.length === 0 ) return [];\n\n\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\t\tif ( subPaths.length === 1 ) {\n\n\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\ttmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\t\tvar betterShapeHoles = [];\n\t\t\tvar newShapes = [];\n\t\t\tvar newShapeHoles = [];\n\t\t\tvar mainIdx = 0;\n\t\t\tvar tmpPoints;\n\n\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\t\tif ( solid ) {\n\n\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t\t//console.log('cw', i);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t\t//console.log('ccw', i);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tif ( newShapes.length > 1 ) {\n\n\t\t\t\tvar ambiguous = false;\n\t\t\t\tvar toChange = [];\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar tmpHoles;\n\n\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Font( data ) {\n\n\t\tthis.data = data;\n\n\t}\n\n\tObject.assign( Font.prototype, {\n\n\t\tisFont: true,\n\n\t\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\t\tfunction createPaths( text ) {\n\n\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\tvar offset = 0;\n\n\t\t\t\tvar paths = [];\n\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\toffset += ret.offset;\n\n\t\t\t\t\tpaths.push( ret.path );\n\n\t\t\t\t}\n\n\t\t\t\treturn paths;\n\n\t\t\t}\n\n\t\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\t\tif ( ! glyph ) return;\n\n\t\t\t\tvar path = new ShapePath();\n\n\t\t\t\tvar pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\t\tif ( glyph.o ) {\n\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( size === undefined ) size = 100;\n\t\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\t\tvar data = this.data;\n\n\t\t\tvar paths = createPaths( text );\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction FontLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( FontLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json;\n\n\t\t\t\ttry {\n\n\t\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar font = scope.parse( json );\n\n\t\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\treturn new Font( json );\n\n\t\t}\n\n\t} );\n\n\tvar context;\n\n\tfunction getAudioContext() {\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn context;\n\n\t}\n\n\t/**\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction AudioLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( AudioLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar context = getAudioContext();\n\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction StereoCamera() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t}\n\n\tObject.assign( StereoCamera.prototype, {\n\n\t\tupdate: ( function () {\n\n\t\t\tvar instance, focus, fov, aspect, near, far, zoom;\n\n\t\t\tvar eyeRight = new Matrix4();\n\t\t\tvar eyeLeft = new Matrix4();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom;\n\n\t\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t\tinstance = this;\n\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\tnear = camera.near;\n\t\t\t\t\tfar = camera.far;\n\t\t\t\t\tzoom = camera.zoom;\n\n\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\tvar eyeSep = this.eyeSep / 2;\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t\t// translate xOffset\n\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t\t// for left eye\n\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t\t// for right eye\n\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * Camera for rendering cube maps\n\t *\t- renders scene into axis-aligned cube\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CubeCamera( near, far, cubeResolution ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tvar fov = 90, aspect = 1;\n\n\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\n\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\n\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\n\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\n\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\n\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\n\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\n\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\t\tvar renderTarget = this.renderTarget;\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t};\n\n\t}\n\n\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\tCubeCamera.prototype.constructor = CubeCamera;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioListener() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = getAudioContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t}\n\n\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: AudioListener,\n\n\t\tgetInput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tremoveFilter: function ( ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\tthis.filter = null;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.filter;\n\n\t\t},\n\n\t\tsetFilter: function ( value ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t\t} else {\n\n\t\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t\t}\n\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect( this.filter );\n\t\t\tthis.filter.connect( this.context.destination );\n\n\t\t},\n\n\t\tgetMasterVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\t\tsetMasterVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3();\n\n\t\t\tvar orientation = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tvar listener = this.context.listener;\n\t\t\t\tvar up = this.up;\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction Audio( listener ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.context = listener.context;\n\t\tthis.source = this.context.createBufferSource();\n\t\tthis.source.onended = this.onEnded.bind( this );\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.startTime = 0;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis.filters = [];\n\n\t}\n\n\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Audio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tsetNodeSource: function ( audioNode ) {\n\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetBuffer: function ( audioBuffer ) {\n\n\t\t\tthis.source.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\n\t\t\tif ( this.autoplay ) this.play();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tplay: function () {\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar source = this.context.createBufferSource();\n\n\t\t\tsource.buffer = this.source.buffer;\n\t\t\tsource.loop = this.source.loop;\n\t\t\tsource.onended = this.source.onended;\n\t\t\tsource.start( 0, this.startTime );\n\t\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\t\tthis.isPlaying = true;\n\n\t\t\tthis.source = source;\n\n\t\t\treturn this.connect();\n\n\t\t},\n\n\t\tpause: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = this.context.currentTime;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = 0;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdisconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilters: function () {\n\n\t\t\treturn this.filters;\n\n\t\t},\n\n\t\tsetFilters: function ( value ) {\n\n\t\t\tif ( ! value ) value = [];\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value;\n\t\t\t\tthis.connect();\n\n\t\t\t} else {\n\n\t\t\t\tthis.filters = value;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.getFilters()[ 0 ];\n\n\t\t},\n\n\t\tsetFilter: function ( filter ) {\n\n\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t\t},\n\n\t\tsetPlaybackRate: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.playbackRate = value;\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetPlaybackRate: function () {\n\n\t\t\treturn this.playbackRate;\n\n\t\t},\n\n\t\tonEnded: function () {\n\n\t\t\tthis.isPlaying = false;\n\n\t\t},\n\n\t\tgetLoop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn this.source.loop;\n\n\t\t},\n\n\t\tsetLoop: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.loop = value;\n\n\t\t},\n\n\t\tgetVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\n\t\tsetVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PositionalAudio( listener ) {\n\n\t\tAudio.call( this, listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\n\t\tconstructor: PositionalAudio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.panner;\n\n\t\t},\n\n\t\tgetRefDistance: function () {\n\n\t\t\treturn this.panner.refDistance;\n\n\t\t},\n\n\t\tsetRefDistance: function ( value ) {\n\n\t\t\tthis.panner.refDistance = value;\n\n\t\t},\n\n\t\tgetRolloffFactor: function () {\n\n\t\t\treturn this.panner.rolloffFactor;\n\n\t\t},\n\n\t\tsetRolloffFactor: function ( value ) {\n\n\t\t\tthis.panner.rolloffFactor = value;\n\n\t\t},\n\n\t\tgetDistanceModel: function () {\n\n\t\t\treturn this.panner.distanceModel;\n\n\t\t},\n\n\t\tsetDistanceModel: function ( value ) {\n\n\t\t\tthis.panner.distanceModel = value;\n\n\t\t},\n\n\t\tgetMaxDistance: function () {\n\n\t\t\treturn this.panner.maxDistance;\n\n\t\t},\n\n\t\tsetMaxDistance: function ( value ) {\n\n\t\t\tthis.panner.maxDistance = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioAnalyser( audio, fftSize ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\tObject.assign( AudioAnalyser.prototype, {\n\n\t\tgetFrequencyData: function () {\n\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\t\treturn this.data;\n\n\t\t},\n\n\t\tgetAverageFrequency: function () {\n\n\t\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tvalue += data[ i ];\n\n\t\t\t}\n\n\t\t\treturn value / data.length;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Buffered scene graph property that allows weighted accumulation.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tvar bufferType = Float64Array,\n\t\t\tmixFunction;\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t\t}\n\n\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\n\t\tthis._mixBufferRegion = mixFunction;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\tPropertyMixer.prototype = {\n\n\t\tconstructor: PropertyMixer,\n\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\taccumulate: function( accuIndex, weight ) {\n\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\t\tif ( currentWeight === 0 ) {\n\n\t\t\t\t// accuN := incoming * weight\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcurrentWeight = weight;\n\n\t\t\t} else {\n\n\t\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = currentWeight;\n\n\t\t},\n\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\tapply: function( accuIndex ) {\n\n\t\t\tvar stride = this.valueSize,\n\t\t\t\tbuffer = this.buffer,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tweight = this.cumulativeWeight,\n\n\t\t\t\tbinding = this.binding;\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t\tif ( weight < 1 ) {\n\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t\t}\n\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remember the state of the bound property and copy it to both accus\n\t\tsaveOriginalState: function() {\n\n\t\t\tvar binding = this.binding;\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toriginalValueOffset = stride * 3;\n\n\t\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t},\n\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\trestoreOriginalState: function() {\n\n\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t\t},\n\n\n\t\t// mix functions\n\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tif ( t >= 0.5 ) {\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tQuaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t\t},\n\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tvar s = 1 - t;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tvar j = dstOffset + i;\n\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * A reference to a real property in the scene graph.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode(\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\t\tthis.rootNode = rootNode;\n\n\t}\n\n\tPropertyBinding.prototype = {\n\n\t\tconstructor: PropertyBinding,\n\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.getValue( targetArray, offset );\n\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t// prototype version of these methods with one that represents\n\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t// become no-ops.\n\n\t\t},\n\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.setValue( sourceArray, offset );\n\n\t\t},\n\n\t\t// create getter / setter pair for a property in the scene graph\n\t\tbind: function() {\n\n\t\t\tvar targetObject = this.node,\n\t\t\t\tparsedPath = this.parsedPath,\n\n\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\ttargetObject = PropertyBinding.findNode(\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\t\tthis.node = targetObject;\n\n\t\t\t}\n\n\t\t\t// set fail state so we can just 'return' on error\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable;\n\n\t \t\t// ensure there is a value node\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( objectName ) {\n\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\tswitch ( objectName ) {\n\n\t\t\t\t\tcase 'materials':\n\n\t\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bones':\n\n\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// resolve property\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\t\tif ( nodeProperty === undefined ) {\n\n\t\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// determine versioning scheme\n\t\t\tvar versioning = this.Versioning.None;\n\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t}\n\n\t\t\t// determine how the property gets bound\n\t\t\tvar bindingType = this.BindingType.Direct;\n\n\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else {\n\n\t\t\t\tthis.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\t// select getter / setter\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tthis.node = null;\n\n\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\n\t\t}\n\n\t};\n\n\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t\t// these are used to \"bind\" a nonexistent property\n\t\t_getValue_unavailable: function() {},\n\t\t_setValue_unavailable: function() {},\n\n\t\t// initial state of these methods that calls 'bind'\n\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n\t\tBindingType: {\n\t\t\tDirect: 0,\n\t\t\tEntireArray: 1,\n\t\t\tArrayElement: 2,\n\t\t\tHasFromToArray: 3\n\t\t},\n\n\t\tVersioning: {\n\t\t\tNone: 0,\n\t\t\tNeedsUpdate: 1,\n\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t},\n\n\t\tGetterByBindingType: [\n\n\t\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\t\tvar source = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t\t}\n\n\t\t],\n\n\t\tSetterByBindingTypeAndVersioning: [\n\n\t\t\t[\n\t\t\t\t// Direct\n\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// EntireArray\n\n\t\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// ArrayElement\n\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// HasToFromArray\n\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t]\n\n\t\t]\n\n\t} );\n\n\tPropertyBinding.Composite =\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t};\n\n\tPropertyBinding.Composite.prototype = {\n\n\t\tconstructor: PropertyBinding.Composite,\n\n\t\tgetValue: function( array, offset ) {\n\n\t\t\tthis.bind(); // bind all binding\n\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t\t// and only call .getValue on the first\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t\t},\n\n\t\tsetValue: function( array, offset ) {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t\t}\n\n\t\t},\n\n\t\tbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].bind();\n\n\t\t\t}\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].unbind();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.create = function( root, path, parsedPath ) {\n\n\t\tif ( ! ( (root && root.isAnimationObjectGroup) ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.parseTrackName = function( trackName ) {\n\n\t\t// matches strings in the form of:\n\t\t//    nodeName.property\n\t\t//    nodeName.property[accessor]\n\t\t//    nodeName.material.property[accessor]\n\t\t//    uuid.property[accessor]\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t//    parentName/nodeName.property\n\t\t//    parentName/parentName/nodeName.property[index]\n\t\t//    .bone[Armature.DEF_cog].position\n\t\t//    scene:helium_balloon_model:helium_balloon_model.position\n\t\t// created and tested via https://regex101.com/#javascript\n\n\t\tvar re = /^((?:\\w+[\\/:])*)(\\w+)?(?:\\.(\\w+)(?:\\[(.+)\\])?)?\\.(\\w+)(?:\\[(.+)\\])?$/;\n\t\tvar matches = re.exec( trackName );\n\n\t\tif ( ! matches ) {\n\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t\t}\n\n\t\tvar results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ], \t// allowed to be null, specified root node.\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ],\n\t\t\tpropertyIndex: matches[ 6 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t};\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t};\n\n\tPropertyBinding.findNode = function( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\t\treturn bone;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\t\tif ( bone ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t * \t-\tInstead pass this object as 'root'.\n\t *\n\t * \t-\tYou can also add and remove objects later when the mixer\n\t * \t\tis running.\n\t *\n\t * Note:\n\t *\n\t *  \tObjects of this class appear as one object to the mixer,\n\t *  \tso cache control of the individual objects must be done\n\t *  \ton the group.\n\t *\n\t * Limitation:\n\t *\n\t * \t- \tThe animated properties must be compatible among the\n\t * \t\tall objects in the group.\n\t *\n\t *  -\tA single property can either be controlled through a\n\t *  \ttarget group or directly, but not both.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction AnimationObjectGroup( var_args ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tvar indices = {};\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t},\n\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t\t};\n\n\t}\n\n\tAnimationObjectGroup.prototype = {\n\n\t\tconstructor: AnimationObjectGroup,\n\n\t\tisAnimationObjectGroup: true,\n\n\t\tadd: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tpaths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index === undefined ) {\n\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\tnew PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\t\tbinding = new PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t\t} // else the object is already where we want it to be\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\tremove: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// remove & forget\n\t\tuncache: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // cached or active\n\n\t\t\t\t} // if object is known\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tobjects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\t\tindex = bindings.length;\n\n\t\t\tindicesByPath[ path ] = index;\n\n\t\t\tpaths.push( path );\n\t\t\tparsedPaths.push( parsedPath );\n\t\t\tbindings.push( bindingsForPath );\n\n\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\tnew PropertyBinding( object, path, parsedPath );\n\n\t\t\t}\n\n\t\t\treturn bindingsForPath;\n\n\t\t},\n\n\t\tunsubscribe_: function( path ) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\tbindings.pop();\n\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\tparsedPaths.pop();\n\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\tpaths.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t * objects.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t *\n\t */\n\n\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\n\t\tvar tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tvar interpolantSettings = {\n\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = -1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n\t}\n\n\tAnimationAction.prototype = {\n\n\t\tconstructor: AnimationAction,\n\n\t\t// State & Scheduling\n\n\t\tplay: function() {\n\n\t\t\tthis._mixer._activateAction( this );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function() {\n\n\t\t\tthis._mixer._deactivateAction( this );\n\n\t\t\treturn this.reset();\n\n\t\t},\n\n\t\treset: function() {\n\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\n\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\tthis._startTime = null;\t// forget scheduling\n\n\t\t\treturn this.stopFading().stopWarping();\n\n\t\t},\n\n\t\tisRunning: function() {\n\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\t// return true when play has been called\n\t\tisScheduled: function() {\n\n\t\t\treturn this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\tstartAt: function( time ) {\n\n\t\t\tthis._startTime = time;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetLoop: function( mode, repetitions ) {\n\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Weight\n\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\t\tsetEffectiveWeight: function( weight ) {\n\n\t\t\tthis.weight = weight;\n\n\t\t\t// note: same logic as when updated at runtime\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\t\treturn this.stopFading();\n\n\t\t},\n\n\t\t// return the weight considering fading and .enabled\n\t\tgetEffectiveWeight: function() {\n\n\t\t\treturn this._effectiveWeight;\n\n\t\t},\n\n\t\tfadeIn: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t\t},\n\n\t\tfadeOut: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t\t},\n\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\tthis.fadeIn( duration );\n\n\t\t\tif( warp ) {\n\n\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t\t},\n\n\t\tstopFading: function() {\n\n\t\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\t\tif ( weightInterpolant !== null ) {\n\n\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Time Scale Control\n\n\t\t// set the weight stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\t\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\t// return the time scale considering warping and .paused\n\t\tgetEffectiveTimeScale: function() {\n\n\t\t\treturn this._effectiveTimeScale;\n\n\t\t},\n\n\t\tsetDuration: function( duration ) {\n\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\tsyncWith: function( action ) {\n\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\thalt: function( duration ) {\n\n\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t\t},\n\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now;\n\t\t\ttimes[ 1 ] = now + duration;\n\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstopWarping: function() {\n\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Object Accessors\n\n\t\tgetMixer: function() {\n\n\t\t\treturn this._mixer;\n\n\t\t},\n\n\t\tgetClip: function() {\n\n\t\t\treturn this._clip;\n\n\t\t},\n\n\t\tgetRoot: function() {\n\n\t\t\treturn this._localRoot || this._mixer._root;\n\n\t\t},\n\n\t\t// Interna\n\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t// called by the mixer\n\n\t\t\tvar startTime = this._startTime;\n\n\t\t\tif ( startTime !== null ) {\n\n\t\t\t\t// check for scheduled start of action\n\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t\t}\n\n\t\t\t\t// start\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t\t// apply time scale and advance time\n\n\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\n\t\t\tvar weight = this._updateWeight( time );\n\n\t\t\tif ( weight > 0 ) {\n\n\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_updateWeight: function( time ) {\n\n\t\t\tvar weight = 0;\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\tweight = this.weight;\n\t\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\n\t\t},\n\n\t\t_updateTimeScale: function( time ) {\n\n\t\t\tvar timeScale = 0;\n\n\t\t\tif ( ! this.paused ) {\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\n\t\t},\n\n\t\t_updateTime: function( deltaTime ) {\n\n\t\t\tvar time = this.time + deltaTime;\n\n\t\t\tif ( deltaTime === 0 ) return time;\n\n\t\t\tvar duration = this._clip.duration,\n\n\t\t\t\tloop = this.loop,\n\t\t\t\tloopCount = this._loopCount;\n\n\t\t\tif ( loop === LoopOnce ) {\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t\t}\n\n\t\t\t\thandle_stop: {\n\n\t\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\t\ttime = duration;\n\n\t\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\t\ttime = 0;\n\n\t\t\t\t\t} else break handle_stop;\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t// wrap around\n\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\n\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\t\tthis.time = time;\n\t\t\t\t\treturn duration - time;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.time = time;\n\t\t\treturn time;\n\n\t\t},\n\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\t\tvar settings = this._interpolantSettings;\n\n\t\t\tif ( pingPong ) {\n\n\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\n\t\t\t} else {\n\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\t\tif ( atStart ) {\n\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t\tif ( atEnd ) {\n\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Player for AnimationClips.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction AnimationMixer( root ) {\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\tObject.assign( AnimationMixer.prototype, EventDispatcher.prototype, {\n\n\t\t// return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\t\tclipAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\tprototypeAction = null;\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\tvar existingAction =\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\t\treturn existingAction;\n\n\t\t\t\t}\n\n\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\tif ( clipObject === null )\n\t\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t\t}\n\n\t\t\t// clip must be known when specified via string\n\t\t\tif ( clipObject === null ) return null;\n\n\t\t\t// allocate all resources required to run it\n\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n\t\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t\t// and make the action known to the memory manager\n\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\t\treturn newAction;\n\n\t\t},\n\n\t\t// get an existing action\n\t\texistingAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// deactivates all previously scheduled actions\n\t\tstopAllAction: function() {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tactions[ i ].reset();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].useCount = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// advance the time and update apply the animation\n\t\tupdate: function( deltaTime ) {\n\n\t\t\tdeltaTime *= this.timeScale;\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\n\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t\t// run active actions\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tvar action = actions[ i ];\n\n\t\t\t\tif ( action.enabled ) {\n\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update scene graph\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// return this mixer's root target object\n\t\tgetRoot: function() {\n\n\t\t\treturn this._root;\n\n\t\t},\n\n\t\t// free all resources specific to a particular clip\n\t\tuncacheClip: function( clip ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t\t}\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t// free all resources specific to a particular root target object\n\t\tuncacheRoot: function( root ) {\n\n\t\t\tvar rootUuid = root.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip;\n\n\t\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( action !== undefined ) {\n\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingByName !== undefined ) {\n\n\t\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remove a targeted clip from the cache\n\t\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\t\tif ( action !== null ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// Implementation details:\n\n\tObject.assign( AnimationMixer.prototype, {\n\n\t\t_bindAction: function( action, prototypeAction ) {\n\n\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\trootUuid = root.uuid,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingsByName === undefined ) {\n\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t}\n\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t\t}\n\n\t\t},\n\n\t\t_activateAction: function( action ) {\n\n\t\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t\t}\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// increment reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._lendAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t_deactivateAction: function( action ) {\n\n\t\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._takeBackAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Memory manager\n\n\t\t_initMemoryManager: function() {\n\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\tthis._nActiveActions = 0;\n\n\t\t\tthis._actionsByClip = {};\n\t\t\t// inside:\n\t\t\t// {\n\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t// }\n\n\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\tthis._nActiveControlInterpolants = 0;\n\n\t\t\tvar scope = this;\n\n\t\t\tthis.stats = {\n\n\t\t\t\tactions: {\n\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t},\n\n\t\t// Memory management for AnimationAction objects\n\n\t\t_isActiveAction: function( action ) {\n\n\t\t\tvar index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\n\t\t},\n\n\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip === undefined ) {\n\n\t\t\t\tactionsForClip = {\n\n\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\tactionByRoot: {}\n\n\t\t\t\t};\n\n\t\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t\t} else {\n\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push( action );\n\n\t\t\t}\n\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push( action );\n\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t\t},\n\n\t\t_removeInactiveAction: function( action ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\tcacheIndex = action._cacheIndex;\n\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\tactions.pop();\n\n\t\t\taction._cacheIndex = null;\n\n\n\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\t\tlastKnownAction =\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\n\t\t\taction._byClipCacheIndex = null;\n\n\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\t\tdelete actionByRoot[ rootUuid ];\n\n\t\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t},\n\n\t\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendAction: function( action ) {\n\n\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t// [  active actions >| inactive actions ]\n\t\t\t//                 s        a\n\t\t\t//                  <-swap->\n\t\t\t//                 a        s\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[ lastActiveIndex ] = action;\n\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t\t},\n\n\t\t_takeBackAction: function( action ) {\n\n\t\t\t// [  active actions  | inactive actions ]\n\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t//        a        s\n\t\t\t//         <-swap->\n\t\t\t//        s        a\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[ firstInactiveIndex ] = action;\n\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t\t},\n\n\t\t// Memory management for PropertyMixer objects\n\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( bindingByName === undefined ) {\n\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t\t}\n\n\t\t\tbindingByName[ trackName ] = binding;\n\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push( binding );\n\n\t\t},\n\n\t\t_removeInactiveBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tpropBinding = binding.binding,\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\ttrackName = propBinding.path,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\n\t\t\tdelete bindingByName[ trackName ];\n\n\t\t\tremove_empty_map: {\n\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t\t},\n\n\t\t_takeBackBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t\t},\n\n\n\t\t// Memory management of Interpolants for weight and time scale\n\n\t\t_lendControlInterpolant: function() {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\t\tif ( interpolant === undefined ) {\n\n\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t\t}\n\n\t\t\treturn interpolant;\n\n\t\t},\n\n\t\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t\t},\n\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Uniform( value ) {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferGeometry() {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.maxInstancedCount = undefined;\n\n\t}\n\n\tInstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tInstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;\n\n\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\n\tInstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t};\n\n\tInstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized === true;\n\n\t}\n\n\n\tInterleavedBufferAttribute.prototype = {\n\n\t\tconstructor: InterleavedBufferAttribute,\n\n\t\tisInterleavedBufferAttribute: true,\n\n\t\tget count() {\n\n\t\t\treturn this.data.count;\n\n\t\t},\n\n\t\tget array() {\n\n\t\t\treturn this.data.array;\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\tthis.data.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBuffer( array, stride ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tInterleavedBuffer.prototype = {\n\n\t\tconstructor: InterleavedBuffer,\n\n\t\tisInterleavedBuffer: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.count = source.count;\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n\t\tInterleavedBuffer.call( this, array, stride );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );\n\tInstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;\n\n\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\n\tInstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\n\t\tBufferAttribute.call( this, array, itemSize );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tInstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;\n\n\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\n\tInstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\t\tBufferAttribute.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author bhouston / http://clara.io/\n\t * @author stephomi / http://stephaneginier.com/\n\t */\n\n\tfunction Raycaster( origin, direction, near, far ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tRaycaster.prototype = {\n\n\t\tconstructor: Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( (camera && camera.isPerspectiveCamera) ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( (camera && camera.isOrthographicCamera) ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Clock( autoStart ) {\n\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tClock.prototype = {\n\n\t\tconstructor: Clock,\n\n\t\tstart: function () {\n\n\t\t\tthis.startTime = ( performance || Date ).now();\n\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\n\t\t},\n\n\t\tgetElapsedTime: function () {\n\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\n\t\t},\n\n\t\tgetDelta: function () {\n\n\t\t\tvar diff = 0;\n\n\t\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\t\tthis.start();\n\n\t\t\t}\n\n\t\t\tif ( this.running ) {\n\n\t\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\n\t\t\t\tthis.elapsedTime += diff;\n\n\t\t\t}\n\n\t\t\treturn diff;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Spline from Tween.js, slightly optimized (and trashed)\n\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t *\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Spline( points ) {\n\n\t\tthis.points = points;\n\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\tpoint, intPoint, weight, w2, w3,\n\t\tpa, pb, pc, pd;\n\n\t\tthis.initFromArray = function ( a ) {\n\n\t\t\tthis.points = [];\n\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getPoint = function ( k ) {\n\n\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\tc[ 1 ] = intPoint;\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\tpd = this.points[ c[ 3 ] ];\n\n\t\t\tw2 = weight * weight;\n\t\t\tw3 = weight * w2;\n\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\t\treturn v3;\n\n\t\t};\n\n\t\tthis.getControlPointsArray = function () {\n\n\t\t\tvar i, p, l = this.points.length,\n\t\t\t\tcoords = [];\n\n\t\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\t\tp = this.points[ i ];\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t\t}\n\n\t\t\treturn coords;\n\n\t\t};\n\n\t\t// approximate length by summing linear segments\n\n\t\tthis.getLength = function ( nSubDivisions ) {\n\n\t\t\tvar i, index, nSamples, position,\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\toldPosition = new Vector3(),\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tchunkLengths = [],\n\t\t\t\ttotalLength = 0;\n\n\t\t\t// first point has 0 length\n\n\t\t\tchunkLengths[ 0 ] = 0;\n\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\t\tindex = i / nSamples;\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\ttmpVec.copy( position );\n\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\t\toldPosition.copy( position );\n\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\tintPoint = Math.floor( point );\n\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// last point ends with total length\n\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t\t};\n\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\t\tvar i, j,\n\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\trealDistance,\n\t\t\t\tsampling, position,\n\t\t\t\tnewpoints = [],\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tsl = this.getLength();\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t\t}\n\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tthis.points = newpoints;\n\n\t\t};\n\n\t\t// Catmull-Rom\n\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The poles (phi) are at the positive and negative y axis.\n\t * The equator starts at positive z.\n\t */\n\n\tfunction Spherical( radius, phi, theta ) {\n\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\t\treturn this;\n\n\t}\n\n\tSpherical.prototype = {\n\n\t\tconstructor: Spherical,\n\n\t\tset: function ( radius, phi, theta ) {\n\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( other ) {\n\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tmakeSafe: function() {\n\n\t\t\tvar EPS = 0.000001;\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromVector3: function( vec3 ) {\n\n\t\t\tthis.radius = vec3.length();\n\n\t\t\tif ( this.radius === 0 ) {\n\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t};\n\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\r\n\tfunction MorphBlendMesh( geometry, material ) {\n\r\n\t\tMesh.call( this, geometry, material );\r\n\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\t\tvar name = \"__default\";\r\n\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\r\n\t\tvar fps = numFrames / 1;\r\n\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\r\n\t}\r\n\r\n\tMorphBlendMesh.prototype = Object.create( Mesh.prototype );\r\n\tMorphBlendMesh.prototype.constructor = MorphBlendMesh;\r\n\r\n\tMorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\t\tvar animation = {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\r\n\t\t\tlength: end - start + 1,\r\n\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\r\n\t\t\tactive: false,\r\n\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\r\n\t\t};\r\n\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\r\n\t\tvar geometry = this.geometry;\r\n\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in frameRanges ) {\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t\t}\r\n\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.weight = weight;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = time;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\t\tvar time = 0;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\ttime = animation.time;\r\n\r\n\t\t}\r\n\r\n\t\treturn time;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\t\tvar duration = - 1;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tduration = animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\treturn duration;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.active = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\t\tif ( ! animation.active ) continue;\r\n\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction ImmediateRenderObject( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.material = material;\n\t\tthis.render = function ( renderCallback ) {};\n\n\t}\n\n\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\n\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length * 3;\n\n\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\n\tVertexNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\t\tvar faces = objGeometry.faces;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction SpotLightHelper( light ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = [\n\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t0, 0, 0,   0, - 1,   1\n\t\t];\n\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\n\tSpotLightHelper.prototype.dispose = function () {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t};\n\n\tSpotLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\t\tvar vector2 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author Sean Griffin / http://twitter.com/sgrif\n\t * @author Michael Guerrero / http://realitymeltdown.com\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkeletonHelper( object ) {\n\n\t\tthis.bones = this.getBoneList( object );\n\n\t\tvar geometry = new Geometry();\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.colors.push( new Color( 0, 0, 1 ) );\n\t\t\t\tgeometry.colors.push( new Color( 0, 1, 0 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.dynamic = true;\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.root = object;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\n\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\n\tSkeletonHelper.prototype.getBoneList = function( object ) {\n\n\t\tvar boneList = [];\n\n\t\tif ( (object && object.isBone) ) {\n\n\t\t\tboneList.push( object );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t\t}\n\n\t\treturn boneList;\n\n\t};\n\n\tSkeletonHelper.prototype.update = function () {\n\n\t\tvar geometry = this.geometry;\n\n\t\tvar matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );\n\n\t\tvar boneMatrix = new Matrix4();\n\n\t\tvar j = 0;\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\tgeometry.computeBoundingSphere();\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PointLightHelper( light, sphereSize ) {\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\t/*\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\t\tvar d = light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\n\t\tthis.add( this.lightDistance );\n\t\t*/\n\n\t}\n\n\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\tPointLightHelper.prototype.constructor = PointLightHelper;\n\n\tPointLightHelper.prototype.dispose = function () {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t};\n\n\tPointLightHelper.prototype.update = function () {\n\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t/*\n\t\tvar d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction HemisphereLightHelper( light, sphereSize ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.colors = [ new Color(), new Color() ];\n\n\t\tvar geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t\t}\n\n\t\tvar material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );\n\n\t\tthis.lightSphere = new Mesh( geometry, material );\n\t\tthis.add( this.lightSphere );\n\n\t\tthis.update();\n\n\t}\n\n\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\n\tHemisphereLightHelper.prototype.dispose = function () {\n\n\t\tthis.lightSphere.geometry.dispose();\n\t\tthis.lightSphere.material.dispose();\n\n\t};\n\n\tHemisphereLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction GridHelper( size, divisions, color1, color2 ) {\n\n\t\tdivisions = divisions || 1;\n\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\t\tvar center = divisions / 2;\n\t\tvar step = ( size * 2 ) / divisions;\n\t\tvar vertices = [], colors = [];\n\n\t\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\t\tvertices.push( k, 0, - size, k, 0, size );\n\n\t\t\tvar color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\tGridHelper.prototype.constructor = GridHelper;\n\n\tGridHelper.prototype.setColors = function () {\n\n\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\n\t\t// FaceNormalsHelper only supports THREE.Geometry\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\t\tthis.update();\n\n\t}\n\n\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\n\tFaceNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction DirectionalLightHelper( light, size ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [\n\t\t\t- size,   size, 0,\n\t\t\t  size,   size, 0,\n\t\t\t  size, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size,   size, 0\n\t\t], 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.add( new Line( geometry, material ) );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.add( new Line( geometry, material ));\n\n\t\tthis.update();\n\n\t}\n\n\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\n\tDirectionalLightHelper.prototype.dispose = function () {\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.geometry.dispose();\n\t\tlightPlane.material.dispose();\n\t\ttargetLine.geometry.dispose();\n\t\ttargetLine.material.dispose();\n\n\t};\n\n\tDirectionalLightHelper.prototype.update = function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar v3 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\tv3.subVectors( v2, v1 );\n\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\n\t\t\tlightPlane.lookAt( v3 );\n\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t\ttargetLine.lookAt( v3 );\n\t\t\ttargetLine.scale.z = v3.length();\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\n\tfunction CameraHelper( camera ) {\n\n\t\tvar geometry = new Geometry();\n\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\n\t\tvar pointMap = {};\n\n\t\t// colors\n\n\t\tvar hexFrustum = 0xffaa00;\n\t\tvar hexCone = 0xff0000;\n\t\tvar hexUp = 0x00aaff;\n\t\tvar hexTarget = 0xffffff;\n\t\tvar hexCross = 0x333333;\n\n\t\t// near\n\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t\t// far\n\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t\t// sides\n\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t\t// cone\n\n\t\taddLine( \"p\", \"n1\", hexCone );\n\t\taddLine( \"p\", \"n2\", hexCone );\n\t\taddLine( \"p\", \"n3\", hexCone );\n\t\taddLine( \"p\", \"n4\", hexCone );\n\n\t\t// up\n\n\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\taddLine( \"u3\", \"u1\", hexUp );\n\n\t\t// target\n\n\t\taddLine( \"c\", \"t\", hexTarget );\n\t\taddLine( \"p\", \"c\", hexCross );\n\n\t\t// cross\n\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\t\tfunction addLine( a, b, hex ) {\n\n\t\t\taddPoint( a, hex );\n\t\t\taddPoint( b, hex );\n\n\t\t}\n\n\t\tfunction addPoint( id, hex ) {\n\n\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\tgeometry.colors.push( new Color( hex ) );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t\t}\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.camera = camera;\n\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t}\n\n\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\tCameraHelper.prototype.constructor = CameraHelper;\n\n\tCameraHelper.prototype.update = function () {\n\n\t\tvar geometry, pointMap;\n\n\t\tvar vector = new Vector3();\n\t\tvar camera = new Camera();\n\n\t\tfunction setPoint( point, x, y, z ) {\n\n\t\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\t\tvar points = pointMap[ point ];\n\n\t\t\tif ( points !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function update() {\n\n\t\t\tgeometry = this.geometry;\n\t\t\tpointMap = this.pointMap;\n\n\t\t\tvar w = 1, h = 1;\n\n\t\t\t// we need just camera projection matrix\n\t\t\t// world matrix must be identity\n\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t\t// center / target\n\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t\t// near\n\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t\t// far\n\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t\t// up\n\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t\t// cross\n\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\t\tgeometry.verticesNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\t// a helper to show the world-axis-aligned bounding box for an object\n\n\tfunction BoundingBoxHelper( object, hex ) {\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\t\tthis.object = object;\n\n\t\tthis.box = new Box3();\n\n\t\tMesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n\t}\n\n\tBoundingBoxHelper.prototype = Object.create( Mesh.prototype );\n\tBoundingBoxHelper.prototype.constructor = BoundingBoxHelper;\n\n\tBoundingBoxHelper.prototype.update = function () {\n\n\t\tthis.box.setFromObject( this.object );\n\n\t\tthis.box.getSize( this.scale );\n\n\t\tthis.box.getCenter( this.position );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BoxHelper( object, color ) {\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tvar positions = new Float32Array( 8 * 3 );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tthis.update( object );\n\n\t\t}\n\n\t}\n\n\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\tBoxHelper.prototype.constructor = BoxHelper;\n\n\tBoxHelper.prototype.update = ( function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function update( object ) {\n\n\t\t\tif ( (object && object.isBox3) ) {\n\n\t\t\t\tbox.copy( object );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromObject( object );\n\n\t\t\t}\n\n\t\t\tif ( box.isEmpty() ) return;\n\n\t\t\tvar min = box.min;\n\t\t\tvar max = box.max;\n\n\t\t\t/*\n\t\t\t  5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\n\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\n\t\t\tvar position = this.geometry.attributes.position;\n\t\t\tvar array = position.array;\n\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t};\n\n\t} )();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author zz85 / http://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t *\n\t * Creates an arrow for visualizing directions\n\t *\n\t * Parameters:\n\t *  dir - Vector3\n\t *  origin - Vector3\n\t *  length - Number\n\t *  color - color in hex value\n\t *  headLength - Number\n\t *  headWidth - Number\n\t */\n\n\tvar lineGeometry = new BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tObject3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\tArrowHelper.prototype.constructor = ArrowHelper;\n\n\tArrowHelper.prototype.setDirection = ( function () {\n\n\t\tvar axis = new Vector3();\n\t\tvar radians;\n\n\t\treturn function setDirection( dir ) {\n\n\t\t\t// dir is assumed to be normalized\n\n\t\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\t\tradians = Math.acos( dir.y );\n\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t};\n\n\tArrowHelper.prototype.setColor = function ( color ) {\n\n\t\tthis.line.material.color.copy( color );\n\t\tthis.cone.material.color.copy( color );\n\n\t};\n\n\t/**\n\t * @author sroucheray / http://sroucheray.org/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AxisHelper( size ) {\n\n\t\tsize = size || 1;\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t0, 0, 0,  0, 0, size\n\t\t] );\n\n\t\tvar colors = new Float32Array( [\n\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t] );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tAxisHelper.prototype = Object.create( LineSegments.prototype );\n\tAxisHelper.prototype.constructor = AxisHelper;\n\n\t/**\n\t * @author zz85 https://github.com/zz85\n\t *\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\tvar CatmullRomCurve3 = ( function() {\n\n\t\tvar\n\t\t\ttmp = new Vector3(),\n\t\t\tpx = new CubicPoly(),\n\t\t\tpy = new CubicPoly(),\n\t\t\tpz = new CubicPoly();\n\n\t\t/*\n\t\tBased on an optimized c++ solution in\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t - http://ideone.com/NoEbVM\n\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\twhich can be placed in CurveUtils.\n\t\t*/\n\n\t\tfunction CubicPoly() {}\n\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *   p(0) = x0, p(1) = x1\n\t\t *  and\n\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t */\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\t\tthis.c0 = x0;\n\t\t\tthis.c1 = t0;\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t\t};\n\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\t// initCubicPoly\n\t\t\tthis.init( x1, x2, t1, t2 );\n\n\t\t};\n\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t};\n\n\t\tCubicPoly.prototype.calc = function( t ) {\n\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t\t};\n\n\t\t// Subclass Three.js curve\n\t\treturn Curve.create(\n\n\t\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\t\tthis.points = p || [];\n\t\t\t\tthis.closed = false;\n\n\t\t\t},\n\n\t\t\tfunction ( t ) {\n\n\t\t\t\tvar points = this.points,\n\t\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\t\tl = points.length;\n\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\n\t\t\t\tif ( this.closed ) {\n\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\tweight = 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate first point\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\tp0 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate last point\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\tp3 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t\t}\n\n\t\t\t\tvar v = new Vector3(\n\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\tpz.calc( weight )\n\t\t\t\t);\n\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t);\n\n\t} )();\n\n\t/**************************************************************\n\t *\tClosed Spline 3D curve\n\t **************************************************************/\n\n\n\tfunction ClosedSplineCurve3( points ) {\n\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\t\tCatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\t\tthis.closed = true;\n\n\t}\n\n\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n\t/**************************************************************\n\t *\tSpline 3D curve\n\t **************************************************************/\n\n\n\tvar SplineCurve3 = Curve.create(\n\n\t\tfunction ( points /* array of Vector3 */ ) {\n\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\t\treturn new Vector3(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tCubic Bezier 3D curve\n\t **************************************************************/\n\n\tvar CubicBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2, v3 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b3 = ShapeUtils.b3;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tQuadratic Bezier 3D curve\n\t **************************************************************/\n\n\tvar QuadraticBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b2 = ShapeUtils.b2;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tLine3D\n\t **************************************************************/\n\n\tvar LineCurve3 = Curve.create(\n\n\t\tfunction ( v1, v2 ) {\n\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tif ( t === 1 ) {\n\n\t\t\t\treturn this.v2.clone();\n\n\t\t\t}\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\tvector.multiplyScalar( t );\n\t\t\tvector.add( this.v1 );\n\n\t\t\treturn vector;\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tArc curve\n\t **************************************************************/\n\n\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t}\n\n\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\tArcCurve.prototype.constructor = ArcCurve;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tvar SceneUtils = {\n\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\t\tvar group = new Group();\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t},\n\n\t\tdetach: function ( child, parent, scene ) {\n\n\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\tparent.remove( child );\n\t\t\tscene.add( child );\n\n\t\t},\n\n\t\tattach: function ( child, scene, parent ) {\n\n\t\t\tvar matrixWorldInverse = new Matrix4();\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\t\tscene.remove( child );\n\t\t\tparent.add( child );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Face4 ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\t}\n\n\tvar LineStrip = 0;\n\n\tvar LinePieces = 1;\n\n\tfunction PointCloud ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction ParticleSystem ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction PointCloudMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleBasicMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleSystemMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction Vertex ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new Vector3( x, y, z );\n\t}\n\n\t//\n\n\tfunction EdgesHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\tfunction WireframeHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\t//\n\n\tObject.assign( Box2.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Box3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Line3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix3.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix3( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix4.prototype, {\n\t\textractPosition: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\treturn this.copyPosition( m );\n\t\t},\n\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t},\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\treturn vector.applyProjection( this );\n\t\t},\n\t\tmultiplyVector4: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t},\n\t\trotateAxis: function ( v ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\tv.transformDirection( this );\n\t\t},\n\t\tcrossVector: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\ttranslate: function ( v ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t},\n\t\trotateX: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t},\n\t\trotateY: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t},\n\t\trotateZ: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t},\n\t\trotateByAxis: function ( axis, angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.assign( Plane.prototype, {\n\t\tisIntersectionLine: function ( line ) {\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\treturn this.intersectsLine( line );\n\t\t}\n\t} );\n\n\tObject.assign( Quaternion.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\treturn vector.applyQuaternion( this );\n\t\t}\n\t} );\n\n\tObject.assign( Ray.prototype, {\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionPlane: function ( plane ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\treturn this.intersectsPlane( plane );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t}\n\t} );\n\n\tObject.assign( Shape.prototype, {\n\t\textrude: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\treturn new ExtrudeGeometry( this, options );\n\t\t},\n\t\tmakeGeometry: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\treturn new ShapeGeometry( this, options );\n\t\t}\n\t} );\n\n\tObject.assign( Vector3.prototype, {\n\t\tsetEulerFromRotationMatrix: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t},\n\t\tsetEulerFromQuaternion: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t},\n\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\treturn this.setFromMatrixPosition( m );\n\t\t},\n\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\treturn this.setFromMatrixScale( m );\n\t\t},\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Object3D.prototype, {\n\t\tgetChildByName: function ( name ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\treturn this.getObjectByName( name );\n\t\t},\n\t\trenderDepth: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t},\n\t\ttranslate: function ( distance, axis ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t}\n\t} );\n\n\tObject.defineProperties( Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( LOD.prototype, {\n\t\tobjects: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\treturn this.levels;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength( focalLength );\n\n\t};\n\n\t//\n\n\tObject.defineProperties( Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.assign( BufferGeometry.prototype, {\n\t\taddIndex: function ( index ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\tthis.setIndex( index );\n\t\t},\n\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t}\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\tthis.addGroup( start, count );\n\t\t},\n\t\tclearDrawCalls: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\tthis.clearGroups();\n\t\t},\n\t\tcomputeTangents: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t},\n\t\tcomputeOffsets: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\treturn new Color();\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\t\tmetal: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tEventDispatcher.prototype = Object.assign( Object.create( {\n\n\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\t\tconstructor: EventDispatcher,\n\n\t\tapply: function ( target ) {\n\n\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\t\tObject.assign( target, this );\n\n\t\t}\n\n\t} ), EventDispatcher.prototype );\n\n\t//\n\n\tObject.defineProperties( Uniform.prototype, {\n\t\tdynamic: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t}\n\t\t},\n\t\tonUpdate: {\n\t\t\tvalue: function () {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( WebGLRenderer.prototype, {\n\t\tsupportsFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t},\n\t\tsupportsHalfFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t},\n\t\tsupportsStandardDerivatives: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t},\n\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t},\n\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t},\n\t\tsupportsBlendMinMax: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t},\n\t\tsupportsVertexTextures: function () {\n\t\t\treturn this.capabilities.vertexTextures;\n\t\t},\n\t\tsupportsInstancedArrays: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t},\n\t\tenableScissorTest: function ( boolean ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\tthis.setScissorTest( boolean );\n\t\t},\n\t\tinitMaterial: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t},\n\t\taddPrePlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t},\n\t\taddPostPlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t},\n\t\tupdateShadowMap: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\n\t\t\t},\n\t\t\tset: function ( cullFace ) {\n\t\t\t\tvar value = ( cullFace !== CullFaceBack );\n\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\tthis.renderReverseSided = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Audio.prototype, {\n\t\tload: function ( file ) {\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\tvar scope = this;\n\t\t\tvar audioLoader = new AudioLoader();\n\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\tscope.setBuffer( buffer );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\n\tObject.assign( AudioAnalyser.prototype, {\n\t\tgetData: function ( file ) {\n\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\treturn this.getFrequencyData();\n\t\t}\n\t} );\n\n\t//\n\n\tvar GeometryUtils = {\n\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\t\tvar matrix;\n\n\t\t\tif ( geometry2.isMesh ) {\n\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t\t}\n\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t\t},\n\n\t\tcenter: function ( geometry ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\treturn geometry.center();\n\n\t\t}\n\n\t};\n\n\tvar ImageUtils = {\n\n\t\tcrossOrigin: undefined,\n\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\t\tvar loader = new TextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\t\tvar loader = new CubeTextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadCompressedTexture: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t},\n\n\t\tloadCompressedTextureCube: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Projector () {\n\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\t\tthis.projectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\n\t\t};\n\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\n\t\t};\n\n\t\tthis.pickingRay = function ( vector, camera ) {\n\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t\t};\n\n\t}\n\n\t//\n\n\tfunction CanvasRenderer () {\n\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tthis.clear = function () {};\n\t\tthis.render = function () {};\n\t\tthis.setClearColor = function () {};\n\t\tthis.setSize = function () {};\n\n\t}\n\n\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\texports.WebGLRenderTarget = WebGLRenderTarget;\n\texports.WebGLRenderer = WebGLRenderer;\n\texports.ShaderLib = ShaderLib;\n\texports.UniformsLib = UniformsLib;\n\texports.UniformsUtils = UniformsUtils;\n\texports.ShaderChunk = ShaderChunk;\n\texports.FogExp2 = FogExp2;\n\texports.Fog = Fog;\n\texports.Scene = Scene;\n\texports.LensFlare = LensFlare;\n\texports.Sprite = Sprite;\n\texports.LOD = LOD;\n\texports.SkinnedMesh = SkinnedMesh;\n\texports.Skeleton = Skeleton;\n\texports.Bone = Bone;\n\texports.Mesh = Mesh;\n\texports.LineSegments = LineSegments;\n\texports.Line = Line;\n\texports.Points = Points;\n\texports.Group = Group;\n\texports.VideoTexture = VideoTexture;\n\texports.DataTexture = DataTexture;\n\texports.CompressedTexture = CompressedTexture;\n\texports.CubeTexture = CubeTexture;\n\texports.CanvasTexture = CanvasTexture;\n\texports.DepthTexture = DepthTexture;\n\texports.TextureIdCount = TextureIdCount;\n\texports.Texture = Texture;\n\texports.MaterialIdCount = MaterialIdCount;\n\texports.CompressedTextureLoader = CompressedTextureLoader;\n\texports.BinaryTextureLoader = BinaryTextureLoader;\n\texports.DataTextureLoader = DataTextureLoader;\n\texports.CubeTextureLoader = CubeTextureLoader;\n\texports.TextureLoader = TextureLoader;\n\texports.ObjectLoader = ObjectLoader;\n\texports.MaterialLoader = MaterialLoader;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.DefaultLoadingManager = DefaultLoadingManager;\n\texports.LoadingManager = LoadingManager;\n\texports.JSONLoader = JSONLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.FontLoader = FontLoader;\n\texports.XHRLoader = XHRLoader;\n\texports.Loader = Loader;\n\texports.Cache = Cache;\n\texports.AudioLoader = AudioLoader;\n\texports.SpotLightShadow = SpotLightShadow;\n\texports.SpotLight = SpotLight;\n\texports.PointLight = PointLight;\n\texports.HemisphereLight = HemisphereLight;\n\texports.DirectionalLightShadow = DirectionalLightShadow;\n\texports.DirectionalLight = DirectionalLight;\n\texports.AmbientLight = AmbientLight;\n\texports.LightShadow = LightShadow;\n\texports.Light = Light;\n\texports.StereoCamera = StereoCamera;\n\texports.PerspectiveCamera = PerspectiveCamera;\n\texports.OrthographicCamera = OrthographicCamera;\n\texports.CubeCamera = CubeCamera;\n\texports.Camera = Camera;\n\texports.AudioListener = AudioListener;\n\texports.PositionalAudio = PositionalAudio;\n\texports.getAudioContext = getAudioContext;\n\texports.AudioAnalyser = AudioAnalyser;\n\texports.Audio = Audio;\n\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\texports.StringKeyframeTrack = StringKeyframeTrack;\n\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\texports.PropertyMixer = PropertyMixer;\n\texports.PropertyBinding = PropertyBinding;\n\texports.KeyframeTrack = KeyframeTrack;\n\texports.AnimationUtils = AnimationUtils;\n\texports.AnimationObjectGroup = AnimationObjectGroup;\n\texports.AnimationMixer = AnimationMixer;\n\texports.AnimationClip = AnimationClip;\n\texports.Uniform = Uniform;\n\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\texports.BufferGeometry = BufferGeometry;\n\texports.GeometryIdCount = GeometryIdCount;\n\texports.Geometry = Geometry;\n\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\texports.InterleavedBuffer = InterleavedBuffer;\n\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\texports.Float64Attribute = Float64Attribute;\n\texports.Float32Attribute = Float32Attribute;\n\texports.Uint32Attribute = Uint32Attribute;\n\texports.Int32Attribute = Int32Attribute;\n\texports.Uint16Attribute = Uint16Attribute;\n\texports.Int16Attribute = Int16Attribute;\n\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\texports.Uint8Attribute = Uint8Attribute;\n\texports.Int8Attribute = Int8Attribute;\n\texports.BufferAttribute = BufferAttribute;\n\texports.Face3 = Face3;\n\texports.Object3DIdCount = Object3DIdCount;\n\texports.Object3D = Object3D;\n\texports.Raycaster = Raycaster;\n\texports.Layers = Layers;\n\texports.EventDispatcher = EventDispatcher;\n\texports.Clock = Clock;\n\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\texports.LinearInterpolant = LinearInterpolant;\n\texports.DiscreteInterpolant = DiscreteInterpolant;\n\texports.CubicInterpolant = CubicInterpolant;\n\texports.Interpolant = Interpolant;\n\texports.Triangle = Triangle;\n\texports.Spline = Spline;\n\texports.Math = _Math;\n\texports.Spherical = Spherical;\n\texports.Plane = Plane;\n\texports.Frustum = Frustum;\n\texports.Sphere = Sphere;\n\texports.Ray = Ray;\n\texports.Matrix4 = Matrix4;\n\texports.Matrix3 = Matrix3;\n\texports.Box3 = Box3;\n\texports.Box2 = Box2;\n\texports.Line3 = Line3;\n\texports.Euler = Euler;\n\texports.Vector4 = Vector4;\n\texports.Vector3 = Vector3;\n\texports.Vector2 = Vector2;\n\texports.Quaternion = Quaternion;\n\texports.ColorKeywords = ColorKeywords;\n\texports.Color = Color;\n\texports.MorphBlendMesh = MorphBlendMesh;\n\texports.ImmediateRenderObject = ImmediateRenderObject;\n\texports.VertexNormalsHelper = VertexNormalsHelper;\n\texports.SpotLightHelper = SpotLightHelper;\n\texports.SkeletonHelper = SkeletonHelper;\n\texports.PointLightHelper = PointLightHelper;\n\texports.HemisphereLightHelper = HemisphereLightHelper;\n\texports.GridHelper = GridHelper;\n\texports.FaceNormalsHelper = FaceNormalsHelper;\n\texports.DirectionalLightHelper = DirectionalLightHelper;\n\texports.CameraHelper = CameraHelper;\n\texports.BoundingBoxHelper = BoundingBoxHelper;\n\texports.BoxHelper = BoxHelper;\n\texports.ArrowHelper = ArrowHelper;\n\texports.AxisHelper = AxisHelper;\n\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\texports.SplineCurve3 = SplineCurve3;\n\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\texports.LineCurve3 = LineCurve3;\n\texports.ArcCurve = ArcCurve;\n\texports.EllipseCurve = EllipseCurve;\n\texports.SplineCurve = SplineCurve;\n\texports.CubicBezierCurve = CubicBezierCurve;\n\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\texports.LineCurve = LineCurve;\n\texports.Shape = Shape;\n\texports.ShapePath = ShapePath;\n\texports.Path = Path;\n\texports.Font = Font;\n\texports.CurvePath = CurvePath;\n\texports.Curve = Curve;\n\texports.ShapeUtils = ShapeUtils;\n\texports.SceneUtils = SceneUtils;\n\texports.CurveUtils = CurveUtils;\n\texports.WireframeGeometry = WireframeGeometry;\n\texports.ParametricGeometry = ParametricGeometry;\n\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\texports.TetrahedronGeometry = TetrahedronGeometry;\n\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\texports.OctahedronGeometry = OctahedronGeometry;\n\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\texports.IcosahedronGeometry = IcosahedronGeometry;\n\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\texports.DodecahedronGeometry = DodecahedronGeometry;\n\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\texports.PolyhedronGeometry = PolyhedronGeometry;\n\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\texports.TubeGeometry = TubeGeometry;\n\texports.TubeBufferGeometry = TubeBufferGeometry;\n\texports.TorusKnotGeometry = TorusKnotGeometry;\n\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\texports.TorusGeometry = TorusGeometry;\n\texports.TorusBufferGeometry = TorusBufferGeometry;\n\texports.TextGeometry = TextGeometry;\n\texports.SphereBufferGeometry = SphereBufferGeometry;\n\texports.SphereGeometry = SphereGeometry;\n\texports.RingGeometry = RingGeometry;\n\texports.RingBufferGeometry = RingBufferGeometry;\n\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\texports.PlaneGeometry = PlaneGeometry;\n\texports.LatheGeometry = LatheGeometry;\n\texports.LatheBufferGeometry = LatheBufferGeometry;\n\texports.ShapeGeometry = ShapeGeometry;\n\texports.ExtrudeGeometry = ExtrudeGeometry;\n\texports.EdgesGeometry = EdgesGeometry;\n\texports.ConeGeometry = ConeGeometry;\n\texports.ConeBufferGeometry = ConeBufferGeometry;\n\texports.CylinderGeometry = CylinderGeometry;\n\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\texports.CircleBufferGeometry = CircleBufferGeometry;\n\texports.CircleGeometry = CircleGeometry;\n\texports.BoxBufferGeometry = BoxBufferGeometry;\n\texports.BoxGeometry = BoxGeometry;\n\texports.ShadowMaterial = ShadowMaterial;\n\texports.SpriteMaterial = SpriteMaterial;\n\texports.RawShaderMaterial = RawShaderMaterial;\n\texports.ShaderMaterial = ShaderMaterial;\n\texports.PointsMaterial = PointsMaterial;\n\texports.MultiMaterial = MultiMaterial;\n\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\texports.MeshStandardMaterial = MeshStandardMaterial;\n\texports.MeshPhongMaterial = MeshPhongMaterial;\n\texports.MeshNormalMaterial = MeshNormalMaterial;\n\texports.MeshLambertMaterial = MeshLambertMaterial;\n\texports.MeshDepthMaterial = MeshDepthMaterial;\n\texports.MeshBasicMaterial = MeshBasicMaterial;\n\texports.LineDashedMaterial = LineDashedMaterial;\n\texports.LineBasicMaterial = LineBasicMaterial;\n\texports.Material = Material;\n\texports.REVISION = REVISION;\n\texports.MOUSE = MOUSE;\n\texports.CullFaceNone = CullFaceNone;\n\texports.CullFaceBack = CullFaceBack;\n\texports.CullFaceFront = CullFaceFront;\n\texports.CullFaceFrontBack = CullFaceFrontBack;\n\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\texports.BasicShadowMap = BasicShadowMap;\n\texports.PCFShadowMap = PCFShadowMap;\n\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\texports.FrontSide = FrontSide;\n\texports.BackSide = BackSide;\n\texports.DoubleSide = DoubleSide;\n\texports.FlatShading = FlatShading;\n\texports.SmoothShading = SmoothShading;\n\texports.NoColors = NoColors;\n\texports.FaceColors = FaceColors;\n\texports.VertexColors = VertexColors;\n\texports.NoBlending = NoBlending;\n\texports.NormalBlending = NormalBlending;\n\texports.AdditiveBlending = AdditiveBlending;\n\texports.SubtractiveBlending = SubtractiveBlending;\n\texports.MultiplyBlending = MultiplyBlending;\n\texports.CustomBlending = CustomBlending;\n\texports.BlendingMode = BlendingMode;\n\texports.AddEquation = AddEquation;\n\texports.SubtractEquation = SubtractEquation;\n\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\texports.MinEquation = MinEquation;\n\texports.MaxEquation = MaxEquation;\n\texports.ZeroFactor = ZeroFactor;\n\texports.OneFactor = OneFactor;\n\texports.SrcColorFactor = SrcColorFactor;\n\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\texports.SrcAlphaFactor = SrcAlphaFactor;\n\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\texports.DstAlphaFactor = DstAlphaFactor;\n\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\texports.DstColorFactor = DstColorFactor;\n\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\texports.NeverDepth = NeverDepth;\n\texports.AlwaysDepth = AlwaysDepth;\n\texports.LessDepth = LessDepth;\n\texports.LessEqualDepth = LessEqualDepth;\n\texports.EqualDepth = EqualDepth;\n\texports.GreaterEqualDepth = GreaterEqualDepth;\n\texports.GreaterDepth = GreaterDepth;\n\texports.NotEqualDepth = NotEqualDepth;\n\texports.MultiplyOperation = MultiplyOperation;\n\texports.MixOperation = MixOperation;\n\texports.AddOperation = AddOperation;\n\texports.NoToneMapping = NoToneMapping;\n\texports.LinearToneMapping = LinearToneMapping;\n\texports.ReinhardToneMapping = ReinhardToneMapping;\n\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\texports.CineonToneMapping = CineonToneMapping;\n\texports.UVMapping = UVMapping;\n\texports.CubeReflectionMapping = CubeReflectionMapping;\n\texports.CubeRefractionMapping = CubeRefractionMapping;\n\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\texports.TextureMapping = TextureMapping;\n\texports.RepeatWrapping = RepeatWrapping;\n\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\texports.TextureWrapping = TextureWrapping;\n\texports.NearestFilter = NearestFilter;\n\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\texports.LinearFilter = LinearFilter;\n\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\texports.TextureFilter = TextureFilter;\n\texports.UnsignedByteType = UnsignedByteType;\n\texports.ByteType = ByteType;\n\texports.ShortType = ShortType;\n\texports.UnsignedShortType = UnsignedShortType;\n\texports.IntType = IntType;\n\texports.UnsignedIntType = UnsignedIntType;\n\texports.FloatType = FloatType;\n\texports.HalfFloatType = HalfFloatType;\n\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\texports.UnsignedShort565Type = UnsignedShort565Type;\n\texports.UnsignedInt248Type = UnsignedInt248Type;\n\texports.AlphaFormat = AlphaFormat;\n\texports.RGBFormat = RGBFormat;\n\texports.RGBAFormat = RGBAFormat;\n\texports.LuminanceFormat = LuminanceFormat;\n\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\texports.RGBEFormat = RGBEFormat;\n\texports.DepthFormat = DepthFormat;\n\texports.DepthStencilFormat = DepthStencilFormat;\n\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\texports.LoopOnce = LoopOnce;\n\texports.LoopRepeat = LoopRepeat;\n\texports.LoopPingPong = LoopPingPong;\n\texports.InterpolateDiscrete = InterpolateDiscrete;\n\texports.InterpolateLinear = InterpolateLinear;\n\texports.InterpolateSmooth = InterpolateSmooth;\n\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\texports.WrapAroundEnding = WrapAroundEnding;\n\texports.TrianglesDrawMode = TrianglesDrawMode;\n\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\texports.LinearEncoding = LinearEncoding;\n\texports.sRGBEncoding = sRGBEncoding;\n\texports.GammaEncoding = GammaEncoding;\n\texports.RGBEEncoding = RGBEEncoding;\n\texports.LogLuvEncoding = LogLuvEncoding;\n\texports.RGBM7Encoding = RGBM7Encoding;\n\texports.RGBM16Encoding = RGBM16Encoding;\n\texports.RGBDEncoding = RGBDEncoding;\n\texports.BasicDepthPacking = BasicDepthPacking;\n\texports.RGBADepthPacking = RGBADepthPacking;\n\texports.CubeGeometry = BoxGeometry;\n\texports.Face4 = Face4;\n\texports.LineStrip = LineStrip;\n\texports.LinePieces = LinePieces;\n\texports.MeshFaceMaterial = MultiMaterial;\n\texports.PointCloud = PointCloud;\n\texports.Particle = Sprite;\n\texports.ParticleSystem = ParticleSystem;\n\texports.PointCloudMaterial = PointCloudMaterial;\n\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\texports.Vertex = Vertex;\n\texports.EdgesHelper = EdgesHelper;\n\texports.WireframeHelper = WireframeHelper;\n\texports.GeometryUtils = GeometryUtils;\n\texports.ImageUtils = ImageUtils;\n\texports.Projector = Projector;\n\texports.CanvasRenderer = CanvasRenderer;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n\tObject.defineProperty( exports, 'AudioContext', {\n\t\tget: function () {\n\t\t\treturn exports.getAudioContext();\n\t\t}\n\t});\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/three/build/three.js\n// module id = 3\n// module chunks = 0","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time > prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\nif ( typeof module === 'object' ) {\n\n\tmodule.exports = Stats;\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/libs/stats.js","module.exports = require('./vendor/dat.gui')\nmodule.exports.color = require('./vendor/dat.color')\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dat-gui/index.js\n// module id = 5\n// module chunks = 0","/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n/** @namespace */\nvar dat = module.exports = dat || {};\n\n/** @namespace */\ndat.gui = dat.gui || {};\n\n/** @namespace */\ndat.utils = dat.utils || {};\n\n/** @namespace */\ndat.controllers = dat.controllers || {};\n\n/** @namespace */\ndat.dom = dat.dom || {};\n\n/** @namespace */\ndat.color = dat.color || {};\n\ndat.utils.css = (function () {\n  return {\n    load: function (url, doc) {\n      doc = doc || document;\n      var link = doc.createElement('link');\n      link.type = 'text/css';\n      link.rel = 'stylesheet';\n      link.href = url;\n      doc.getElementsByTagName('head')[0].appendChild(link);\n    },\n    inject: function(css, doc) {\n      doc = doc || document;\n      var injected = document.createElement('style');\n      injected.type = 'text/css';\n      injected.innerHTML = css;\n      doc.getElementsByTagName('head')[0].appendChild(injected);\n    }\n  }\n})();\n\n\ndat.utils.common = (function () {\n  \n  var ARR_EACH = Array.prototype.forEach;\n  var ARR_SLICE = Array.prototype.slice;\n\n  /**\n   * Band-aid methods for things that should be a lot easier in JavaScript.\n   * Implementation and structure inspired by underscore.js\n   * http://documentcloud.github.com/underscore/\n   */\n\n  return { \n    \n    BREAK: {},\n  \n    extend: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (!this.isUndefined(obj[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n      \n    },\n    \n    defaults: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (this.isUndefined(target[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n    \n    },\n    \n    compose: function() {\n      var toCall = ARR_SLICE.call(arguments);\n            return function() {\n              var args = ARR_SLICE.call(arguments);\n              for (var i = toCall.length -1; i >= 0; i--) {\n                args = [toCall[i].apply(this, args)];\n              }\n              return args[0];\n            }\n    },\n    \n    each: function(obj, itr, scope) {\n\n      \n      if (ARR_EACH && obj.forEach === ARR_EACH) { \n        \n        obj.forEach(itr, scope);\n        \n      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n        \n        for (var key = 0, l = obj.length; key < l; key++)\n          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n            return;\n            \n      } else {\n\n        for (var key in obj) \n          if (itr.call(scope, obj[key], key) === this.BREAK)\n            return;\n            \n      }\n            \n    },\n    \n    defer: function(fnc) {\n      setTimeout(fnc, 0);\n    },\n    \n    toArray: function(obj) {\n      if (obj.toArray) return obj.toArray();\n      return ARR_SLICE.call(obj);\n    },\n\n    isUndefined: function(obj) {\n      return obj === undefined;\n    },\n    \n    isNull: function(obj) {\n      return obj === null;\n    },\n    \n    isNaN: function(obj) {\n      return obj !== obj;\n    },\n    \n    isArray: Array.isArray || function(obj) {\n      return obj.constructor === Array;\n    },\n    \n    isObject: function(obj) {\n      return obj === Object(obj);\n    },\n    \n    isNumber: function(obj) {\n      return obj === obj+0;\n    },\n    \n    isString: function(obj) {\n      return obj === obj+'';\n    },\n    \n    isBoolean: function(obj) {\n      return obj === false || obj === true;\n    },\n    \n    isFunction: function(obj) {\n      return Object.prototype.toString.call(obj) === '[object Function]';\n    }\n  \n  };\n    \n})();\n\n\ndat.controllers.Controller = (function (common) {\n\n  /**\n   * @class An \"abstract\" class that represents a given property of an object.\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var Controller = function(object, property) {\n\n    this.initialValue = object[property];\n\n    /**\n     * Those who extend this class will put their DOM elements in here.\n     * @type {DOMElement}\n     */\n    this.domElement = document.createElement('div');\n\n    /**\n     * The object to manipulate\n     * @type {Object}\n     */\n    this.object = object;\n\n    /**\n     * The name of the property to manipulate\n     * @type {String}\n     */\n    this.property = property;\n\n    /**\n     * The function to be called on change.\n     * @type {Function}\n     * @ignore\n     */\n    this.__onChange = undefined;\n\n    /**\n     * The function to be called on finishing change.\n     * @type {Function}\n     * @ignore\n     */\n    this.__onFinishChange = undefined;\n\n  };\n\n  common.extend(\n\n      Controller.prototype,\n\n      /** @lends dat.controllers.Controller.prototype */\n      {\n\n        /**\n         * Specify that a function fire every time someone changes the value with\n         * this Controller.\n         *\n         * @param {Function} fnc This function will be called whenever the value\n         * is modified via this Controller.\n         * @returns {dat.controllers.Controller} this\n         */\n        onChange: function(fnc) {\n          this.__onChange = fnc;\n          return this;\n        },\n\n        /**\n         * Specify that a function fire every time someone \"finishes\" changing\n         * the value wih this Controller. Useful for values that change\n         * incrementally like numbers or strings.\n         *\n         * @param {Function} fnc This function will be called whenever\n         * someone \"finishes\" changing the value via this Controller.\n         * @returns {dat.controllers.Controller} this\n         */\n        onFinishChange: function(fnc) {\n          this.__onFinishChange = fnc;\n          return this;\n        },\n\n        /**\n         * Change the value of <code>object[property]</code>\n         *\n         * @param {Object} newValue The new value of <code>object[property]</code>\n         */\n        setValue: function(newValue) {\n          this.object[this.property] = newValue;\n          if (this.__onChange) {\n            this.__onChange.call(this, newValue);\n          }\n          this.updateDisplay();\n          return this;\n        },\n\n        /**\n         * Gets the value of <code>object[property]</code>\n         *\n         * @returns {Object} The current value of <code>object[property]</code>\n         */\n        getValue: function() {\n          return this.object[this.property];\n        },\n\n        /**\n         * Refreshes the visual display of a Controller in order to keep sync\n         * with the object's current value.\n         * @returns {dat.controllers.Controller} this\n         */\n        updateDisplay: function() {\n          return this;\n        },\n\n        /**\n         * @returns {Boolean} true if the value has deviated from initialValue\n         */\n        isModified: function() {\n          return this.initialValue !== this.getValue()\n        }\n\n      }\n\n  );\n\n  return Controller;\n\n\n})(dat.utils.common);\n\n\ndat.dom.dom = (function (common) {\n\n  var EVENT_MAP = {\n    'HTMLEvents': ['change'],\n    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],\n    'KeyboardEvents': ['keydown']\n  };\n\n  var EVENT_MAP_INV = {};\n  common.each(EVENT_MAP, function(v, k) {\n    common.each(v, function(e) {\n      EVENT_MAP_INV[e] = k;\n    });\n  });\n\n  var CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\n\n  function cssValueToPixels(val) {\n\n    if (val === '0' || common.isUndefined(val)) return 0;\n\n    var match = val.match(CSS_VALUE_PIXELS);\n\n    if (!common.isNull(match)) {\n      return parseFloat(match[1]);\n    }\n\n    // TODO ...ems? %?\n\n    return 0;\n\n  }\n\n  /**\n   * @namespace\n   * @member dat.dom\n   */\n  var dom = {\n\n    /**\n     * \n     * @param elem\n     * @param selectable\n     */\n    makeSelectable: function(elem, selectable) {\n\n      if (elem === undefined || elem.style === undefined) return;\n\n      elem.onselectstart = selectable ? function() {\n        return false;\n      } : function() {\n      };\n\n      elem.style.MozUserSelect = selectable ? 'auto' : 'none';\n      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\n      elem.unselectable = selectable ? 'on' : 'off';\n\n    },\n\n    /**\n     *\n     * @param elem\n     * @param horizontal\n     * @param vertical\n     */\n    makeFullscreen: function(elem, horizontal, vertical) {\n\n      if (common.isUndefined(horizontal)) horizontal = true;\n      if (common.isUndefined(vertical)) vertical = true;\n\n      elem.style.position = 'absolute';\n\n      if (horizontal) {\n        elem.style.left = 0;\n        elem.style.right = 0;\n      }\n      if (vertical) {\n        elem.style.top = 0;\n        elem.style.bottom = 0;\n      }\n\n    },\n\n    /**\n     *\n     * @param elem\n     * @param eventType\n     * @param params\n     */\n    fakeEvent: function(elem, eventType, params, aux) {\n      params = params || {};\n      var className = EVENT_MAP_INV[eventType];\n      if (!className) {\n        throw new Error('Event type ' + eventType + ' not supported.');\n      }\n      var evt = document.createEvent(className);\n      switch (className) {\n        case 'MouseEvents':\n          var clientX = params.x || params.clientX || 0;\n          var clientY = params.y || params.clientY || 0;\n          evt.initMouseEvent(eventType, params.bubbles || false,\n              params.cancelable || true, window, params.clickCount || 1,\n              0, //screen X\n              0, //screen Y\n              clientX, //client X\n              clientY, //client Y\n              false, false, false, false, 0, null);\n          break;\n        case 'KeyboardEvents':\n          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz\n          common.defaults(params, {\n            cancelable: true,\n            ctrlKey: false,\n            altKey: false,\n            shiftKey: false,\n            metaKey: false,\n            keyCode: undefined,\n            charCode: undefined\n          });\n          init(eventType, params.bubbles || false,\n              params.cancelable, window,\n              params.ctrlKey, params.altKey,\n              params.shiftKey, params.metaKey,\n              params.keyCode, params.charCode);\n          break;\n        default:\n          evt.initEvent(eventType, params.bubbles || false,\n              params.cancelable || true);\n          break;\n      }\n      common.defaults(evt, aux);\n      elem.dispatchEvent(evt);\n    },\n\n    /**\n     *\n     * @param elem\n     * @param event\n     * @param func\n     * @param bool\n     */\n    bind: function(elem, event, func, bool) {\n      bool = bool || false;\n      if (elem.addEventListener)\n        elem.addEventListener(event, func, bool);\n      else if (elem.attachEvent)\n        elem.attachEvent('on' + event, func);\n      return dom;\n    },\n\n    /**\n     *\n     * @param elem\n     * @param event\n     * @param func\n     * @param bool\n     */\n    unbind: function(elem, event, func, bool) {\n      bool = bool || false;\n      if (elem.removeEventListener)\n        elem.removeEventListener(event, func, bool);\n      else if (elem.detachEvent)\n        elem.detachEvent('on' + event, func);\n      return dom;\n    },\n\n    /**\n     *\n     * @param elem\n     * @param className\n     */\n    addClass: function(elem, className) {\n      if (elem.className === undefined) {\n        elem.className = className;\n      } else if (elem.className !== className) {\n        var classes = elem.className.split(/ +/);\n        if (classes.indexOf(className) == -1) {\n          classes.push(className);\n          elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\n        }\n      }\n      return dom;\n    },\n\n    /**\n     *\n     * @param elem\n     * @param className\n     */\n    removeClass: function(elem, className) {\n      if (className) {\n        if (elem.className === undefined) {\n          // elem.className = className;\n        } else if (elem.className === className) {\n          elem.removeAttribute('class');\n        } else {\n          var classes = elem.className.split(/ +/);\n          var index = classes.indexOf(className);\n          if (index != -1) {\n            classes.splice(index, 1);\n            elem.className = classes.join(' ');\n          }\n        }\n      } else {\n        elem.className = undefined;\n      }\n      return dom;\n    },\n\n    hasClass: function(elem, className) {\n      return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\n    },\n\n    /**\n     *\n     * @param elem\n     */\n    getWidth: function(elem) {\n\n      var style = getComputedStyle(elem);\n\n      return cssValueToPixels(style['border-left-width']) +\n          cssValueToPixels(style['border-right-width']) +\n          cssValueToPixels(style['padding-left']) +\n          cssValueToPixels(style['padding-right']) +\n          cssValueToPixels(style['width']);\n    },\n\n    /**\n     *\n     * @param elem\n     */\n    getHeight: function(elem) {\n\n      var style = getComputedStyle(elem);\n\n      return cssValueToPixels(style['border-top-width']) +\n          cssValueToPixels(style['border-bottom-width']) +\n          cssValueToPixels(style['padding-top']) +\n          cssValueToPixels(style['padding-bottom']) +\n          cssValueToPixels(style['height']);\n    },\n\n    /**\n     *\n     * @param elem\n     */\n    getOffset: function(elem) {\n      var offset = {left: 0, top:0};\n      if (elem.offsetParent) {\n        do {\n          offset.left += elem.offsetLeft;\n          offset.top += elem.offsetTop;\n        } while (elem = elem.offsetParent);\n      }\n      return offset;\n    },\n\n    // http://stackoverflow.com/posts/2684561/revisions\n    /**\n     * \n     * @param elem\n     */\n    isActive: function(elem) {\n      return elem === document.activeElement && ( elem.type || elem.href );\n    }\n\n  };\n\n  return dom;\n\n})(dat.utils.common);\n\n\ndat.controllers.OptionController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a select input to alter the property of an object, using a\n   * list of accepted values.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Object|string[]} options A map of labels to acceptable values, or\n   * a list of acceptable string values.\n   *\n   * @member dat.controllers\n   */\n  var OptionController = function(object, property, options) {\n\n    OptionController.superclass.call(this, object, property);\n\n    var _this = this;\n\n    /**\n     * The drop down menu\n     * @ignore\n     */\n    this.__select = document.createElement('select');\n\n    if (common.isArray(options)) {\n      var map = {};\n      common.each(options, function(element) {\n        map[element] = element;\n      });\n      options = map;\n    }\n\n    common.each(options, function(value, key) {\n\n      var opt = document.createElement('option');\n      opt.innerHTML = key;\n      opt.setAttribute('value', value);\n      _this.__select.appendChild(opt);\n\n    });\n\n    // Acknowledge original value\n    this.updateDisplay();\n\n    dom.bind(this.__select, 'change', function() {\n      var desiredValue = this.options[this.selectedIndex].value;\n      _this.setValue(desiredValue);\n    });\n\n    this.domElement.appendChild(this.__select);\n\n  };\n\n  OptionController.superclass = Controller;\n\n  common.extend(\n\n      OptionController.prototype,\n      Controller.prototype,\n\n      {\n\n        setValue: function(v) {\n          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);\n          if (this.__onFinishChange) {\n            this.__onFinishChange.call(this, this.getValue());\n          }\n          return toReturn;\n        },\n\n        updateDisplay: function() {\n          this.__select.value = this.getValue();\n          return OptionController.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n  );\n\n  return OptionController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.controllers.NumberController = (function (Controller, common) {\n\n  /**\n   * @class Represents a given property of an object that is a number.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Object} [params] Optional parameters\n   * @param {Number} [params.min] Minimum allowed value\n   * @param {Number} [params.max] Maximum allowed value\n   * @param {Number} [params.step] Increment by which to change value\n   *\n   * @member dat.controllers\n   */\n  var NumberController = function(object, property, params) {\n\n    NumberController.superclass.call(this, object, property);\n\n    params = params || {};\n\n    this.__min = params.min;\n    this.__max = params.max;\n    this.__step = params.step;\n\n    if (common.isUndefined(this.__step)) {\n\n      if (this.initialValue == 0) {\n        this.__impliedStep = 1; // What are we, psychics?\n      } else {\n        // Hey Doug, check this out.\n        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;\n      }\n\n    } else {\n\n      this.__impliedStep = this.__step;\n\n    }\n\n    this.__precision = numDecimals(this.__impliedStep);\n\n\n  };\n\n  NumberController.superclass = Controller;\n\n  common.extend(\n\n      NumberController.prototype,\n      Controller.prototype,\n\n      /** @lends dat.controllers.NumberController.prototype */\n      {\n\n        setValue: function(v) {\n\n          if (this.__min !== undefined && v < this.__min) {\n            v = this.__min;\n          } else if (this.__max !== undefined && v > this.__max) {\n            v = this.__max;\n          }\n\n          if (this.__step !== undefined && v % this.__step != 0) {\n            v = Math.round(v / this.__step) * this.__step;\n          }\n\n          return NumberController.superclass.prototype.setValue.call(this, v);\n\n        },\n\n        /**\n         * Specify a minimum value for <code>object[property]</code>.\n         *\n         * @param {Number} minValue The minimum value for\n         * <code>object[property]</code>\n         * @returns {dat.controllers.NumberController} this\n         */\n        min: function(v) {\n          this.__min = v;\n          return this;\n        },\n\n        /**\n         * Specify a maximum value for <code>object[property]</code>.\n         *\n         * @param {Number} maxValue The maximum value for\n         * <code>object[property]</code>\n         * @returns {dat.controllers.NumberController} this\n         */\n        max: function(v) {\n          this.__max = v;\n          return this;\n        },\n\n        /**\n         * Specify a step value that dat.controllers.NumberController\n         * increments by.\n         *\n         * @param {Number} stepValue The step value for\n         * dat.controllers.NumberController\n         * @default if minimum and maximum specified increment is 1% of the\n         * difference otherwise stepValue is 1\n         * @returns {dat.controllers.NumberController} this\n         */\n        step: function(v) {\n          this.__step = v;\n          return this;\n        }\n\n      }\n\n  );\n\n  function numDecimals(x) {\n    x = x.toString();\n    if (x.indexOf('.') > -1) {\n      return x.length - x.indexOf('.') - 1;\n    } else {\n      return 0;\n    }\n  }\n\n  return NumberController;\n\n})(dat.controllers.Controller,\ndat.utils.common);\n\n\ndat.controllers.NumberControllerBox = (function (NumberController, dom, common) {\n\n  /**\n   * @class Represents a given property of an object that is a number and\n   * provides an input element with which to manipulate it.\n   *\n   * @extends dat.controllers.Controller\n   * @extends dat.controllers.NumberController\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Object} [params] Optional parameters\n   * @param {Number} [params.min] Minimum allowed value\n   * @param {Number} [params.max] Maximum allowed value\n   * @param {Number} [params.step] Increment by which to change value\n   *\n   * @member dat.controllers\n   */\n  var NumberControllerBox = function(object, property, params) {\n\n    this.__truncationSuspended = false;\n\n    NumberControllerBox.superclass.call(this, object, property, params);\n\n    var _this = this;\n\n    /**\n     * {Number} Previous mouse y position\n     * @ignore\n     */\n    var prev_y;\n\n    this.__input = document.createElement('input');\n    this.__input.setAttribute('type', 'text');\n\n    // Makes it so manually specified values are not truncated.\n\n    dom.bind(this.__input, 'change', onChange);\n    dom.bind(this.__input, 'blur', onBlur);\n    dom.bind(this.__input, 'mousedown', onMouseDown);\n    dom.bind(this.__input, 'keydown', function(e) {\n\n      // When pressing entire, you can be as precise as you want.\n      if (e.keyCode === 13) {\n        _this.__truncationSuspended = true;\n        this.blur();\n        _this.__truncationSuspended = false;\n      }\n\n    });\n\n    function onChange() {\n      var attempted = parseFloat(_this.__input.value);\n      if (!common.isNaN(attempted)) _this.setValue(attempted);\n    }\n\n    function onBlur() {\n      onChange();\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n\n    function onMouseDown(e) {\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n      prev_y = e.clientY;\n    }\n\n    function onMouseDrag(e) {\n\n      var diff = prev_y - e.clientY;\n      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\n\n      prev_y = e.clientY;\n\n    }\n\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n    }\n\n    this.updateDisplay();\n\n    this.domElement.appendChild(this.__input);\n\n  };\n\n  NumberControllerBox.superclass = NumberController;\n\n  common.extend(\n\n      NumberControllerBox.prototype,\n      NumberController.prototype,\n\n      {\n\n        updateDisplay: function() {\n\n          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\n          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n  );\n\n  function roundToDecimal(value, decimals) {\n    var tenTo = Math.pow(10, decimals);\n    return Math.round(value * tenTo) / tenTo;\n  }\n\n  return NumberControllerBox;\n\n})(dat.controllers.NumberController,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {\n\n  /**\n   * @class Represents a given property of an object that is a number, contains\n   * a minimum and maximum, and provides a slider element with which to\n   * manipulate it. It should be noted that the slider element is made up of\n   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5\n   * <code>&lt;slider&gt;</code> element.\n   *\n   * @extends dat.controllers.Controller\n   * @extends dat.controllers.NumberController\n   * \n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   * @param {Number} minValue Minimum allowed value\n   * @param {Number} maxValue Maximum allowed value\n   * @param {Number} stepValue Increment by which to change value\n   *\n   * @member dat.controllers\n   */\n  var NumberControllerSlider = function(object, property, min, max, step) {\n\n    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });\n\n    var _this = this;\n\n    this.__background = document.createElement('div');\n    this.__foreground = document.createElement('div');\n    \n\n\n    dom.bind(this.__background, 'mousedown', onMouseDown);\n    \n    dom.addClass(this.__background, 'slider');\n    dom.addClass(this.__foreground, 'slider-fg');\n\n    function onMouseDown(e) {\n\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n\n      onMouseDrag(e);\n    }\n\n    function onMouseDrag(e) {\n\n      e.preventDefault();\n\n      var offset = dom.getOffset(_this.__background);\n      var width = dom.getWidth(_this.__background);\n      \n      _this.setValue(\n        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)\n      );\n\n      return false;\n\n    }\n\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n\n    this.updateDisplay();\n\n    this.__background.appendChild(this.__foreground);\n    this.domElement.appendChild(this.__background);\n\n  };\n\n  NumberControllerSlider.superclass = NumberController;\n\n  /**\n   * Injects default stylesheet for slider elements.\n   */\n  NumberControllerSlider.useDefaultStyles = function() {\n    css.inject(styleSheet);\n  };\n\n  common.extend(\n\n      NumberControllerSlider.prototype,\n      NumberController.prototype,\n\n      {\n\n        updateDisplay: function() {\n          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);\n          this.__foreground.style.width = pct*100+'%';\n          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n\n\n  );\n\n  function map(v, i1, i2, o1, o2) {\n    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\n  }\n\n  return NumberControllerSlider;\n  \n})(dat.controllers.NumberController,\ndat.dom.dom,\ndat.utils.css,\ndat.utils.common,\n\".slider {\\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\\n  height: 1em;\\n  border-radius: 1em;\\n  background-color: #eee;\\n  padding: 0 0.5em;\\n  overflow: hidden;\\n}\\n\\n.slider-fg {\\n  padding: 1px 0 2px 0;\\n  background-color: #aaa;\\n  height: 1em;\\n  margin-left: -0.5em;\\n  padding-right: 0.5em;\\n  border-radius: 1em 0 0 1em;\\n}\\n\\n.slider-fg:after {\\n  display: inline-block;\\n  border-radius: 1em;\\n  background-color: #fff;\\n  border:  1px solid #aaa;\\n  content: '';\\n  float: right;\\n  margin-right: -1em;\\n  margin-top: -1px;\\n  height: 0.9em;\\n  width: 0.9em;\\n}\");\n\n\ndat.controllers.FunctionController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a GUI interface to fire a specified method, a property of an object.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var FunctionController = function(object, property, text) {\n\n    FunctionController.superclass.call(this, object, property);\n\n    var _this = this;\n\n    this.__button = document.createElement('div');\n    this.__button.innerHTML = text === undefined ? 'Fire' : text;\n    dom.bind(this.__button, 'click', function(e) {\n      e.preventDefault();\n      _this.fire();\n      return false;\n    });\n\n    dom.addClass(this.__button, 'button');\n\n    this.domElement.appendChild(this.__button);\n\n\n  };\n\n  FunctionController.superclass = Controller;\n\n  common.extend(\n\n      FunctionController.prototype,\n      Controller.prototype,\n      {\n        \n        fire: function() {\n          if (this.__onChange) {\n            this.__onChange.call(this);\n          }\n          if (this.__onFinishChange) {\n            this.__onFinishChange.call(this, this.getValue());\n          }\n          this.getValue().call(this.object);\n        }\n      }\n\n  );\n\n  return FunctionController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.controllers.BooleanController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a checkbox input to alter the boolean property of an object.\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var BooleanController = function(object, property) {\n\n    BooleanController.superclass.call(this, object, property);\n\n    var _this = this;\n    this.__prev = this.getValue();\n\n    this.__checkbox = document.createElement('input');\n    this.__checkbox.setAttribute('type', 'checkbox');\n\n\n    dom.bind(this.__checkbox, 'change', onChange, false);\n\n    this.domElement.appendChild(this.__checkbox);\n\n    // Match original value\n    this.updateDisplay();\n\n    function onChange() {\n      _this.setValue(!_this.__prev);\n    }\n\n  };\n\n  BooleanController.superclass = Controller;\n\n  common.extend(\n\n      BooleanController.prototype,\n      Controller.prototype,\n\n      {\n\n        setValue: function(v) {\n          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);\n          if (this.__onFinishChange) {\n            this.__onFinishChange.call(this, this.getValue());\n          }\n          this.__prev = this.getValue();\n          return toReturn;\n        },\n\n        updateDisplay: function() {\n          \n          if (this.getValue() === true) {\n            this.__checkbox.setAttribute('checked', 'checked');\n            this.__checkbox.checked = true;    \n          } else {\n              this.__checkbox.checked = false;\n          }\n\n          return BooleanController.superclass.prototype.updateDisplay.call(this);\n\n        }\n\n\n      }\n\n  );\n\n  return BooleanController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common);\n\n\ndat.color.toString = (function (common) {\n\n  return function(color) {\n\n    if (color.a == 1 || common.isUndefined(color.a)) {\n\n      var s = color.hex.toString(16);\n      while (s.length < 6) {\n        s = '0' + s;\n      }\n\n      return '#' + s;\n\n    } else {\n\n      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\n    }\n\n  }\n\n})(dat.utils.common);\n\n\ndat.color.interpret = (function (toString, common) {\n\n  var result, toReturn;\n\n  var interpret = function() {\n\n    toReturn = false;\n\n    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\n    common.each(INTERPRETATIONS, function(family) {\n\n      if (family.litmus(original)) {\n\n        common.each(family.conversions, function(conversion, conversionName) {\n\n          result = conversion.read(original);\n\n          if (toReturn === false && result !== false) {\n            toReturn = result;\n            result.conversionName = conversionName;\n            result.conversion = conversion;\n            return common.BREAK;\n\n          }\n\n        });\n\n        return common.BREAK;\n\n      }\n\n    });\n\n    return toReturn;\n\n  };\n\n  var INTERPRETATIONS = [\n\n    // Strings\n    {\n\n      litmus: common.isString,\n\n      conversions: {\n\n        THREE_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt(\n                  '0x' +\n                      test[1].toString() + test[1].toString() +\n                      test[2].toString() + test[2].toString() +\n                      test[3].toString() + test[3].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        SIX_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9]{6})$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt('0x' + test[1].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGB: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3])\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGBA: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3]),\n              a: parseFloat(test[4])\n            };\n\n          },\n\n          write: toString\n\n        }\n\n      }\n\n    },\n\n    // Numbers\n    {\n\n      litmus: common.isNumber,\n\n      conversions: {\n\n        HEX: {\n          read: function(original) {\n            return {\n              space: 'HEX',\n              hex: original,\n              conversionName: 'HEX'\n            }\n          },\n\n          write: function(color) {\n            return color.hex;\n          }\n        }\n\n      }\n\n    },\n\n    // Arrays\n    {\n\n      litmus: common.isArray,\n\n      conversions: {\n\n        RGB_ARRAY: {\n          read: function(original) {\n            if (original.length != 3) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b];\n          }\n\n        },\n\n        RGBA_ARRAY: {\n          read: function(original) {\n            if (original.length != 4) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2],\n              a: original[3]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b, color.a];\n          }\n\n        }\n\n      }\n\n    },\n\n    // Objects\n    {\n\n      litmus: common.isObject,\n\n      conversions: {\n\n        RGBA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: color.a\n            }\n          }\n        },\n\n        RGB_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b\n            }\n          }\n        },\n\n        HSVA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v,\n              a: color.a\n            }\n          }\n        },\n\n        HSV_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v\n            }\n          }\n\n        }\n\n      }\n\n    }\n\n\n  ];\n\n  return interpret;\n\n\n})(dat.color.toString,\ndat.utils.common);\n\n\ndat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {\n\n  css.inject(styleSheet);\n\n  /** Outer-most className for GUI's */\n  var CSS_NAMESPACE = 'dg';\n\n  var HIDE_KEY_CODE = 72;\n\n  /** The only value shared between the JS and SCSS. Use caution. */\n  var CLOSE_BUTTON_HEIGHT = 20;\n\n  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';\n\n  var SUPPORTS_LOCAL_STORAGE = (function() {\n    try {\n      return 'localStorage' in window && window['localStorage'] !== null;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  var SAVE_DIALOGUE;\n\n  /** Have we yet to create an autoPlace GUI? */\n  var auto_place_virgin = true;\n\n  /** Fixed position div that auto place GUI's go inside */\n  var auto_place_container;\n\n  /** Are we hiding the GUI's ? */\n  var hide = false;\n\n  /** GUI's which should be hidden */\n  var hideable_guis = [];\n\n  /**\n   * A lightweight controller library for JavaScript. It allows you to easily\n   * manipulate variables and fire functions on the fly.\n   * @class\n   *\n   * @member dat.gui\n   *\n   * @param {Object} [params]\n   * @param {String} [params.name] The name of this GUI.\n   * @param {Object} [params.load] JSON object representing the saved state of\n   * this GUI.\n   * @param {Boolean} [params.auto=true]\n   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.\n   * @param {Boolean} [params.closed] If true, starts closed\n   */\n  var GUI = function(params) {\n\n    var _this = this;\n\n    /**\n     * Outermost DOM Element\n     * @type DOMElement\n     */\n    this.domElement = document.createElement('div');\n    this.__ul = document.createElement('ul');\n    this.domElement.appendChild(this.__ul);\n\n    dom.addClass(this.domElement, CSS_NAMESPACE);\n\n    /**\n     * Nested GUI's by name\n     * @ignore\n     */\n    this.__folders = {};\n\n    this.__controllers = [];\n\n    /**\n     * List of objects I'm remembering for save, only used in top level GUI\n     * @ignore\n     */\n    this.__rememberedObjects = [];\n\n    /**\n     * Maps the index of remembered objects to a map of controllers, only used\n     * in top level GUI.\n     *\n     * @private\n     * @ignore\n     *\n     * @example\n     * [\n     *  {\n     *    propertyName: Controller,\n     *    anotherPropertyName: Controller\n     *  },\n     *  {\n     *    propertyName: Controller\n     *  }\n     * ]\n     */\n    this.__rememberedObjectIndecesToControllers = [];\n\n    this.__listening = [];\n\n    params = params || {};\n\n    // Default parameters\n    params = common.defaults(params, {\n      autoPlace: true,\n      width: GUI.DEFAULT_WIDTH\n    });\n\n    params = common.defaults(params, {\n      resizable: params.autoPlace,\n      hideable: params.autoPlace\n    });\n\n\n    if (!common.isUndefined(params.load)) {\n\n      // Explicit preset\n      if (params.preset) params.load.preset = params.preset;\n\n    } else {\n\n      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\n\n    }\n\n    if (common.isUndefined(params.parent) && params.hideable) {\n      hideable_guis.push(this);\n    }\n\n    // Only root level GUI's are resizable.\n    params.resizable = common.isUndefined(params.parent) && params.resizable;\n\n\n    if (params.autoPlace && common.isUndefined(params.scrollable)) {\n      params.scrollable = true;\n    }\n//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;\n\n    // Not part of params because I don't want people passing this in via\n    // constructor. Should be a 'remembered' value.\n    var use_local_storage =\n        SUPPORTS_LOCAL_STORAGE &&\n            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\n\n    Object.defineProperties(this,\n\n        /** @lends dat.gui.GUI.prototype */\n        {\n\n          /**\n           * The parent <code>GUI</code>\n           * @type dat.gui.GUI\n           */\n          parent: {\n            get: function() {\n              return params.parent;\n            }\n          },\n\n          scrollable: {\n            get: function() {\n              return params.scrollable;\n            }\n          },\n\n          /**\n           * Handles <code>GUI</code>'s element placement for you\n           * @type Boolean\n           */\n          autoPlace: {\n            get: function() {\n              return params.autoPlace;\n            }\n          },\n\n          /**\n           * The identifier for a set of saved values\n           * @type String\n           */\n          preset: {\n\n            get: function() {\n              if (_this.parent) {\n                return _this.getRoot().preset;\n              } else {\n                return params.load.preset;\n              }\n            },\n\n            set: function(v) {\n              if (_this.parent) {\n                _this.getRoot().preset = v;\n              } else {\n                params.load.preset = v;\n              }\n              setPresetSelectIndex(this);\n              _this.revert();\n            }\n\n          },\n\n          /**\n           * The width of <code>GUI</code> element\n           * @type Number\n           */\n          width: {\n            get: function() {\n              return params.width;\n            },\n            set: function(v) {\n              params.width = v;\n              setWidth(_this, v);\n            }\n          },\n\n          /**\n           * The name of <code>GUI</code>. Used for folders. i.e\n           * a folder's name\n           * @type String\n           */\n          name: {\n            get: function() {\n              return params.name;\n            },\n            set: function(v) {\n              // TODO Check for collisions among sibling folders\n              params.name = v;\n              if (title_row_name) {\n                title_row_name.innerHTML = params.name;\n              }\n            }\n          },\n\n          /**\n           * Whether the <code>GUI</code> is collapsed or not\n           * @type Boolean\n           */\n          closed: {\n            get: function() {\n              return params.closed;\n            },\n            set: function(v) {\n              params.closed = v;\n              if (params.closed) {\n                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\n              } else {\n                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\n              }\n              // For browsers that aren't going to respect the CSS transition,\n              // Lets just check our height against the window height right off\n              // the bat.\n              this.onResize();\n\n              if (_this.__closeButton) {\n                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\n              }\n            }\n          },\n\n          /**\n           * Contains all presets\n           * @type Object\n           */\n          load: {\n            get: function() {\n              return params.load;\n            }\n          },\n\n          /**\n           * Determines whether or not to use <a href=\"https://developer.mozilla.org/en/DOM/Storage#localStorage\">localStorage</a> as the means for\n           * <code>remember</code>ing\n           * @type Boolean\n           */\n          useLocalStorage: {\n\n            get: function() {\n              return use_local_storage;\n            },\n            set: function(bool) {\n              if (SUPPORTS_LOCAL_STORAGE) {\n                use_local_storage = bool;\n                if (bool) {\n                  dom.bind(window, 'unload', saveToLocalStorage);\n                } else {\n                  dom.unbind(window, 'unload', saveToLocalStorage);\n                }\n                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\n              }\n            }\n\n          }\n\n        });\n\n    // Are we a root level GUI?\n    if (common.isUndefined(params.parent)) {\n\n      params.closed = false;\n\n      dom.addClass(this.domElement, GUI.CLASS_MAIN);\n      dom.makeSelectable(this.domElement, false);\n\n      // Are we supposed to be loading locally?\n      if (SUPPORTS_LOCAL_STORAGE) {\n\n        if (use_local_storage) {\n\n          _this.useLocalStorage = true;\n\n          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\n\n          if (saved_gui) {\n            params.load = JSON.parse(saved_gui);\n          }\n\n        }\n\n      }\n\n      this.__closeButton = document.createElement('div');\n      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\n      this.domElement.appendChild(this.__closeButton);\n\n      dom.bind(this.__closeButton, 'click', function() {\n\n        _this.closed = !_this.closed;\n\n\n      });\n\n\n      // Oh, you're a nested GUI!\n    } else {\n\n      if (params.closed === undefined) {\n        params.closed = true;\n      }\n\n      var title_row_name = document.createTextNode(params.name);\n      dom.addClass(title_row_name, 'controller-name');\n\n      var title_row = addRow(_this, title_row_name);\n\n      var on_click_title = function(e) {\n        e.preventDefault();\n        _this.closed = !_this.closed;\n        return false;\n      };\n\n      dom.addClass(this.__ul, GUI.CLASS_CLOSED);\n\n      dom.addClass(title_row, 'title');\n      dom.bind(title_row, 'click', on_click_title);\n\n      if (!params.closed) {\n        this.closed = false;\n      }\n\n    }\n\n    if (params.autoPlace) {\n\n      if (common.isUndefined(params.parent)) {\n\n        if (auto_place_virgin) {\n          auto_place_container = document.createElement('div');\n          dom.addClass(auto_place_container, CSS_NAMESPACE);\n          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);\n          document.body.appendChild(auto_place_container);\n          auto_place_virgin = false;\n        }\n\n        // Put it in the dom for you.\n        auto_place_container.appendChild(this.domElement);\n\n        // Apply the auto styles\n        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\n\n      }\n\n\n      // Make it not elastic.\n      if (!this.parent) setWidth(_this, params.width);\n\n    }\n\n    dom.bind(window, 'resize', function() { _this.onResize() });\n    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });\n    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });\n    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });\n    this.onResize();\n\n\n    if (params.resizable) {\n      addResizeHandle(this);\n    }\n\n    function saveToLocalStorage() {\n      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\n    }\n\n    var root = _this.getRoot();\n    function resetWidth() {\n        var root = _this.getRoot();\n        root.width += 1;\n        common.defer(function() {\n          root.width -= 1;\n        });\n      }\n\n      if (!params.parent) {\n        resetWidth();\n      }\n\n  };\n\n  GUI.toggleHide = function() {\n\n    hide = !hide;\n    common.each(hideable_guis, function(gui) {\n      gui.domElement.style.zIndex = hide ? -999 : 999;\n      gui.domElement.style.opacity = hide ? 0 : 1;\n    });\n  };\n\n  GUI.CLASS_AUTO_PLACE = 'a';\n  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\n  GUI.CLASS_MAIN = 'main';\n  GUI.CLASS_CONTROLLER_ROW = 'cr';\n  GUI.CLASS_TOO_TALL = 'taller-than-window';\n  GUI.CLASS_CLOSED = 'closed';\n  GUI.CLASS_CLOSE_BUTTON = 'close-button';\n  GUI.CLASS_DRAG = 'drag';\n\n  GUI.DEFAULT_WIDTH = 245;\n  GUI.TEXT_CLOSED = 'Close Controls';\n  GUI.TEXT_OPEN = 'Open Controls';\n\n  dom.bind(window, 'keydown', function(e) {\n\n    if (document.activeElement.type !== 'text' &&\n        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {\n      GUI.toggleHide();\n    }\n\n  }, false);\n\n  common.extend(\n\n      GUI.prototype,\n\n      /** @lends dat.gui.GUI */\n      {\n\n        /**\n         * @param object\n         * @param property\n         * @returns {dat.controllers.Controller} The new controller that was added.\n         * @instance\n         */\n        add: function(object, property) {\n\n          return add(\n              this,\n              object,\n              property,\n              {\n                factoryArgs: Array.prototype.slice.call(arguments, 2)\n              }\n          );\n\n        },\n\n        /**\n         * @param object\n         * @param property\n         * @returns {dat.controllers.ColorController} The new controller that was added.\n         * @instance\n         */\n        addColor: function(object, property) {\n\n          return add(\n              this,\n              object,\n              property,\n              {\n                color: true\n              }\n          );\n\n        },\n\n        /**\n         * @param controller\n         * @instance\n         */\n        remove: function(controller) {\n\n          // TODO listening?\n          this.__ul.removeChild(controller.__li);\n          this.__controllers.slice(this.__controllers.indexOf(controller), 1);\n          var _this = this;\n          common.defer(function() {\n            _this.onResize();\n          });\n\n        },\n\n        destroy: function() {\n\n          if (this.autoPlace) {\n            auto_place_container.removeChild(this.domElement);\n          }\n\n        },\n\n        /**\n         * @param name\n         * @returns {dat.gui.GUI} The new folder.\n         * @throws {Error} if this GUI already has a folder by the specified\n         * name\n         * @instance\n         */\n        addFolder: function(name) {\n\n          // We have to prevent collisions on names in order to have a key\n          // by which to remember saved values\n          if (this.__folders[name] !== undefined) {\n            throw new Error('You already have a folder in this GUI by the' +\n                ' name \"' + name + '\"');\n          }\n\n          var new_gui_params = { name: name, parent: this };\n\n          // We need to pass down the autoPlace trait so that we can\n          // attach event listeners to open/close folder actions to\n          // ensure that a scrollbar appears if the window is too short.\n          new_gui_params.autoPlace = this.autoPlace;\n\n          // Do we have saved appearance data for this folder?\n\n          if (this.load && // Anything loaded?\n              this.load.folders && // Was my parent a dead-end?\n              this.load.folders[name]) { // Did daddy remember me?\n\n            // Start me closed if I was closed\n            new_gui_params.closed = this.load.folders[name].closed;\n\n            // Pass down the loaded data\n            new_gui_params.load = this.load.folders[name];\n\n          }\n\n          var gui = new GUI(new_gui_params);\n          this.__folders[name] = gui;\n\n          var li = addRow(this, gui.domElement);\n          dom.addClass(li, 'folder');\n          return gui;\n\n        },\n\n        open: function() {\n          this.closed = false;\n        },\n\n        close: function() {\n          this.closed = true;\n        },\n\n        onResize: function() {\n\n          var root = this.getRoot();\n\n          if (root.scrollable) {\n\n            var top = dom.getOffset(root.__ul).top;\n            var h = 0;\n\n            common.each(root.__ul.childNodes, function(node) {\n              if (! (root.autoPlace && node === root.__save_row))\n                h += dom.getHeight(node);\n            });\n\n            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\n              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\n              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\n            } else {\n              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\n              root.__ul.style.height = 'auto';\n            }\n\n          }\n\n          if (root.__resize_handle) {\n            common.defer(function() {\n              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\n            });\n          }\n\n          if (root.__closeButton) {\n            root.__closeButton.style.width = root.width + 'px';\n          }\n\n        },\n\n        /**\n         * Mark objects for saving. The order of these objects cannot change as\n         * the GUI grows. When remembering new objects, append them to the end\n         * of the list.\n         *\n         * @param {Object...} objects\n         * @throws {Error} if not called on a top level GUI.\n         * @instance\n         */\n        remember: function() {\n\n          if (common.isUndefined(SAVE_DIALOGUE)) {\n            SAVE_DIALOGUE = new CenteredDiv();\n            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;\n          }\n\n          if (this.parent) {\n            throw new Error(\"You can only call remember on a top level GUI.\");\n          }\n\n          var _this = this;\n\n          common.each(Array.prototype.slice.call(arguments), function(object) {\n            if (_this.__rememberedObjects.length == 0) {\n              addSaveMenu(_this);\n            }\n            if (_this.__rememberedObjects.indexOf(object) == -1) {\n              _this.__rememberedObjects.push(object);\n            }\n          });\n\n          if (this.autoPlace) {\n            // Set save row width\n            setWidth(this, this.width);\n          }\n\n        },\n\n        /**\n         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.\n         * @instance\n         */\n        getRoot: function() {\n          var gui = this;\n          while (gui.parent) {\n            gui = gui.parent;\n          }\n          return gui;\n        },\n\n        /**\n         * @returns {Object} a JSON object representing the current state of\n         * this GUI as well as its remembered properties.\n         * @instance\n         */\n        getSaveObject: function() {\n\n          var toReturn = this.load;\n\n          toReturn.closed = this.closed;\n\n          // Am I remembering any values?\n          if (this.__rememberedObjects.length > 0) {\n\n            toReturn.preset = this.preset;\n\n            if (!toReturn.remembered) {\n              toReturn.remembered = {};\n            }\n\n            toReturn.remembered[this.preset] = getCurrentPreset(this);\n\n          }\n\n          toReturn.folders = {};\n          common.each(this.__folders, function(element, key) {\n            toReturn.folders[key] = element.getSaveObject();\n          });\n\n          return toReturn;\n\n        },\n\n        save: function() {\n\n          if (!this.load.remembered) {\n            this.load.remembered = {};\n          }\n\n          this.load.remembered[this.preset] = getCurrentPreset(this);\n          markPresetModified(this, false);\n\n        },\n\n        saveAs: function(presetName) {\n\n          if (!this.load.remembered) {\n\n            // Retain default values upon first save\n            this.load.remembered = {};\n            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\n\n          }\n\n          this.load.remembered[presetName] = getCurrentPreset(this);\n          this.preset = presetName;\n          addPresetOption(this, presetName, true);\n\n        },\n\n        revert: function(gui) {\n\n          common.each(this.__controllers, function(controller) {\n            // Make revert work on Default.\n            if (!this.getRoot().load.remembered) {\n              controller.setValue(controller.initialValue);\n            } else {\n              recallSavedValue(gui || this.getRoot(), controller);\n            }\n          }, this);\n\n          common.each(this.__folders, function(folder) {\n            folder.revert(folder);\n          });\n\n          if (!gui) {\n            markPresetModified(this.getRoot(), false);\n          }\n\n\n        },\n\n        listen: function(controller) {\n\n          var init = this.__listening.length == 0;\n          this.__listening.push(controller);\n          if (init) updateDisplays(this.__listening);\n\n        }\n\n      }\n\n  );\n\n  function add(gui, object, property, params) {\n\n    if (object[property] === undefined) {\n      throw new Error(\"Object \" + object + \" has no property \\\"\" + property + \"\\\"\");\n    }\n\n    var controller;\n\n    if (params.color) {\n\n      controller = new ColorController(object, property);\n\n    } else {\n\n      var factoryArgs = [object,property].concat(params.factoryArgs);\n      controller = controllerFactory.apply(gui, factoryArgs);\n\n    }\n\n    if (params.before instanceof Controller) {\n      params.before = params.before.__li;\n    }\n\n    recallSavedValue(gui, controller);\n\n    dom.addClass(controller.domElement, 'c');\n\n    var name = document.createElement('span');\n    dom.addClass(name, 'property-name');\n    name.innerHTML = controller.property;\n\n    var container = document.createElement('div');\n    container.appendChild(name);\n    container.appendChild(controller.domElement);\n\n    var li = addRow(gui, container, params.before);\n\n    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\n    dom.addClass(li, typeof controller.getValue());\n\n    augmentController(gui, li, controller);\n\n    gui.__controllers.push(controller);\n\n    return controller;\n\n  }\n\n  /**\n   * Add a row to the end of the GUI or before another row.\n   *\n   * @param gui\n   * @param [dom] If specified, inserts the dom content in the new row\n   * @param [liBefore] If specified, places the new row before another row\n   */\n  function addRow(gui, dom, liBefore) {\n    var li = document.createElement('li');\n    if (dom) li.appendChild(dom);\n    if (liBefore) {\n      gui.__ul.insertBefore(li, params.before);\n    } else {\n      gui.__ul.appendChild(li);\n    }\n    gui.onResize();\n    return li;\n  }\n\n  function augmentController(gui, li, controller) {\n\n    controller.__li = li;\n    controller.__gui = gui;\n\n    common.extend(controller, {\n\n      options: function(options) {\n\n        if (arguments.length > 1) {\n          controller.remove();\n\n          return add(\n              gui,\n              controller.object,\n              controller.property,\n              {\n                before: controller.__li.nextElementSibling,\n                factoryArgs: [common.toArray(arguments)]\n              }\n          );\n\n        }\n\n        if (common.isArray(options) || common.isObject(options)) {\n          controller.remove();\n\n          return add(\n              gui,\n              controller.object,\n              controller.property,\n              {\n                before: controller.__li.nextElementSibling,\n                factoryArgs: [options]\n              }\n          );\n\n        }\n\n      },\n\n      name: function(v) {\n        controller.__li.firstElementChild.firstElementChild.innerHTML = v;\n        return controller;\n      },\n\n      listen: function() {\n        controller.__gui.listen(controller);\n        return controller;\n      },\n\n      remove: function() {\n        controller.__gui.remove(controller);\n        return controller;\n      }\n\n    });\n\n    // All sliders should be accompanied by a box.\n    if (controller instanceof NumberControllerSlider) {\n\n      var box = new NumberControllerBox(controller.object, controller.property,\n          { min: controller.__min, max: controller.__max, step: controller.__step });\n\n      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {\n        var pc = controller[method];\n        var pb = box[method];\n        controller[method] = box[method] = function() {\n          var args = Array.prototype.slice.call(arguments);\n          pc.apply(controller, args);\n          return pb.apply(box, args);\n        }\n      });\n\n      dom.addClass(li, 'has-slider');\n      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\n\n    }\n    else if (controller instanceof NumberControllerBox) {\n\n      var r = function(returned) {\n\n        // Have we defined both boundaries?\n        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {\n\n          // Well, then lets just replace this with a slider.\n          controller.remove();\n          return add(\n              gui,\n              controller.object,\n              controller.property,\n              {\n                before: controller.__li.nextElementSibling,\n                factoryArgs: [controller.__min, controller.__max, controller.__step]\n              });\n\n        }\n\n        return returned;\n\n      };\n\n      controller.min = common.compose(r, controller.min);\n      controller.max = common.compose(r, controller.max);\n\n    }\n    else if (controller instanceof BooleanController) {\n\n      dom.bind(li, 'click', function() {\n        dom.fakeEvent(controller.__checkbox, 'click');\n      });\n\n      dom.bind(controller.__checkbox, 'click', function(e) {\n        e.stopPropagation(); // Prevents double-toggle\n      })\n\n    }\n    else if (controller instanceof FunctionController) {\n\n      dom.bind(li, 'click', function() {\n        dom.fakeEvent(controller.__button, 'click');\n      });\n\n      dom.bind(li, 'mouseover', function() {\n        dom.addClass(controller.__button, 'hover');\n      });\n\n      dom.bind(li, 'mouseout', function() {\n        dom.removeClass(controller.__button, 'hover');\n      });\n\n    }\n    else if (controller instanceof ColorController) {\n\n      dom.addClass(li, 'color');\n      controller.updateDisplay = common.compose(function(r) {\n        li.style.borderLeftColor = controller.__color.toString();\n        return r;\n      }, controller.updateDisplay);\n\n      controller.updateDisplay();\n\n    }\n\n    controller.setValue = common.compose(function(r) {\n      if (gui.getRoot().__preset_select && controller.isModified()) {\n        markPresetModified(gui.getRoot(), true);\n      }\n      return r;\n    }, controller.setValue);\n\n  }\n\n  function recallSavedValue(gui, controller) {\n\n    // Find the topmost GUI, that's where remembered objects live.\n    var root = gui.getRoot();\n\n    // Does the object we're controlling match anything we've been told to\n    // remember?\n    var matched_index = root.__rememberedObjects.indexOf(controller.object);\n\n    // Why yes, it does!\n    if (matched_index != -1) {\n\n      // Let me fetch a map of controllers for thcommon.isObject.\n      var controller_map =\n          root.__rememberedObjectIndecesToControllers[matched_index];\n\n      // Ohp, I believe this is the first controller we've created for this\n      // object. Lets make the map fresh.\n      if (controller_map === undefined) {\n        controller_map = {};\n        root.__rememberedObjectIndecesToControllers[matched_index] =\n            controller_map;\n      }\n\n      // Keep track of this controller\n      controller_map[controller.property] = controller;\n\n      // Okay, now have we saved any values for this controller?\n      if (root.load && root.load.remembered) {\n\n        var preset_map = root.load.remembered;\n\n        // Which preset are we trying to load?\n        var preset;\n\n        if (preset_map[gui.preset]) {\n\n          preset = preset_map[gui.preset];\n\n        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {\n\n          // Uhh, you can have the default instead?\n          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];\n\n        } else {\n\n          // Nada.\n\n          return;\n\n        }\n\n\n        // Did the loaded object remember thcommon.isObject?\n        if (preset[matched_index] &&\n\n          // Did we remember this particular property?\n            preset[matched_index][controller.property] !== undefined) {\n\n          // We did remember something for this guy ...\n          var value = preset[matched_index][controller.property];\n\n          // And that's what it is.\n          controller.initialValue = value;\n          controller.setValue(value);\n\n        }\n\n      }\n\n    }\n\n  }\n\n  function getLocalStorageHash(gui, key) {\n    // TODO how does this deal with multiple GUI's?\n    return document.location.href + '.' + key;\n\n  }\n\n  function addSaveMenu(gui) {\n\n    var div = gui.__save_row = document.createElement('li');\n\n    dom.addClass(gui.domElement, 'has-save');\n\n    gui.__ul.insertBefore(div, gui.__ul.firstChild);\n\n    dom.addClass(div, 'save-row');\n\n    var gears = document.createElement('span');\n    gears.innerHTML = '&nbsp;';\n    dom.addClass(gears, 'button gears');\n\n    // TODO replace with FunctionController\n    var button = document.createElement('span');\n    button.innerHTML = 'Save';\n    dom.addClass(button, 'button');\n    dom.addClass(button, 'save');\n\n    var button2 = document.createElement('span');\n    button2.innerHTML = 'New';\n    dom.addClass(button2, 'button');\n    dom.addClass(button2, 'save-as');\n\n    var button3 = document.createElement('span');\n    button3.innerHTML = 'Revert';\n    dom.addClass(button3, 'button');\n    dom.addClass(button3, 'revert');\n\n    var select = gui.__preset_select = document.createElement('select');\n\n    if (gui.load && gui.load.remembered) {\n\n      common.each(gui.load.remembered, function(value, key) {\n        addPresetOption(gui, key, key == gui.preset);\n      });\n\n    } else {\n      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\n    }\n\n    dom.bind(select, 'change', function() {\n\n\n      for (var index = 0; index < gui.__preset_select.length; index++) {\n        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\n      }\n\n      gui.preset = this.value;\n\n    });\n\n    div.appendChild(select);\n    div.appendChild(gears);\n    div.appendChild(button);\n    div.appendChild(button2);\n    div.appendChild(button3);\n\n    if (SUPPORTS_LOCAL_STORAGE) {\n\n      var saveLocally = document.getElementById('dg-save-locally');\n      var explain = document.getElementById('dg-local-explain');\n\n      saveLocally.style.display = 'block';\n\n      var localStorageCheckBox = document.getElementById('dg-local-storage');\n\n      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\n        localStorageCheckBox.setAttribute('checked', 'checked');\n      }\n\n      function showHideExplain() {\n        explain.style.display = gui.useLocalStorage ? 'block' : 'none';\n      }\n\n      showHideExplain();\n\n      // TODO: Use a boolean controller, fool!\n      dom.bind(localStorageCheckBox, 'change', function() {\n        gui.useLocalStorage = !gui.useLocalStorage;\n        showHideExplain();\n      });\n\n    }\n\n    var newConstructorTextArea = document.getElementById('dg-new-constructor');\n\n    dom.bind(newConstructorTextArea, 'keydown', function(e) {\n      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {\n        SAVE_DIALOGUE.hide();\n      }\n    });\n\n    dom.bind(gears, 'click', function() {\n      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\n      SAVE_DIALOGUE.show();\n      newConstructorTextArea.focus();\n      newConstructorTextArea.select();\n    });\n\n    dom.bind(button, 'click', function() {\n      gui.save();\n    });\n\n    dom.bind(button2, 'click', function() {\n      var presetName = prompt('Enter a new preset name.');\n      if (presetName) gui.saveAs(presetName);\n    });\n\n    dom.bind(button3, 'click', function() {\n      gui.revert();\n    });\n\n//    div.appendChild(button2);\n\n  }\n\n  function addResizeHandle(gui) {\n\n    gui.__resize_handle = document.createElement('div');\n\n    common.extend(gui.__resize_handle.style, {\n\n      width: '6px',\n      marginLeft: '-3px',\n      height: '200px',\n      cursor: 'ew-resize',\n      position: 'absolute'\n//      border: '1px solid blue'\n\n    });\n\n    var pmouseX;\n\n    dom.bind(gui.__resize_handle, 'mousedown', dragStart);\n    dom.bind(gui.__closeButton, 'mousedown', dragStart);\n\n    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\n\n    function dragStart(e) {\n\n      e.preventDefault();\n\n      pmouseX = e.clientX;\n\n      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\n      dom.bind(window, 'mousemove', drag);\n      dom.bind(window, 'mouseup', dragStop);\n\n      return false;\n\n    }\n\n    function drag(e) {\n\n      e.preventDefault();\n\n      gui.width += pmouseX - e.clientX;\n      gui.onResize();\n      pmouseX = e.clientX;\n\n      return false;\n\n    }\n\n    function dragStop() {\n\n      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\n      dom.unbind(window, 'mousemove', drag);\n      dom.unbind(window, 'mouseup', dragStop);\n\n    }\n\n  }\n\n  function setWidth(gui, w) {\n    gui.domElement.style.width = w + 'px';\n    // Auto placed save-rows are position fixed, so we have to\n    // set the width manually if we want it to bleed to the edge\n    if (gui.__save_row && gui.autoPlace) {\n      gui.__save_row.style.width = w + 'px';\n    }if (gui.__closeButton) {\n      gui.__closeButton.style.width = w + 'px';\n    }\n  }\n\n  function getCurrentPreset(gui, useInitialValues) {\n\n    var toReturn = {};\n\n    // For each object I'm remembering\n    common.each(gui.__rememberedObjects, function(val, index) {\n\n      var saved_values = {};\n\n      // The controllers I've made for thcommon.isObject by property\n      var controller_map =\n          gui.__rememberedObjectIndecesToControllers[index];\n\n      // Remember each value for each property\n      common.each(controller_map, function(controller, property) {\n        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();\n      });\n\n      // Save the values for thcommon.isObject\n      toReturn[index] = saved_values;\n\n    });\n\n    return toReturn;\n\n  }\n\n  function addPresetOption(gui, name, setSelected) {\n    var opt = document.createElement('option');\n    opt.innerHTML = name;\n    opt.value = name;\n    gui.__preset_select.appendChild(opt);\n    if (setSelected) {\n      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\n    }\n  }\n\n  function setPresetSelectIndex(gui) {\n    for (var index = 0; index < gui.__preset_select.length; index++) {\n      if (gui.__preset_select[index].value == gui.preset) {\n        gui.__preset_select.selectedIndex = index;\n      }\n    }\n  }\n\n  function markPresetModified(gui, modified) {\n    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\n//    console.log('mark', modified, opt);\n    if (modified) {\n      opt.innerHTML = opt.value + \"*\";\n    } else {\n      opt.innerHTML = opt.value;\n    }\n  }\n\n  function updateDisplays(controllerArray) {\n\n\n    if (controllerArray.length != 0) {\n\n      requestAnimationFrame(function() {\n        updateDisplays(controllerArray);\n      });\n\n    }\n\n    common.each(controllerArray, function(c) {\n      c.updateDisplay();\n    });\n\n  }\n\n  return GUI;\n\n})(dat.utils.css,\n\"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n      \\n    </div>\\n    \\n  </div>\\n\\n</div>\",\n\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\",\ndat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {\n\n      return function(object, property) {\n\n        var initialValue = object[property];\n\n        // Providing options?\n        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {\n          return new OptionController(object, property, arguments[2]);\n        }\n\n        // Providing a map?\n\n        if (common.isNumber(initialValue)) {\n\n          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {\n\n            // Has min and max.\n            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\n\n          } else {\n\n            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\n\n          }\n\n        }\n\n        if (common.isString(initialValue)) {\n          return new StringController(object, property);\n        }\n\n        if (common.isFunction(initialValue)) {\n          return new FunctionController(object, property, '');\n        }\n\n        if (common.isBoolean(initialValue)) {\n          return new BooleanController(object, property);\n        }\n\n      }\n\n    })(dat.controllers.OptionController,\ndat.controllers.NumberControllerBox,\ndat.controllers.NumberControllerSlider,\ndat.controllers.StringController = (function (Controller, dom, common) {\n\n  /**\n   * @class Provides a text input to alter the string property of an object.\n   *\n   * @extends dat.controllers.Controller\n   *\n   * @param {Object} object The object to be manipulated\n   * @param {string} property The name of the property to be manipulated\n   *\n   * @member dat.controllers\n   */\n  var StringController = function(object, property) {\n\n    StringController.superclass.call(this, object, property);\n\n    var _this = this;\n\n    this.__input = document.createElement('input');\n    this.__input.setAttribute('type', 'text');\n\n    dom.bind(this.__input, 'keyup', onChange);\n    dom.bind(this.__input, 'change', onChange);\n    dom.bind(this.__input, 'blur', onBlur);\n    dom.bind(this.__input, 'keydown', function(e) {\n      if (e.keyCode === 13) {\n        this.blur();\n      }\n    });\n    \n\n    function onChange() {\n      _this.setValue(_this.__input.value);\n    }\n\n    function onBlur() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n\n    this.updateDisplay();\n\n    this.domElement.appendChild(this.__input);\n\n  };\n\n  StringController.superclass = Controller;\n\n  common.extend(\n\n      StringController.prototype,\n      Controller.prototype,\n\n      {\n\n        updateDisplay: function() {\n          // Stops the caret from moving on account of:\n          // keyup -> setValue -> updateDisplay\n          if (!dom.isActive(this.__input)) {\n            this.__input.value = this.getValue();\n          }\n          return StringController.superclass.prototype.updateDisplay.call(this);\n        }\n\n      }\n\n  );\n\n  return StringController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.utils.common),\ndat.controllers.FunctionController,\ndat.controllers.BooleanController,\ndat.utils.common),\ndat.controllers.Controller,\ndat.controllers.BooleanController,\ndat.controllers.FunctionController,\ndat.controllers.NumberControllerBox,\ndat.controllers.NumberControllerSlider,\ndat.controllers.OptionController,\ndat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {\n\n  var ColorController = function(object, property) {\n\n    ColorController.superclass.call(this, object, property);\n\n    this.__color = new Color(this.getValue());\n    this.__temp = new Color(0);\n\n    var _this = this;\n\n    this.domElement = document.createElement('div');\n\n    dom.makeSelectable(this.domElement, false);\n\n    this.__selector = document.createElement('div');\n    this.__selector.className = 'selector';\n\n    this.__saturation_field = document.createElement('div');\n    this.__saturation_field.className = 'saturation-field';\n\n    this.__field_knob = document.createElement('div');\n    this.__field_knob.className = 'field-knob';\n    this.__field_knob_border = '2px solid ';\n\n    this.__hue_knob = document.createElement('div');\n    this.__hue_knob.className = 'hue-knob';\n\n    this.__hue_field = document.createElement('div');\n    this.__hue_field.className = 'hue-field';\n\n    this.__input = document.createElement('input');\n    this.__input.type = 'text';\n    this.__input_textShadow = '0 1px 1px ';\n\n    dom.bind(this.__input, 'keydown', function(e) {\n      if (e.keyCode === 13) { // on enter\n        onBlur.call(this);\n      }\n    });\n\n    dom.bind(this.__input, 'blur', onBlur);\n\n    dom.bind(this.__selector, 'mousedown', function(e) {\n\n      dom\n        .addClass(this, 'drag')\n        .bind(window, 'mouseup', function(e) {\n          dom.removeClass(_this.__selector, 'drag');\n        });\n\n    });\n\n    var value_field = document.createElement('div');\n\n    common.extend(this.__selector.style, {\n      width: '122px',\n      height: '102px',\n      padding: '3px',\n      backgroundColor: '#222',\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\n    });\n\n    common.extend(this.__field_knob.style, {\n      position: 'absolute',\n      width: '12px',\n      height: '12px',\n      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\n      borderRadius: '12px',\n      zIndex: 1\n    });\n    \n    common.extend(this.__hue_knob.style, {\n      position: 'absolute',\n      width: '15px',\n      height: '2px',\n      borderRight: '4px solid #fff',\n      zIndex: 1\n    });\n\n    common.extend(this.__saturation_field.style, {\n      width: '100px',\n      height: '100px',\n      border: '1px solid #555',\n      marginRight: '3px',\n      display: 'inline-block',\n      cursor: 'pointer'\n    });\n\n    common.extend(value_field.style, {\n      width: '100%',\n      height: '100%',\n      background: 'none'\n    });\n    \n    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');\n\n    common.extend(this.__hue_field.style, {\n      width: '15px',\n      height: '100px',\n      display: 'inline-block',\n      border: '1px solid #555',\n      cursor: 'ns-resize'\n    });\n\n    hueGradient(this.__hue_field);\n\n    common.extend(this.__input.style, {\n      outline: 'none',\n//      width: '120px',\n      textAlign: 'center',\n//      padding: '4px',\n//      marginBottom: '6px',\n      color: '#fff',\n      border: 0,\n      fontWeight: 'bold',\n      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'\n    });\n\n    dom.bind(this.__saturation_field, 'mousedown', fieldDown);\n    dom.bind(this.__field_knob, 'mousedown', fieldDown);\n\n    dom.bind(this.__hue_field, 'mousedown', function(e) {\n      setH(e);\n      dom.bind(window, 'mousemove', setH);\n      dom.bind(window, 'mouseup', unbindH);\n    });\n\n    function fieldDown(e) {\n      setSV(e);\n      // document.body.style.cursor = 'none';\n      dom.bind(window, 'mousemove', setSV);\n      dom.bind(window, 'mouseup', unbindSV);\n    }\n\n    function unbindSV() {\n      dom.unbind(window, 'mousemove', setSV);\n      dom.unbind(window, 'mouseup', unbindSV);\n      // document.body.style.cursor = 'default';\n    }\n\n    function onBlur() {\n      var i = interpret(this.value);\n      if (i !== false) {\n        _this.__color.__state = i;\n        _this.setValue(_this.__color.toOriginal());\n      } else {\n        this.value = _this.__color.toString();\n      }\n    }\n\n    function unbindH() {\n      dom.unbind(window, 'mousemove', setH);\n      dom.unbind(window, 'mouseup', unbindH);\n    }\n\n    this.__saturation_field.appendChild(value_field);\n    this.__selector.appendChild(this.__field_knob);\n    this.__selector.appendChild(this.__saturation_field);\n    this.__selector.appendChild(this.__hue_field);\n    this.__hue_field.appendChild(this.__hue_knob);\n\n    this.domElement.appendChild(this.__input);\n    this.domElement.appendChild(this.__selector);\n\n    this.updateDisplay();\n\n    function setSV(e) {\n\n      e.preventDefault();\n\n      var w = dom.getWidth(_this.__saturation_field);\n      var o = dom.getOffset(_this.__saturation_field);\n      var s = (e.clientX - o.left + document.body.scrollLeft) / w;\n      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;\n\n      if (v > 1) v = 1;\n      else if (v < 0) v = 0;\n\n      if (s > 1) s = 1;\n      else if (s < 0) s = 0;\n\n      _this.__color.v = v;\n      _this.__color.s = s;\n\n      _this.setValue(_this.__color.toOriginal());\n\n\n      return false;\n\n    }\n\n    function setH(e) {\n\n      e.preventDefault();\n\n      var s = dom.getHeight(_this.__hue_field);\n      var o = dom.getOffset(_this.__hue_field);\n      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;\n\n      if (h > 1) h = 1;\n      else if (h < 0) h = 0;\n\n      _this.__color.h = h * 360;\n\n      _this.setValue(_this.__color.toOriginal());\n\n      return false;\n\n    }\n\n  };\n\n  ColorController.superclass = Controller;\n\n  common.extend(\n\n      ColorController.prototype,\n      Controller.prototype,\n\n      {\n\n        updateDisplay: function() {\n\n          var i = interpret(this.getValue());\n\n          if (i !== false) {\n\n            var mismatch = false;\n\n            // Check for mismatch on the interpreted value.\n\n            common.each(Color.COMPONENTS, function(component) {\n              if (!common.isUndefined(i[component]) &&\n                  !common.isUndefined(this.__color.__state[component]) &&\n                  i[component] !== this.__color.__state[component]) {\n                mismatch = true;\n                return {}; // break\n              }\n            }, this);\n\n            // If nothing diverges, we keep our previous values\n            // for statefulness, otherwise we recalculate fresh\n            if (mismatch) {\n              common.extend(this.__color.__state, i);\n            }\n\n          }\n\n          common.extend(this.__temp.__state, this.__color.__state);\n\n          this.__temp.a = 1;\n\n          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;\n          var _flip = 255 - flip;\n\n          common.extend(this.__field_knob.style, {\n            marginLeft: 100 * this.__color.s - 7 + 'px',\n            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\n            backgroundColor: this.__temp.toString(),\n            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'\n          });\n\n          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'\n\n          this.__temp.s = 1;\n          this.__temp.v = 1;\n\n          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());\n\n          common.extend(this.__input.style, {\n            backgroundColor: this.__input.value = this.__color.toString(),\n            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',\n            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'\n          });\n\n        }\n\n      }\n\n  );\n  \n  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];\n  \n  function linearGradient(elem, x, a, b) {\n    elem.style.background = '';\n    common.each(vendors, function(vendor) {\n      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';\n    });\n  }\n  \n  function hueGradient(elem) {\n    elem.style.background = '';\n    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'\n    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'\n  }\n\n\n  return ColorController;\n\n})(dat.controllers.Controller,\ndat.dom.dom,\ndat.color.Color = (function (interpret, math, toString, common) {\n\n  var Color = function() {\n\n    this.__state = interpret.apply(this, arguments);\n\n    if (this.__state === false) {\n      throw 'Failed to interpret color arguments';\n    }\n\n    this.__state.a = this.__state.a || 1;\n\n\n  };\n\n  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\n  common.extend(Color.prototype, {\n\n    toString: function() {\n      return toString(this);\n    },\n\n    toOriginal: function() {\n      return this.__state.conversion.write(this);\n    }\n\n  });\n\n  defineRGBComponent(Color.prototype, 'r', 2);\n  defineRGBComponent(Color.prototype, 'g', 1);\n  defineRGBComponent(Color.prototype, 'b', 0);\n\n  defineHSVComponent(Color.prototype, 'h');\n  defineHSVComponent(Color.prototype, 's');\n  defineHSVComponent(Color.prototype, 'v');\n\n  Object.defineProperty(Color.prototype, 'a', {\n\n    get: function() {\n      return this.__state.a;\n    },\n\n    set: function(v) {\n      this.__state.a = v;\n    }\n\n  });\n\n  Object.defineProperty(Color.prototype, 'hex', {\n\n    get: function() {\n\n      if (!this.__state.space !== 'HEX') {\n        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n      }\n\n      return this.__state.hex;\n\n    },\n\n    set: function(v) {\n\n      this.__state.space = 'HEX';\n      this.__state.hex = v;\n\n    }\n\n  });\n\n  function defineRGBComponent(target, component, componentHexIndex) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'RGB') {\n          return this.__state[component];\n        }\n\n        recalculateRGB(this, component, componentHexIndex);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'RGB') {\n          recalculateRGB(this, component, componentHexIndex);\n          this.__state.space = 'RGB';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function defineHSVComponent(target, component) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'HSV')\n          return this.__state[component];\n\n        recalculateHSV(this);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'HSV') {\n          recalculateHSV(this);\n          this.__state.space = 'HSV';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function recalculateRGB(color, component, componentHexIndex) {\n\n    if (color.__state.space === 'HEX') {\n\n      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\n    } else if (color.__state.space === 'HSV') {\n\n      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\n    } else {\n\n      throw 'Corrupted color state';\n\n    }\n\n  }\n\n  function recalculateHSV(color) {\n\n    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\n    common.extend(color.__state,\n        {\n          s: result.s,\n          v: result.v\n        }\n    );\n\n    if (!common.isNaN(result.h)) {\n      color.__state.h = result.h;\n    } else if (common.isUndefined(color.__state.h)) {\n      color.__state.h = 0;\n    }\n\n  }\n\n  return Color;\n\n})(dat.color.interpret,\ndat.color.math = (function () {\n\n  var tmpComponent;\n\n  return {\n\n    hsv_to_rgb: function(h, s, v) {\n\n      var hi = Math.floor(h / 60) % 6;\n\n      var f = h / 60 - Math.floor(h / 60);\n      var p = v * (1.0 - s);\n      var q = v * (1.0 - (f * s));\n      var t = v * (1.0 - ((1.0 - f) * s));\n      var c = [\n        [v, t, p],\n        [q, v, p],\n        [p, v, t],\n        [p, q, v],\n        [t, p, v],\n        [v, p, q]\n      ][hi];\n\n      return {\n        r: c[0] * 255,\n        g: c[1] * 255,\n        b: c[2] * 255\n      };\n\n    },\n\n    rgb_to_hsv: function(r, g, b) {\n\n      var min = Math.min(r, g, b),\n          max = Math.max(r, g, b),\n          delta = max - min,\n          h, s;\n\n      if (max != 0) {\n        s = delta / max;\n      } else {\n        return {\n          h: NaN,\n          s: 0,\n          v: 0\n        };\n      }\n\n      if (r == max) {\n        h = (g - b) / delta;\n      } else if (g == max) {\n        h = 2 + (b - r) / delta;\n      } else {\n        h = 4 + (r - g) / delta;\n      }\n      h /= 6;\n      if (h < 0) {\n        h += 1;\n      }\n\n      return {\n        h: h * 360,\n        s: s,\n        v: max / 255\n      };\n    },\n\n    rgb_to_hex: function(r, g, b) {\n      var hex = this.hex_with_component(0, 2, r);\n      hex = this.hex_with_component(hex, 1, g);\n      hex = this.hex_with_component(hex, 0, b);\n      return hex;\n    },\n\n    component_from_hex: function(hex, componentIndex) {\n      return (hex >> (componentIndex * 8)) & 0xFF;\n    },\n\n    hex_with_component: function(hex, componentIndex, value) {\n      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n    }\n\n  }\n\n})(),\ndat.color.toString,\ndat.utils.common),\ndat.color.interpret,\ndat.utils.common),\ndat.utils.requestAnimationFrame = (function () {\n\n  /**\n   * requirejs version of Paul Irish's RequestAnimationFrame\n   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   */\n\n  return window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(callback, element) {\n\n        window.setTimeout(callback, 1000 / 60);\n\n      };\n})(),\ndat.dom.CenteredDiv = (function (dom, common) {\n\n\n  var CenteredDiv = function() {\n\n    this.backgroundElement = document.createElement('div');\n    common.extend(this.backgroundElement.style, {\n      backgroundColor: 'rgba(0,0,0,0.8)',\n      top: 0,\n      left: 0,\n      display: 'none',\n      zIndex: '1000',\n      opacity: 0,\n      WebkitTransition: 'opacity 0.2s linear'\n    });\n\n    dom.makeFullscreen(this.backgroundElement);\n    this.backgroundElement.style.position = 'fixed';\n\n    this.domElement = document.createElement('div');\n    common.extend(this.domElement.style, {\n      position: 'fixed',\n      display: 'none',\n      zIndex: '1001',\n      opacity: 0,\n      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'\n    });\n\n\n    document.body.appendChild(this.backgroundElement);\n    document.body.appendChild(this.domElement);\n\n    var _this = this;\n    dom.bind(this.backgroundElement, 'click', function() {\n      _this.hide();\n    });\n\n\n  };\n\n  CenteredDiv.prototype.show = function() {\n\n    var _this = this;\n    \n\n\n    this.backgroundElement.style.display = 'block';\n\n    this.domElement.style.display = 'block';\n    this.domElement.style.opacity = 0;\n//    this.domElement.style.top = '52%';\n    this.domElement.style.webkitTransform = 'scale(1.1)';\n\n    this.layout();\n\n    common.defer(function() {\n      _this.backgroundElement.style.opacity = 1;\n      _this.domElement.style.opacity = 1;\n      _this.domElement.style.webkitTransform = 'scale(1)';\n    });\n\n  };\n\n  CenteredDiv.prototype.hide = function() {\n\n    var _this = this;\n\n    var hide = function() {\n\n      _this.domElement.style.display = 'none';\n      _this.backgroundElement.style.display = 'none';\n\n      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\n      dom.unbind(_this.domElement, 'transitionend', hide);\n      dom.unbind(_this.domElement, 'oTransitionEnd', hide);\n\n    };\n\n    dom.bind(this.domElement, 'webkitTransitionEnd', hide);\n    dom.bind(this.domElement, 'transitionend', hide);\n    dom.bind(this.domElement, 'oTransitionEnd', hide);\n\n    this.backgroundElement.style.opacity = 0;\n//    this.domElement.style.top = '48%';\n    this.domElement.style.opacity = 0;\n    this.domElement.style.webkitTransform = 'scale(1.1)';\n\n  };\n\n  CenteredDiv.prototype.layout = function() {\n    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';\n    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';\n  };\n  \n  function lockScroll(e) {\n    console.log(e);\n  }\n\n  return CenteredDiv;\n\n})(dat.dom.dom,\ndat.utils.common),\ndat.dom.dom,\ndat.utils.common);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dat-gui/vendor/dat.gui.js\n// module id = 6\n// module chunks = 0","/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n/** @namespace */\nvar dat = module.exports = dat || {};\n\n/** @namespace */\ndat.color = dat.color || {};\n\n/** @namespace */\ndat.utils = dat.utils || {};\n\ndat.utils.common = (function () {\n  \n  var ARR_EACH = Array.prototype.forEach;\n  var ARR_SLICE = Array.prototype.slice;\n\n  /**\n   * Band-aid methods for things that should be a lot easier in JavaScript.\n   * Implementation and structure inspired by underscore.js\n   * http://documentcloud.github.com/underscore/\n   */\n\n  return { \n    \n    BREAK: {},\n  \n    extend: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (!this.isUndefined(obj[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n      \n    },\n    \n    defaults: function(target) {\n      \n      this.each(ARR_SLICE.call(arguments, 1), function(obj) {\n        \n        for (var key in obj)\n          if (this.isUndefined(target[key])) \n            target[key] = obj[key];\n        \n      }, this);\n      \n      return target;\n    \n    },\n    \n    compose: function() {\n      var toCall = ARR_SLICE.call(arguments);\n            return function() {\n              var args = ARR_SLICE.call(arguments);\n              for (var i = toCall.length -1; i >= 0; i--) {\n                args = [toCall[i].apply(this, args)];\n              }\n              return args[0];\n            }\n    },\n    \n    each: function(obj, itr, scope) {\n\n      \n      if (ARR_EACH && obj.forEach === ARR_EACH) { \n        \n        obj.forEach(itr, scope);\n        \n      } else if (obj.length === obj.length + 0) { // Is number but not NaN\n        \n        for (var key = 0, l = obj.length; key < l; key++)\n          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) \n            return;\n            \n      } else {\n\n        for (var key in obj) \n          if (itr.call(scope, obj[key], key) === this.BREAK)\n            return;\n            \n      }\n            \n    },\n    \n    defer: function(fnc) {\n      setTimeout(fnc, 0);\n    },\n    \n    toArray: function(obj) {\n      if (obj.toArray) return obj.toArray();\n      return ARR_SLICE.call(obj);\n    },\n\n    isUndefined: function(obj) {\n      return obj === undefined;\n    },\n    \n    isNull: function(obj) {\n      return obj === null;\n    },\n    \n    isNaN: function(obj) {\n      return obj !== obj;\n    },\n    \n    isArray: Array.isArray || function(obj) {\n      return obj.constructor === Array;\n    },\n    \n    isObject: function(obj) {\n      return obj === Object(obj);\n    },\n    \n    isNumber: function(obj) {\n      return obj === obj+0;\n    },\n    \n    isString: function(obj) {\n      return obj === obj+'';\n    },\n    \n    isBoolean: function(obj) {\n      return obj === false || obj === true;\n    },\n    \n    isFunction: function(obj) {\n      return Object.prototype.toString.call(obj) === '[object Function]';\n    }\n  \n  };\n    \n})();\n\n\ndat.color.toString = (function (common) {\n\n  return function(color) {\n\n    if (color.a == 1 || common.isUndefined(color.a)) {\n\n      var s = color.hex.toString(16);\n      while (s.length < 6) {\n        s = '0' + s;\n      }\n\n      return '#' + s;\n\n    } else {\n\n      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';\n\n    }\n\n  }\n\n})(dat.utils.common);\n\n\ndat.Color = dat.color.Color = (function (interpret, math, toString, common) {\n\n  var Color = function() {\n\n    this.__state = interpret.apply(this, arguments);\n\n    if (this.__state === false) {\n      throw 'Failed to interpret color arguments';\n    }\n\n    this.__state.a = this.__state.a || 1;\n\n\n  };\n\n  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];\n\n  common.extend(Color.prototype, {\n\n    toString: function() {\n      return toString(this);\n    },\n\n    toOriginal: function() {\n      return this.__state.conversion.write(this);\n    }\n\n  });\n\n  defineRGBComponent(Color.prototype, 'r', 2);\n  defineRGBComponent(Color.prototype, 'g', 1);\n  defineRGBComponent(Color.prototype, 'b', 0);\n\n  defineHSVComponent(Color.prototype, 'h');\n  defineHSVComponent(Color.prototype, 's');\n  defineHSVComponent(Color.prototype, 'v');\n\n  Object.defineProperty(Color.prototype, 'a', {\n\n    get: function() {\n      return this.__state.a;\n    },\n\n    set: function(v) {\n      this.__state.a = v;\n    }\n\n  });\n\n  Object.defineProperty(Color.prototype, 'hex', {\n\n    get: function() {\n\n      if (!this.__state.space !== 'HEX') {\n        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);\n      }\n\n      return this.__state.hex;\n\n    },\n\n    set: function(v) {\n\n      this.__state.space = 'HEX';\n      this.__state.hex = v;\n\n    }\n\n  });\n\n  function defineRGBComponent(target, component, componentHexIndex) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'RGB') {\n          return this.__state[component];\n        }\n\n        recalculateRGB(this, component, componentHexIndex);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'RGB') {\n          recalculateRGB(this, component, componentHexIndex);\n          this.__state.space = 'RGB';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function defineHSVComponent(target, component) {\n\n    Object.defineProperty(target, component, {\n\n      get: function() {\n\n        if (this.__state.space === 'HSV')\n          return this.__state[component];\n\n        recalculateHSV(this);\n\n        return this.__state[component];\n\n      },\n\n      set: function(v) {\n\n        if (this.__state.space !== 'HSV') {\n          recalculateHSV(this);\n          this.__state.space = 'HSV';\n        }\n\n        this.__state[component] = v;\n\n      }\n\n    });\n\n  }\n\n  function recalculateRGB(color, component, componentHexIndex) {\n\n    if (color.__state.space === 'HEX') {\n\n      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);\n\n    } else if (color.__state.space === 'HSV') {\n\n      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n\n    } else {\n\n      throw 'Corrupted color state';\n\n    }\n\n  }\n\n  function recalculateHSV(color) {\n\n    var result = math.rgb_to_hsv(color.r, color.g, color.b);\n\n    common.extend(color.__state,\n        {\n          s: result.s,\n          v: result.v\n        }\n    );\n\n    if (!common.isNaN(result.h)) {\n      color.__state.h = result.h;\n    } else if (common.isUndefined(color.__state.h)) {\n      color.__state.h = 0;\n    }\n\n  }\n\n  return Color;\n\n})(dat.color.interpret = (function (toString, common) {\n\n  var result, toReturn;\n\n  var interpret = function() {\n\n    toReturn = false;\n\n    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];\n\n    common.each(INTERPRETATIONS, function(family) {\n\n      if (family.litmus(original)) {\n\n        common.each(family.conversions, function(conversion, conversionName) {\n\n          result = conversion.read(original);\n\n          if (toReturn === false && result !== false) {\n            toReturn = result;\n            result.conversionName = conversionName;\n            result.conversion = conversion;\n            return common.BREAK;\n\n          }\n\n        });\n\n        return common.BREAK;\n\n      }\n\n    });\n\n    return toReturn;\n\n  };\n\n  var INTERPRETATIONS = [\n\n    // Strings\n    {\n\n      litmus: common.isString,\n\n      conversions: {\n\n        THREE_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt(\n                  '0x' +\n                      test[1].toString() + test[1].toString() +\n                      test[2].toString() + test[2].toString() +\n                      test[3].toString() + test[3].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        SIX_CHAR_HEX: {\n\n          read: function(original) {\n\n            var test = original.match(/^#([A-F0-9]{6})$/i);\n            if (test === null) return false;\n\n            return {\n              space: 'HEX',\n              hex: parseInt('0x' + test[1].toString())\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGB: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3])\n            };\n\n          },\n\n          write: toString\n\n        },\n\n        CSS_RGBA: {\n\n          read: function(original) {\n\n            var test = original.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\,\\s*(.+)\\s*\\)/);\n            if (test === null) return false;\n\n            return {\n              space: 'RGB',\n              r: parseFloat(test[1]),\n              g: parseFloat(test[2]),\n              b: parseFloat(test[3]),\n              a: parseFloat(test[4])\n            };\n\n          },\n\n          write: toString\n\n        }\n\n      }\n\n    },\n\n    // Numbers\n    {\n\n      litmus: common.isNumber,\n\n      conversions: {\n\n        HEX: {\n          read: function(original) {\n            return {\n              space: 'HEX',\n              hex: original,\n              conversionName: 'HEX'\n            }\n          },\n\n          write: function(color) {\n            return color.hex;\n          }\n        }\n\n      }\n\n    },\n\n    // Arrays\n    {\n\n      litmus: common.isArray,\n\n      conversions: {\n\n        RGB_ARRAY: {\n          read: function(original) {\n            if (original.length != 3) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b];\n          }\n\n        },\n\n        RGBA_ARRAY: {\n          read: function(original) {\n            if (original.length != 4) return false;\n            return {\n              space: 'RGB',\n              r: original[0],\n              g: original[1],\n              b: original[2],\n              a: original[3]\n            };\n          },\n\n          write: function(color) {\n            return [color.r, color.g, color.b, color.a];\n          }\n\n        }\n\n      }\n\n    },\n\n    // Objects\n    {\n\n      litmus: common.isObject,\n\n      conversions: {\n\n        RGBA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: color.a\n            }\n          }\n        },\n\n        RGB_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.r) &&\n                common.isNumber(original.g) &&\n                common.isNumber(original.b)) {\n              return {\n                space: 'RGB',\n                r: original.r,\n                g: original.g,\n                b: original.b\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              r: color.r,\n              g: color.g,\n              b: color.b\n            }\n          }\n        },\n\n        HSVA_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v) &&\n                common.isNumber(original.a)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v,\n                a: original.a\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v,\n              a: color.a\n            }\n          }\n        },\n\n        HSV_OBJ: {\n          read: function(original) {\n            if (common.isNumber(original.h) &&\n                common.isNumber(original.s) &&\n                common.isNumber(original.v)) {\n              return {\n                space: 'HSV',\n                h: original.h,\n                s: original.s,\n                v: original.v\n              }\n            }\n            return false;\n          },\n\n          write: function(color) {\n            return {\n              h: color.h,\n              s: color.s,\n              v: color.v\n            }\n          }\n\n        }\n\n      }\n\n    }\n\n\n  ];\n\n  return interpret;\n\n\n})(dat.color.toString,\ndat.utils.common),\ndat.color.math = (function () {\n\n  var tmpComponent;\n\n  return {\n\n    hsv_to_rgb: function(h, s, v) {\n\n      var hi = Math.floor(h / 60) % 6;\n\n      var f = h / 60 - Math.floor(h / 60);\n      var p = v * (1.0 - s);\n      var q = v * (1.0 - (f * s));\n      var t = v * (1.0 - ((1.0 - f) * s));\n      var c = [\n        [v, t, p],\n        [q, v, p],\n        [p, v, t],\n        [p, q, v],\n        [t, p, v],\n        [v, p, q]\n      ][hi];\n\n      return {\n        r: c[0] * 255,\n        g: c[1] * 255,\n        b: c[2] * 255\n      };\n\n    },\n\n    rgb_to_hsv: function(r, g, b) {\n\n      var min = Math.min(r, g, b),\n          max = Math.max(r, g, b),\n          delta = max - min,\n          h, s;\n\n      if (max != 0) {\n        s = delta / max;\n      } else {\n        return {\n          h: NaN,\n          s: 0,\n          v: 0\n        };\n      }\n\n      if (r == max) {\n        h = (g - b) / delta;\n      } else if (g == max) {\n        h = 2 + (b - r) / delta;\n      } else {\n        h = 4 + (r - g) / delta;\n      }\n      h /= 6;\n      if (h < 0) {\n        h += 1;\n      }\n\n      return {\n        h: h * 360,\n        s: s,\n        v: max / 255\n      };\n    },\n\n    rgb_to_hex: function(r, g, b) {\n      var hex = this.hex_with_component(0, 2, r);\n      hex = this.hex_with_component(hex, 1, g);\n      hex = this.hex_with_component(hex, 0, b);\n      return hex;\n    },\n\n    component_from_hex: function(hex, componentIndex) {\n      return (hex >> (componentIndex * 8)) & 0xFF;\n    },\n\n    hex_with_component: function(hex, componentIndex, value) {\n      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));\n    }\n\n  }\n\n})(),\ndat.color.toString,\ndat.utils.common);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dat-gui/vendor/dat.color.js\n// module id = 7\n// module chunks = 0","window.THREE = require('three');\n\n(function(){\n  /**\n   * Cube\n   */\n  var Cube = window.Cube || {};\n\n  window.Cube = function () {\n    //Cube\n    p.init();\n  };\n\n  var p, s;\n\n  s = window.Cube;\n  p = s.prototype;\n\n  /**\n   * Cube\n   **/\n  p.init = function () {\n    var self = this;\n\n    //cubeGeometry\n    self.cubeGeometry = new THREE.BoxGeometry(4,4,4);\n\n    //cubeMaterial\n    self.cubeMaterial = new THREE.MeshLambertMaterial({\n      color: 0xff0000, wireframe: false\n    });\n\n    //cube\n    self.CubeObject = new THREE.Mesh(self.cubeGeometry,self.cubeMaterial);\n    self.CubeObject.castShadow = true;\n    //CubeObject\n    self.CubeObject.position.x = -4;\n    self.CubeObject.position.y = 3;\n    self.CubeObject.position.z = 0;\n\n    //CubeObject\n    return self.CubeObject;\n  };\n\n})();\n\n\n// WEBPACK FOOTER //\n// ./src/js/object/Cube.js","window.THREE = require('three');\n\n(function(){\n  /**\n   * Plane\n   */\n  var Plane = window.Plane || {};\n\n  window.Plane = function () {\n    //Plane\n    p.init();\n  };\n\n  var p, s;\n\n  s = window.Plane;\n  p = s.prototype;\n\n  /**\n   * Plane\n   **/\n  p.init = function () {\n    var self = this;\n\n    //planeGeometry\n    self.planeGeometry = new THREE.PlaneGeometry(60,20);\n\n    //planeMaterial\n    self.planeMaterial = new THREE.MeshLambertMaterial({\n      color: 0xffffff\n    });\n\n    //plane\n    self.PlaneObject = new THREE.Mesh(self.planeGeometry, self.planeMaterial);\n    self.PlaneObject.receiveShadow = true;\n    //plane\n    self.PlaneObject.rotation.x = -0.5 * Math.PI;\n    self.PlaneObject.position.x = 15;\n    self.PlaneObject.position.y = 0;\n    self.PlaneObject.position.z = 0;\n\n    //PlaneObject\n    return self.PlaneObject;\n  };\n\n})();\n\n\n// WEBPACK FOOTER //\n// ./src/js/object/Plane.js"],"sourceRoot":""}